# Optimized Shared Ride Database Design

This document defines an **optimized, consolidated schema** for the shared ride feature that eliminates redundancy by using a single `SharedEntity` table approach. This design simplifies relationships and reduces table proliferation while maintaining all necessary functionality.

---

## Table of Contents
1. [Design Philosophy](#design-philosophy)
2. [Core Entity: SharedEntity](#core-entity-sharedentity)
3. [rider-app Schema](#rider-app-schema)
4. [dynamic-offer-driver-app Schema](#dynamic-offer-driver-app-schema)
5. [Integration with Existing Tables](#integration-with-existing-tables)
6. [Migration Strategy](#migration-strategy)
7. [Type Definitions](#type-definitions)

---

## Design Philosophy

### **Key Principles:**
1. **Single Source of Truth**: One `SharedEntity` table tracks all shared ride states
2. **Array-Based Relationships**: Use UUID arrays to link to existing entities (SearchRequest, Estimate, Booking, Ride)
3. **State-Driven Design**: Entity lifecycle managed through status transitions
4. **Minimal Redundancy**: Avoid duplicating data that exists in linked entities
5. **Cross-Platform Consistency**: Same structure for both rider-app and driver-app

### **Benefits:**
- **Reduced Complexity**: Single table vs. 4 separate shared tables
- **Simplified Queries**: No complex joins between shared entities
- **Easy State Management**: All shared ride state in one place
- **Flexible Linking**: Can link to any combination of existing entities
- **Future-Proof**: Easy to add new entity types without schema changes

---

## Core Entity: SharedEntity

The `SharedEntity` table is the central hub that manages all shared ride state and relationships.

### **State Flow:**
```
SEARCHING → MATCHED → ESTIMATED → BOOKED → ONGOING → COMPLETED/CANCELLED
```

### **Domain Fields:**
- `id`: `Id SharedEntity` (Primary Key)
- `status`: `SharedEntityStatus` (State machine driver)
- `entityType`: `SharedEntityType` (SEARCH_GROUP, ESTIMATE_GROUP, BOOKING_GROUP, RIDE_GROUP)
- `searchRequestIds`: `[Id SearchRequest]` (Core relationship)
- `estimateIds`: `[Id Estimate]` (Linked estimates)
- `bookingIds`: `[Id Booking]` (Linked bookings)
- `rideIds`: `[Id Ride]` (Linked rides) 
- `merchantId`: `Id Merchant`
- `merchantOperatingCityId`: `Id MerchantOperatingCity`
- `vehicleCategory`: `VehicleCategory`
- `tripCategory`: `TripCategory` (Always RideShare)
- `driverId`: `Maybe (Id Person)` (Assigned driver)
- `transactionId`: `Maybe Text` (Cross-platform sync)
- `counterAppSharedEntityId`: `Maybe Text` (Cross-platform entity sync)
- `waypoints`: `Value` (JSON array of pickup/drop points)
- `totalSeats`: `Int` (Sum of all passenger seats)
- `pairingTime`: `Maybe UTCTime`
- `createdAt`: `UTCTime`
- `updatedAt`: `UTCTime`

---

## rider-app Schema

### Table: `SharedEntity`

**YAML Reference:** `Backend/app/rider-platform/rider-app/Main/spec/Storage/SharedEntity.yaml`

**Database Schema (Beam):**
```sql
CREATE TABLE atlas_app.shared_entity (
    id UUID PRIMARY KEY,
    status VARCHAR(255) NOT NULL,
    entity_type VARCHAR(255) NOT NULL,
    search_request_ids UUID[] NOT NULL,
    estimate_ids UUID[],
    booking_ids UUID[],
    ride_ids UUID[],
    merchant_id VARCHAR(36) NOT NULL,
    merchant_operating_city_id VARCHAR(36) NOT NULL,
    vehicle_category VARCHAR(255) NOT NULL,
    trip_category VARCHAR(255) DEFAULT 'RideShare',
    driver_id VARCHAR(36),
    transaction_id VARCHAR(255),
    counter_app_shared_entity_id VARCHAR(255),
    waypoints JSONB NOT NULL,
    total_seats INT NOT NULL,
    pairing_time TIMESTAMPTZ,
    valid_till TIMESTAMPTZ NOT NULL,
    created_at TIMESTAMPTZ NOT NULL,
    updated_at TIMESTAMPTZ NOT NULL
);

-- Indexes for performance
CREATE INDEX idx_shared_entity_status ON atlas_app.shared_entity(status);
CREATE INDEX idx_shared_entity_merchant_city ON atlas_app.shared_entity(merchant_operating_city_id);
CREATE INDEX idx_shared_entity_search_requests ON atlas_app.shared_entity USING GIN(search_request_ids);
CREATE INDEX idx_shared_entity_driver_id ON atlas_app.shared_entity(driver_id) WHERE driver_id IS NOT NULL;
CREATE INDEX idx_shared_entity_valid_till ON atlas_app.shared_entity(valid_till);
CREATE INDEX idx_shared_entity_transaction_id ON atlas_app.shared_entity(transaction_id) WHERE transaction_id IS NOT NULL;
```

**Beam Transformations:**
- No complex transformations needed for current fields

**Core Queries:**
```haskell
-- Find by individual search request
findBySearchRequestId :: Id SearchRequest -> Flow [SharedEntity]

-- Find by any linked entity
findByEstimateId :: Id Estimate -> Flow (Maybe SharedEntity)
findByBookingId :: Id Booking -> Flow (Maybe SharedEntity) 
findByRideId :: Id Ride -> Flow (Maybe SharedEntity)

-- Status-based queries
findByStatus :: SharedEntityStatus -> Flow [SharedEntity]
findActiveEntities :: Flow [SharedEntity]

-- Driver queries
findByDriverId :: Id Person -> Flow [SharedEntity]
findActiveRidesByDriver :: Id Person -> Flow [SharedEntity]

-- Merchant queries  
findByMerchantOperatingCityId :: Id MerchantOperatingCity -> Flow [SharedEntity]

-- Transaction sync
findByTransactionId :: Text -> Flow (Maybe SharedEntity)

-- Update operations
updateStatus :: SharedEntityStatus -> UTCTime -> Id SharedEntity -> Flow ()
updateDriverAssignment :: Id Person -> UTCTime -> Id SharedEntity -> Flow ()
updateCounterAppEntityId :: Text -> UTCTime -> Id SharedEntity -> Flow ()
linkEstimates :: [Id Estimate] -> UTCTime -> Id SharedEntity -> Flow ()
linkBookings :: [Id Booking] -> UTCTime -> Id SharedEntity -> Flow ()
linkRides :: [Id Ride] -> UTCTime -> Id SharedEntity -> Flow ()
```

**Sample waypoints JSON:**
```json
[
  {
    "type": "PICKUP",
    "search_request_id": "search-uuid-1",
    "customer_id": "customer-uuid-1",
    "lat": 12.9716,
    "lon": 77.5946,
    "address": "Pickup Address 1"
  },
  {
    "type": "PICKUP", 
    "search_request_id": "search-uuid-2",
    "customer_id": "customer-uuid-2",
    "lat": 12.9726,
    "lon": 77.5956,
    "address": "Pickup Address 2"
  },
  {
    "type": "DROPOFF",
    "search_request_id": "search-uuid-1", 
    "customer_id": "customer-uuid-1",
    "lat": 12.9816,
    "lon": 77.6046,
    "address": "Drop Address 1"
  },
  {
    "type": "DROPOFF",
    "search_request_id": "search-uuid-2",
    "customer_id": "customer-uuid-2", 
    "lat": 12.9826,
    "lon": 77.6056,
    "address": "Drop Address 2"
  }
]
```

### Configuration Table: `SharedRideConfigs`

**Unchanged from original design** - Still needed for configuration management.

---

## dynamic-offer-driver-app Schema

### Table: `SharedEntity`

**YAML Reference:** `Backend/app/provider-platform/dynamic-offer-driver-app/Main/spec/Storage/SharedEntity.yaml`

**Identical schema to rider-app** with additional driver-specific fields:

**Additional Fields:**
- `driverQuoteIds`: `[Id DriverQuote]` (Driver quotes for this shared entity)
- `searchRequestForDriverIds`: `[Id SearchRequestForDriver]` (Driver search requests)
- `tollCharges`: `Maybe HighPrecMoney`
- `tollNames`: `Maybe [Text]`
- `estimatedTollCharges`: `Maybe HighPrecMoney`
- `estimatedTollNames`: `Maybe [Text]`
- `rideEndedBy`: `Maybe RideEndedBy`
- `passedThroughDestination`: `Maybe Bool`
- `isPickupOrDestinationEdited`: `Maybe Bool`
- `numberOfSnapToRoadCalls`: `Maybe Int`
- `numberOfOsrmSnapToRoadCalls`: `Maybe Int`
- `chargeableDistanceValue`: `Maybe HighPrecDistance`
- `traveledDistanceValue`: `Maybe HighPrecDistance`

**Driver-Specific Queries:**
```haskell
-- Driver quote linking
findByDriverQuoteId :: Id DriverQuote -> Flow (Maybe SharedEntity)
linkDriverQuotes :: [Id DriverQuote] -> UTCTime -> Id SharedEntity -> Flow ()

-- Driver search request linking  
findBySearchRequestForDriverId :: Id SearchRequestForDriver -> Flow (Maybe SharedEntity)
linkSearchRequestsForDriver :: [Id SearchRequestForDriver] -> UTCTime -> Id SharedEntity -> Flow ()

-- Toll and ride tracking
updateTollCharges :: HighPrecMoney -> [Text] -> UTCTime -> Id SharedEntity -> Flow ()
updateRideMetrics :: HighPrecDistance -> HighPrecDistance -> UTCTime -> Id SharedEntity -> Flow ()
```

---

## Integration with Existing Tables

### Linking Strategy

Instead of adding shared ride IDs to existing tables, we **reverse the relationship**:

**Before (Redundant Approach):**
```haskell
-- Every table needs shared ride fields
data SearchRequest = SearchRequest 
  { sharedEntityId :: Maybe (Id SharedEntity) -- ❌ Redundant
  , ... 
  }

data Estimate = Estimate
  { sharedEntityId :: Maybe (Id SharedEntity) -- ❌ Redundant  
  , ...
  }
```

**After (Array-Based Approach):**
```haskell
-- Only SharedEntity tracks relationships
data SharedEntity = SharedEntity
  { searchRequestIds :: [Id SearchRequest] -- ✅ Single source of truth
  , estimateIds :: [Id Estimate]           -- ✅ No redundancy
  , bookingIds :: [Id Booking]
  , rideIds :: [Id Ride]
  , ...
  }
```

### Query Patterns

**Find shared entity for any linked entity:**
```haskell
findSharedEntityBySearchRequest :: Id SearchRequest -> Flow (Maybe SharedEntity)
findSharedEntityBySearchRequest searchId = do
  entities <- runInReplica $ QSharedEntity.findBySearchRequestId searchId
  return $ listToMaybe entities

findSharedEntityByEstimate :: Id Estimate -> Flow (Maybe SharedEntity)  
findSharedEntityByEstimate estimateId = do
  runInReplica $ QSharedEntity.findByEstimateId estimateId
```

**Check if entity is part of shared ride:**
```haskell
isSharedRide :: Id SearchRequest -> Flow Bool
isSharedRide searchId = do
  mbSharedEntity <- findSharedEntityBySearchRequest searchId
  return $ isJust mbSharedEntity
```

### Minimal Changes to Existing Tables

**Only add these fields where absolutely necessary:**

**DriverQuote.yaml** (only if needed for driver-app queries):
```yaml
# Optional - only if direct query access needed
isSharedRide: Bool  # Default: False
```

**SearchRequestForDriver.yaml** (only if needed for driver-app queries):
```yaml  
# Optional - only if direct query access needed
isSharedRide: Bool  # Default: False
```

**All other tables remain unchanged.**

---

## Migration Strategy

### Phase 1: Create SharedEntity Table
1. Create `shared_entity` table in both rider-app and driver-app
2. Add indexes and constraints
3. Deploy schema changes

### Phase 2: Migrate Existing Data (if any)
```sql
-- Example migration from old shared tables to new SharedEntity
INSERT INTO atlas_app.shared_entity (
    id, status, entity_type, search_request_ids, 
    merchant_id, merchant_operating_city_id, 
    vehicle_category, waypoints, total_seats,
    valid_till, created_at, updated_at
)
SELECT 
    shared_search_request.id,
    'SEARCHING'::varchar,
    'SEARCH_GROUP'::varchar,
    shared_search_request.search_request_ids,
    shared_search_request.merchant_id,
    shared_search_request.merchant_operating_city_id,
    shared_search_request.vehicle_category,
    shared_search_request.waypoints,
    calculate_total_seats(shared_search_request.search_request_ids),
    shared_search_request.valid_till,
    shared_search_request.created_at,
    shared_search_request.updated_at
FROM atlas_app.shared_search_request;
```

### Phase 3: Update Application Code
1. Replace queries to old shared tables with SharedEntity queries
2. Update business logic to use new status-driven model
3. Remove dependencies on old shared tables

### Phase 4: Cleanup (Optional)
1. Drop old shared tables once migration is verified
2. Remove unused indexes and constraints

---

## Type Definitions

### New Enums for Consolidated Design

```yaml
SharedEntityStatus:
  enum: "SEARCHING, MATCHED, ESTIMATED, BOOKED, DRIVER_ASSIGNED, ONGOING, COMPLETED, CANCELLED, EXPIRED"
  derive: "HttpInstance"

SharedEntityType:  
  enum: "SEARCH_GROUP, ESTIMATE_GROUP, BOOKING_GROUP, RIDE_GROUP"
  derive: "HttpInstance"
  
WaypointType:
  enum: "PICKUP, DROPOFF, INTERMEDIATE"
  derive: "HttpInstance"
```

### Status Transition Rules

```haskell
validStatusTransitions :: SharedEntityStatus -> [SharedEntityStatus]
validStatusTransitions = \case
  SEARCHING -> [MATCHED, EXPIRED, CANCELLED]
  MATCHED -> [ESTIMATED, CANCELLED]  
  ESTIMATED -> [BOOKED, CANCELLED]
  BOOKED -> [DRIVER_ASSIGNED, CANCELLED]
  DRIVER_ASSIGNED -> [ONGOING, CANCELLED]
  ONGOING -> [COMPLETED, CANCELLED]
  _ -> [CANCELLED] -- Terminal states can only be cancelled
```

---

## Benefits of Optimized Design

### **Reduced Complexity:**
- **1 table** instead of 8 shared tables (4 per app)
- **Single query** to get all shared ride state
- **No complex joins** between shared entities
- **Unified status management** 

### **Better Performance:**
- **Array-based lookups** using GIN indexes
- **Fewer table joins** in complex queries
- **Single transaction** for shared ride updates
- **Reduced storage overhead**

### **Improved Maintainability:**
- **Single schema** to maintain
- **Centralized business logic** 
- **Easier debugging** with all state in one place
- **Simplified testing** with fewer moving parts

### **Enhanced Flexibility:**
- **Easy to add new fields** without schema proliferation
- **Support for complex ride scenarios** (multi-stop, etc.)
- **Future-proof design** for new shared ride features
- **Cross-platform consistency** guaranteed

---

## Comparison: Old vs New Design

| Aspect | Old Design (Multiple Tables) | New Design (SharedEntity) |
|--------|------------------------------|---------------------------|
| **Tables** | 8 shared tables (4 × 2 apps) | 2 SharedEntity tables |
| **Relationships** | Complex foreign key chains | Simple array-based links |
| **Queries** | Multiple joins required | Single table queries |
| **State Management** | Scattered across tables | Centralized status machine |
| **Code Complexity** | High (multiple table ops) | Low (single entity ops) |
| **Data Consistency** | Risk of inconsistency | Single source of truth |
| **Migration Effort** | Complex schema changes | Simple array updates |
| **Performance** | Multiple table scans | Single table with indexes |

---

**Last Updated:** 2025-01-29  
**Design Status:** Optimized Consolidated Approach  
**Compatibility:** Replaces original multi-table design