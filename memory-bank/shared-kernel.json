{
  "size": {
    "tokens": 489159,
    "totalTokens": 489353,
    "characters": 2446765,
    "lines": 57919
  },
  "tree": {
    ".envrc": null,
    ".gitattributes": null,
    ".github": {
      "ISSUE_TEMPLATE": {
        "bug_report.md": null,
        "feature_request.md": null
      },
      "PULL_REQUEST_TEMPLATE.md": null,
      "workflows": {
        "nix.yml": null
      }
    },
    ".gitignore": null,
    ".hlint.yaml": null,
    "LICENSE.md": null,
    "README.md": null,
    "cabal.project": null,
    "cli-tools": {
      "gql": {
        "README.md": null,
        "code-gen.sh": null,
        "code-gen.yaml": null,
        "morpheus": null,
        "morpheus-mac-os.zip": null
      }
    },
    "flake.lock": null,
    "flake.nix": null,
    "hie.yaml": null,
    "lib": {
      "mobility-core": {
        "auto-generated": {
          "Kernel": {
            "External": {
              "MultiModal": {
                "OpenTripPlanner": {
                  "Types.hs": null,
                  "query-2.gql": null,
                  "query.gql": null,
                  "schema.gql": null
                }
              }
            }
          }
        },
        "mobility-core.cabal": null,
        "package.yaml": null,
        "src": {
          "Kernel": {
            "Beam": {
              "Connection": {
                "EnvVars.hs": null,
                "Flow.hs": null,
                "Postgres.hs": null,
                "Redis.hs": null,
                "Types.hs": null
              },
              "Functions.hs": null,
              "Lib": {
                "SqlObjectInstances.hs": null,
                "Utils.hs": null,
                "UtilsTH.hs": null
              },
              "Types.hs": null
            },
            "Exit.hs": null,
            "External": {
              "AadhaarVerification.hs": null,
              "AadhaarVerification": {
                "Gridline": {
                  "API.hs": null,
                  "Client.hs": null,
                  "Config.hs": null,
                  "Error.hs": null,
                  "Types.hs": null
                },
                "Interface.hs": null,
                "Interface": {
                  "Gridline.hs": null,
                  "Types.hs": null
                },
                "Types.hs": null
              },
              "BackgroundVerification.hs": null,
              "BackgroundVerification": {
                "Checkr": {
                  "Config.hs": null,
                  "Error.hs": null,
                  "Flow.hs": null,
                  "Types.hs": null
                },
                "Interface.hs": null,
                "Interface": {
                  "Checkr.hs": null,
                  "Types.hs": null
                },
                "Types.hs": null
              },
              "Call.hs": null,
              "Call": {
                "Exotel": {
                  "Client.hs": null,
                  "Config.hs": null,
                  "Types.hs": null
                },
                "Interface.hs": null,
                "Interface": {
                  "Exotel.hs": null,
                  "TataClickToCall.hs": null,
                  "Types.hs": null
                },
                "TataClickToCall": {
                  "Client.hs": null,
                  "Config.hs": null,
                  "Types.hs": null
                },
                "Twillio": {
                  "Config.hs": null
                },
                "Types.hs": null
              },
              "Encryption.hs": null,
              "GoogleTranslate": {
                "API.hs": null,
                "Client.hs": null,
                "Types.hs": null
              },
              "IncidentReport.hs": null,
              "IncidentReport": {
                "ERSS": {
                  "Config.hs": null,
                  "Flow.hs": null,
                  "Types.hs": null
                },
                "Interface.hs": null,
                "Interface": {
                  "ERSS.hs": null,
                  "Error.hs": null,
                  "Types.hs": null
                },
                "Types.hs": null
              },
              "Infobip": {
                "API": {
                  "SendSms.hs": null,
                  "WebengageWebhook.hs": null
                },
                "Flow.hs": null,
                "Types.hs": null
              },
              "Insurance": {
                "Acko": {
                  "Flow.hs": null,
                  "Types.hs": null
                },
                "Interface.hs": null,
                "Interface": {
                  "Acko.hs": null,
                  "Types.hs": null
                },
                "Types.hs": null
              },
              "Maps.hs": null,
              "Maps": {
                "Google": {
                  "Config.hs": null,
                  "MapsClient.hs": null,
                  "MapsClient": {
                    "Types.hs": null
                  },
                  "PolyLinePoints.hs": null,
                  "RoadsClient.hs": null
                },
                "HasCoordinates.hs": null,
                "Interface.hs": null,
                "Interface": {
                  "Google.hs": null,
                  "MMI.hs": null,
                  "NextBillion.hs": null,
                  "OSRM.hs": null,
                  "Types.hs": null
                },
                "MMI": {
                  "AutoSuggest.hs": null,
                  "Config.hs": null,
                  "DistanceMatrix.hs": null,
                  "Geocode.hs": null,
                  "MMIAuthToken.hs": null,
                  "PlaceDetails.hs": null,
                  "ReverseGeocoding.hs": null,
                  "Routes.hs": null,
                  "SnapToRoad.hs": null,
                  "Types.hs": null
                },
                "NextBillion": {
                  "Config.hs": null,
                  "Route.hs": null,
                  "Types.hs": null
                },
                "OSRM": {
                  "Config.hs": null,
                  "RoadsClient.hs": null
                },
                "Types.hs": null,
                "Utils.hs": null
              },
              "MultiModal.hs": null,
              "MultiModal": {
                "Interface.hs": null,
                "Interface": {
                  "Google.hs": null,
                  "OpenTripPlanner.hs": null,
                  "Types.hs": null
                },
                "OpenTripPlanner": {
                  "Config.hs": null
                },
                "Types.hs": null,
                "Utils.hs": null
              },
              "Notification.hs": null,
              "Notification": {
                "FCM": {
                  "Error.hs": null,
                  "Flow.hs": null,
                  "Types.hs": null
                },
                "GRPC": {
                  "Flow.hs": null,
                  "Types.hs": null
                },
                "Interface.hs": null,
                "Interface": {
                  "FCM.hs": null,
                  "GRPC.hs": null,
                  "PayTM.hs": null,
                  "Types.hs": null
                },
                "PayTM": {
                  "API.hs": null,
                  "Client.hs": null,
                  "Types.hs": null
                },
                "Types.hs": null
              },
              "Payment": {
                "Interface.hs": null,
                "Interface": {
                  "Juspay.hs": null,
                  "Stripe.hs": null,
                  "Types.hs": null
                },
                "Juspay": {
                  "Config.hs": null,
                  "Flow.hs": null,
                  "Types.hs": null,
                  "Types": {
                    "Common.hs": null,
                    "CreateCustomer.hs": null,
                    "CreateOrder.hs": null,
                    "Mandate.hs": null,
                    "Offer.hs": null,
                    "UpdateOrder.hs": null,
                    "Webhook.hs": null
                  },
                  "Webhook.hs": null
                },
                "Stripe": {
                  "Config.hs": null,
                  "Flow.hs": null,
                  "Types.hs": null,
                  "Types": {
                    "Accounts.hs": null,
                    "Card.hs": null,
                    "Common.hs": null,
                    "Customer.hs": null,
                    "Error.hs": null,
                    "PaymentIntent.hs": null,
                    "SetupIntent.hs": null
                  }
                },
                "Types.hs": null
              },
              "Payout": {
                "Interface.hs": null,
                "Interface": {
                  "Juspay.hs": null,
                  "Types.hs": null
                },
                "Juspay": {
                  "Config.hs": null,
                  "Flow.hs": null,
                  "Types.hs": null,
                  "Types": {
                    "Payout.hs": null,
                    "Webhook.hs": null
                  },
                  "Webhook.hs": null
                },
                "Types.hs": null
              },
              "SMS.hs": null,
              "SMS": {
                "DigoEngage": {
                  "API.hs": null,
                  "Config.hs": null,
                  "Flow.hs": null,
                  "Types.hs": null
                },
                "ExotelSms": {
                  "API.hs": null,
                  "Config.hs": null,
                  "Flow.hs": null,
                  "Types.hs": null
                },
                "GupShup": {
                  "API.hs": null,
                  "Config.hs": null,
                  "Flow.hs": null,
                  "Types.hs": null
                },
                "Interface.hs": null,
                "Interface": {
                  "DigoEngageSms.hs": null,
                  "ExotelSms.hs": null,
                  "GupShup.hs": null,
                  "MyValueFirst.hs": null,
                  "TwillioSms.hs": null,
                  "Types.hs": null
                },
                "MyValueFirst": {
                  "API.hs": null,
                  "Config.hs": null,
                  "Flow.hs": null,
                  "Types.hs": null
                },
                "TwillioSms": {
                  "API.hs": null,
                  "Config.hs": null,
                  "Flow.hs": null,
                  "Types.hs": null
                },
                "Types.hs": null
              },
              "SharedLogic": {
                "HyperVerge": {
                  "Error.hs": null,
                  "Functions.hs": null
                }
              },
              "Slack": {
                "Flow.hs": null,
                "Types.hs": null
              },
              "Ticket": {
                "Interface.hs": null,
                "Interface": {
                  "Kapture.hs": null,
                  "Types.hs": null
                },
                "Kapture": {
                  "Config.hs": null,
                  "Flow.hs": null,
                  "Types.hs": null
                },
                "Types.hs": null
              },
              "Tokenize.hs": null,
              "Tokenize": {
                "Gullak": {
                  "Flow.hs": null,
                  "Types.hs": null
                },
                "HyperVerge": {
                  "Flow.hs": null,
                  "Types.hs": null
                },
                "Interface.hs": null,
                "Interface": {
                  "Error.hs": null,
                  "Gullak.hs": null,
                  "HyperVerge.hs": null,
                  "JourneyMonitoring.hs": null,
                  "Types.hs": null
                },
                "JourneyMonitoring": {
                  "Error.hs": null,
                  "Flow.hs": null,
                  "Types.hs": null
                },
                "Types.hs": null
              },
              "Types.hs": null,
              "Verification.hs": null,
              "Verification": {
                "GovtData": {
                  "Client.hs": null,
                  "Storage": {
                    "Beam.hs": null,
                    "Query.hs": null
                  },
                  "Types.hs": null
                },
                "HyperVerge": {
                  "Flow.hs": null,
                  "Types.hs": null
                },
                "Idfy": {
                  "Auth.hs": null,
                  "Client.hs": null,
                  "Config.hs": null,
                  "Flow.hs": null,
                  "Types.hs": null,
                  "Types": {
                    "Error.hs": null,
                    "Request.hs": null,
                    "Response.hs": null
                  },
                  "WebhookHandler.hs": null
                },
                "Interface.hs": null,
                "Interface": {
                  "HyperVerge.hs": null,
                  "Idfy.hs": null,
                  "InternalScripts.hs": null,
                  "SafetyPortal.hs": null,
                  "Types.hs": null
                },
                "InternalScripts": {
                  "Error.hs": null,
                  "FaceVerification.hs": null,
                  "Types.hs": null
                },
                "SafetyPortal": {
                  "API.hs": null,
                  "Client.hs": null,
                  "Config.hs": null,
                  "Error.hs": null,
                  "Types.hs": null
                },
                "Types.hs": null
              },
              "Whatsapp": {
                "GupShup": {
                  "Config.hs": null,
                  "Flow.hs": null,
                  "Types.hs": null
                },
                "Interface.hs": null,
                "Interface": {
                  "GupShup.hs": null,
                  "TataCommunications.hs": null,
                  "Types.hs": null
                },
                "TataCommunications": {
                  "Config.hs": null,
                  "Flow.hs": null,
                  "Types.hs": null
                },
                "Types.hs": null
              }
            },
            "InternalAPI": {
              "Auth": {
                "API.hs": null,
                "Client.hs": null
              }
            },
            "Mock": {
              "App.hs": null,
              "Exceptions.hs": null,
              "ExternalAPI.hs": null,
              "Utils.hs": null
            },
            "Prelude.hs": null,
            "Prelude": {
              "OrphanInstances.hs": null
            },
            "Product": {
              "Validation": {
                "Context.hs": null
              }
            },
            "Randomizer.hs": null,
            "ServantMultipart.hs": null,
            "Serviceability.hs": null,
            "Sms": {
              "Config.hs": null
            },
            "Storage": {
              ".DS_Store": null,
              "Beam": {
                "BecknRequest.hs": null,
                "SystemConfigs.hs": null
              },
              "Clickhouse": {
                "Config.hs": null,
                "Operators.hs": null,
                "Queries.hs": null,
                "Types.hs": null
              },
              "ClickhouseV2.hs": null,
              "ClickhouseV2": {
                "ClickhouseDb.hs": null,
                "ClickhouseTable.hs": null,
                "ClickhouseValue.hs": null,
                "Internal": {
                  "ClickhouseColumns.hs": null,
                  "ClickhouseQuery.hs": null,
                  "Types.hs": null
                },
                "Operators.hs": null,
                "Queries.hs": null,
                "UtilsTH.hs": null
              },
              "Esqueleto.hs": null,
              "Esqueleto": {
                "Class.hs": null,
                "Config.hs": null,
                "DTypeBuilder.hs": null,
                "Functions.hs": null,
                "Logger.hs": null,
                "Migration.hs": null,
                "Queries.hs": null,
                "SqlDB.hs": null,
                "Transactionable.hs": null,
                "Types.hs": null
              },
              "Hedis.hs": null,
              "Hedis": {
                "AppPrefixes.hs": null,
                "Config.hs": null,
                "Error.hs": null,
                "Queries.hs": null
              },
              "Queries": {
                "BecknRequest.hs": null,
                "SystemConfigs.hs": null
              }
            },
            "Streaming": {
              "Kafka": {
                "Commons.hs": null,
                "Consumer.hs": null,
                "Consumer": {
                  "Types.hs": null
                },
                "HasKafkaTopics.hs": null,
                "Producer.hs": null,
                "Producer": {
                  "Types.hs": null
                },
                "Topic": {
                  "BusinessEvent.hs": null,
                  "BusinessEvent": {
                    "Environment.hs": null,
                    "Functions.hs": null,
                    "Types.hs": null
                  },
                  "PublicTransportQuoteList.hs": null,
                  "PublicTransportQuoteList": {
                    "Functions.hs": null,
                    "Types.hs": null
                  },
                  "PublicTransportSearch.hs": null,
                  "PublicTransportSearch": {
                    "Functions.hs": null,
                    "Types.hs": null
                  }
                }
              },
              "MonadConsumer.hs": null,
              "MonadProducer.hs": null
            },
            "Tools": {
              "ARTUtils.hs": null,
              "Logging.hs": null,
              "LoopGracefully.hs": null,
              "Metrics": {
                "AppMetrics.hs": null,
                "CoreMetrics.hs": null,
                "CoreMetrics": {
                  "Types.hs": null
                },
                "Init.hs": null
              },
              "Slack.hs": null,
              "Slack": {
                "Internal.hs": null,
                "Middleware.hs": null
              },
              "SystemEnv.hs": null
            },
            "Types": {
              ".DS_Store": null,
              "APISuccess.hs": null,
              "App.hs": null,
              "Base64.hs": null,
              "Beckn": {
                "Ack.hs": null,
                "City.hs": null,
                "Context.hs": null,
                "Country.hs": null,
                "DecimalValue.hs": null,
                "Domain.hs": null,
                "Error.hs": null,
                "Gps.hs": null,
                "IndianState.hs": null,
                "ReqTypes.hs": null
              },
              "BecknRequest.hs": null,
              "Cac.hs": null,
              "Cache.hs": null,
              "CacheFlow.hs": null,
              "Centesimal.hs": null,
              "Common.hs": null,
              "Confidence.hs": null,
              "Credentials.hs": null,
              "Distance.hs": null,
              "Documents.hs": null,
              "Error.hs": null,
              "Error": {
                "BaseError.hs": null,
                "BaseError": {
                  "HTTPError.hs": null,
                  "HTTPError": {
                    "APIError.hs": null,
                    "BecknAPIError.hs": null,
                    "CallAPIError.hs": null,
                    "FromResponse.hs": null,
                    "HttpCode.hs": null
                  }
                }
              },
              "Field.hs": null,
              "Flow.hs": null,
              "Forkable.hs": null,
              "FromField.hs": null,
              "Geofencing.hs": null,
              "GuidLike.hs": null,
              "HideSecrets.hs": null,
              "Id.hs": null,
              "Logging.hs": null,
              "MonadGuid.hs": null,
              "Predicate.hs": null,
              "Price.hs": null,
              "Registry.hs": null,
              "Registry": {
                "API.hs": null,
                "Routes.hs": null,
                "Subscriber.hs": null
              },
              "Servant.hs": null,
              "SharedRedisKeys.hs": null,
              "SlidingWindowCounters.hs": null,
              "SlidingWindowLimiter.hs": null,
              "SystemConfigs.hs": null,
              "Time.hs": null,
              "TimeBound.hs": null,
              "TimeRFC339.hs": null,
              "Validation.hs": null,
              "Value.hs": null,
              "Version.hs": null
            },
            "Utils": {
              ".DS_Store": null,
              "App.hs": null,
              "CalculateDistance.hs": null,
              "Callback.hs": null,
              "Common.hs": null,
              "ComputeIntersection.hs": null,
              "Context.hs": null,
              "DatastoreLatencyCalculator.hs": null,
              "Dhall.hs": null,
              "Error.hs": null,
              "Error": {
                "BaseError": {
                  "HTTPError": {
                    "APIError.hs": null,
                    "BecknAPIError.hs": null
                  }
                },
                "DB.hs": null,
                "FlowHandling.hs": null,
                "Hierarchy.hs": null,
                "Throwing.hs": null
              },
              "Example.hs": null,
              "ExternalAPICallLogging.hs": null,
              "FlowLogging.hs": null,
              "GenericPretty.hs": null,
              "Geometry.hs": null,
              "IOLogging.hs": null,
              "JSON.hs": null,
              "JWT.hs": null,
              "Logging.hs": null,
              "Monitoring": {
                "Prometheus": {
                  "Servant.hs": null
                }
              },
              "NonEmpty.hs": null,
              "Predicates.hs": null,
              "Registry.hs": null,
              "Schema.hs": null,
              "Servant": {
                "API.hs": null,
                "BaseUrl.hs": null,
                "BasicAuth.hs": null,
                "Client.hs": null,
                "HTML.hs": null,
                "HeaderAuth.hs": null,
                "JSONBS.hs": null,
                "Server.hs": null,
                "SignatureAuth.hs": null
              },
              "Service.hs": null,
              "Shutdown.hs": null,
              "SignatureAuth.hs": null,
              "SlidingWindowCounters.hs": null,
              "SlidingWindowLimiter.hs": null,
              "TH.hs": null,
              "Text.hs": null,
              "Time.hs": null,
              "Validation.hs": null,
              "Version.hs": null,
              "XML.hs": null
            }
          }
        },
        "test": {
          "app": {
            "Main.hs": null
          },
          "src": {
            "APIExceptions.hs": null,
            "Centesimal.hs": null,
            "ComputeIntersectionTests.hs": null,
            "DistanceCalculation.hs": null,
            "SignatureAuth.hs": null,
            "SlidingWindowLimiter.hs": null,
            "SnippetsCheck.hs": null,
            "TestSilentIOLogger.hs": null,
            "Utils": {
              "Numeric.hs": null
            },
            "Version.hs": null
          }
        }
      }
    }
  },
  "files": {
    "/.envrc": {
      "type": "content",
      "content": "nix_direnv_watch_file \\\n    lib/*/*.cabal\nuse flake\n",
      "hash": "1889e9954e5a2c2a3b40cacffa116b9565caaa5e63c3a39c93a00d5cece95595",
      "size": 52
    },
    "/.gitattributes": {
      "type": "content",
      "content": "flake.lock linguist-generated=true\n",
      "hash": "81bfed215a979900f668e7aaa4f867739cde8e579ed30e28cd0ddf2503bf2364",
      "size": 35
    },
    "/.github/ISSUE_TEMPLATE/bug_report.md": {
      "type": "content",
      "content": "---\nname: Bug report\nabout: Create a report to help us improve\ntitle: ''\nlabels: ''\nassignees: ''\n\n---\n\n**Describe the bug**\nA clear and concise description of what the bug is.\n\n**To Reproduce**\nSteps to reproduce the behavior.\n\n**Expected behavior**\nA clear and concise description of what you expected to happen.\n\n**Screenshots**\nIf applicable, add screenshots to help explain your problem.\n\n**Additional context**\nAdd any other context about the problem here.\n",
      "hash": "3b06246605e830301a8a112acf0cc7c995df25a96fad1b9a46086bd08a6c7029",
      "size": 463
    },
    "/.github/ISSUE_TEMPLATE/feature_request.md": {
      "type": "content",
      "content": "---\nname: Feature request\nabout: Suggest an idea for this project\ntitle: ''\nlabels: ''\nassignees: ''\n\n---\n\n**Is your feature request related to a problem? Please describe.**\nA clear and concise description of what the problem is. Ex. I'm always frustrated when [...]\n\n**Describe the solution you'd like**\nA clear and concise description of what you want to happen.\n\n**Describe alternatives you've considered**\nA clear and concise description of any alternative solutions or features you've considered.\n\n**Additional context**\nAdd any other context or screenshots about the feature request here.\n",
      "hash": "1f48c52f209a971b8e7eae4120144d28fcf8ee38a7778a7b4d8cf1ab356617d2",
      "size": 595
    },
    "/.github/PULL_REQUEST_TEMPLATE.md": {
      "type": "content",
      "content": "## Type of Change\n<!-- Put an `x` in the boxes that apply -->\n\n- [ ] Bugfix\n- [ ] New feature\n- [ ] Enhancement\n- [ ] Refactoring\n- [ ] Dependency updates\n\n## Description\n<!-- Describe your changes in detail -->\n\n\n### Additional Changes\n\n- [ ] This PR modifies the database schema (database migration added)\n- [ ] This PR modifies dhall configs/environment variables\n\n\n## Motivation and Context\n<!--\nWhy is this change required? What problem does it solve?\nIf it fixes an open issue, please link to the issue here.\n\nIf you don't have an issue, we'd recommend starting with one first so the PR\ncan focus on the implementation (unless its an obvious bug or documentation fix\nthat will have little conversation).\n-->\n\n\n## How did you test it?\n<!--\nDid you write an integration/unit/API test to verify the code changes?\nOr did you test this change manually (provide relevant screenshots)?\n-->\n\n\n## Checklist\n<!-- Put an `x` in the boxes that apply -->\n\n- [ ] I formatted the code and addressed linter errors `./dev/format-all-files.sh`\n- [ ] I reviewed submitted code\n- [ ] I added unit tests for my changes where possible\n- [ ] I added a [CHANGELOG](/CHANGELOG.md) entry if applicable\n",
      "hash": "02a5004d96e4d5ef8b62ad83534aa99be5926f4364bf9fee4b103e215f180527",
      "size": 1182
    },
    "/.github/workflows/nix.yml": {
      "type": "content",
      "content": "name: CI\n\non:\n  # Triggers the workflow on push or pull request events but only for the \"main\" branch\n  push:\n    branches: [\"main\"]\n  pull_request:\n    branches: [\"main\"]\n\n  # Allows you to run this workflow manually from the Actions tab\n  workflow_dispatch:\n\n# A workflow run is made up of one or more jobs that can run sequentially or in parallel\njobs:\n  nix-ci:\n    runs-on: x86_64-linux\n\n    steps:\n      - uses: actions/checkout@v4\n\n      - uses: cachix/cachix-action@v15\n        with:\n          name: nammayatri\n          authToken: \"${{ secrets.CACHIX_AUTH_TOKEN }}\"\n          skipPush: true\n\n      - name: Build all flake outputs\n        run: om ci\n\n      # Push and pin whitelisted paths to cachix\n      - name: Push to cachix\n        if: github.ref == 'refs/heads/main'\n        run: nix run .#cachix-push\n",
      "hash": "647fc4352216d5e5be81d10efe0687548c9a00064de876da00baa66f30469452",
      "size": 816,
      "json": {
        "name": "CI",
        "on": {
          "push": {
            "branches": [
              "main"
            ]
          },
          "pull_request": {
            "branches": [
              "main"
            ]
          },
          "workflow_dispatch": null
        },
        "jobs": {
          "nix-ci": {
            "runs-on": "x86_64-linux",
            "steps": [
              {
                "uses": "actions/checkout@v4"
              },
              {
                "uses": "cachix/cachix-action@v15",
                "with": {
                  "name": "nammayatri",
                  "authToken": "${{ secrets.CACHIX_AUTH_TOKEN }}",
                  "skipPush": true
                }
              },
              {
                "name": "Build all flake outputs",
                "run": "om ci"
              },
              {
                "name": "Push to cachix",
                "if": "github.ref == 'refs/heads/main'",
                "run": "nix run .#cachix-push"
              }
            ]
          }
        }
      }
    },
    "/.gitignore": {
      "type": "content",
      "content": "*~\n.psc-ide-port\ndist\ndist-*\ncabal-dev\n*.o\n*.hi\n*.hie\n*.chi\n*.chs.h\n*.dyn_o\n*.dyn_hi\n.hpc\n.hsenv\n.cabal-sandbox/\ncabal.sandbox.config\n*.prof\n*.aux\n*.hp\n*.eventlog\n.vscode/\n*.vim\ncabal.project.local\ncabal.project.local~\n.HTF/\n.ghc.environment.*\n*.log\ndhall-configs/dev/secrets/top-secret.dhall\n.DS_Store\n\n# load test files\n.dev/load-test/*.json\n\n# Nix\n.direnv\nresult\n.pre-commit-config.yaml\n.hie-bios-cache\n.cabal-dir\n\n# Non-Nix bans\nMakefile\n*.sh\n!cli-tools/gql/code-gen.sh\n\n",
      "hash": "ad7dc28cb128e28f720819490fd4e0a3d54981c943c70c5fead984276d424aee",
      "size": 475
    },
    "/.hlint.yaml": {
      "type": "content",
      "content": "# HLint configuration file\n# https://github.com/ndmitchell/hlint\n##########################\n\n# This file contains a template configuration file, which is typically\n# placed as .hlint.yaml in the root of your project\n\n- ignore: {name: Redundant id}\n- ignore: {name: Redundant ^.}\n\n# To generate a suitable file for HLint do:\n# $ hlint --default > .hlint.yaml",
      "hash": "ead21c5c18be02112f124cac8c7a187d4e5cf7b8e7340b118858fabce9e88c60",
      "size": 357,
      "json": [
        {
          "ignore": {
            "name": "Redundant id"
          }
        },
        {
          "ignore": {
            "name": "Redundant ^."
          }
        }
      ]
    },
    "/LICENSE.md": {
      "type": "content",
      "content": "                    GNU AFFERO GENERAL PUBLIC LICENSE\n                       Version 3, 19 November 2007\n\n Copyright (C) 2007 Free Software Foundation, Inc. <https://fsf.org/>\n Everyone is permitted to copy and distribute verbatim copies\n of this license document, but changing it is not allowed.\n\n                            Preamble\n\n  The GNU Affero General Public License is a free, copyleft license for\nsoftware and other kinds of works, specifically designed to ensure\ncooperation with the community in the case of network server software.\n\n  The licenses for most software and other practical works are designed\nto take away your freedom to share and change the works.  By contrast,\nour General Public Licenses are intended to guarantee your freedom to\nshare and change all versions of a program--to make sure it remains free\nsoftware for all its users.\n\n  When we speak of free software, we are referring to freedom, not\nprice.  Our General Public Licenses are designed to make sure that you\nhave the freedom to distribute copies of free software (and charge for\nthem if you wish), that you receive source code or can get it if you\nwant it, that you can change the software or use pieces of it in new\nfree programs, and that you know you can do these things.\n\n  Developers that use our General Public Licenses protect your rights\nwith two steps: (1) assert copyright on the software, and (2) offer\nyou this License which gives you legal permission to copy, distribute\nand/or modify the software.\n\n  A secondary benefit of defending all users' freedom is that\nimprovements made in alternate versions of the program, if they\nreceive widespread use, become available for other developers to\nincorporate.  Many developers of free software are heartened and\nencouraged by the resulting cooperation.  However, in the case of\nsoftware used on network servers, this result may fail to come about.\nThe GNU General Public License permits making a modified version and\nletting the public access it on a server without ever releasing its\nsource code to the public.\n\n  The GNU Affero General Public License is designed specifically to\nensure that, in such cases, the modified source code becomes available\nto the community.  It requires the operator of a network server to\nprovide the source code of the modified version running there to the\nusers of that server.  Therefore, public use of a modified version, on\na publicly accessible server, gives the public access to the source\ncode of the modified version.\n\n  An older license, called the Affero General Public License and\npublished by Affero, was designed to accomplish similar goals.  This is\na different license, not a version of the Affero GPL, but Affero has\nreleased a new version of the Affero GPL which permits relicensing under\nthis license.\n\n  The precise terms and conditions for copying, distribution and\nmodification follow.\n\n                       TERMS AND CONDITIONS\n\n  0. Definitions.\n\n  \"This License\" refers to version 3 of the GNU Affero General Public License.\n\n  \"Copyright\" also means copyright-like laws that apply to other kinds of\nworks, such as semiconductor masks.\n\n  \"The Program\" refers to any copyrightable work licensed under this\nLicense.  Each licensee is addressed as \"you\".  \"Licensees\" and\n\"recipients\" may be individuals or organizations.\n\n  To \"modify\" a work means to copy from or adapt all or part of the work\nin a fashion requiring copyright permission, other than the making of an\nexact copy.  The resulting work is called a \"modified version\" of the\nearlier work or a work \"based on\" the earlier work.\n\n  A \"covered work\" means either the unmodified Program or a work based\non the Program.\n\n  To \"propagate\" a work means to do anything with it that, without\npermission, would make you directly or secondarily liable for\ninfringement under applicable copyright law, except executing it on a\ncomputer or modifying a private copy.  Propagation includes copying,\ndistribution (with or without modification), making available to the\npublic, and in some countries other activities as well.\n\n  To \"convey\" a work means any kind of propagation that enables other\nparties to make or receive copies.  Mere interaction with a user through\na computer network, with no transfer of a copy, is not conveying.\n\n  An interactive user interface displays \"Appropriate Legal Notices\"\nto the extent that it includes a convenient and prominently visible\nfeature that (1) displays an appropriate copyright notice, and (2)\ntells the user that there is no warranty for the work (except to the\nextent that warranties are provided), that licensees may convey the\nwork under this License, and how to view a copy of this License.  If\nthe interface presents a list of user commands or options, such as a\nmenu, a prominent item in the list meets this criterion.\n\n  1. Source Code.\n\n  The \"source code\" for a work means the preferred form of the work\nfor making modifications to it.  \"Object code\" means any non-source\nform of a work.\n\n  A \"Standard Interface\" means an interface that either is an official\nstandard defined by a recognized standards body, or, in the case of\ninterfaces specified for a particular programming language, one that\nis widely used among developers working in that language.\n\n  The \"System Libraries\" of an executable work include anything, other\nthan the work as a whole, that (a) is included in the normal form of\npackaging a Major Component, but which is not part of that Major\nComponent, and (b) serves only to enable use of the work with that\nMajor Component, or to implement a Standard Interface for which an\nimplementation is available to the public in source code form.  A\n\"Major Component\", in this context, means a major essential component\n(kernel, window system, and so on) of the specific operating system\n(if any) on which the executable work runs, or a compiler used to\nproduce the work, or an object code interpreter used to run it.\n\n  The \"Corresponding Source\" for a work in object code form means all\nthe source code needed to generate, install, and (for an executable\nwork) run the object code and to modify the work, including scripts to\ncontrol those activities.  However, it does not include the work's\nSystem Libraries, or general-purpose tools or generally available free\nprograms which are used unmodified in performing those activities but\nwhich are not part of the work.  For example, Corresponding Source\nincludes interface definition files associated with source files for\nthe work, and the source code for shared libraries and dynamically\nlinked subprograms that the work is specifically designed to require,\nsuch as by intimate data communication or control flow between those\nsubprograms and other parts of the work.\n\n  The Corresponding Source need not include anything that users\ncan regenerate automatically from other parts of the Corresponding\nSource.\n\n  The Corresponding Source for a work in source code form is that\nsame work.\n\n  2. Basic Permissions.\n\n  All rights granted under this License are granted for the term of\ncopyright on the Program, and are irrevocable provided the stated\nconditions are met.  This License explicitly affirms your unlimited\npermission to run the unmodified Program.  The output from running a\ncovered work is covered by this License only if the output, given its\ncontent, constitutes a covered work.  This License acknowledges your\nrights of fair use or other equivalent, as provided by copyright law.\n\n  You may make, run and propagate covered works that you do not\nconvey, without conditions so long as your license otherwise remains\nin force.  You may convey covered works to others for the sole purpose\nof having them make modifications exclusively for you, or provide you\nwith facilities for running those works, provided that you comply with\nthe terms of this License in conveying all material for which you do\nnot control copyright.  Those thus making or running the covered works\nfor you must do so exclusively on your behalf, under your direction\nand control, on terms that prohibit them from making any copies of\nyour copyrighted material outside their relationship with you.\n\n  Conveying under any other circumstances is permitted solely under\nthe conditions stated below.  Sublicensing is not allowed; section 10\nmakes it unnecessary.\n\n  3. Protecting Users' Legal Rights From Anti-Circumvention Law.\n\n  No covered work shall be deemed part of an effective technological\nmeasure under any applicable law fulfilling obligations under article\n11 of the WIPO copyright treaty adopted on 20 December 1996, or\nsimilar laws prohibiting or restricting circumvention of such\nmeasures.\n\n  When you convey a covered work, you waive any legal power to forbid\ncircumvention of technological measures to the extent such circumvention\nis effected by exercising rights under this License with respect to\nthe covered work, and you disclaim any intention to limit operation or\nmodification of the work as a means of enforcing, against the work's\nusers, your or third parties' legal rights to forbid circumvention of\ntechnological measures.\n\n  4. Conveying Verbatim Copies.\n\n  You may convey verbatim copies of the Program's source code as you\nreceive it, in any medium, provided that you conspicuously and\nappropriately publish on each copy an appropriate copyright notice;\nkeep intact all notices stating that this License and any\nnon-permissive terms added in accord with section 7 apply to the code;\nkeep intact all notices of the absence of any warranty; and give all\nrecipients a copy of this License along with the Program.\n\n  You may charge any price or no price for each copy that you convey,\nand you may offer support or warranty protection for a fee.\n\n  5. Conveying Modified Source Versions.\n\n  You may convey a work based on the Program, or the modifications to\nproduce it from the Program, in the form of source code under the\nterms of section 4, provided that you also meet all of these conditions:\n\n    a) The work must carry prominent notices stating that you modified\n    it, and giving a relevant date.\n\n    b) The work must carry prominent notices stating that it is\n    released under this License and any conditions added under section\n    7.  This requirement modifies the requirement in section 4 to\n    \"keep intact all notices\".\n\n    c) You must license the entire work, as a whole, under this\n    License to anyone who comes into possession of a copy.  This\n    License will therefore apply, along with any applicable section 7\n    additional terms, to the whole of the work, and all its parts,\n    regardless of how they are packaged.  This License gives no\n    permission to license the work in any other way, but it does not\n    invalidate such permission if you have separately received it.\n\n    d) If the work has interactive user interfaces, each must display\n    Appropriate Legal Notices; however, if the Program has interactive\n    interfaces that do not display Appropriate Legal Notices, your\n    work need not make them do so.\n\n  A compilation of a covered work with other separate and independent\nworks, which are not by their nature extensions of the covered work,\nand which are not combined with it such as to form a larger program,\nin or on a volume of a storage or distribution medium, is called an\n\"aggregate\" if the compilation and its resulting copyright are not\nused to limit the access or legal rights of the compilation's users\nbeyond what the individual works permit.  Inclusion of a covered work\nin an aggregate does not cause this License to apply to the other\nparts of the aggregate.\n\n  6. Conveying Non-Source Forms.\n\n  You may convey a covered work in object code form under the terms\nof sections 4 and 5, provided that you also convey the\nmachine-readable Corresponding Source under the terms of this License,\nin one of these ways:\n\n    a) Convey the object code in, or embodied in, a physical product\n    (including a physical distribution medium), accompanied by the\n    Corresponding Source fixed on a durable physical medium\n    customarily used for software interchange.\n\n    b) Convey the object code in, or embodied in, a physical product\n    (including a physical distribution medium), accompanied by a\n    written offer, valid for at least three years and valid for as\n    long as you offer spare parts or customer support for that product\n    model, to give anyone who possesses the object code either (1) a\n    copy of the Corresponding Source for all the software in the\n    product that is covered by this License, on a durable physical\n    medium customarily used for software interchange, for a price no\n    more than your reasonable cost of physically performing this\n    conveying of source, or (2) access to copy the\n    Corresponding Source from a network server at no charge.\n\n    c) Convey individual copies of the object code with a copy of the\n    written offer to provide the Corresponding Source.  This\n    alternative is allowed only occasionally and noncommercially, and\n    only if you received the object code with such an offer, in accord\n    with subsection 6b.\n\n    d) Convey the object code by offering access from a designated\n    place (gratis or for a charge), and offer equivalent access to the\n    Corresponding Source in the same way through the same place at no\n    further charge.  You need not require recipients to copy the\n    Corresponding Source along with the object code.  If the place to\n    copy the object code is a network server, the Corresponding Source\n    may be on a different server (operated by you or a third party)\n    that supports equivalent copying facilities, provided you maintain\n    clear directions next to the object code saying where to find the\n    Corresponding Source.  Regardless of what server hosts the\n    Corresponding Source, you remain obligated to ensure that it is\n    available for as long as needed to satisfy these requirements.\n\n    e) Convey the object code using peer-to-peer transmission, provided\n    you inform other peers where the object code and Corresponding\n    Source of the work are being offered to the general public at no\n    charge under subsection 6d.\n\n  A separable portion of the object code, whose source code is excluded\nfrom the Corresponding Source as a System Library, need not be\nincluded in conveying the object code work.\n\n  A \"User Product\" is either (1) a \"consumer product\", which means any\ntangible personal property which is normally used for personal, family,\nor household purposes, or (2) anything designed or sold for incorporation\ninto a dwelling.  In determining whether a product is a consumer product,\ndoubtful cases shall be resolved in favor of coverage.  For a particular\nproduct received by a particular user, \"normally used\" refers to a\ntypical or common use of that class of product, regardless of the status\nof the particular user or of the way in which the particular user\nactually uses, or expects or is expected to use, the product.  A product\nis a consumer product regardless of whether the product has substantial\ncommercial, industrial or non-consumer uses, unless such uses represent\nthe only significant mode of use of the product.\n\n  \"Installation Information\" for a User Product means any methods,\nprocedures, authorization keys, or other information required to install\nand execute modified versions of a covered work in that User Product from\na modified version of its Corresponding Source.  The information must\nsuffice to ensure that the continued functioning of the modified object\ncode is in no case prevented or interfered with solely because\nmodification has been made.\n\n  If you convey an object code work under this section in, or with, or\nspecifically for use in, a User Product, and the conveying occurs as\npart of a transaction in which the right of possession and use of the\nUser Product is transferred to the recipient in perpetuity or for a\nfixed term (regardless of how the transaction is characterized), the\nCorresponding Source conveyed under this section must be accompanied\nby the Installation Information.  But this requirement does not apply\nif neither you nor any third party retains the ability to install\nmodified object code on the User Product (for example, the work has\nbeen installed in ROM).\n\n  The requirement to provide Installation Information does not include a\nrequirement to continue to provide support service, warranty, or updates\nfor a work that has been modified or installed by the recipient, or for\nthe User Product in which it has been modified or installed.  Access to a\nnetwork may be denied when the modification itself materially and\nadversely affects the operation of the network or violates the rules and\nprotocols for communication across the network.\n\n  Corresponding Source conveyed, and Installation Information provided,\nin accord with this section must be in a format that is publicly\ndocumented (and with an implementation available to the public in\nsource code form), and must require no special password or key for\nunpacking, reading or copying.\n\n  7. Additional Terms.\n\n  \"Additional permissions\" are terms that supplement the terms of this\nLicense by making exceptions from one or more of its conditions.\nAdditional permissions that are applicable to the entire Program shall\nbe treated as though they were included in this License, to the extent\nthat they are valid under applicable law.  If additional permissions\napply only to part of the Program, that part may be used separately\nunder those permissions, but the entire Program remains governed by\nthis License without regard to the additional permissions.\n\n  When you convey a copy of a covered work, you may at your option\nremove any additional permissions from that copy, or from any part of\nit.  (Additional permissions may be written to require their own\nremoval in certain cases when you modify the work.)  You may place\nadditional permissions on material, added by you to a covered work,\nfor which you have or can give appropriate copyright permission.\n\n  Notwithstanding any other provision of this License, for material you\nadd to a covered work, you may (if authorized by the copyright holders of\nthat material) supplement the terms of this License with terms:\n\n    a) Disclaiming warranty or limiting liability differently from the\n    terms of sections 15 and 16 of this License; or\n\n    b) Requiring preservation of specified reasonable legal notices or\n    author attributions in that material or in the Appropriate Legal\n    Notices displayed by works containing it; or\n\n    c) Prohibiting misrepresentation of the origin of that material, or\n    requiring that modified versions of such material be marked in\n    reasonable ways as different from the original version; or\n\n    d) Limiting the use for publicity purposes of names of licensors or\n    authors of the material; or\n\n    e) Declining to grant rights under trademark law for use of some\n    trade names, trademarks, or service marks; or\n\n    f) Requiring indemnification of licensors and authors of that\n    material by anyone who conveys the material (or modified versions of\n    it) with contractual assumptions of liability to the recipient, for\n    any liability that these contractual assumptions directly impose on\n    those licensors and authors.\n\n  All other non-permissive additional terms are considered \"further\nrestrictions\" within the meaning of section 10.  If the Program as you\nreceived it, or any part of it, contains a notice stating that it is\ngoverned by this License along with a term that is a further\nrestriction, you may remove that term.  If a license document contains\na further restriction but permits relicensing or conveying under this\nLicense, you may add to a covered work material governed by the terms\nof that license document, provided that the further restriction does\nnot survive such relicensing or conveying.\n\n  If you add terms to a covered work in accord with this section, you\nmust place, in the relevant source files, a statement of the\nadditional terms that apply to those files, or a notice indicating\nwhere to find the applicable terms.\n\n  Additional terms, permissive or non-permissive, may be stated in the\nform of a separately written license, or stated as exceptions;\nthe above requirements apply either way.\n\n  8. Termination.\n\n  You may not propagate or modify a covered work except as expressly\nprovided under this License.  Any attempt otherwise to propagate or\nmodify it is void, and will automatically terminate your rights under\nthis License (including any patent licenses granted under the third\nparagraph of section 11).\n\n  However, if you cease all violation of this License, then your\nlicense from a particular copyright holder is reinstated (a)\nprovisionally, unless and until the copyright holder explicitly and\nfinally terminates your license, and (b) permanently, if the copyright\nholder fails to notify you of the violation by some reasonable means\nprior to 60 days after the cessation.\n\n  Moreover, your license from a particular copyright holder is\nreinstated permanently if the copyright holder notifies you of the\nviolation by some reasonable means, this is the first time you have\nreceived notice of violation of this License (for any work) from that\ncopyright holder, and you cure the violation prior to 30 days after\nyour receipt of the notice.\n\n  Termination of your rights under this section does not terminate the\nlicenses of parties who have received copies or rights from you under\nthis License.  If your rights have been terminated and not permanently\nreinstated, you do not qualify to receive new licenses for the same\nmaterial under section 10.\n\n  9. Acceptance Not Required for Having Copies.\n\n  You are not required to accept this License in order to receive or\nrun a copy of the Program.  Ancillary propagation of a covered work\noccurring solely as a consequence of using peer-to-peer transmission\nto receive a copy likewise does not require acceptance.  However,\nnothing other than this License grants you permission to propagate or\nmodify any covered work.  These actions infringe copyright if you do\nnot accept this License.  Therefore, by modifying or propagating a\ncovered work, you indicate your acceptance of this License to do so.\n\n  10. Automatic Licensing of Downstream Recipients.\n\n  Each time you convey a covered work, the recipient automatically\nreceives a license from the original licensors, to run, modify and\npropagate that work, subject to this License.  You are not responsible\nfor enforcing compliance by third parties with this License.\n\n  An \"entity transaction\" is a transaction transferring control of an\norganization, or substantially all assets of one, or subdividing an\norganization, or merging organizations.  If propagation of a covered\nwork results from an entity transaction, each party to that\ntransaction who receives a copy of the work also receives whatever\nlicenses to the work the party's predecessor in interest had or could\ngive under the previous paragraph, plus a right to possession of the\nCorresponding Source of the work from the predecessor in interest, if\nthe predecessor has it or can get it with reasonable efforts.\n\n  You may not impose any further restrictions on the exercise of the\nrights granted or affirmed under this License.  For example, you may\nnot impose a license fee, royalty, or other charge for exercise of\nrights granted under this License, and you may not initiate litigation\n(including a cross-claim or counterclaim in a lawsuit) alleging that\nany patent claim is infringed by making, using, selling, offering for\nsale, or importing the Program or any portion of it.\n\n  11. Patents.\n\n  A \"contributor\" is a copyright holder who authorizes use under this\nLicense of the Program or a work on which the Program is based.  The\nwork thus licensed is called the contributor's \"contributor version\".\n\n  A contributor's \"essential patent claims\" are all patent claims\nowned or controlled by the contributor, whether already acquired or\nhereafter acquired, that would be infringed by some manner, permitted\nby this License, of making, using, or selling its contributor version,\nbut do not include claims that would be infringed only as a\nconsequence of further modification of the contributor version.  For\npurposes of this definition, \"control\" includes the right to grant\npatent sublicenses in a manner consistent with the requirements of\nthis License.\n\n  Each contributor grants you a non-exclusive, worldwide, royalty-free\npatent license under the contributor's essential patent claims, to\nmake, use, sell, offer for sale, import and otherwise run, modify and\npropagate the contents of its contributor version.\n\n  In the following three paragraphs, a \"patent license\" is any express\nagreement or commitment, however denominated, not to enforce a patent\n(such as an express permission to practice a patent or covenant not to\nsue for patent infringement).  To \"grant\" such a patent license to a\nparty means to make such an agreement or commitment not to enforce a\npatent against the party.\n\n  If you convey a covered work, knowingly relying on a patent license,\nand the Corresponding Source of the work is not available for anyone\nto copy, free of charge and under the terms of this License, through a\npublicly available network server or other readily accessible means,\nthen you must either (1) cause the Corresponding Source to be so\navailable, or (2) arrange to deprive yourself of the benefit of the\npatent license for this particular work, or (3) arrange, in a manner\nconsistent with the requirements of this License, to extend the patent\nlicense to downstream recipients.  \"Knowingly relying\" means you have\nactual knowledge that, but for the patent license, your conveying the\ncovered work in a country, or your recipient's use of the covered work\nin a country, would infringe one or more identifiable patents in that\ncountry that you have reason to believe are valid.\n\n  If, pursuant to or in connection with a single transaction or\narrangement, you convey, or propagate by procuring conveyance of, a\ncovered work, and grant a patent license to some of the parties\nreceiving the covered work authorizing them to use, propagate, modify\nor convey a specific copy of the covered work, then the patent license\nyou grant is automatically extended to all recipients of the covered\nwork and works based on it.\n\n  A patent license is \"discriminatory\" if it does not include within\nthe scope of its coverage, prohibits the exercise of, or is\nconditioned on the non-exercise of one or more of the rights that are\nspecifically granted under this License.  You may not convey a covered\nwork if you are a party to an arrangement with a third party that is\nin the business of distributing software, under which you make payment\nto the third party based on the extent of your activity of conveying\nthe work, and under which the third party grants, to any of the\nparties who would receive the covered work from you, a discriminatory\npatent license (a) in connection with copies of the covered work\nconveyed by you (or copies made from those copies), or (b) primarily\nfor and in connection with specific products or compilations that\ncontain the covered work, unless you entered into that arrangement,\nor that patent license was granted, prior to 28 March 2007.\n\n  Nothing in this License shall be construed as excluding or limiting\nany implied license or other defenses to infringement that may\notherwise be available to you under applicable patent law.\n\n  12. No Surrender of Others' Freedom.\n\n  If conditions are imposed on you (whether by court order, agreement or\notherwise) that contradict the conditions of this License, they do not\nexcuse you from the conditions of this License.  If you cannot convey a\ncovered work so as to satisfy simultaneously your obligations under this\nLicense and any other pertinent obligations, then as a consequence you may\nnot convey it at all.  For example, if you agree to terms that obligate you\nto collect a royalty for further conveying from those to whom you convey\nthe Program, the only way you could satisfy both those terms and this\nLicense would be to refrain entirely from conveying the Program.\n\n  13. Remote Network Interaction; Use with the GNU General Public License.\n\n  Notwithstanding any other provision of this License, if you modify the\nProgram, your modified version must prominently offer all users\ninteracting with it remotely through a computer network (if your version\nsupports such interaction) an opportunity to receive the Corresponding\nSource of your version by providing access to the Corresponding Source\nfrom a network server at no charge, through some standard or customary\nmeans of facilitating copying of software.  This Corresponding Source\nshall include the Corresponding Source for any work covered by version 3\nof the GNU General Public License that is incorporated pursuant to the\nfollowing paragraph.\n\n  Notwithstanding any other provision of this License, you have\npermission to link or combine any covered work with a work licensed\nunder version 3 of the GNU General Public License into a single\ncombined work, and to convey the resulting work.  The terms of this\nLicense will continue to apply to the part which is the covered work,\nbut the work with which it is combined will remain governed by version\n3 of the GNU General Public License.\n\n  14. Revised Versions of this License.\n\n  The Free Software Foundation may publish revised and/or new versions of\nthe GNU Affero General Public License from time to time.  Such new versions\nwill be similar in spirit to the present version, but may differ in detail to\naddress new problems or concerns.\n\n  Each version is given a distinguishing version number.  If the\nProgram specifies that a certain numbered version of the GNU Affero General\nPublic License \"or any later version\" applies to it, you have the\noption of following the terms and conditions either of that numbered\nversion or of any later version published by the Free Software\nFoundation.  If the Program does not specify a version number of the\nGNU Affero General Public License, you may choose any version ever published\nby the Free Software Foundation.\n\n  If the Program specifies that a proxy can decide which future\nversions of the GNU Affero General Public License can be used, that proxy's\npublic statement of acceptance of a version permanently authorizes you\nto choose that version for the Program.\n\n  Later license versions may give you additional or different\npermissions.  However, no additional obligations are imposed on any\nauthor or copyright holder as a result of your choosing to follow a\nlater version.\n\n  15. Disclaimer of Warranty.\n\n  THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY\nAPPLICABLE LAW.  EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT\nHOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM \"AS IS\" WITHOUT WARRANTY\nOF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO,\nTHE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\nPURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM\nIS WITH YOU.  SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF\nALL NECESSARY SERVICING, REPAIR OR CORRECTION.\n\n  16. Limitation of Liability.\n\n  IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING\nWILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR CONVEYS\nTHE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY\nGENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE\nUSE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF\nDATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD\nPARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS),\nEVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF\nSUCH DAMAGES.\n\n  17. Interpretation of Sections 15 and 16.\n\n  If the disclaimer of warranty and limitation of liability provided\nabove cannot be given local legal effect according to their terms,\nreviewing courts shall apply local law that most closely approximates\nan absolute waiver of all civil liability in connection with the\nProgram, unless a warranty or assumption of liability accompanies a\ncopy of the Program in return for a fee.\n\n                     END OF TERMS AND CONDITIONS\n\n            How to Apply These Terms to Your New Programs\n\n  If you develop a new program, and you want it to be of the greatest\npossible use to the public, the best way to achieve this is to make it\nfree software which everyone can redistribute and change under these terms.\n\n  To do so, attach the following notices to the program.  It is safest\nto attach them to the start of each source file to most effectively\nstate the exclusion of warranty; and each file should have at least\nthe \"copyright\" line and a pointer to where the full notice is found.\n\n    <one line to give the program's name and a brief idea of what it does.>\n    Copyright (C) <year>  <name of author>\n\n    This program is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Affero General Public License as published\n    by the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Affero General Public License for more details.\n\n    You should have received a copy of the GNU Affero General Public License\n    along with this program.  If not, see <https://www.gnu.org/licenses/>.\n\nAlso add information on how to contact you by electronic and paper mail.\n\n  If your software can interact with users remotely through a computer\nnetwork, you should also make sure that it provides a way for users to\nget its source.  For example, if your program is a web application, its\ninterface could display a \"Source\" link that leads users to an archive\nof the code.  There are many ways you could offer source, and different\nsolutions will be better for different programs; see section 13 for the\nspecific requirements.\n\n  You should also get your employer (if you work as a programmer) or school,\nif any, to sign a \"copyright disclaimer\" for the program, if necessary.\nFor more information on this, and how to apply and follow the GNU AGPL, see\n<https://www.gnu.org/licenses/>.\n",
      "hash": "8486a10c4393cee1c25392769ddd3b2d6c242d6ec7928e1414efff7dfb2f07ef",
      "size": 34523
    },
    "/README.md": {
      "type": "content",
      "content": "# Shared Kernel Library\r\n\r\nThis is the core shared library component of the [Namma Yatri](https://github.com/nammayatri/nammayatri) project. It provides essential functionality, types, and interfaces that are used across various services in the Namma Yatri ecosystem.\r\n\r\n## Core Purpose\r\n\r\nThe shared kernel library serves as the foundation for the Namma Yatri platform, providing:\r\n\r\n1. **Database Layer** (`src/Kernel/Beam/`)\r\n   - PostgreSQL connection management\r\n   - Redis integration\r\n   - Beam ORM utilities and types\r\n   - Common database functions and queries\r\n\r\n2. **External Service Integrations** (`src/Kernel/External/`)\r\n   - Payment processing\r\n   - Communication services (SMS, WhatsApp, Call)\r\n   - Maps and location services\r\n   - Verification services (Aadhaar, Background checks)\r\n   - Multi-modal transportation integration\r\n   - Incident reporting\r\n   - Notification systems\r\n\r\n3. **Core Utilities** (`src/Kernel/Utils/`)\r\n   - Common data types and interfaces\r\n   - Error handling and logging\r\n   - Configuration management\r\n   - Encryption utilities\r\n   - Serviceability checks\r\n\r\n4. **Internal APIs** (`src/Kernel/InternalAPI/`)\r\n   - Shared API types and interfaces\r\n   - Common API utilities\r\n\r\n5. **Storage Layer** (`src/Kernel/Storage/`)\r\n   - Clickhouse integration (both V1 and V2)\r\n   - Redis integration via Hedis\r\n   - SQL query building with Esqueleto\r\n   - Beam ORM integration\r\n   - Common storage queries and utilities\r\n\r\n## Project Structure\r\n\r\n```\r\nsrc/\r\n Kernel/\r\n     Beam/           # Database operations and ORM\r\n     External/       # External service integrations\r\n        Payment/    # Payment gateway integrations\r\n        SMS/        # SMS service integrations\r\n        Maps/       # Maps and location services\r\n        Verification/# Verification services\r\n     InternalAPI/    # Internal API definitions\r\n     Storage/        # Storage utilities\r\n     Types/          # Common type definitions\r\n     Utils/          # Utility functions\r\n     Prelude.hs      # Custom prelude with common imports\r\n```\r\n\r\n## Key Features\r\n\r\n### Database Operations\r\n- Type-safe database queries using Beam ORM\r\n- Connection pooling and management\r\n- Redis caching utilities\r\n- Common database functions and utilities\r\n\r\n### External Services\r\n- Payment gateway integrations\r\n- Communication services (SMS, WhatsApp, Voice calls)\r\n- Maps and location services\r\n- Verification services (Aadhaar, Background checks)\r\n- Multi-modal transportation integration\r\n- Incident reporting system\r\n- Notification delivery system\r\n\r\n### Core Utilities\r\n- Common data types and interfaces\r\n- Error handling and logging\r\n- Configuration management\r\n- Encryption utilities\r\n- Serviceability checks\r\n- Randomization utilities\r\n\r\n## Development Setup\r\n\r\n### Prerequisites\r\n\r\n- [Nix](https://nixos.org/download.html) (version 2.4 or later)\r\n- [Haskell](https://www.haskell.org/downloads/) (managed via Nix)\r\n- [direnv](https://direnv.net/) (optional)\r\n- PostgreSQL (for local development)\r\n- Redis (for local development)\r\n\r\n### Getting Started\r\n\r\n1. Clone the Namma Yatri repository:\r\n   ```bash\r\n   git clone https://github.com/nammayatri/nammayatri.git\r\n   cd nammayatri/Backend/shared-kernel\r\n   ```\r\n\r\n2. Set up the development environment:\r\n   ```bash\r\n   nix develop\r\n   ```\r\n\r\n3. Configure environment variables:\r\n   ```bash\r\n   direnv allow\r\n   ```\r\n\r\n4. Build the library:\r\n   ```bash\r\n   # Choose one of the following commands:\r\n   cabal build\r\n   # or\r\n   nix build\r\n   # or\r\n   cabal repl all\r\n   ```\r\n   \r\n\r\n5. Run tests:\r\n   ```bash\r\n   cabal test\r\n   ```\r\n\r\n## Development Guidelines\r\n\r\n### Code Organization\r\n\r\n- Place new database types in `src/Kernel/Beam/Types/`\r\n- Add external service integrations in `src/Kernel/External/`\r\n- Put utility functions in `src/Kernel/Utils/`\r\n- Define common types in `src/Kernel/Types/`\r\n\r\n\r\n### Code Quality\r\n\r\nThe project uses:\r\n- ormolu for code formatting\r\n- hlint for linting\r\n- Pre-commit hooks for automated checks\r\n\r\n## Contributing\r\n\r\nPlease read the [Namma Yatri Contributing Guidelines](https://github.com/nammayatri/nammayatri/blob/main/docs/CONTRIBUTING.md.md) before submitting changes.\r\n\r\nKey points:\r\n- Follow the existing code style\r\n- Add tests for new functionality\r\n- Update documentation\r\n- Ensure all tests pass\r\n- Update CHANGELOG.md for significant changes\r\n\r\n## License\r\n\r\nThis project is licensed under the AGPL License - see the [LICENSE.md](LICENSE.md) file for details.\r\n\r\n## Support\r\n\r\nFor support:\r\n1. Check the [Namma Yatri documentation](https://github.com/nammayatri/nammayatri/tree/main/Backend#getting-started)\r\n2. Search existing issues\r\n3. Create a new issue if needed\r\n\r\n## Related Components\r\n\r\n- [Backend Services](https://github.com/nammayatri/nammayatri/tree/main/Backend)\r\n",
      "hash": "2118914cf38d4905bc1cab23509968e27710be8d98d033f42e723cbab133b8dd",
      "size": 4903
    },
    "/cabal.project": {
      "type": "content",
      "content": "packages:\n  lib/mobility-core\n",
      "hash": "27f3d28ae7e89ae60b4a1f1c57e5db9ebbd49b20f7f4183f9f15fb8f1a09de65",
      "size": 30
    },
    "/cli-tools/gql/README.md": {
      "type": "content",
      "content": "# Downloads:\nGet the latest morpheus-cli from [morpheusgraphql](https://github.com/morpheusgraphql/morpheus-graphql/releases)\n\nReplace file query file path in the [yaml](./gql-code-gen.yaml)\n\nUpdate the schema.gql if any new fields you are using in query.\n\n# Generate:\n```shell\n./gql-code-gen.sh\n```\n",
      "hash": "fad879a8f7e394461664751c5ee8a654c8f223457f7d13a821f267c573f2201b",
      "size": 300
    },
    "/cli-tools/gql/code-gen.sh": {
      "type": "content",
      "content": "chmod +x ./morpheus\n./morpheus build ./\nqueryFilename=../../lib/mobility-core/auto-generated/Kernel/External/MultiModal/OpenTripPlanner/Query-2.hs\nschemaFilename=../../lib/mobility-core/auto-generated/Kernel/External/MultiModal/OpenTripPlanner/Schema.hs\nif [[ \"$OSTYPE\" == \"darwin\"* ]]; then\n  # macOS\n  sed -i '' 's/[[:<:]]Float[[:>:]]/Double/g' \"$queryFilename\"\n  sed -i '' 's/[[:<:]]Float[[:>:]]/Double/g' \"$schemaFilename\"\nelse\n  # Linux and other Unix-like\n  sed -i 's/\\bFloat\\b/Double/g' \"$queryFilename\"\n  sed -i 's/\\bFloat\\b/Double/g' \"$schemaFilename\"\nfi\n",
      "hash": "3cb57c22297c892f7ed7096682f4596e8dee5d9fa4a01b61b9a76bb9675c0f89",
      "size": 564
    },
    "/cli-tools/gql/code-gen.yaml": {
      "type": "content",
      "content": "client:\n  - name: OpenTripPlanner API # Name of the service\n    source: ../../lib/mobility-core/auto-generated/Kernel/External/MultiModal/OpenTripPlanner/ # root folder for haskell source files\n    schema: schema.gql\n    includes:\n      - path: query-2.gql # list of gql sources\n\n# reference: https://morpheusgraphql.com/code-gen\n# morpheus build ./  will generate two files Schema.hs and Query.hs Combine these two files to one\n",
      "hash": "0a26ab8d16e982ffef9468ea7ecaf57b96b68e200a989291d0dff91123ba7443",
      "size": 429,
      "json": {
        "client": [
          {
            "name": "OpenTripPlanner API",
            "source": "../../lib/mobility-core/auto-generated/Kernel/External/MultiModal/OpenTripPlanner/",
            "schema": "schema.gql",
            "includes": [
              {
                "path": "query-2.gql"
              }
            ]
          }
        ]
      }
    },
    "/cli-tools/gql/morpheus": {
      "type": "binary",
      "hash": "c2edcc235082cd5795ae877fe6498a15dc013f3a3d1546ab6d06e23c03e0b4ca",
      "size": 9172168,
      "url": "https://raw.githubusercontent.com/nammayatri/shared-kernel/b19b62ccc9511b2ecf8c74a7948725e979e990a2/cli-tools/gql/morpheus"
    },
    "/cli-tools/gql/morpheus-mac-os.zip": {
      "type": "binary",
      "hash": "8a1b3895ac38bf9b7b370874eea276396a07522f62812a7fb914fe7f14157b5b",
      "size": 1824095,
      "url": "https://raw.githubusercontent.com/nammayatri/shared-kernel/b19b62ccc9511b2ecf8c74a7948725e979e990a2/cli-tools/gql/morpheus-mac-os.zip"
    },
    "/flake.lock": {
      "type": "content",
      "content": "{\n  \"nodes\": {\n    \"beam\": {\n      \"inputs\": {\n        \"flake-parts\": \"flake-parts_7\",\n        \"haskell-flake\": [\n          \"euler-hs\",\n          \"sequelize\",\n          \"beam-mysql\",\n          \"haskell-flake\"\n        ],\n        \"nixpkgs\": [\n          \"euler-hs\",\n          \"sequelize\",\n          \"beam-mysql\",\n          \"nixpkgs\"\n        ]\n      },\n      \"locked\": {\n        \"lastModified\": 1693307537,\n        \"narHash\": \"sha256-BIq3ZjZQWQ0w3zWA19zGBggiVVfnOzR5d4b7De0oVZY=\",\n        \"owner\": \"arjunkathuria\",\n        \"repo\": \"beam\",\n        \"rev\": \"06bcc50997fdcfb87125bed252e888e5dd1e6d9c\",\n        \"type\": \"github\"\n      },\n      \"original\": {\n        \"owner\": \"arjunkathuria\",\n        \"ref\": \"GHC-927-Upgrade\",\n        \"repo\": \"beam\",\n        \"type\": \"github\"\n      }\n    },\n    \"beam-mysql\": {\n      \"inputs\": {\n        \"beam\": \"beam\",\n        \"bytestring-lexing\": \"bytestring-lexing\",\n        \"flake-parts\": \"flake-parts_8\",\n        \"haskell-flake\": [\n          \"euler-hs\",\n          \"sequelize\",\n          \"haskell-flake\"\n        ],\n        \"mysql-haskell\": \"mysql-haskell\",\n        \"nixpkgs\": [\n          \"euler-hs\",\n          \"sequelize\",\n          \"nixpkgs\"\n        ]\n      },\n      \"locked\": {\n        \"lastModified\": 1693308989,\n        \"narHash\": \"sha256-3qyg/Uj3A+MTS494VH2lTBtOz9uptgm+V1M1bPFxTX0=\",\n        \"owner\": \"arjunkathuria\",\n        \"repo\": \"beam-mysql\",\n        \"rev\": \"2ef13d8ecdcd0959b8604b3106b2013baf2ad272\",\n        \"type\": \"github\"\n      },\n      \"original\": {\n        \"owner\": \"arjunkathuria\",\n        \"ref\": \"GHC-927\",\n        \"repo\": \"beam-mysql\",\n        \"type\": \"github\"\n      }\n    },\n    \"bytestring-lexing\": {\n      \"flake\": false,\n      \"locked\": {\n        \"lastModified\": 1596188445,\n        \"narHash\": \"sha256-n/5kFb5msE8NPQZf6bsm8MQh0RGDoOx6EJXoji6FPMs=\",\n        \"owner\": \"juspay\",\n        \"repo\": \"bytestring-lexing\",\n        \"rev\": \"0a46db1139011736687cb50bbd3877d223bcb737\",\n        \"type\": \"github\"\n      },\n      \"original\": {\n        \"owner\": \"juspay\",\n        \"repo\": \"bytestring-lexing\",\n        \"type\": \"github\"\n      }\n    },\n    \"cachix\": {\n      \"inputs\": {\n        \"devenv\": \"devenv\",\n        \"flake-compat\": \"flake-compat_2\",\n        \"hnix-store-core\": \"hnix-store-core\",\n        \"nixpkgs\": \"nixpkgs_10\"\n      },\n      \"locked\": {\n        \"lastModified\": 1679144949,\n        \"narHash\": \"sha256-xhLCsAkz5c+XIqQ4eGY9bSp3zBgCDCaHXZ2HLk8vqmE=\",\n        \"owner\": \"cachix\",\n        \"repo\": \"cachix\",\n        \"rev\": \"c8f0d787939c93cc686c2604f7d024e631e4a00d\",\n        \"type\": \"github\"\n      },\n      \"original\": {\n        \"owner\": \"cachix\",\n        \"ref\": \"v1.3.3\",\n        \"repo\": \"cachix\",\n        \"type\": \"github\"\n      }\n    },\n    \"cachix-push\": {\n      \"locked\": {\n        \"lastModified\": 1726080112,\n        \"narHash\": \"sha256-OcmKmI5lO6ZcJNdZkWK5ObauO8YyazG3nBqGlwC9Y+0=\",\n        \"owner\": \"juspay\",\n        \"repo\": \"cachix-push\",\n        \"rev\": \"8ed534b817ab110387ff3bc95c211f668d7ccf2f\",\n        \"type\": \"github\"\n      },\n      \"original\": {\n        \"owner\": \"juspay\",\n        \"repo\": \"cachix-push\",\n        \"type\": \"github\"\n      }\n    },\n    \"cachix-push_2\": {\n      \"inputs\": {\n        \"cachix\": \"cachix\",\n        \"devour-flake\": \"devour-flake\"\n      },\n      \"locked\": {\n        \"lastModified\": 1682526722,\n        \"narHash\": \"sha256-KT6KrzN61amTBoQjI1u+gXYYOaYYMLR4p7lcFLpwqy8=\",\n        \"owner\": \"juspay\",\n        \"repo\": \"cachix-push\",\n        \"rev\": \"18652f04b2bd28892f13571d6fd42853aaaf7862\",\n        \"type\": \"github\"\n      },\n      \"original\": {\n        \"owner\": \"juspay\",\n        \"repo\": \"cachix-push\",\n        \"type\": \"github\"\n      }\n    },\n    \"cereal\": {\n      \"flake\": false,\n      \"locked\": {\n        \"lastModified\": 1696234101,\n        \"narHash\": \"sha256-dDUIny/9kZ0Bx/r/IPa9XRDcNT10XweR1uHqKx1CbAk=\",\n        \"owner\": \"juspay\",\n        \"repo\": \"cereal\",\n        \"rev\": \"ee7fc69f499e86b8274906ba183b60f4f08457a6\",\n        \"type\": \"github\"\n      },\n      \"original\": {\n        \"owner\": \"juspay\",\n        \"repo\": \"cereal\",\n        \"type\": \"github\"\n      }\n    },\n    \"clickhouse-haskell\": {\n      \"inputs\": {\n        \"common\": [\n          \"common\"\n        ]\n      },\n      \"locked\": {\n        \"lastModified\": 1699959073,\n        \"narHash\": \"sha256-0Ovbd1CzgI4tSCTBe6z/7p8DpbajKyFlyS39hu4xpNY=\",\n        \"owner\": \"nammayatri\",\n        \"repo\": \"clickhouse-haskell\",\n        \"rev\": \"5314118b2635724b87f7993da9dc8446602bcd65\",\n        \"type\": \"github\"\n      },\n      \"original\": {\n        \"owner\": \"nammayatri\",\n        \"repo\": \"clickhouse-haskell\",\n        \"type\": \"github\"\n      }\n    },\n    \"common\": {\n      \"inputs\": {\n        \"cachix-push\": \"cachix-push\",\n        \"crane\": \"crane\",\n        \"flake-parts\": \"flake-parts\",\n        \"flake-root\": \"flake-root\",\n        \"haskell-flake\": \"haskell-flake\",\n        \"mission-control\": \"mission-control\",\n        \"nix-health\": \"nix-health\",\n        \"nixpkgs\": \"nixpkgs_4\",\n        \"nixpkgs-140774-workaround\": \"nixpkgs-140774-workaround\",\n        \"nixpkgs-21_11\": \"nixpkgs-21_11\",\n        \"nixpkgs-latest\": \"nixpkgs-latest\",\n        \"pre-commit-hooks-nix\": \"pre-commit-hooks-nix\",\n        \"process-compose\": \"process-compose\",\n        \"process-compose-flake\": \"process-compose-flake\",\n        \"rust-overlay\": \"rust-overlay_2\",\n        \"systems\": \"systems_4\",\n        \"treefmt-nix\": \"treefmt-nix_2\"\n      },\n      \"locked\": {\n        \"lastModified\": 1726080673,\n        \"narHash\": \"sha256-rZALUTNsH0ZJf7E9uu7PIZNErEG0nApiXouSCuqiKH8=\",\n        \"owner\": \"nammayatri\",\n        \"repo\": \"common\",\n        \"rev\": \"b3ab35d3a393ad5b9c587cd60fc3690e7a35ef62\",\n        \"type\": \"github\"\n      },\n      \"original\": {\n        \"owner\": \"nammayatri\",\n        \"repo\": \"common\",\n        \"type\": \"github\"\n      }\n    },\n    \"common_2\": {\n      \"inputs\": {\n        \"cachix-push\": \"cachix-push_2\",\n        \"flake-parts\": \"flake-parts_3\",\n        \"flake-root\": \"flake-root_2\",\n        \"haskell-flake\": \"haskell-flake_2\",\n        \"mission-control\": \"mission-control_2\",\n        \"nixpkgs\": \"nixpkgs_11\",\n        \"nixpkgs-140774-workaround\": \"nixpkgs-140774-workaround_2\",\n        \"nixpkgs-21_11\": \"nixpkgs-21_11_2\",\n        \"pre-commit-hooks-nix\": \"pre-commit-hooks-nix_2\",\n        \"process-compose-flake\": \"process-compose-flake_2\",\n        \"systems\": \"systems_5\",\n        \"treefmt-nix\": \"treefmt-nix_3\"\n      },\n      \"locked\": {\n        \"lastModified\": 1699950488,\n        \"narHash\": \"sha256-llyrSKHNFL1FptFykCelRjitl3x0b4JsSkQQyCKVZhU=\",\n        \"owner\": \"nammayatri\",\n        \"repo\": \"common\",\n        \"rev\": \"0ae95ce0df4a0c6be221fdbd946f35e54e97ccf5\",\n        \"type\": \"github\"\n      },\n      \"original\": {\n        \"owner\": \"nammayatri\",\n        \"repo\": \"common\",\n        \"type\": \"github\"\n      }\n    },\n    \"crane\": {\n      \"inputs\": {\n        \"nixpkgs\": [\n          \"common\",\n          \"nixpkgs\"\n        ]\n      },\n      \"locked\": {\n        \"lastModified\": 1704300976,\n        \"narHash\": \"sha256-QLMpTrHxsND2T8+khAhLCqzOY/h2SzWS0s4Z7N2ds/E=\",\n        \"owner\": \"ipetkov\",\n        \"repo\": \"crane\",\n        \"rev\": \"0efe36f9232e0961512572883ba9c995aa1f54b1\",\n        \"type\": \"github\"\n      },\n      \"original\": {\n        \"owner\": \"ipetkov\",\n        \"repo\": \"crane\",\n        \"type\": \"github\"\n      }\n    },\n    \"crane_2\": {\n      \"inputs\": {\n        \"nixpkgs\": [\n          \"common\",\n          \"nix-health\",\n          \"rust-flake\",\n          \"nixpkgs\"\n        ]\n      },\n      \"locked\": {\n        \"lastModified\": 1707685877,\n        \"narHash\": \"sha256-XoXRS+5whotelr1rHiZle5t5hDg9kpguS5yk8c8qzOc=\",\n        \"owner\": \"ipetkov\",\n        \"repo\": \"crane\",\n        \"rev\": \"2c653e4478476a52c6aa3ac0495e4dea7449ea0e\",\n        \"type\": \"github\"\n      },\n      \"original\": {\n        \"owner\": \"ipetkov\",\n        \"repo\": \"crane\",\n        \"rev\": \"2c653e4478476a52c6aa3ac0495e4dea7449ea0e\",\n        \"type\": \"github\"\n      }\n    },\n    \"devenv\": {\n      \"inputs\": {\n        \"flake-compat\": [\n          \"euler-hs\",\n          \"common\",\n          \"cachix-push\",\n          \"cachix\",\n          \"flake-compat\"\n        ],\n        \"nix\": \"nix\",\n        \"nixpkgs\": \"nixpkgs_9\",\n        \"pre-commit-hooks\": \"pre-commit-hooks\"\n      },\n      \"locked\": {\n        \"lastModified\": 1678184100,\n        \"narHash\": \"sha256-6R0LmBiS2E6CApdqqFpY2IBXDAg2RQ2JHBkJOLMxXsY=\",\n        \"owner\": \"cachix\",\n        \"repo\": \"devenv\",\n        \"rev\": \"b9e0ace80abd0ca5631ab5df7d6562ba9d8af50c\",\n        \"type\": \"github\"\n      },\n      \"original\": {\n        \"owner\": \"cachix\",\n        \"repo\": \"devenv\",\n        \"type\": \"github\"\n      }\n    },\n    \"devour-flake\": {\n      \"flake\": false,\n      \"locked\": {\n        \"lastModified\": 1682445319,\n        \"narHash\": \"sha256-TTWt0MNxCjW6Rc0z8Li0X3O7wdAj1tr7tnPHxERb0p0=\",\n        \"owner\": \"srid\",\n        \"repo\": \"devour-flake\",\n        \"rev\": \"6cd32c62c4d7ef76f6e8534ae578a395af6cafce\",\n        \"type\": \"github\"\n      },\n      \"original\": {\n        \"owner\": \"srid\",\n        \"repo\": \"devour-flake\",\n        \"type\": \"github\"\n      }\n    },\n    \"euler-events-hs\": {\n      \"inputs\": {\n        \"flake-parts\": \"flake-parts_4\",\n        \"haskell-flake\": [\n          \"euler-hs\",\n          \"haskell-flake\"\n        ],\n        \"nixpkgs\": \"nixpkgs_14\",\n        \"prometheus-haskell\": \"prometheus-haskell\"\n      },\n      \"locked\": {\n        \"lastModified\": 1690219299,\n        \"narHash\": \"sha256-YXz1EjpFkgFAC3txAj/9ItuO0SQBKrOwykBmc9w4qXs=\",\n        \"owner\": \"juspay\",\n        \"repo\": \"euler-events-hs\",\n        \"rev\": \"214d436a83113c04b6f937c68488abf53beea4e8\",\n        \"type\": \"github\"\n      },\n      \"original\": {\n        \"owner\": \"juspay\",\n        \"ref\": \"main\",\n        \"repo\": \"euler-events-hs\",\n        \"type\": \"github\"\n      }\n    },\n    \"euler-hs\": {\n      \"inputs\": {\n        \"cereal\": \"cereal\",\n        \"common\": \"common_2\",\n        \"euler-events-hs\": \"euler-events-hs\",\n        \"flake-parts\": [\n          \"euler-hs\",\n          \"common\",\n          \"flake-parts\"\n        ],\n        \"haskell-flake\": [\n          \"haskell-flake\"\n        ],\n        \"hedis\": \"hedis\",\n        \"juspay-extra\": \"juspay-extra\",\n        \"nixpkgs\": [\n          \"nixpkgs\"\n        ],\n        \"sequelize\": \"sequelize\",\n        \"servant-mock\": \"servant-mock\",\n        \"tinylog\": \"tinylog\"\n      },\n      \"locked\": {\n        \"lastModified\": 1741173147,\n        \"narHash\": \"sha256-ksarQpBsANKu35mwK5iSvEZK9L7INyZlBelU39HkMZA=\",\n        \"owner\": \"nammayatri\",\n        \"repo\": \"euler-hs\",\n        \"rev\": \"1e5873dfe47eae540df4ffe975c8a1e17c27c423\",\n        \"type\": \"github\"\n      },\n      \"original\": {\n        \"owner\": \"nammayatri\",\n        \"repo\": \"euler-hs\",\n        \"type\": \"github\"\n      }\n    },\n    \"flake-compat\": {\n      \"flake\": false,\n      \"locked\": {\n        \"lastModified\": 1673956053,\n        \"narHash\": \"sha256-4gtG9iQuiKITOjNQQeQIpoIB6b16fm+504Ch3sNKLd8=\",\n        \"owner\": \"edolstra\",\n        \"repo\": \"flake-compat\",\n        \"rev\": \"35bb57c0c8d8b62bbfd284272c928ceb64ddbde9\",\n        \"type\": \"github\"\n      },\n      \"original\": {\n        \"owner\": \"edolstra\",\n        \"repo\": \"flake-compat\",\n        \"type\": \"github\"\n      }\n    },\n    \"flake-compat_2\": {\n      \"flake\": false,\n      \"locked\": {\n        \"lastModified\": 1673956053,\n        \"narHash\": \"sha256-4gtG9iQuiKITOjNQQeQIpoIB6b16fm+504Ch3sNKLd8=\",\n        \"owner\": \"edolstra\",\n        \"repo\": \"flake-compat\",\n        \"rev\": \"35bb57c0c8d8b62bbfd284272c928ceb64ddbde9\",\n        \"type\": \"github\"\n      },\n      \"original\": {\n        \"owner\": \"edolstra\",\n        \"repo\": \"flake-compat\",\n        \"type\": \"github\"\n      }\n    },\n    \"flake-compat_3\": {\n      \"flake\": false,\n      \"locked\": {\n        \"lastModified\": 1673956053,\n        \"narHash\": \"sha256-4gtG9iQuiKITOjNQQeQIpoIB6b16fm+504Ch3sNKLd8=\",\n        \"owner\": \"edolstra\",\n        \"repo\": \"flake-compat\",\n        \"rev\": \"35bb57c0c8d8b62bbfd284272c928ceb64ddbde9\",\n        \"type\": \"github\"\n      },\n      \"original\": {\n        \"owner\": \"edolstra\",\n        \"repo\": \"flake-compat\",\n        \"type\": \"github\"\n      }\n    },\n    \"flake-parts\": {\n      \"inputs\": {\n        \"nixpkgs-lib\": \"nixpkgs-lib\"\n      },\n      \"locked\": {\n        \"lastModified\": 1725234343,\n        \"narHash\": \"sha256-+ebgonl3NbiKD2UD0x4BszCZQ6sTfL4xioaM49o5B3Y=\",\n        \"owner\": \"hercules-ci\",\n        \"repo\": \"flake-parts\",\n        \"rev\": \"567b938d64d4b4112ee253b9274472dc3a346eb6\",\n        \"type\": \"github\"\n      },\n      \"original\": {\n        \"owner\": \"hercules-ci\",\n        \"repo\": \"flake-parts\",\n        \"type\": \"github\"\n      }\n    },\n    \"flake-parts_10\": {\n      \"inputs\": {\n        \"nixpkgs-lib\": \"nixpkgs-lib_10\"\n      },\n      \"locked\": {\n        \"lastModified\": 1683560683,\n        \"narHash\": \"sha256-XAygPMN5Xnk/W2c1aW0jyEa6lfMDZWlQgiNtmHXytPc=\",\n        \"owner\": \"hercules-ci\",\n        \"repo\": \"flake-parts\",\n        \"rev\": \"006c75898cf814ef9497252b022e91c946ba8e17\",\n        \"type\": \"github\"\n      },\n      \"original\": {\n        \"owner\": \"hercules-ci\",\n        \"repo\": \"flake-parts\",\n        \"type\": \"github\"\n      }\n    },\n    \"flake-parts_2\": {\n      \"inputs\": {\n        \"nixpkgs-lib\": \"nixpkgs-lib_2\"\n      },\n      \"locked\": {\n        \"lastModified\": 1698882062,\n        \"narHash\": \"sha256-HkhafUayIqxXyHH1X8d9RDl1M2CkFgZLjKD3MzabiEo=\",\n        \"owner\": \"hercules-ci\",\n        \"repo\": \"flake-parts\",\n        \"rev\": \"8c9fa2545007b49a5db5f650ae91f227672c3877\",\n        \"type\": \"github\"\n      },\n      \"original\": {\n        \"owner\": \"hercules-ci\",\n        \"repo\": \"flake-parts\",\n        \"type\": \"github\"\n      }\n    },\n    \"flake-parts_3\": {\n      \"inputs\": {\n        \"nixpkgs-lib\": \"nixpkgs-lib_3\"\n      },\n      \"locked\": {\n        \"lastModified\": 1677714448,\n        \"narHash\": \"sha256-Hq8qLs8xFu28aDjytfxjdC96bZ6pds21Yy09mSC156I=\",\n        \"owner\": \"hercules-ci\",\n        \"repo\": \"flake-parts\",\n        \"rev\": \"dc531e3a9ce757041e1afaff8ee932725ca60002\",\n        \"type\": \"github\"\n      },\n      \"original\": {\n        \"owner\": \"hercules-ci\",\n        \"repo\": \"flake-parts\",\n        \"type\": \"github\"\n      }\n    },\n    \"flake-parts_4\": {\n      \"inputs\": {\n        \"nixpkgs-lib\": \"nixpkgs-lib_4\"\n      },\n      \"locked\": {\n        \"lastModified\": 1683560683,\n        \"narHash\": \"sha256-XAygPMN5Xnk/W2c1aW0jyEa6lfMDZWlQgiNtmHXytPc=\",\n        \"owner\": \"hercules-ci\",\n        \"repo\": \"flake-parts\",\n        \"rev\": \"006c75898cf814ef9497252b022e91c946ba8e17\",\n        \"type\": \"github\"\n      },\n      \"original\": {\n        \"owner\": \"hercules-ci\",\n        \"repo\": \"flake-parts\",\n        \"type\": \"github\"\n      }\n    },\n    \"flake-parts_5\": {\n      \"inputs\": {\n        \"nixpkgs-lib\": \"nixpkgs-lib_5\"\n      },\n      \"locked\": {\n        \"lastModified\": 1683560683,\n        \"narHash\": \"sha256-XAygPMN5Xnk/W2c1aW0jyEa6lfMDZWlQgiNtmHXytPc=\",\n        \"owner\": \"hercules-ci\",\n        \"repo\": \"flake-parts\",\n        \"rev\": \"006c75898cf814ef9497252b022e91c946ba8e17\",\n        \"type\": \"github\"\n      },\n      \"original\": {\n        \"owner\": \"hercules-ci\",\n        \"repo\": \"flake-parts\",\n        \"type\": \"github\"\n      }\n    },\n    \"flake-parts_6\": {\n      \"inputs\": {\n        \"nixpkgs-lib\": \"nixpkgs-lib_6\"\n      },\n      \"locked\": {\n        \"lastModified\": 1683560683,\n        \"narHash\": \"sha256-XAygPMN5Xnk/W2c1aW0jyEa6lfMDZWlQgiNtmHXytPc=\",\n        \"owner\": \"hercules-ci\",\n        \"repo\": \"flake-parts\",\n        \"rev\": \"006c75898cf814ef9497252b022e91c946ba8e17\",\n        \"type\": \"github\"\n      },\n      \"original\": {\n        \"owner\": \"hercules-ci\",\n        \"repo\": \"flake-parts\",\n        \"type\": \"github\"\n      }\n    },\n    \"flake-parts_7\": {\n      \"inputs\": {\n        \"nixpkgs-lib\": \"nixpkgs-lib_7\"\n      },\n      \"locked\": {\n        \"lastModified\": 1690933134,\n        \"narHash\": \"sha256-ab989mN63fQZBFrkk4Q8bYxQCktuHmBIBqUG1jl6/FQ=\",\n        \"owner\": \"hercules-ci\",\n        \"repo\": \"flake-parts\",\n        \"rev\": \"59cf3f1447cfc75087e7273b04b31e689a8599fb\",\n        \"type\": \"github\"\n      },\n      \"original\": {\n        \"owner\": \"hercules-ci\",\n        \"repo\": \"flake-parts\",\n        \"type\": \"github\"\n      }\n    },\n    \"flake-parts_8\": {\n      \"inputs\": {\n        \"nixpkgs-lib\": \"nixpkgs-lib_8\"\n      },\n      \"locked\": {\n        \"lastModified\": 1690933134,\n        \"narHash\": \"sha256-ab989mN63fQZBFrkk4Q8bYxQCktuHmBIBqUG1jl6/FQ=\",\n        \"owner\": \"hercules-ci\",\n        \"repo\": \"flake-parts\",\n        \"rev\": \"59cf3f1447cfc75087e7273b04b31e689a8599fb\",\n        \"type\": \"github\"\n      },\n      \"original\": {\n        \"owner\": \"hercules-ci\",\n        \"repo\": \"flake-parts\",\n        \"type\": \"github\"\n      }\n    },\n    \"flake-parts_9\": {\n      \"inputs\": {\n        \"nixpkgs-lib\": \"nixpkgs-lib_9\"\n      },\n      \"locked\": {\n        \"lastModified\": 1690933134,\n        \"narHash\": \"sha256-ab989mN63fQZBFrkk4Q8bYxQCktuHmBIBqUG1jl6/FQ=\",\n        \"owner\": \"hercules-ci\",\n        \"repo\": \"flake-parts\",\n        \"rev\": \"59cf3f1447cfc75087e7273b04b31e689a8599fb\",\n        \"type\": \"github\"\n      },\n      \"original\": {\n        \"owner\": \"hercules-ci\",\n        \"repo\": \"flake-parts\",\n        \"type\": \"github\"\n      }\n    },\n    \"flake-root\": {\n      \"locked\": {\n        \"lastModified\": 1680210152,\n        \"narHash\": \"sha256-VgFdqsu2i2oUcId9n8BFlRRc4GJHFvrmprdamcSZR1o=\",\n        \"owner\": \"srid\",\n        \"repo\": \"flake-root\",\n        \"rev\": \"6000244701c8ae8cf43263564095fd357d89c328\",\n        \"type\": \"github\"\n      },\n      \"original\": {\n        \"owner\": \"srid\",\n        \"repo\": \"flake-root\",\n        \"type\": \"github\"\n      }\n    },\n    \"flake-root_2\": {\n      \"locked\": {\n        \"lastModified\": 1680210152,\n        \"narHash\": \"sha256-VgFdqsu2i2oUcId9n8BFlRRc4GJHFvrmprdamcSZR1o=\",\n        \"owner\": \"srid\",\n        \"repo\": \"flake-root\",\n        \"rev\": \"6000244701c8ae8cf43263564095fd357d89c328\",\n        \"type\": \"github\"\n      },\n      \"original\": {\n        \"owner\": \"srid\",\n        \"repo\": \"flake-root\",\n        \"type\": \"github\"\n      }\n    },\n    \"flake-utils\": {\n      \"inputs\": {\n        \"systems\": \"systems\"\n      },\n      \"locked\": {\n        \"lastModified\": 1681202837,\n        \"narHash\": \"sha256-H+Rh19JDwRtpVPAWp64F+rlEtxUWBAQW28eAi3SRSzg=\",\n        \"owner\": \"numtide\",\n        \"repo\": \"flake-utils\",\n        \"rev\": \"cfacdce06f30d2b68473a46042957675eebb3401\",\n        \"type\": \"github\"\n      },\n      \"original\": {\n        \"owner\": \"numtide\",\n        \"repo\": \"flake-utils\",\n        \"type\": \"github\"\n      }\n    },\n    \"flake-utils_2\": {\n      \"locked\": {\n        \"lastModified\": 1667395993,\n        \"narHash\": \"sha256-nuEHfE/LcWyuSWnS8t12N1wc105Qtau+/OdUAjtQ0rA=\",\n        \"owner\": \"numtide\",\n        \"repo\": \"flake-utils\",\n        \"rev\": \"5aed5285a952e0b949eb3ba02c12fa4fcfef535f\",\n        \"type\": \"github\"\n      },\n      \"original\": {\n        \"owner\": \"numtide\",\n        \"repo\": \"flake-utils\",\n        \"type\": \"github\"\n      }\n    },\n    \"flake-utils_3\": {\n      \"locked\": {\n        \"lastModified\": 1659877975,\n        \"narHash\": \"sha256-zllb8aq3YO3h8B/U0/J1WBgAL8EX5yWf5pMj3G0NAmc=\",\n        \"owner\": \"numtide\",\n        \"repo\": \"flake-utils\",\n        \"rev\": \"c0e246b9b83f637f4681389ecabcb2681b4f3af0\",\n        \"type\": \"github\"\n      },\n      \"original\": {\n        \"owner\": \"numtide\",\n        \"repo\": \"flake-utils\",\n        \"type\": \"github\"\n      }\n    },\n    \"flake-utils_4\": {\n      \"inputs\": {\n        \"systems\": \"systems_3\"\n      },\n      \"locked\": {\n        \"lastModified\": 1681202837,\n        \"narHash\": \"sha256-H+Rh19JDwRtpVPAWp64F+rlEtxUWBAQW28eAi3SRSzg=\",\n        \"owner\": \"numtide\",\n        \"repo\": \"flake-utils\",\n        \"rev\": \"cfacdce06f30d2b68473a46042957675eebb3401\",\n        \"type\": \"github\"\n      },\n      \"original\": {\n        \"owner\": \"numtide\",\n        \"repo\": \"flake-utils\",\n        \"type\": \"github\"\n      }\n    },\n    \"flake-utils_5\": {\n      \"locked\": {\n        \"lastModified\": 1667395993,\n        \"narHash\": \"sha256-nuEHfE/LcWyuSWnS8t12N1wc105Qtau+/OdUAjtQ0rA=\",\n        \"owner\": \"numtide\",\n        \"repo\": \"flake-utils\",\n        \"rev\": \"5aed5285a952e0b949eb3ba02c12fa4fcfef535f\",\n        \"type\": \"github\"\n      },\n      \"original\": {\n        \"owner\": \"numtide\",\n        \"repo\": \"flake-utils\",\n        \"type\": \"github\"\n      }\n    },\n    \"flake-utils_6\": {\n      \"locked\": {\n        \"lastModified\": 1667395993,\n        \"narHash\": \"sha256-nuEHfE/LcWyuSWnS8t12N1wc105Qtau+/OdUAjtQ0rA=\",\n        \"owner\": \"numtide\",\n        \"repo\": \"flake-utils\",\n        \"rev\": \"5aed5285a952e0b949eb3ba02c12fa4fcfef535f\",\n        \"type\": \"github\"\n      },\n      \"original\": {\n        \"owner\": \"numtide\",\n        \"repo\": \"flake-utils\",\n        \"type\": \"github\"\n      }\n    },\n    \"gitignore\": {\n      \"inputs\": {\n        \"nixpkgs\": [\n          \"common\",\n          \"pre-commit-hooks-nix\",\n          \"nixpkgs\"\n        ]\n      },\n      \"locked\": {\n        \"lastModified\": 1660459072,\n        \"narHash\": \"sha256-8DFJjXG8zqoONA1vXtgeKXy68KdJL5UaXR8NtVMUbx8=\",\n        \"owner\": \"hercules-ci\",\n        \"repo\": \"gitignore.nix\",\n        \"rev\": \"a20de23b925fd8264fd7fad6454652e142fd7f73\",\n        \"type\": \"github\"\n      },\n      \"original\": {\n        \"owner\": \"hercules-ci\",\n        \"repo\": \"gitignore.nix\",\n        \"type\": \"github\"\n      }\n    },\n    \"gitignore_2\": {\n      \"inputs\": {\n        \"nixpkgs\": [\n          \"euler-hs\",\n          \"common\",\n          \"cachix-push\",\n          \"cachix\",\n          \"devenv\",\n          \"pre-commit-hooks\",\n          \"nixpkgs\"\n        ]\n      },\n      \"locked\": {\n        \"lastModified\": 1660459072,\n        \"narHash\": \"sha256-8DFJjXG8zqoONA1vXtgeKXy68KdJL5UaXR8NtVMUbx8=\",\n        \"owner\": \"hercules-ci\",\n        \"repo\": \"gitignore.nix\",\n        \"rev\": \"a20de23b925fd8264fd7fad6454652e142fd7f73\",\n        \"type\": \"github\"\n      },\n      \"original\": {\n        \"owner\": \"hercules-ci\",\n        \"repo\": \"gitignore.nix\",\n        \"type\": \"github\"\n      }\n    },\n    \"gitignore_3\": {\n      \"inputs\": {\n        \"nixpkgs\": [\n          \"euler-hs\",\n          \"common\",\n          \"pre-commit-hooks-nix\",\n          \"nixpkgs\"\n        ]\n      },\n      \"locked\": {\n        \"lastModified\": 1660459072,\n        \"narHash\": \"sha256-8DFJjXG8zqoONA1vXtgeKXy68KdJL5UaXR8NtVMUbx8=\",\n        \"owner\": \"hercules-ci\",\n        \"repo\": \"gitignore.nix\",\n        \"rev\": \"a20de23b925fd8264fd7fad6454652e142fd7f73\",\n        \"type\": \"github\"\n      },\n      \"original\": {\n        \"owner\": \"hercules-ci\",\n        \"repo\": \"gitignore.nix\",\n        \"type\": \"github\"\n      }\n    },\n    \"haskell-flake\": {\n      \"locked\": {\n        \"lastModified\": 1714025946,\n        \"narHash\": \"sha256-R2k/UG5XtyTtmezRs0HZZ9MlvhWXtkyHR+ngEAWrtZI=\",\n        \"owner\": \"srid\",\n        \"repo\": \"haskell-flake\",\n        \"rev\": \"2ee7904390ce78a81d0f66fcc98bf4c32d128d33\",\n        \"type\": \"github\"\n      },\n      \"original\": {\n        \"owner\": \"srid\",\n        \"repo\": \"haskell-flake\",\n        \"type\": \"github\"\n      }\n    },\n    \"haskell-flake_2\": {\n      \"locked\": {\n        \"lastModified\": 1685469326,\n        \"narHash\": \"sha256-esxJLsGexI/J6Fc32tJd2p3K5IOBZSCHgFvegjIpc+0=\",\n        \"owner\": \"srid\",\n        \"repo\": \"haskell-flake\",\n        \"rev\": \"996f5c2cdc67285c4990df378976f9dbf26f8401\",\n        \"type\": \"github\"\n      },\n      \"original\": {\n        \"owner\": \"srid\",\n        \"repo\": \"haskell-flake\",\n        \"type\": \"github\"\n      }\n    },\n    \"hedis\": {\n      \"flake\": false,\n      \"locked\": {\n        \"lastModified\": 1740460297,\n        \"narHash\": \"sha256-4FjUqrP+63Te39UM9PctBS8cuJUiJYkZ3zIJ2IPeTA8=\",\n        \"owner\": \"nammayatri\",\n        \"repo\": \"hedis\",\n        \"rev\": \"089d22be67103f613bd1eecbac8c2e6d6d0576c6\",\n        \"type\": \"github\"\n      },\n      \"original\": {\n        \"owner\": \"nammayatri\",\n        \"ref\": \"enh/zone-aware-replica-usage\",\n        \"repo\": \"hedis\",\n        \"type\": \"github\"\n      }\n    },\n    \"hnix-store-core\": {\n      \"flake\": false,\n      \"locked\": {\n        \"lastModified\": 1672658037,\n        \"narHash\": \"sha256-UOe+dY1dhCvdEKjPF1gNpfc4cNhZSKSbvu4yG+XVqbg=\",\n        \"owner\": \"haskell-nix\",\n        \"repo\": \"hnix-store\",\n        \"rev\": \"81700e6e7c53bbd7c6b2c4913b9481e5827af92f\",\n        \"type\": \"github\"\n      },\n      \"original\": {\n        \"owner\": \"haskell-nix\",\n        \"ref\": \"core-0.6.1.0\",\n        \"repo\": \"hnix-store\",\n        \"type\": \"github\"\n      }\n    },\n    \"juspay-extra\": {\n      \"inputs\": {\n        \"flake-parts\": \"flake-parts_6\",\n        \"haskell-flake\": [\n          \"euler-hs\",\n          \"haskell-flake\"\n        ],\n        \"nixpkgs\": \"nixpkgs_16\"\n      },\n      \"locked\": {\n        \"lastModified\": 1686322580,\n        \"narHash\": \"sha256-EDdBN4Nfm/u+QRDZRv+vb8RfcJZpoToSr9pSBGc9vBI=\",\n        \"owner\": \"juspay\",\n        \"repo\": \"euler-haskell-common\",\n        \"rev\": \"4892071b7af07e5faa085e7917ab12110399f0e5\",\n        \"type\": \"github\"\n      },\n      \"original\": {\n        \"owner\": \"juspay\",\n        \"repo\": \"euler-haskell-common\",\n        \"type\": \"github\"\n      }\n    },\n    \"lowdown-src\": {\n      \"flake\": false,\n      \"locked\": {\n        \"lastModified\": 1633514407,\n        \"narHash\": \"sha256-Dw32tiMjdK9t3ETl5fzGrutQTzh2rufgZV4A/BbxuD4=\",\n        \"owner\": \"kristapsdz\",\n        \"repo\": \"lowdown\",\n        \"rev\": \"d2c2b44ff6c27b936ec27358a2653caaef8f73b8\",\n        \"type\": \"github\"\n      },\n      \"original\": {\n        \"owner\": \"kristapsdz\",\n        \"repo\": \"lowdown\",\n        \"type\": \"github\"\n      }\n    },\n    \"mission-control\": {\n      \"locked\": {\n        \"lastModified\": 1680209746,\n        \"narHash\": \"sha256-P8Q0mPdeo2SvKQUejvl7nOKO2ahIXb6aintYofCxcP8=\",\n        \"owner\": \"Platonic-Systems\",\n        \"repo\": \"mission-control\",\n        \"rev\": \"c1bd7344283d4006efb02cc660c5fd9befb73980\",\n        \"type\": \"github\"\n      },\n      \"original\": {\n        \"owner\": \"Platonic-Systems\",\n        \"repo\": \"mission-control\",\n        \"type\": \"github\"\n      }\n    },\n    \"mission-control_2\": {\n      \"locked\": {\n        \"lastModified\": 1680209746,\n        \"narHash\": \"sha256-P8Q0mPdeo2SvKQUejvl7nOKO2ahIXb6aintYofCxcP8=\",\n        \"owner\": \"Platonic-Systems\",\n        \"repo\": \"mission-control\",\n        \"rev\": \"c1bd7344283d4006efb02cc660c5fd9befb73980\",\n        \"type\": \"github\"\n      },\n      \"original\": {\n        \"owner\": \"Platonic-Systems\",\n        \"repo\": \"mission-control\",\n        \"type\": \"github\"\n      }\n    },\n    \"mysql-haskell\": {\n      \"inputs\": {\n        \"flake-parts\": \"flake-parts_9\",\n        \"haskell-flake\": [\n          \"euler-hs\",\n          \"sequelize\",\n          \"beam-mysql\",\n          \"haskell-flake\"\n        ],\n        \"nixpkgs\": [\n          \"euler-hs\",\n          \"sequelize\",\n          \"beam-mysql\",\n          \"nixpkgs\"\n        ],\n        \"word24\": \"word24\"\n      },\n      \"locked\": {\n        \"lastModified\": 1692868544,\n        \"narHash\": \"sha256-UY9HRnqWXv5Ud6pfBa/fPNwjauDYpgzJoLcQb4NuH7I=\",\n        \"owner\": \"arjunkathuria\",\n        \"repo\": \"mysql-haskell\",\n        \"rev\": \"2f4861667d19e84474700f32922c97af94f5dfc4\",\n        \"type\": \"github\"\n      },\n      \"original\": {\n        \"owner\": \"arjunkathuria\",\n        \"ref\": \"GHC-927\",\n        \"repo\": \"mysql-haskell\",\n        \"type\": \"github\"\n      }\n    },\n    \"nix\": {\n      \"inputs\": {\n        \"lowdown-src\": \"lowdown-src\",\n        \"nixpkgs\": [\n          \"euler-hs\",\n          \"common\",\n          \"cachix-push\",\n          \"cachix\",\n          \"devenv\",\n          \"nixpkgs\"\n        ],\n        \"nixpkgs-regression\": \"nixpkgs-regression\"\n      },\n      \"locked\": {\n        \"lastModified\": 1676545802,\n        \"narHash\": \"sha256-EK4rZ+Hd5hsvXnzSzk2ikhStJnD63odF7SzsQ8CuSPU=\",\n        \"owner\": \"domenkozar\",\n        \"repo\": \"nix\",\n        \"rev\": \"7c91803598ffbcfe4a55c44ac6d49b2cf07a527f\",\n        \"type\": \"github\"\n      },\n      \"original\": {\n        \"owner\": \"domenkozar\",\n        \"ref\": \"relaxed-flakes\",\n        \"repo\": \"nix\",\n        \"type\": \"github\"\n      }\n    },\n    \"nix-health\": {\n      \"inputs\": {\n        \"flake-parts\": \"flake-parts_2\",\n        \"nixpkgs\": \"nixpkgs\",\n        \"rust-flake\": \"rust-flake\",\n        \"systems\": \"systems_2\",\n        \"treefmt-nix\": \"treefmt-nix\"\n      },\n      \"locked\": {\n        \"lastModified\": 1717084565,\n        \"narHash\": \"sha256-zB6eDFFecSHEm6JKXeMDFIzsPICODAsUas/nHWOedkY=\",\n        \"owner\": \"juspay\",\n        \"repo\": \"nix-health\",\n        \"rev\": \"d83c80c022034b646e84df08b4d591b1f8af7832\",\n        \"type\": \"github\"\n      },\n      \"original\": {\n        \"owner\": \"juspay\",\n        \"repo\": \"nix-health\",\n        \"type\": \"github\"\n      }\n    },\n    \"nixpkgs\": {\n      \"locked\": {\n        \"lastModified\": 1716509168,\n        \"narHash\": \"sha256-4zSIhSRRIoEBwjbPm3YiGtbd8HDWzFxJjw5DYSDy1n8=\",\n        \"owner\": \"nixos\",\n        \"repo\": \"nixpkgs\",\n        \"rev\": \"bfb7a882678e518398ce9a31a881538679f6f092\",\n        \"type\": \"github\"\n      },\n      \"original\": {\n        \"owner\": \"nixos\",\n        \"ref\": \"nixos-unstable\",\n        \"repo\": \"nixpkgs\",\n        \"type\": \"github\"\n      }\n    },\n    \"nixpkgs-140774-workaround\": {\n      \"locked\": {\n        \"lastModified\": 1678736468,\n        \"narHash\": \"sha256-l5BdAeq9ymhUox0sTqeKibx9zkreWbIllwTvCamJLE8=\",\n        \"owner\": \"srid\",\n        \"repo\": \"nixpkgs-140774-workaround\",\n        \"rev\": \"335c2052970106d8f09f6f7f522f29d6ccaa2416\",\n        \"type\": \"github\"\n      },\n      \"original\": {\n        \"owner\": \"srid\",\n        \"repo\": \"nixpkgs-140774-workaround\",\n        \"type\": \"github\"\n      }\n    },\n    \"nixpkgs-140774-workaround_2\": {\n      \"locked\": {\n        \"lastModified\": 1678736468,\n        \"narHash\": \"sha256-l5BdAeq9ymhUox0sTqeKibx9zkreWbIllwTvCamJLE8=\",\n        \"owner\": \"srid\",\n        \"repo\": \"nixpkgs-140774-workaround\",\n        \"rev\": \"335c2052970106d8f09f6f7f522f29d6ccaa2416\",\n        \"type\": \"github\"\n      },\n      \"original\": {\n        \"owner\": \"srid\",\n        \"repo\": \"nixpkgs-140774-workaround\",\n        \"type\": \"github\"\n      }\n    },\n    \"nixpkgs-21_11\": {\n      \"locked\": {\n        \"lastModified\": 1659446231,\n        \"narHash\": \"sha256-hekabNdTdgR/iLsgce5TGWmfIDZ86qjPhxDg/8TlzhE=\",\n        \"owner\": \"nixos\",\n        \"repo\": \"nixpkgs\",\n        \"rev\": \"eabc38219184cc3e04a974fe31857d8e0eac098d\",\n        \"type\": \"github\"\n      },\n      \"original\": {\n        \"owner\": \"nixos\",\n        \"ref\": \"nixos-21.11\",\n        \"repo\": \"nixpkgs\",\n        \"type\": \"github\"\n      }\n    },\n    \"nixpkgs-21_11_2\": {\n      \"locked\": {\n        \"lastModified\": 1659446231,\n        \"narHash\": \"sha256-hekabNdTdgR/iLsgce5TGWmfIDZ86qjPhxDg/8TlzhE=\",\n        \"owner\": \"nixos\",\n        \"repo\": \"nixpkgs\",\n        \"rev\": \"eabc38219184cc3e04a974fe31857d8e0eac098d\",\n        \"type\": \"github\"\n      },\n      \"original\": {\n        \"owner\": \"nixos\",\n        \"ref\": \"nixos-21.11\",\n        \"repo\": \"nixpkgs\",\n        \"type\": \"github\"\n      }\n    },\n    \"nixpkgs-latest\": {\n      \"locked\": {\n        \"lastModified\": 1724395761,\n        \"narHash\": \"sha256-zRkDV/nbrnp3Y8oCADf5ETl1sDrdmAW6/bBVJ8EbIdQ=\",\n        \"owner\": \"nixos\",\n        \"repo\": \"nixpkgs\",\n        \"rev\": \"ae815cee91b417be55d43781eb4b73ae1ecc396c\",\n        \"type\": \"github\"\n      },\n      \"original\": {\n        \"owner\": \"nixos\",\n        \"ref\": \"nixpkgs-unstable\",\n        \"repo\": \"nixpkgs\",\n        \"type\": \"github\"\n      }\n    },\n    \"nixpkgs-lib\": {\n      \"locked\": {\n        \"lastModified\": 1725233747,\n        \"narHash\": \"sha256-Ss8QWLXdr2JCBPcYChJhz4xJm+h/xjl4G0c0XlP6a74=\",\n        \"type\": \"tarball\",\n        \"url\": \"https://github.com/NixOS/nixpkgs/archive/356624c12086a18f2ea2825fed34523d60ccc4e3.tar.gz\"\n      },\n      \"original\": {\n        \"type\": \"tarball\",\n        \"url\": \"https://github.com/NixOS/nixpkgs/archive/356624c12086a18f2ea2825fed34523d60ccc4e3.tar.gz\"\n      }\n    },\n    \"nixpkgs-lib_10\": {\n      \"locked\": {\n        \"dir\": \"lib\",\n        \"lastModified\": 1682879489,\n        \"narHash\": \"sha256-sASwo8gBt7JDnOOstnps90K1wxmVfyhsTPPNTGBPjjg=\",\n        \"owner\": \"NixOS\",\n        \"repo\": \"nixpkgs\",\n        \"rev\": \"da45bf6ec7bbcc5d1e14d3795c025199f28e0de0\",\n        \"type\": \"github\"\n      },\n      \"original\": {\n        \"dir\": \"lib\",\n        \"owner\": \"NixOS\",\n        \"ref\": \"nixos-unstable\",\n        \"repo\": \"nixpkgs\",\n        \"type\": \"github\"\n      }\n    },\n    \"nixpkgs-lib_2\": {\n      \"locked\": {\n        \"dir\": \"lib\",\n        \"lastModified\": 1698611440,\n        \"narHash\": \"sha256-jPjHjrerhYDy3q9+s5EAsuhyhuknNfowY6yt6pjn9pc=\",\n        \"owner\": \"NixOS\",\n        \"repo\": \"nixpkgs\",\n        \"rev\": \"0cbe9f69c234a7700596e943bfae7ef27a31b735\",\n        \"type\": \"github\"\n      },\n      \"original\": {\n        \"dir\": \"lib\",\n        \"owner\": \"NixOS\",\n        \"ref\": \"nixos-unstable\",\n        \"repo\": \"nixpkgs\",\n        \"type\": \"github\"\n      }\n    },\n    \"nixpkgs-lib_3\": {\n      \"locked\": {\n        \"dir\": \"lib\",\n        \"lastModified\": 1677407201,\n        \"narHash\": \"sha256-3blwdI9o1BAprkvlByHvtEm5HAIRn/XPjtcfiunpY7s=\",\n        \"owner\": \"NixOS\",\n        \"repo\": \"nixpkgs\",\n        \"rev\": \"7f5639fa3b68054ca0b062866dc62b22c3f11505\",\n        \"type\": \"github\"\n      },\n      \"original\": {\n        \"dir\": \"lib\",\n        \"owner\": \"NixOS\",\n        \"ref\": \"nixos-unstable\",\n        \"repo\": \"nixpkgs\",\n        \"type\": \"github\"\n      }\n    },\n    \"nixpkgs-lib_4\": {\n      \"locked\": {\n        \"dir\": \"lib\",\n        \"lastModified\": 1682879489,\n        \"narHash\": \"sha256-sASwo8gBt7JDnOOstnps90K1wxmVfyhsTPPNTGBPjjg=\",\n        \"owner\": \"NixOS\",\n        \"repo\": \"nixpkgs\",\n        \"rev\": \"da45bf6ec7bbcc5d1e14d3795c025199f28e0de0\",\n        \"type\": \"github\"\n      },\n      \"original\": {\n        \"dir\": \"lib\",\n        \"owner\": \"NixOS\",\n        \"ref\": \"nixos-unstable\",\n        \"repo\": \"nixpkgs\",\n        \"type\": \"github\"\n      }\n    },\n    \"nixpkgs-lib_5\": {\n      \"locked\": {\n        \"dir\": \"lib\",\n        \"lastModified\": 1682879489,\n        \"narHash\": \"sha256-sASwo8gBt7JDnOOstnps90K1wxmVfyhsTPPNTGBPjjg=\",\n        \"owner\": \"NixOS\",\n        \"repo\": \"nixpkgs\",\n        \"rev\": \"da45bf6ec7bbcc5d1e14d3795c025199f28e0de0\",\n        \"type\": \"github\"\n      },\n      \"original\": {\n        \"dir\": \"lib\",\n        \"owner\": \"NixOS\",\n        \"ref\": \"nixos-unstable\",\n        \"repo\": \"nixpkgs\",\n        \"type\": \"github\"\n      }\n    },\n    \"nixpkgs-lib_6\": {\n      \"locked\": {\n        \"dir\": \"lib\",\n        \"lastModified\": 1682879489,\n        \"narHash\": \"sha256-sASwo8gBt7JDnOOstnps90K1wxmVfyhsTPPNTGBPjjg=\",\n        \"owner\": \"NixOS\",\n        \"repo\": \"nixpkgs\",\n        \"rev\": \"da45bf6ec7bbcc5d1e14d3795c025199f28e0de0\",\n        \"type\": \"github\"\n      },\n      \"original\": {\n        \"dir\": \"lib\",\n        \"owner\": \"NixOS\",\n        \"ref\": \"nixos-unstable\",\n        \"repo\": \"nixpkgs\",\n        \"type\": \"github\"\n      }\n    },\n    \"nixpkgs-lib_7\": {\n      \"locked\": {\n        \"dir\": \"lib\",\n        \"lastModified\": 1690881714,\n        \"narHash\": \"sha256-h/nXluEqdiQHs1oSgkOOWF+j8gcJMWhwnZ9PFabN6q0=\",\n        \"owner\": \"NixOS\",\n        \"repo\": \"nixpkgs\",\n        \"rev\": \"9e1960bc196baf6881340d53dccb203a951745a2\",\n        \"type\": \"github\"\n      },\n      \"original\": {\n        \"dir\": \"lib\",\n        \"owner\": \"NixOS\",\n        \"ref\": \"nixos-unstable\",\n        \"repo\": \"nixpkgs\",\n        \"type\": \"github\"\n      }\n    },\n    \"nixpkgs-lib_8\": {\n      \"locked\": {\n        \"dir\": \"lib\",\n        \"lastModified\": 1690881714,\n        \"narHash\": \"sha256-h/nXluEqdiQHs1oSgkOOWF+j8gcJMWhwnZ9PFabN6q0=\",\n        \"owner\": \"NixOS\",\n        \"repo\": \"nixpkgs\",\n        \"rev\": \"9e1960bc196baf6881340d53dccb203a951745a2\",\n        \"type\": \"github\"\n      },\n      \"original\": {\n        \"dir\": \"lib\",\n        \"owner\": \"NixOS\",\n        \"ref\": \"nixos-unstable\",\n        \"repo\": \"nixpkgs\",\n        \"type\": \"github\"\n      }\n    },\n    \"nixpkgs-lib_9\": {\n      \"locked\": {\n        \"dir\": \"lib\",\n        \"lastModified\": 1690881714,\n        \"narHash\": \"sha256-h/nXluEqdiQHs1oSgkOOWF+j8gcJMWhwnZ9PFabN6q0=\",\n        \"owner\": \"NixOS\",\n        \"repo\": \"nixpkgs\",\n        \"rev\": \"9e1960bc196baf6881340d53dccb203a951745a2\",\n        \"type\": \"github\"\n      },\n      \"original\": {\n        \"dir\": \"lib\",\n        \"owner\": \"NixOS\",\n        \"ref\": \"nixos-unstable\",\n        \"repo\": \"nixpkgs\",\n        \"type\": \"github\"\n      }\n    },\n    \"nixpkgs-regression\": {\n      \"locked\": {\n        \"lastModified\": 1643052045,\n        \"narHash\": \"sha256-uGJ0VXIhWKGXxkeNnq4TvV3CIOkUJ3PAoLZ3HMzNVMw=\",\n        \"owner\": \"NixOS\",\n        \"repo\": \"nixpkgs\",\n        \"rev\": \"215d4d0fd80ca5163643b03a33fde804a29cc1e2\",\n        \"type\": \"github\"\n      },\n      \"original\": {\n        \"owner\": \"NixOS\",\n        \"repo\": \"nixpkgs\",\n        \"rev\": \"215d4d0fd80ca5163643b03a33fde804a29cc1e2\",\n        \"type\": \"github\"\n      }\n    },\n    \"nixpkgs-stable\": {\n      \"locked\": {\n        \"lastModified\": 1678872516,\n        \"narHash\": \"sha256-/E1YwtMtFAu2KUQKV/1+KFuReYPANM2Rzehk84VxVoc=\",\n        \"owner\": \"NixOS\",\n        \"repo\": \"nixpkgs\",\n        \"rev\": \"9b8e5abb18324c7fe9f07cb100c3cd4a29cda8b8\",\n        \"type\": \"github\"\n      },\n      \"original\": {\n        \"owner\": \"NixOS\",\n        \"ref\": \"nixos-22.11\",\n        \"repo\": \"nixpkgs\",\n        \"type\": \"github\"\n      }\n    },\n    \"nixpkgs-stable_2\": {\n      \"locked\": {\n        \"lastModified\": 1673800717,\n        \"narHash\": \"sha256-SFHraUqLSu5cC6IxTprex/nTsI81ZQAtDvlBvGDWfnA=\",\n        \"owner\": \"NixOS\",\n        \"repo\": \"nixpkgs\",\n        \"rev\": \"2f9fd351ec37f5d479556cd48be4ca340da59b8f\",\n        \"type\": \"github\"\n      },\n      \"original\": {\n        \"owner\": \"NixOS\",\n        \"ref\": \"nixos-22.11\",\n        \"repo\": \"nixpkgs\",\n        \"type\": \"github\"\n      }\n    },\n    \"nixpkgs-stable_3\": {\n      \"locked\": {\n        \"lastModified\": 1678872516,\n        \"narHash\": \"sha256-/E1YwtMtFAu2KUQKV/1+KFuReYPANM2Rzehk84VxVoc=\",\n        \"owner\": \"NixOS\",\n        \"repo\": \"nixpkgs\",\n        \"rev\": \"9b8e5abb18324c7fe9f07cb100c3cd4a29cda8b8\",\n        \"type\": \"github\"\n      },\n      \"original\": {\n        \"owner\": \"NixOS\",\n        \"ref\": \"nixos-22.11\",\n        \"repo\": \"nixpkgs\",\n        \"type\": \"github\"\n      }\n    },\n    \"nixpkgs_10\": {\n      \"locked\": {\n        \"lastModified\": 1678072060,\n        \"narHash\": \"sha256-6a9Tbjhir5HxDx4uw0u6Z+LHUfYf7tsT9QxF9FN/32w=\",\n        \"owner\": \"NixOS\",\n        \"repo\": \"nixpkgs\",\n        \"rev\": \"47c003416297e4d59a5e3e7a8b15cdbdf5110560\",\n        \"type\": \"github\"\n      },\n      \"original\": {\n        \"owner\": \"NixOS\",\n        \"ref\": \"nixos-22.11\",\n        \"repo\": \"nixpkgs\",\n        \"type\": \"github\"\n      }\n    },\n    \"nixpkgs_11\": {\n      \"locked\": {\n        \"lastModified\": 1696261572,\n        \"narHash\": \"sha256-s8TtSYJ1LBpuITXjbPLUPyxzAKw35LhETcajJjCS5f0=\",\n        \"owner\": \"nixos\",\n        \"repo\": \"nixpkgs\",\n        \"rev\": \"0c7ffbc66e6d78c50c38e717ec91a2a14e0622fb\",\n        \"type\": \"github\"\n      },\n      \"original\": {\n        \"owner\": \"nixos\",\n        \"ref\": \"nixpkgs-unstable\",\n        \"repo\": \"nixpkgs\",\n        \"type\": \"github\"\n      }\n    },\n    \"nixpkgs_12\": {\n      \"locked\": {\n        \"lastModified\": 1681303793,\n        \"narHash\": \"sha256-JEdQHsYuCfRL2PICHlOiH/2ue3DwoxUX7DJ6zZxZXFk=\",\n        \"owner\": \"NixOS\",\n        \"repo\": \"nixpkgs\",\n        \"rev\": \"fe2ecaf706a5907b5e54d979fbde4924d84b65fc\",\n        \"type\": \"github\"\n      },\n      \"original\": {\n        \"owner\": \"NixOS\",\n        \"ref\": \"nixos-unstable\",\n        \"repo\": \"nixpkgs\",\n        \"type\": \"github\"\n      }\n    },\n    \"nixpkgs_13\": {\n      \"locked\": {\n        \"lastModified\": 1680945546,\n        \"narHash\": \"sha256-8FuaH5t/aVi/pR1XxnF0qi4WwMYC+YxlfdsA0V+TEuQ=\",\n        \"owner\": \"nixos\",\n        \"repo\": \"nixpkgs\",\n        \"rev\": \"d9f759f2ea8d265d974a6e1259bd510ac5844c5d\",\n        \"type\": \"github\"\n      },\n      \"original\": {\n        \"owner\": \"nixos\",\n        \"ref\": \"nixos-unstable\",\n        \"repo\": \"nixpkgs\",\n        \"type\": \"github\"\n      }\n    },\n    \"nixpkgs_14\": {\n      \"locked\": {\n        \"lastModified\": 1684879512,\n        \"narHash\": \"sha256-BoAOf19Dshtfu6BDPznrKO97oeCkXlYfa1Hyt0Qv8VU=\",\n        \"owner\": \"nixos\",\n        \"repo\": \"nixpkgs\",\n        \"rev\": \"e6e049b7a24decd1f0caee8b035913795697c699\",\n        \"type\": \"github\"\n      },\n      \"original\": {\n        \"owner\": \"nixos\",\n        \"ref\": \"nixpkgs-unstable\",\n        \"repo\": \"nixpkgs\",\n        \"type\": \"github\"\n      }\n    },\n    \"nixpkgs_15\": {\n      \"locked\": {\n        \"lastModified\": 1683657389,\n        \"narHash\": \"sha256-jx91UqqoBneE8QPAKJA29GANrU/Z7ULghoa/JE0+Edw=\",\n        \"owner\": \"nixos\",\n        \"repo\": \"nixpkgs\",\n        \"rev\": \"9524f57dd5b3944c819dd594aed8ed941932ef56\",\n        \"type\": \"github\"\n      },\n      \"original\": {\n        \"owner\": \"nixos\",\n        \"ref\": \"nixpkgs-unstable\",\n        \"repo\": \"nixpkgs\",\n        \"type\": \"github\"\n      }\n    },\n    \"nixpkgs_16\": {\n      \"locked\": {\n        \"lastModified\": 1684879512,\n        \"narHash\": \"sha256-BoAOf19Dshtfu6BDPznrKO97oeCkXlYfa1Hyt0Qv8VU=\",\n        \"owner\": \"nixos\",\n        \"repo\": \"nixpkgs\",\n        \"rev\": \"e6e049b7a24decd1f0caee8b035913795697c699\",\n        \"type\": \"github\"\n      },\n      \"original\": {\n        \"owner\": \"nixos\",\n        \"ref\": \"nixpkgs-unstable\",\n        \"repo\": \"nixpkgs\",\n        \"type\": \"github\"\n      }\n    },\n    \"nixpkgs_17\": {\n      \"locked\": {\n        \"lastModified\": 1683657389,\n        \"narHash\": \"sha256-jx91UqqoBneE8QPAKJA29GANrU/Z7ULghoa/JE0+Edw=\",\n        \"owner\": \"nixos\",\n        \"repo\": \"nixpkgs\",\n        \"rev\": \"9524f57dd5b3944c819dd594aed8ed941932ef56\",\n        \"type\": \"github\"\n      },\n      \"original\": {\n        \"owner\": \"nixos\",\n        \"ref\": \"nixpkgs-unstable\",\n        \"repo\": \"nixpkgs\",\n        \"type\": \"github\"\n      }\n    },\n    \"nixpkgs_2\": {\n      \"locked\": {\n        \"lastModified\": 1681358109,\n        \"narHash\": \"sha256-eKyxW4OohHQx9Urxi7TQlFBTDWII+F+x2hklDOQPB50=\",\n        \"owner\": \"NixOS\",\n        \"repo\": \"nixpkgs\",\n        \"rev\": \"96ba1c52e54e74c3197f4d43026b3f3d92e83ff9\",\n        \"type\": \"github\"\n      },\n      \"original\": {\n        \"owner\": \"NixOS\",\n        \"ref\": \"nixpkgs-unstable\",\n        \"repo\": \"nixpkgs\",\n        \"type\": \"github\"\n      }\n    },\n    \"nixpkgs_3\": {\n      \"locked\": {\n        \"lastModified\": 1712122226,\n        \"narHash\": \"sha256-pmgwKs8Thu1WETMqCrWUm0CkN1nmCKX3b51+EXsAZyY=\",\n        \"owner\": \"nixos\",\n        \"repo\": \"nixpkgs\",\n        \"rev\": \"08b9151ed40350725eb40b1fe96b0b86304a654b\",\n        \"type\": \"github\"\n      },\n      \"original\": {\n        \"owner\": \"nixos\",\n        \"ref\": \"nixos-unstable\",\n        \"repo\": \"nixpkgs\",\n        \"type\": \"github\"\n      }\n    },\n    \"nixpkgs_4\": {\n      \"locked\": {\n        \"lastModified\": 1696261572,\n        \"narHash\": \"sha256-s8TtSYJ1LBpuITXjbPLUPyxzAKw35LhETcajJjCS5f0=\",\n        \"owner\": \"nixos\",\n        \"repo\": \"nixpkgs\",\n        \"rev\": \"0c7ffbc66e6d78c50c38e717ec91a2a14e0622fb\",\n        \"type\": \"github\"\n      },\n      \"original\": {\n        \"owner\": \"nixos\",\n        \"ref\": \"nixpkgs-unstable\",\n        \"repo\": \"nixpkgs\",\n        \"type\": \"github\"\n      }\n    },\n    \"nixpkgs_5\": {\n      \"locked\": {\n        \"lastModified\": 1681303793,\n        \"narHash\": \"sha256-JEdQHsYuCfRL2PICHlOiH/2ue3DwoxUX7DJ6zZxZXFk=\",\n        \"owner\": \"NixOS\",\n        \"repo\": \"nixpkgs\",\n        \"rev\": \"fe2ecaf706a5907b5e54d979fbde4924d84b65fc\",\n        \"type\": \"github\"\n      },\n      \"original\": {\n        \"owner\": \"NixOS\",\n        \"ref\": \"nixos-unstable\",\n        \"repo\": \"nixpkgs\",\n        \"type\": \"github\"\n      }\n    },\n    \"nixpkgs_6\": {\n      \"locked\": {\n        \"lastModified\": 1701985094,\n        \"narHash\": \"sha256-SrEEAeDvsdehVrvoq47pGFZ+p/QbUcTovL84S7tn6Sk=\",\n        \"owner\": \"NixOS\",\n        \"repo\": \"nixpkgs\",\n        \"rev\": \"a24421da00be9ebfdade97135db98a1fac5173d4\",\n        \"type\": \"github\"\n      },\n      \"original\": {\n        \"owner\": \"NixOS\",\n        \"ref\": \"release-23.11\",\n        \"repo\": \"nixpkgs\",\n        \"type\": \"github\"\n      }\n    },\n    \"nixpkgs_7\": {\n      \"locked\": {\n        \"lastModified\": 1681358109,\n        \"narHash\": \"sha256-eKyxW4OohHQx9Urxi7TQlFBTDWII+F+x2hklDOQPB50=\",\n        \"owner\": \"NixOS\",\n        \"repo\": \"nixpkgs\",\n        \"rev\": \"96ba1c52e54e74c3197f4d43026b3f3d92e83ff9\",\n        \"type\": \"github\"\n      },\n      \"original\": {\n        \"owner\": \"NixOS\",\n        \"ref\": \"nixpkgs-unstable\",\n        \"repo\": \"nixpkgs\",\n        \"type\": \"github\"\n      }\n    },\n    \"nixpkgs_8\": {\n      \"locked\": {\n        \"lastModified\": 1680945546,\n        \"narHash\": \"sha256-8FuaH5t/aVi/pR1XxnF0qi4WwMYC+YxlfdsA0V+TEuQ=\",\n        \"owner\": \"nixos\",\n        \"repo\": \"nixpkgs\",\n        \"rev\": \"d9f759f2ea8d265d974a6e1259bd510ac5844c5d\",\n        \"type\": \"github\"\n      },\n      \"original\": {\n        \"owner\": \"nixos\",\n        \"ref\": \"nixos-unstable\",\n        \"repo\": \"nixpkgs\",\n        \"type\": \"github\"\n      }\n    },\n    \"nixpkgs_9\": {\n      \"locked\": {\n        \"lastModified\": 1677534593,\n        \"narHash\": \"sha256-PuZSAHeq4/9pP/uYH1FcagQ3nLm/DrDrvKi/xC9glvw=\",\n        \"owner\": \"NixOS\",\n        \"repo\": \"nixpkgs\",\n        \"rev\": \"3ad64d9e2d5bf80c877286102355b1625891ae9a\",\n        \"type\": \"github\"\n      },\n      \"original\": {\n        \"owner\": \"NixOS\",\n        \"ref\": \"nixpkgs-unstable\",\n        \"repo\": \"nixpkgs\",\n        \"type\": \"github\"\n      }\n    },\n    \"passetto-hs\": {\n      \"flake\": false,\n      \"locked\": {\n        \"lastModified\": 1657005302,\n        \"narHash\": \"sha256-iNdX1XMryrQ3IYmAgTI1wiBJ6Y+k265Snoluk4aMe7I=\",\n        \"owner\": \"juspay\",\n        \"repo\": \"passetto\",\n        \"rev\": \"bb92cf1dd9699662d2a7bb96cd6a6aed6f20e8ff\",\n        \"type\": \"github\"\n      },\n      \"original\": {\n        \"owner\": \"juspay\",\n        \"repo\": \"passetto\",\n        \"rev\": \"bb92cf1dd9699662d2a7bb96cd6a6aed6f20e8ff\",\n        \"type\": \"github\"\n      }\n    },\n    \"pre-commit-hooks\": {\n      \"inputs\": {\n        \"flake-compat\": [\n          \"euler-hs\",\n          \"common\",\n          \"cachix-push\",\n          \"cachix\",\n          \"devenv\",\n          \"flake-compat\"\n        ],\n        \"flake-utils\": \"flake-utils_5\",\n        \"gitignore\": \"gitignore_2\",\n        \"nixpkgs\": [\n          \"euler-hs\",\n          \"common\",\n          \"cachix-push\",\n          \"cachix\",\n          \"devenv\",\n          \"nixpkgs\"\n        ],\n        \"nixpkgs-stable\": \"nixpkgs-stable_2\"\n      },\n      \"locked\": {\n        \"lastModified\": 1677160285,\n        \"narHash\": \"sha256-tBzpCjMP+P3Y3nKLYvdBkXBg3KvTMo3gvi8tLQaqXVY=\",\n        \"owner\": \"cachix\",\n        \"repo\": \"pre-commit-hooks.nix\",\n        \"rev\": \"2bd861ab81469428d9c823ef72c4bb08372dd2c4\",\n        \"type\": \"github\"\n      },\n      \"original\": {\n        \"owner\": \"cachix\",\n        \"repo\": \"pre-commit-hooks.nix\",\n        \"type\": \"github\"\n      }\n    },\n    \"pre-commit-hooks-nix\": {\n      \"inputs\": {\n        \"flake-compat\": \"flake-compat\",\n        \"flake-utils\": \"flake-utils_2\",\n        \"gitignore\": \"gitignore\",\n        \"nixpkgs\": \"nixpkgs_5\",\n        \"nixpkgs-stable\": \"nixpkgs-stable\"\n      },\n      \"locked\": {\n        \"lastModified\": 1682596858,\n        \"narHash\": \"sha256-Hf9XVpqaGqe/4oDGr30W8HlsWvJXtMsEPHDqHZA6dDg=\",\n        \"owner\": \"cachix\",\n        \"repo\": \"pre-commit-hooks.nix\",\n        \"rev\": \"fb58866e20af98779017134319b5663b8215d912\",\n        \"type\": \"github\"\n      },\n      \"original\": {\n        \"owner\": \"cachix\",\n        \"repo\": \"pre-commit-hooks.nix\",\n        \"type\": \"github\"\n      }\n    },\n    \"pre-commit-hooks-nix_2\": {\n      \"inputs\": {\n        \"flake-compat\": \"flake-compat_3\",\n        \"flake-utils\": \"flake-utils_6\",\n        \"gitignore\": \"gitignore_3\",\n        \"nixpkgs\": \"nixpkgs_12\",\n        \"nixpkgs-stable\": \"nixpkgs-stable_3\"\n      },\n      \"locked\": {\n        \"lastModified\": 1682596858,\n        \"narHash\": \"sha256-Hf9XVpqaGqe/4oDGr30W8HlsWvJXtMsEPHDqHZA6dDg=\",\n        \"owner\": \"cachix\",\n        \"repo\": \"pre-commit-hooks.nix\",\n        \"rev\": \"fb58866e20af98779017134319b5663b8215d912\",\n        \"type\": \"github\"\n      },\n      \"original\": {\n        \"owner\": \"cachix\",\n        \"repo\": \"pre-commit-hooks.nix\",\n        \"type\": \"github\"\n      }\n    },\n    \"process-compose\": {\n      \"inputs\": {\n        \"flake-utils\": \"flake-utils_3\",\n        \"nixpkgs\": \"nixpkgs_6\"\n      },\n      \"locked\": {\n        \"lastModified\": 1705188742,\n        \"narHash\": \"sha256-yOBC9Lz0oyvgwZdBnkuYcFF24dx7YMOKJnwQ8msi6Mg=\",\n        \"owner\": \"F1bonacc1\",\n        \"repo\": \"process-compose\",\n        \"rev\": \"363b0af699d1f34511f0f908016a6484ddf42ac5\",\n        \"type\": \"github\"\n      },\n      \"original\": {\n        \"owner\": \"F1bonacc1\",\n        \"repo\": \"process-compose\",\n        \"type\": \"github\"\n      }\n    },\n    \"process-compose-flake\": {\n      \"locked\": {\n        \"lastModified\": 1705650762,\n        \"narHash\": \"sha256-kSLMsz0tXc1N5Jx8ghEXhLmK4X3Bktt3S4ttXJXCzCo=\",\n        \"owner\": \"Platonic-Systems\",\n        \"repo\": \"process-compose-flake\",\n        \"rev\": \"c8942208e7c7122aef4811a606f7c12ad0753a98\",\n        \"type\": \"github\"\n      },\n      \"original\": {\n        \"owner\": \"Platonic-Systems\",\n        \"repo\": \"process-compose-flake\",\n        \"type\": \"github\"\n      }\n    },\n    \"process-compose-flake_2\": {\n      \"locked\": {\n        \"lastModified\": 1687298948,\n        \"narHash\": \"sha256-7Lu4/odCkkwrzR8Mo+3D+URv4oLap8WWLESzi/75eb0=\",\n        \"owner\": \"Platonic-Systems\",\n        \"repo\": \"process-compose-flake\",\n        \"rev\": \"5bdb90b85642901cf9a5dccfe8c907091c261604\",\n        \"type\": \"github\"\n      },\n      \"original\": {\n        \"owner\": \"Platonic-Systems\",\n        \"repo\": \"process-compose-flake\",\n        \"type\": \"github\"\n      }\n    },\n    \"prometheus-haskell\": {\n      \"inputs\": {\n        \"flake-parts\": \"flake-parts_5\",\n        \"haskell-flake\": [\n          \"euler-hs\",\n          \"euler-events-hs\",\n          \"haskell-flake\"\n        ],\n        \"nixpkgs\": \"nixpkgs_15\"\n      },\n      \"locked\": {\n        \"lastModified\": 1687373886,\n        \"narHash\": \"sha256-KWxG4SyXo39yG+7b1H0ULKzVu8Z1Hj8KCqS0rQKw3qU=\",\n        \"owner\": \"juspay\",\n        \"repo\": \"prometheus-haskell\",\n        \"rev\": \"f1d996bb317d0a50450ace2b4ae08b5afdf22955\",\n        \"type\": \"github\"\n      },\n      \"original\": {\n        \"owner\": \"juspay\",\n        \"ref\": \"more-proc-metrics\",\n        \"repo\": \"prometheus-haskell\",\n        \"type\": \"github\"\n      }\n    },\n    \"prometheus-haskell_2\": {\n      \"inputs\": {\n        \"flake-parts\": \"flake-parts_10\",\n        \"haskell-flake\": [\n          \"common\",\n          \"haskell-flake\"\n        ],\n        \"nixpkgs\": \"nixpkgs_17\"\n      },\n      \"locked\": {\n        \"lastModified\": 1687373886,\n        \"narHash\": \"sha256-KWxG4SyXo39yG+7b1H0ULKzVu8Z1Hj8KCqS0rQKw3qU=\",\n        \"owner\": \"juspay\",\n        \"repo\": \"prometheus-haskell\",\n        \"rev\": \"f1d996bb317d0a50450ace2b4ae08b5afdf22955\",\n        \"type\": \"github\"\n      },\n      \"original\": {\n        \"owner\": \"juspay\",\n        \"ref\": \"more-proc-metrics\",\n        \"repo\": \"prometheus-haskell\",\n        \"type\": \"github\"\n      }\n    },\n    \"root\": {\n      \"inputs\": {\n        \"clickhouse-haskell\": \"clickhouse-haskell\",\n        \"common\": \"common\",\n        \"euler-hs\": \"euler-hs\",\n        \"haskell-flake\": [\n          \"common\",\n          \"haskell-flake\"\n        ],\n        \"nixpkgs\": [\n          \"common\",\n          \"nixpkgs\"\n        ],\n        \"passetto-hs\": \"passetto-hs\",\n        \"prometheus-haskell\": \"prometheus-haskell_2\"\n      }\n    },\n    \"rust-flake\": {\n      \"inputs\": {\n        \"crane\": \"crane_2\",\n        \"nixpkgs\": [\n          \"common\",\n          \"nix-health\",\n          \"nixpkgs\"\n        ],\n        \"rust-overlay\": \"rust-overlay\"\n      },\n      \"locked\": {\n        \"lastModified\": 1712193152,\n        \"narHash\": \"sha256-flsXt92BrijmpbzW2cvO181t9x5w651hFndFnNoyBMU=\",\n        \"owner\": \"juspay\",\n        \"repo\": \"rust-flake\",\n        \"rev\": \"eddd86d1a47c8b4078e5da59866bac26b5726c47\",\n        \"type\": \"github\"\n      },\n      \"original\": {\n        \"owner\": \"juspay\",\n        \"repo\": \"rust-flake\",\n        \"type\": \"github\"\n      }\n    },\n    \"rust-overlay\": {\n      \"inputs\": {\n        \"flake-utils\": \"flake-utils\",\n        \"nixpkgs\": \"nixpkgs_2\"\n      },\n      \"locked\": {\n        \"lastModified\": 1701310566,\n        \"narHash\": \"sha256-CL9J3xUR2Ejni4LysrEGX0IdO+Y4BXCiH/By0lmF3eQ=\",\n        \"owner\": \"oxalica\",\n        \"repo\": \"rust-overlay\",\n        \"rev\": \"6d3c6e185198b8bf7ad639f22404a75aa9a09bff\",\n        \"type\": \"github\"\n      },\n      \"original\": {\n        \"owner\": \"oxalica\",\n        \"repo\": \"rust-overlay\",\n        \"type\": \"github\"\n      }\n    },\n    \"rust-overlay_2\": {\n      \"inputs\": {\n        \"flake-utils\": \"flake-utils_4\",\n        \"nixpkgs\": \"nixpkgs_7\"\n      },\n      \"locked\": {\n        \"lastModified\": 1704766659,\n        \"narHash\": \"sha256-Q2wQ9jzp4j96HokmhUQey+pyZMp4Fye/ZPSLtBBV1J8=\",\n        \"owner\": \"oxalica\",\n        \"repo\": \"rust-overlay\",\n        \"rev\": \"afa87241c19241aca9b7a9103635b82db2b147bb\",\n        \"type\": \"github\"\n      },\n      \"original\": {\n        \"owner\": \"oxalica\",\n        \"repo\": \"rust-overlay\",\n        \"type\": \"github\"\n      }\n    },\n    \"sequelize\": {\n      \"inputs\": {\n        \"beam-mysql\": \"beam-mysql\",\n        \"flake-parts\": [\n          \"euler-hs\",\n          \"flake-parts\"\n        ],\n        \"haskell-flake\": [\n          \"euler-hs\",\n          \"haskell-flake\"\n        ],\n        \"nixpkgs\": [\n          \"euler-hs\",\n          \"nixpkgs\"\n        ]\n      },\n      \"locked\": {\n        \"lastModified\": 1706179382,\n        \"narHash\": \"sha256-uhv/uKOwu1IfFnYyFFB4k5dMrYcorjs1DCd6ehm9ReA=\",\n        \"owner\": \"nammayatri\",\n        \"repo\": \"haskell-sequelize\",\n        \"rev\": \"38a8266d1bfa0ade37aa6b3ded2e1435f6839e7e\",\n        \"type\": \"github\"\n      },\n      \"original\": {\n        \"owner\": \"nammayatri\",\n        \"ref\": \"backend/decoupled-drainer-changes\",\n        \"repo\": \"haskell-sequelize\",\n        \"type\": \"github\"\n      }\n    },\n    \"servant-mock\": {\n      \"flake\": false,\n      \"locked\": {\n        \"lastModified\": 1672315259,\n        \"narHash\": \"sha256-J7Lsa3zI1Z05Gtf5m1x4yRE5vRnuhZLWeUShtrhsPbk=\",\n        \"owner\": \"arjunkathuria\",\n        \"repo\": \"servant-mock\",\n        \"rev\": \"17e90cb831820a30b3215d4f164cf8268607891e\",\n        \"type\": \"github\"\n      },\n      \"original\": {\n        \"owner\": \"arjunkathuria\",\n        \"repo\": \"servant-mock\",\n        \"rev\": \"17e90cb831820a30b3215d4f164cf8268607891e\",\n        \"type\": \"github\"\n      }\n    },\n    \"systems\": {\n      \"locked\": {\n        \"lastModified\": 1681028828,\n        \"narHash\": \"sha256-Vy1rq5AaRuLzOxct8nz4T6wlgyUR7zLU309k9mBC768=\",\n        \"owner\": \"nix-systems\",\n        \"repo\": \"default\",\n        \"rev\": \"da67096a3b9bf56a91d16901293e51ba5b49a27e\",\n        \"type\": \"github\"\n      },\n      \"original\": {\n        \"owner\": \"nix-systems\",\n        \"repo\": \"default\",\n        \"type\": \"github\"\n      }\n    },\n    \"systems_2\": {\n      \"locked\": {\n        \"lastModified\": 1681028828,\n        \"narHash\": \"sha256-Vy1rq5AaRuLzOxct8nz4T6wlgyUR7zLU309k9mBC768=\",\n        \"owner\": \"nix-systems\",\n        \"repo\": \"default\",\n        \"rev\": \"da67096a3b9bf56a91d16901293e51ba5b49a27e\",\n        \"type\": \"github\"\n      },\n      \"original\": {\n        \"owner\": \"nix-systems\",\n        \"repo\": \"default\",\n        \"type\": \"github\"\n      }\n    },\n    \"systems_3\": {\n      \"locked\": {\n        \"lastModified\": 1681028828,\n        \"narHash\": \"sha256-Vy1rq5AaRuLzOxct8nz4T6wlgyUR7zLU309k9mBC768=\",\n        \"owner\": \"nix-systems\",\n        \"repo\": \"default\",\n        \"rev\": \"da67096a3b9bf56a91d16901293e51ba5b49a27e\",\n        \"type\": \"github\"\n      },\n      \"original\": {\n        \"owner\": \"nix-systems\",\n        \"repo\": \"default\",\n        \"type\": \"github\"\n      }\n    },\n    \"systems_4\": {\n      \"locked\": {\n        \"lastModified\": 1681028828,\n        \"narHash\": \"sha256-Vy1rq5AaRuLzOxct8nz4T6wlgyUR7zLU309k9mBC768=\",\n        \"owner\": \"nix-systems\",\n        \"repo\": \"default\",\n        \"rev\": \"da67096a3b9bf56a91d16901293e51ba5b49a27e\",\n        \"type\": \"github\"\n      },\n      \"original\": {\n        \"owner\": \"nix-systems\",\n        \"repo\": \"default\",\n        \"type\": \"github\"\n      }\n    },\n    \"systems_5\": {\n      \"locked\": {\n        \"lastModified\": 1681028828,\n        \"narHash\": \"sha256-Vy1rq5AaRuLzOxct8nz4T6wlgyUR7zLU309k9mBC768=\",\n        \"owner\": \"nix-systems\",\n        \"repo\": \"default\",\n        \"rev\": \"da67096a3b9bf56a91d16901293e51ba5b49a27e\",\n        \"type\": \"github\"\n      },\n      \"original\": {\n        \"owner\": \"nix-systems\",\n        \"repo\": \"default\",\n        \"type\": \"github\"\n      }\n    },\n    \"tinylog\": {\n      \"flake\": false,\n      \"locked\": {\n        \"lastModified\": 1669960992,\n        \"narHash\": \"sha256-o0WEbygbbfIYPonyY6ui1HcbaJcFdngjBhnjWbe65zs=\",\n        \"owner\": \"arjunkathuria\",\n        \"repo\": \"tinylog\",\n        \"rev\": \"08d3b6066cd2f883e183b7cd01809d1711092d33\",\n        \"type\": \"gitlab\"\n      },\n      \"original\": {\n        \"owner\": \"arjunkathuria\",\n        \"repo\": \"tinylog\",\n        \"rev\": \"08d3b6066cd2f883e183b7cd01809d1711092d33\",\n        \"type\": \"gitlab\"\n      }\n    },\n    \"treefmt-nix\": {\n      \"inputs\": {\n        \"nixpkgs\": \"nixpkgs_3\"\n      },\n      \"locked\": {\n        \"lastModified\": 1699786194,\n        \"narHash\": \"sha256-3h3EH1FXQkIeAuzaWB+nK0XK54uSD46pp+dMD3gAcB4=\",\n        \"owner\": \"numtide\",\n        \"repo\": \"treefmt-nix\",\n        \"rev\": \"e82f32aa7f06bbbd56d7b12186d555223dc399d1\",\n        \"type\": \"github\"\n      },\n      \"original\": {\n        \"owner\": \"numtide\",\n        \"repo\": \"treefmt-nix\",\n        \"type\": \"github\"\n      }\n    },\n    \"treefmt-nix_2\": {\n      \"inputs\": {\n        \"nixpkgs\": \"nixpkgs_8\"\n      },\n      \"locked\": {\n        \"lastModified\": 1682536470,\n        \"narHash\": \"sha256-dGR2FRxWswpQCHdivejB3uiLZPktnT3DYp6ZkybR/SE=\",\n        \"owner\": \"numtide\",\n        \"repo\": \"treefmt-nix\",\n        \"rev\": \"6d8bea2820630576ad8c3a3bde2c95c38bcc471f\",\n        \"type\": \"github\"\n      },\n      \"original\": {\n        \"owner\": \"numtide\",\n        \"repo\": \"treefmt-nix\",\n        \"type\": \"github\"\n      }\n    },\n    \"treefmt-nix_3\": {\n      \"inputs\": {\n        \"nixpkgs\": \"nixpkgs_13\"\n      },\n      \"locked\": {\n        \"lastModified\": 1682536470,\n        \"narHash\": \"sha256-dGR2FRxWswpQCHdivejB3uiLZPktnT3DYp6ZkybR/SE=\",\n        \"owner\": \"numtide\",\n        \"repo\": \"treefmt-nix\",\n        \"rev\": \"6d8bea2820630576ad8c3a3bde2c95c38bcc471f\",\n        \"type\": \"github\"\n      },\n      \"original\": {\n        \"owner\": \"numtide\",\n        \"repo\": \"treefmt-nix\",\n        \"type\": \"github\"\n      }\n    },\n    \"word24\": {\n      \"flake\": false,\n      \"locked\": {\n        \"lastModified\": 1647587255,\n        \"narHash\": \"sha256-S37S10sJ45BulvpqJzlhX/J4hY7cW5jLM9nP4xAftac=\",\n        \"owner\": \"winterland1989\",\n        \"repo\": \"word24\",\n        \"rev\": \"445f791e35ddc8098f05879dbcd07c41b115cb39\",\n        \"type\": \"github\"\n      },\n      \"original\": {\n        \"owner\": \"winterland1989\",\n        \"repo\": \"word24\",\n        \"type\": \"github\"\n      }\n    }\n  },\n  \"root\": \"root\",\n  \"version\": 7\n}\n",
      "hash": "b7cef8417088a5f02bbe775145464ec214f41a7d2a141afb46543e3f408d8715",
      "size": 57830
    },
    "/flake.nix": {
      "type": "content",
      "content": "{\n  inputs = {\n    common.url = \"github:nammayatri/common\";\n    nixpkgs.follows = \"common/nixpkgs\";\n    haskell-flake.follows = \"common/haskell-flake\";\n\n    passetto-hs.url = \"github:juspay/passetto/bb92cf1dd9699662d2a7bb96cd6a6aed6f20e8ff\";\n    passetto-hs.flake = false;\n\n    clickhouse-haskell.url = \"github:nammayatri/clickhouse-haskell\";\n    clickhouse-haskell.inputs.common.follows = \"common\";\n    prometheus-haskell.url = \"github:juspay/prometheus-haskell/more-proc-metrics\";\n    prometheus-haskell.inputs.haskell-flake.follows = \"common/haskell-flake\";\n\n    euler-hs = {\n      url = \"github:nammayatri/euler-hs\";\n      inputs.nixpkgs.follows = \"nixpkgs\";\n      inputs.haskell-flake.follows = \"haskell-flake\";\n    };\n  };\n  outputs = inputs:\n    inputs.common.lib.mkFlake { inherit inputs; } {\n      debug = true;\n      perSystem = { self', pkgs, lib, config, ... }: {\n        haskellProjects.default = {\n          imports = [\n            inputs.euler-hs.haskellFlakeProjectModules.output\n            inputs.clickhouse-haskell.haskellFlakeProjectModules.output\n          ];\n          packages = {\n            passetto-client.source = inputs.passetto-hs + /client;\n            passetto-core.source = inputs.passetto-hs + /core;\n          };\n          settings = {\n            # Tests and documentation generation fail for some reason.\n            euler-hs = {\n              check = false;\n              jailbreak = true;\n              haddock = false;\n              libraryProfiling = false;\n            };\n            wai-middleware-prometheus = {\n              check = false;\n              haddock = false;\n            };\n            euler-events-hs = {\n              check = false;\n              libraryProfiling = false;\n              jailbreak = true;\n            };\n            prometheus-client = {\n              check = false;\n              libraryProfiling = false;\n              jailbreak = true;\n            };\n            clickhouse-haskell.jailbreak = true;\n            generic-deriving.check = false;\n            singletons-th.jailbreak = true;\n          };\n          autoWire = [ \"packages\" \"checks\" ];\n        };\n        process-compose = { };\n        packages.default = self'.packages.mobility-core;\n        devShells.default = pkgs.mkShell {\n          name = \"shared-kernel-shell\";\n          # cf. https://haskell.flake.page/devshell#composing-devshells\n          inputsFrom = [\n            config.haskellProjects.default.outputs.devShell\n            config.pre-commit.devShell\n            config.flake-root.devShell\n          ];\n        };\n      };\n    };\n}\n",
      "hash": "6441754709853b124234520ebe1b217b72229f90e14f3001ed09a07a7ebd0b4a",
      "size": 2583
    },
    "/hie.yaml": {
      "type": "content",
      "content": "cradle:\n  cabal:\n",
      "hash": "bdb4779aeb4d2c1b665f51e3f896a04ef219d3bb5aacbab2df4a7d7fda4e3d54",
      "size": 17,
      "json": {
        "cradle": {
          "cabal": null
        }
      }
    },
    "/lib/mobility-core/auto-generated/Kernel/External/MultiModal/OpenTripPlanner/Types.hs": {
      "type": "content",
      "content": "{-# LANGUAGE DeriveGeneric #-}\n{-# LANGUAGE DerivingStrategies #-}\n{-# LANGUAGE DuplicateRecordFields #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE OverloadedStrings #-}\n{-# LANGUAGE TypeFamilies #-}\n\nmodule Kernel.External.MultiModal.OpenTripPlanner.Types where\n\nimport Data.Morpheus.Client.CodeGen.Internal\nimport qualified Data.Text as T\nimport qualified Database.Beam as B\nimport Database.Beam.Backend\nimport Database.Beam.Postgres\nimport EulerHS.Prelude hiding (id, product)\nimport Kernel.Prelude (ToSchema)\nimport Prelude (Show (..))\n\ndata AbsoluteDirection\n  = AbsoluteDirectionNORTH\n  | AbsoluteDirectionNORTHEAST\n  | AbsoluteDirectionEAST\n  | AbsoluteDirectionSOUTHEAST\n  | AbsoluteDirectionSOUTH\n  | AbsoluteDirectionSOUTHWEST\n  | AbsoluteDirectionWEST\n  | AbsoluteDirectionNORTHWEST\n  deriving (Generic, Show, Eq, ToSchema, Ord)\n\ninstance FromJSON AbsoluteDirection where\n  parseJSON = \\case\n    \"NORTH\" -> pure AbsoluteDirectionNORTH\n    \"NORTHEAST\" -> pure AbsoluteDirectionNORTHEAST\n    \"EAST\" -> pure AbsoluteDirectionEAST\n    \"SOUTHEAST\" -> pure AbsoluteDirectionSOUTHEAST\n    \"SOUTH\" -> pure AbsoluteDirectionSOUTH\n    \"SOUTHWEST\" -> pure AbsoluteDirectionSOUTHWEST\n    \"WEST\" -> pure AbsoluteDirectionWEST\n    \"NORTHWEST\" -> pure AbsoluteDirectionNORTHWEST\n    v -> invalidConstructorError v\n\ninstance ToJSON AbsoluteDirection where\n  toJSON = \\case\n    AbsoluteDirectionNORTH -> \"NORTH\"\n    AbsoluteDirectionNORTHEAST -> \"NORTHEAST\"\n    AbsoluteDirectionEAST -> \"EAST\"\n    AbsoluteDirectionSOUTHEAST -> \"SOUTHEAST\"\n    AbsoluteDirectionSOUTH -> \"SOUTH\"\n    AbsoluteDirectionSOUTHWEST -> \"SOUTHWEST\"\n    AbsoluteDirectionWEST -> \"WEST\"\n    AbsoluteDirectionNORTHWEST -> \"NORTHWEST\"\n\ndata InputCoordinates = InputCoordinates\n  { lat :: Double,\n    lon :: Double\n  }\n  deriving (Generic, Show, Eq)\n\ninstance ToJSON InputCoordinates where\n  toJSON (InputCoordinates inputCoordinatesLat inputCoordinatesLon) =\n    omitNulls\n      [ \"lat\" .= inputCoordinatesLat,\n        \"lon\" .= inputCoordinatesLon\n      ]\n\ndata Mode\n  = ModeAIRPLANE\n  | ModeBICYCLE\n  | ModeBUS\n  | ModeCABLE_CAR\n  | ModeCAR\n  | ModeCOACH\n  | ModeFERRY\n  | ModeFLEX\n  | ModeFUNICULAR\n  | ModeGONDOLA\n  | ModeRAIL\n  | ModeSCOOTER\n  | ModeSUBWAY\n  | ModeTRAM\n  | ModeCARPOOL\n  | ModeTAXI\n  | ModeTRANSIT\n  | ModeWALK\n  | ModeTROLLEYBUS\n  | ModeMONORAIL\n  deriving (Generic, Eq)\n\ninstance Show Mode where\n  show = \\case\n    ModeAIRPLANE -> \"AIRPLANE\"\n    ModeBICYCLE -> \"BICYCLE\"\n    ModeBUS -> \"BUS\"\n    ModeCABLE_CAR -> \"CABLE_CAR\"\n    ModeCAR -> \"CAR\"\n    ModeCOACH -> \"COACH\"\n    ModeFERRY -> \"FERRY\"\n    ModeFLEX -> \"FLEX\"\n    ModeFUNICULAR -> \"FUNICULAR\"\n    ModeGONDOLA -> \"GONDOLA\"\n    ModeRAIL -> \"RAIL\"\n    ModeSCOOTER -> \"SCOOTER\"\n    ModeSUBWAY -> \"SUBWAY\"\n    ModeTRAM -> \"TRAM\"\n    ModeCARPOOL -> \"CARPOOL\"\n    ModeTAXI -> \"TAXI\"\n    ModeTRANSIT -> \"TRANSIT\"\n    ModeWALK -> \"WALK\"\n    ModeTROLLEYBUS -> \"TROLLEYBUS\"\n    ModeMONORAIL -> \"MONORAIL\"\n\ninstance FromJSON Mode where\n  parseJSON = \\case\n    \"AIRPLANE\" -> pure ModeAIRPLANE\n    \"BICYCLE\" -> pure ModeBICYCLE\n    \"BUS\" -> pure ModeBUS\n    \"CABLE_CAR\" -> pure ModeCABLE_CAR\n    \"CAR\" -> pure ModeCAR\n    \"COACH\" -> pure ModeCOACH\n    \"FERRY\" -> pure ModeFERRY\n    \"FLEX\" -> pure ModeFLEX\n    \"FUNICULAR\" -> pure ModeFUNICULAR\n    \"GONDOLA\" -> pure ModeGONDOLA\n    \"RAIL\" -> pure ModeRAIL\n    \"SCOOTER\" -> pure ModeSCOOTER\n    \"SUBWAY\" -> pure ModeSUBWAY\n    \"TRAM\" -> pure ModeTRAM\n    \"CARPOOL\" -> pure ModeCARPOOL\n    \"TAXI\" -> pure ModeTAXI\n    \"TRANSIT\" -> pure ModeTRANSIT\n    \"WALK\" -> pure ModeWALK\n    \"TROLLEYBUS\" -> pure ModeTROLLEYBUS\n    \"MONORAIL\" -> pure ModeMONORAIL\n    v -> invalidConstructorError v\n\ninstance ToJSON Mode where\n  toJSON = \\case\n    ModeAIRPLANE -> \"AIRPLANE\"\n    ModeBICYCLE -> \"BICYCLE\"\n    ModeBUS -> \"BUS\"\n    ModeCABLE_CAR -> \"CABLE_CAR\"\n    ModeCAR -> \"CAR\"\n    ModeCOACH -> \"COACH\"\n    ModeFERRY -> \"FERRY\"\n    ModeFLEX -> \"FLEX\"\n    ModeFUNICULAR -> \"FUNICULAR\"\n    ModeGONDOLA -> \"GONDOLA\"\n    ModeRAIL -> \"RAIL\"\n    ModeSCOOTER -> \"SCOOTER\"\n    ModeSUBWAY -> \"SUBWAY\"\n    ModeTRAM -> \"TRAM\"\n    ModeCARPOOL -> \"CARPOOL\"\n    ModeTAXI -> \"TAXI\"\n    ModeTRANSIT -> \"TRANSIT\"\n    ModeWALK -> \"WALK\"\n    ModeTROLLEYBUS -> \"TROLLEYBUS\"\n    ModeMONORAIL -> \"MONORAIL\"\n\ndata RelativeDirection\n  = RelativeDirectionDEPART\n  | RelativeDirectionHARD_LEFT\n  | RelativeDirectionLEFT\n  | RelativeDirectionSLIGHTLY_LEFT\n  | RelativeDirectionCONTINUE\n  | RelativeDirectionSLIGHTLY_RIGHT\n  | RelativeDirectionRIGHT\n  | RelativeDirectionHARD_RIGHT\n  | RelativeDirectionCIRCLE_CLOCKWISE\n  | RelativeDirectionCIRCLE_COUNTERCLOCKWISE\n  | RelativeDirectionELEVATOR\n  | RelativeDirectionUTURN_LEFT\n  | RelativeDirectionUTURN_RIGHT\n  | RelativeDirectionENTER_STATION\n  | RelativeDirectionEXIT_STATION\n  | RelativeDirectionFOLLOW_SIGNS\n  deriving (Generic, Show, Eq)\n\ninstance FromJSON RelativeDirection where\n  parseJSON = \\case\n    \"DEPART\" -> pure RelativeDirectionDEPART\n    \"HARD_LEFT\" -> pure RelativeDirectionHARD_LEFT\n    \"LEFT\" -> pure RelativeDirectionLEFT\n    \"SLIGHTLY_LEFT\" -> pure RelativeDirectionSLIGHTLY_LEFT\n    \"CONTINUE\" -> pure RelativeDirectionCONTINUE\n    \"SLIGHTLY_RIGHT\" -> pure RelativeDirectionSLIGHTLY_RIGHT\n    \"RIGHT\" -> pure RelativeDirectionRIGHT\n    \"HARD_RIGHT\" -> pure RelativeDirectionHARD_RIGHT\n    \"CIRCLE_CLOCKWISE\" -> pure RelativeDirectionCIRCLE_CLOCKWISE\n    \"CIRCLE_COUNTERCLOCKWISE\" -> pure RelativeDirectionCIRCLE_COUNTERCLOCKWISE\n    \"ELEVATOR\" -> pure RelativeDirectionELEVATOR\n    \"UTURN_LEFT\" -> pure RelativeDirectionUTURN_LEFT\n    \"UTURN_RIGHT\" -> pure RelativeDirectionUTURN_RIGHT\n    \"ENTER_STATION\" -> pure RelativeDirectionENTER_STATION\n    \"EXIT_STATION\" -> pure RelativeDirectionEXIT_STATION\n    \"FOLLOW_SIGNS\" -> pure RelativeDirectionFOLLOW_SIGNS\n    v -> invalidConstructorError v\n\ninstance ToJSON RelativeDirection where\n  toJSON = \\case\n    RelativeDirectionDEPART -> \"DEPART\"\n    RelativeDirectionHARD_LEFT -> \"HARD_LEFT\"\n    RelativeDirectionLEFT -> \"LEFT\"\n    RelativeDirectionSLIGHTLY_LEFT -> \"SLIGHTLY_LEFT\"\n    RelativeDirectionCONTINUE -> \"CONTINUE\"\n    RelativeDirectionSLIGHTLY_RIGHT -> \"SLIGHTLY_RIGHT\"\n    RelativeDirectionRIGHT -> \"RIGHT\"\n    RelativeDirectionHARD_RIGHT -> \"HARD_RIGHT\"\n    RelativeDirectionCIRCLE_CLOCKWISE -> \"CIRCLE_CLOCKWISE\"\n    RelativeDirectionCIRCLE_COUNTERCLOCKWISE -> \"CIRCLE_COUNTERCLOCKWISE\"\n    RelativeDirectionELEVATOR -> \"ELEVATOR\"\n    RelativeDirectionUTURN_LEFT -> \"UTURN_LEFT\"\n    RelativeDirectionUTURN_RIGHT -> \"UTURN_RIGHT\"\n    RelativeDirectionENTER_STATION -> \"ENTER_STATION\"\n    RelativeDirectionEXIT_STATION -> \"EXIT_STATION\"\n    RelativeDirectionFOLLOW_SIGNS -> \"FOLLOW_SIGNS\"\n\nnewtype TransportMode = TransportMode\n  { mode :: String\n  }\n  deriving (Generic, Show, Eq, ToSchema, FromJSON)\n\ninstance ToJSON TransportMode where\n  toJSON (TransportMode transportModeMode) =\n    omitNulls\n      [ \"mode\" .= transportModeMode\n      ]\n\ninstance RequestType OTPPlan where\n  type RequestArgs OTPPlan = OTPPlanArgs\n  __name _ = \"OTPPlan\"\n  __query _ = \"query OTPPlan (\\n    $from: InputCoordinates!,\\n    $to: InputCoordinates!,\\n    $date: String,\\n    $time:String,\\n    $transportModes: [TransportMode],\\n    $numItineraries: Int\\n){\\n  plan(\\n    from: $from,\\n    to: $to,\\n    date: $date,\\n    time: $time,\\n    transportModes: $transportModes,\\n    numItineraries : $numItineraries\\n  ) {\\n    itineraries {\\n      duration\\n      startTime\\n      endTime\\n      legs {\\n        pickupType\\n        distance\\n        mode\\n        duration\\n        startTime\\n        endTime\\n        from {\\n          name\\n          lat\\n          lon\\n          departureTime\\n          arrivalTime\\n          stop {\\n            code\\n            gtfsId\\n            platformCode\\n          }\\n        }\\n        to {\\n          name\\n          lat\\n          lon\\n          departureTime\\n          arrivalTime\\n          stop {\\n            code\\n            gtfsId\\n            platformCode\\n          }\\n        }\\n        route {\\n          gtfsId\\n          longName\\n          trips {\\n            gtfsId\\n          }\\n          shortName\\n          color\\n          agency {\\n            gtfsId\\n            name\\n          }\\n        }\\n        legGeometry {\\n          points\\n        }\\n        fareProducts {\\n          id\\n        }\\n      }\\n    }\\n  }\\n}\\n\"\n  __type _ = OPERATION_QUERY\n\nnewtype OTPPlan = OTPPlan\n  { plan :: OTPPlanPlan\n  }\n  deriving (Generic, Show, Eq)\n\ninstance FromJSON OTPPlan where\n  parseJSON =\n    withObject \"OTPPlan\" (\\v -> OTPPlan <$> v .: \"plan\")\n\nnewtype OTPPlanPlan = OTPPlanPlan\n  { itineraries :: [Maybe OTPPlanPlanItineraries]\n  }\n  deriving (Generic, Show, Eq)\n\ninstance FromJSON OTPPlanPlan where\n  parseJSON =\n    withObject \"OTPPlanPlan\" (\\v -> OTPPlanPlan <$> v .: \"itineraries\")\n\ndata OTPPlanPlanItineraries = OTPPlanPlanItineraries\n  { duration :: Maybe Double,\n    startTime :: Maybe Double,\n    endTime :: Maybe Double,\n    legs :: [Maybe OTPPlanPlanItinerariesLegs]\n  }\n  deriving (Generic, Show, Eq)\n\ninstance FromJSON OTPPlanPlanItineraries where\n  parseJSON =\n    withObject \"OTPPlanPlanItineraries\" (\\v -> OTPPlanPlanItineraries <$> v .:? \"duration\" <*> v .:? \"startTime\" <*> v .:? \"endTime\" <*> v .: \"legs\")\n\ndata OTPPlanPlanItinerariesLegs = OTPPlanPlanItinerariesLegs\n  { pickupType :: Maybe String,\n    distance :: Maybe Double,\n    mode :: Maybe Mode,\n    entrance :: Maybe OTPPlanPlanItinerariesLegsEntrance,\n    exit :: Maybe OTPPlanPlanItinerariesLegsExit,\n    duration :: Maybe Double,\n    startTime :: Maybe Double,\n    endTime :: Maybe Double,\n    from :: OTPPlanPlanItinerariesLegsFrom,\n    to :: OTPPlanPlanItinerariesLegsTo,\n    route :: Maybe OTPPlanPlanItinerariesLegsRoute,\n    legGeometry :: Maybe OTPPlanPlanItinerariesLegsLegGeometry,\n    fareProducts :: Maybe [Maybe OTPPlanPlanItinerariesLegsFareProducts]\n  }\n  deriving (Generic, Show, Eq)\n\ninstance FromJSON OTPPlanPlanItinerariesLegs where\n  parseJSON =\n    withObject \"OTPPlanPlanItinerariesLegs\" (\\v -> OTPPlanPlanItinerariesLegs <$> v .:? \"pickupType\" <*> v .:? \"distance\" <*> v .:? \"mode\" <*> v .:? \"entrance\" <*> v .:? \"exit\" <*> v .:? \"duration\" <*> v .:? \"startTime\" <*> v .:? \"endTime\" <*> v .: \"from\" <*> v .: \"to\" <*> v .:? \"route\" <*> v .:? \"legGeometry\" <*> v .:? \"fareProducts\")\n\ndata OTPPlanPlanItinerariesLegsEntrance = OTPPlanPlanItinerariesLegsEntrance\n  { distance :: Maybe Double,\n    lon :: Maybe Double,\n    lat :: Maybe Double,\n    relativeDirection :: Maybe RelativeDirection,\n    absoluteDirection :: Maybe AbsoluteDirection,\n    streetName :: Maybe String,\n    exit :: Maybe String,\n    stayOn :: Maybe Bool,\n    area :: Maybe Bool,\n    bogusName :: Maybe Bool,\n    walkingBike :: Maybe Bool\n  }\n  deriving (Generic, Show, Eq)\n\ninstance FromJSON OTPPlanPlanItinerariesLegsEntrance where\n  parseJSON =\n    withObject \"OTPPlanPlanItinerariesLegsEntrance\" (\\v -> OTPPlanPlanItinerariesLegsEntrance <$> v .:? \"distance\" <*> v .:? \"lon\" <*> v .:? \"lat\" <*> v .:? \"relativeDirection\" <*> v .:? \"absoluteDirection\" <*> v .:? \"streetName\" <*> v .:? \"exit\" <*> v .:? \"stayOn\" <*> v .:? \"area\" <*> v .:? \"bogusName\" <*> v .:? \"walkingBike\")\n\ndata OTPPlanPlanItinerariesLegsExit = OTPPlanPlanItinerariesLegsExit\n  { distance :: Maybe Double,\n    lon :: Maybe Double,\n    lat :: Maybe Double,\n    relativeDirection :: Maybe RelativeDirection,\n    absoluteDirection :: Maybe AbsoluteDirection,\n    streetName :: Maybe String,\n    exit :: Maybe String,\n    stayOn :: Maybe Bool,\n    area :: Maybe Bool,\n    bogusName :: Maybe Bool,\n    walkingBike :: Maybe Bool\n  }\n  deriving (Generic, Show, Eq)\n\ninstance FromJSON OTPPlanPlanItinerariesLegsExit where\n  parseJSON =\n    withObject \"OTPPlanPlanItinerariesLegsExit\" (\\v -> OTPPlanPlanItinerariesLegsExit <$> v .:? \"distance\" <*> v .:? \"lon\" <*> v .:? \"lat\" <*> v .:? \"relativeDirection\" <*> v .:? \"absoluteDirection\" <*> v .:? \"streetName\" <*> v .:? \"exit\" <*> v .:? \"stayOn\" <*> v .:? \"area\" <*> v .:? \"bogusName\" <*> v .:? \"walkingBike\")\n\ndata OTPPlanPlanItinerariesLegsFrom = OTPPlanPlanItinerariesLegsFrom\n  { name :: Maybe String,\n    lat :: Double,\n    lon :: Double,\n    departureTime :: Double,\n    arrivalTime :: Double,\n    stop :: Maybe OTPPlanPlanItinerariesLegsFromStop\n  }\n  deriving (Generic, Show, Eq)\n\ninstance FromJSON OTPPlanPlanItinerariesLegsFrom where\n  parseJSON =\n    withObject \"OTPPlanPlanItinerariesLegsFrom\" (\\v -> OTPPlanPlanItinerariesLegsFrom <$> v .:? \"name\" <*> v .: \"lat\" <*> v .: \"lon\" <*> v .: \"departureTime\" <*> v .: \"arrivalTime\" <*> v .:? \"stop\")\n\ndata OTPPlanPlanItinerariesLegsFromStop = OTPPlanPlanItinerariesLegsFromStop\n  { code :: Maybe String,\n    gtfsId :: String,\n    platformCode :: Maybe String\n  }\n  deriving (Generic, Show, Eq)\n\ninstance FromJSON OTPPlanPlanItinerariesLegsFromStop where\n  parseJSON =\n    withObject \"OTPPlanPlanItinerariesLegsFromStop\" (\\v -> OTPPlanPlanItinerariesLegsFromStop <$> v .:? \"code\" <*> v .: \"gtfsId\" <*> v .:? \"platformCode\")\n\ndata OTPPlanPlanItinerariesLegsTo = OTPPlanPlanItinerariesLegsTo\n  { name :: Maybe String,\n    lat :: Double,\n    lon :: Double,\n    departureTime :: Double,\n    arrivalTime :: Double,\n    stop :: Maybe OTPPlanPlanItinerariesLegsToStop\n  }\n  deriving (Generic, Show, Eq)\n\ninstance FromJSON OTPPlanPlanItinerariesLegsTo where\n  parseJSON =\n    withObject \"OTPPlanPlanItinerariesLegsTo\" (\\v -> OTPPlanPlanItinerariesLegsTo <$> v .:? \"name\" <*> v .: \"lat\" <*> v .: \"lon\" <*> v .: \"departureTime\" <*> v .: \"arrivalTime\" <*> v .:? \"stop\")\n\ndata OTPPlanPlanItinerariesLegsToStop = OTPPlanPlanItinerariesLegsToStop\n  { code :: Maybe String,\n    gtfsId :: String,\n    platformCode :: Maybe String\n  }\n  deriving (Generic, Show, Eq)\n\ninstance FromJSON OTPPlanPlanItinerariesLegsToStop where\n  parseJSON =\n    withObject \"OTPPlanPlanItinerariesLegsToStop\" (\\v -> OTPPlanPlanItinerariesLegsToStop <$> v .:? \"code\" <*> v .: \"gtfsId\" <*> v .:? \"platformCode\")\n\ndata OTPPlanPlanItinerariesLegsRoute = OTPPlanPlanItinerariesLegsRoute\n  { gtfsId :: String,\n    longName :: Maybe String,\n    trips :: Maybe [Maybe OTPPlanPlanItinerariesLegsRouteTrips],\n    shortName :: Maybe String,\n    color :: Maybe String,\n    agency :: Maybe OTPPlanPlanItinerariesLegsRouteAgency\n  }\n  deriving (Generic, Show, Eq)\n\ninstance FromJSON OTPPlanPlanItinerariesLegsRoute where\n  parseJSON =\n    withObject \"OTPPlanPlanItinerariesLegsRoute\" (\\v -> OTPPlanPlanItinerariesLegsRoute <$> v .: \"gtfsId\" <*> v .:? \"longName\" <*> v .:? \"trips\" <*> v .:? \"shortName\" <*> v .:? \"color\" <*> v .:? \"agency\")\n\nnewtype OTPPlanPlanItinerariesLegsRouteTrips = OTPPlanPlanItinerariesLegsRouteTrips\n  { gtfsId :: String\n  }\n  deriving (Generic, Show, Eq)\n\ninstance FromJSON OTPPlanPlanItinerariesLegsRouteTrips where\n  parseJSON =\n    withObject \"OTPPlanPlanItinerariesLegsRouteTrips\" (\\v -> OTPPlanPlanItinerariesLegsRouteTrips <$> v .: \"gtfsId\")\n\ndata OTPPlanPlanItinerariesLegsRouteAgency = OTPPlanPlanItinerariesLegsRouteAgency\n  { gtfsId :: String,\n    name :: String\n  }\n  deriving (Generic, Show, Eq)\n\ninstance FromJSON OTPPlanPlanItinerariesLegsRouteAgency where\n  parseJSON =\n    withObject \"OTPPlanPlanItinerariesLegsRouteAgency\" (\\v -> OTPPlanPlanItinerariesLegsRouteAgency <$> v .: \"gtfsId\" <*> v .: \"name\")\n\nnewtype OTPPlanPlanItinerariesLegsLegGeometry = OTPPlanPlanItinerariesLegsLegGeometry\n  { points :: Maybe String\n  }\n  deriving (Generic, Show, Eq)\n\ninstance FromJSON OTPPlanPlanItinerariesLegsLegGeometry where\n  parseJSON =\n    withObject \"OTPPlanPlanItinerariesLegsLegGeometry\" (\\v -> OTPPlanPlanItinerariesLegsLegGeometry <$> v .:? \"points\")\n\nnewtype OTPPlanPlanItinerariesLegsFareProducts = OTPPlanPlanItinerariesLegsFareProducts\n  { id :: String\n  }\n  deriving (Generic, Show, Eq)\n\ninstance FromJSON OTPPlanPlanItinerariesLegsFareProducts where\n  parseJSON =\n    withObject \"OTPPlanPlanItinerariesLegsFareProducts\" (\\v -> OTPPlanPlanItinerariesLegsFareProducts <$> v .: \"id\")\n\ndata OTPPlanArgs = OTPPlanArgs\n  { from :: InputCoordinates,\n    to :: InputCoordinates,\n    date :: Maybe String,\n    time :: Maybe String,\n    transportModes :: Maybe [Maybe TransportMode],\n    numItineraries :: Maybe Int\n  }\n  deriving (Generic, Show, Eq)\n\ninstance ToJSON OTPPlanArgs where\n  toJSON (OTPPlanArgs oTPPlanArgsFrom oTPPlanArgsTo oTPPlanArgsDate oTPPlanArgsTime oTPPlanArgsTransportModes oTPPlanArgsNumItineraries) =\n    omitNulls\n      [ \"from\" .= oTPPlanArgsFrom,\n        \"to\" .= oTPPlanArgsTo,\n        \"date\" .= oTPPlanArgsDate,\n        \"time\" .= oTPPlanArgsTime,\n        \"transportModes\" .= oTPPlanArgsTransportModes,\n        \"numItineraries\" .= oTPPlanArgsNumItineraries\n      ]\n\ninstance RequestType MultiModePlan where\n  type RequestArgs MultiModePlan = MultiModePlanArgs\n  __name _ = \"MultiModePlan\"\n  __query _ = \"query MultiModePlan(\\n  $from: InputCoordinates!,\\n  $to: InputCoordinates!,\\n  $date: String,\\n  $time: String,\\n  $metroTransportModes: [TransportMode]!,\\n  $metroItineraries: Int!\\n  $subwayTransportModes: [TransportMode]!,\\n  $subwayItineraries: Int!\\n  $busTransportModes: [TransportMode]!,\\n  $busItineraries: Int!\\n  $bestTransportModes: [TransportMode]!,\\n  $bestItineraries: Int!\\n) {\\n  metro: plan(\\n    from: $from,\\n    to:   $to,\\n    date: $date,\\n    time: $time,\\n    transportModes: $metroTransportModes,\\n    numItineraries: $metroItineraries\\n  ) {\\n    itineraries { ...ItineraryFields }\\n  }\\n  subway: plan(\\n    from: $from,\\n    to:   $to,\\n    date: $date,\\n    time: $time,\\n    transportModes: $subwayTransportModes,\\n    numItineraries: $subwayItineraries\\n  ) {\\n    itineraries { ...ItineraryFields }\\n  }\\n  bus: plan(\\n    from: $from,\\n    to:   $to,\\n    date: $date,\\n    time: $time,\\n    transportModes: $busTransportModes,\\n    numItineraries: $busItineraries\\n  ) {\\n    itineraries { ...ItineraryFields }\\n  }\\n  best: plan(\\n    from: $from,\\n    to:   $to,\\n    date: $date,\\n    time: $time,\\n    transportModes: $bestTransportModes,\\n    numItineraries: $bestItineraries\\n  ) {\\n    itineraries { ...ItineraryFields }\\n  }\\n}\\n\\nfragment ItineraryFields on Itinerary {\\n  duration\\n  startTime\\n  endTime\\n  legs {\\n    pickupType\\n    distance\\n    mode\\n    entrance {\\n      distance\\n      lon\\n      lat\\n      relativeDirection\\n      absoluteDirection\\n      streetName\\n      exit\\n      stayOn\\n      area\\n      bogusName\\n      walkingBike\\n    }\\n    exit {\\n      distance\\n      lon\\n      lat\\n      relativeDirection\\n      absoluteDirection\\n      streetName\\n      exit\\n      stayOn\\n      area\\n      bogusName\\n      walkingBike\\n    }\\n    duration\\n    startTime\\n    endTime\\n    from {\\n      name\\n      lat\\n      lon\\n      departureTime\\n      arrivalTime\\n      stop {\\n        code\\n        gtfsId\\n        platformCode\\n      }\\n    }\\n    to {\\n      name\\n      lat\\n      lon\\n      departureTime\\n      arrivalTime\\n      stop {\\n        code\\n        gtfsId\\n        platformCode\\n      }\\n    }\\n    route {\\n      gtfsId\\n      longName\\n      trips {\\n        gtfsId\\n      }\\n      shortName\\n      color\\n      agency {\\n        gtfsId\\n        name\\n      }\\n    }\\n    legGeometry {\\n      points\\n    }\\n    fareProducts {\\n      id\\n    }\\n  }\\n}\\n\"\n  __type _ = OPERATION_QUERY\n\ndata MultiModePlanArgs = MultiModePlanArgs\n  { from :: InputCoordinates,\n    to :: InputCoordinates,\n    date :: Maybe String,\n    time :: Maybe String,\n    metroTransportModes :: [Maybe TransportMode],\n    metroItineraries :: Int,\n    subwayTransportModes :: [Maybe TransportMode],\n    subwayItineraries :: Int,\n    busTransportModes :: [Maybe TransportMode],\n    busItineraries :: Int,\n    bestTransportModes :: [Maybe TransportMode],\n    bestItineraries :: Int\n  }\n  deriving (Generic, Show, Eq)\n\ninstance ToJSON MultiModePlanArgs where\n  toJSON (MultiModePlanArgs multiModePlanArgsFrom multiModePlanArgsTo multiModePlanArgsDate multiModePlanArgsTime multiModePlanArgsMetroTransportModes multiModePlanArgsMetroItineraries multiModePlanArgsSubwayTransportModes multiModePlanArgsSubwayItineraries multiModePlanArgsBusTransportModes multiModePlanArgsBusItineraries multiModePlanArgsBestTransportModes multiModePlanArgsBestItineraries) =\n    omitNulls\n      [ \"from\" .= multiModePlanArgsFrom,\n        \"to\" .= multiModePlanArgsTo,\n        \"date\" .= multiModePlanArgsDate,\n        \"time\" .= multiModePlanArgsTime,\n        \"metroTransportModes\" .= multiModePlanArgsMetroTransportModes,\n        \"metroItineraries\" .= multiModePlanArgsMetroItineraries,\n        \"subwayTransportModes\" .= multiModePlanArgsSubwayTransportModes,\n        \"subwayItineraries\" .= multiModePlanArgsSubwayItineraries,\n        \"busTransportModes\" .= multiModePlanArgsBusTransportModes,\n        \"busItineraries\" .= multiModePlanArgsBusItineraries,\n        \"bestTransportModes\" .= multiModePlanArgsBestTransportModes,\n        \"bestItineraries\" .= multiModePlanArgsBestItineraries\n      ]\n\ndata MultiModePlan = MultiModePlan\n  { metro :: MultiModePlanMetro,\n    subway :: MultiModePlanSubway,\n    bus :: MultiModePlanBus,\n    best :: MultiModePlanBest\n  }\n  deriving (Generic, Show, Eq)\n\ninstance FromJSON MultiModePlan where\n  parseJSON =\n    withObject \"MultiModePlan\" (\\v -> MultiModePlan <$> v .: \"metro\" <*> v .: \"subway\" <*> v .: \"bus\" <*> v .: \"best\")\n\nnewtype MultiModePlanMetro = MultiModePlanMetro\n  { itineraries :: [Maybe OTPPlanPlanItineraries]\n  }\n  deriving (Generic, Show, Eq)\n\ninstance FromJSON MultiModePlanMetro where\n  parseJSON =\n    withObject \"MultiModePlanMetro\" (\\v -> MultiModePlanMetro <$> v .: \"itineraries\")\n\nnewtype MultiModePlanSubway = MultiModePlanSubway\n  { itineraries :: [Maybe OTPPlanPlanItineraries]\n  }\n  deriving (Generic, Show, Eq)\n\ninstance FromJSON MultiModePlanSubway where\n  parseJSON =\n    withObject \"MultiModePlanSubway\" (\\v -> MultiModePlanSubway <$> v .: \"itineraries\")\n\nnewtype MultiModePlanBus = MultiModePlanBus\n  { itineraries :: [Maybe OTPPlanPlanItineraries]\n  }\n  deriving (Generic, Show, Eq)\n\ninstance FromJSON MultiModePlanBus where\n  parseJSON =\n    withObject \"MultiModePlanBus\" (\\v -> MultiModePlanBus <$> v .: \"itineraries\")\n\nnewtype MultiModePlanBest = MultiModePlanBest\n  { itineraries :: [Maybe OTPPlanPlanItineraries]\n  }\n  deriving (Generic, Show, Eq)\n\ninstance FromJSON MultiModePlanBest where\n  parseJSON =\n    withObject \"MultiModePlanBest\" (\\v -> MultiModePlanBest <$> v .: \"itineraries\")\n\ndirectionToText :: AbsoluteDirection -> Text\ndirectionToText = \\case\n  AbsoluteDirectionNORTH -> \"NORTH\"\n  AbsoluteDirectionNORTHEAST -> \"NORTHEAST\"\n  AbsoluteDirectionEAST -> \"EAST\"\n  AbsoluteDirectionSOUTHEAST -> \"SOUTHEAST\"\n  AbsoluteDirectionSOUTH -> \"SOUTH\"\n  AbsoluteDirectionSOUTHWEST -> \"SOUTHWEST\"\n  AbsoluteDirectionWEST -> \"WEST\"\n  AbsoluteDirectionNORTHWEST -> \"NORTHWEST\"\n\ntextToDirection :: Text -> Maybe AbsoluteDirection\ntextToDirection = \\case\n  \"NORTH\" -> Just AbsoluteDirectionNORTH\n  \"NORTHEAST\" -> Just AbsoluteDirectionNORTHEAST\n  \"EAST\" -> Just AbsoluteDirectionEAST\n  \"SOUTHEAST\" -> Just AbsoluteDirectionSOUTHEAST\n  \"SOUTH\" -> Just AbsoluteDirectionSOUTH\n  \"SOUTHWEST\" -> Just AbsoluteDirectionSOUTHWEST\n  \"WEST\" -> Just AbsoluteDirectionWEST\n  \"NORTHWEST\" -> Just AbsoluteDirectionNORTHWEST\n  _ -> Nothing\n\ninstance HasSqlValueSyntax be Text => HasSqlValueSyntax be AbsoluteDirection where\n  sqlValueSyntax = sqlValueSyntax . directionToText\n\ninstance FromBackendRow Postgres AbsoluteDirection where\n  fromBackendRow = do\n    txt <- fromBackendRow\n    case textToDirection txt of\n      Just d -> pure d\n      Nothing -> fail $ \"Invalid AbsoluteDirection value in DB: \" ++ T.unpack txt\n\ninstance BeamSqlBackend be => B.HasSqlEqualityCheck be AbsoluteDirection\n",
      "hash": "7dad6ad8c794b2fd2dc779b360209548b971d2504ddb54caae60976465ad52a4",
      "size": 23669
    },
    "/lib/mobility-core/auto-generated/Kernel/External/MultiModal/OpenTripPlanner/query-2.gql": {
      "type": "content",
      "content": "query MultiModePlan(\n  $from: InputCoordinates!,\n  $to: InputCoordinates!,\n  $date: String,\n  $time: String,\n  $metroTransportModes: [TransportMode]!,\n  $metroItineraries: Int!\n  $subwayTransportModes: [TransportMode]!,\n  $subwayItineraries: Int!\n  $busTransportModes: [TransportMode]!,\n  $busItineraries: Int!\n  $bestTransportModes: [TransportMode]!,\n  $bestItineraries: Int!\n) {\n  metro: plan(\n    from: $from,\n    to:   $to,\n    date: $date,\n    time: $time,\n    transportModes: $metroTransportModes,\n    numItineraries: $metroItineraries\n  ) {\n    itineraries { ...ItineraryFields }\n  }\n  subway: plan(\n    from: $from,\n    to:   $to,\n    date: $date,\n    time: $time,\n    transportModes: $subwayTransportModes,\n    numItineraries: $subwayItineraries\n  ) {\n    itineraries { ...ItineraryFields }\n  }\n  bus: plan(\n    from: $from,\n    to:   $to,\n    date: $date,\n    time: $time,\n    transportModes: $busTransportModes,\n    numItineraries: $busItineraries\n  ) {\n    itineraries { ...ItineraryFields }\n  }\n  best: plan(\n    from: $from,\n    to:   $to,\n    date: $date,\n    time: $time,\n    transportModes: $bestTransportModes,\n    numItineraries: $bestItineraries\n  ) {\n    itineraries { ...ItineraryFields }\n  }\n}\n\nfragment ItineraryFields on Itinerary {\n  duration\n  startTime\n  endTime\n  legs {\n    pickupType\n    distance\n    mode\n    entrance {\n      distance\n      lon\n      lat\n      relativeDirection\n      absoluteDirection\n      streetName\n      exit\n      stayOn\n      area\n      bogusName\n      walkingBike\n    }\n    exit {\n      distance\n      lon\n      lat\n      relativeDirection\n      absoluteDirection\n      streetName\n      exit\n      stayOn\n      area\n      bogusName\n      walkingBike\n    }\n    duration\n    startTime\n    endTime\n    from {\n      name\n      lat\n      lon\n      departureTime\n      arrivalTime\n      stop {\n        code\n        gtfsId\n        platformCode\n      }\n    }\n    to {\n      name\n      lat\n      lon\n      departureTime\n      arrivalTime\n      stop {\n        code\n        gtfsId\n        platformCode\n      }\n    }\n    route {\n      gtfsId\n      longName\n      trips {\n        gtfsId\n      }\n      shortName\n      color\n      agency {\n        gtfsId\n        name\n      }\n    }\n    legGeometry {\n      points\n    }\n    fareProducts {\n      id\n    }\n  }\n}\n",
      "hash": "8bd0e463209945bd68fd003a085743a4e3ef8968641ec75917e433d12867d588",
      "size": 2301
    },
    "/lib/mobility-core/auto-generated/Kernel/External/MultiModal/OpenTripPlanner/query.gql": {
      "type": "content",
      "content": "query OTPPlan (\n    $from: InputCoordinates!,\n    $to: InputCoordinates!,\n    $date: String,\n    $time:String,\n    $transportModes: [TransportMode],\n    $numItineraries: Int\n){\n  plan(\n    from: $from,\n    to: $to,\n    date: $date,\n    time: $time,\n    transportModes: $transportModes,\n    numItineraries : $numItineraries\n  ) {\n    itineraries {\n      duration\n      startTime\n      endTime\n      legs {\n        pickupType\n        distance\n        mode\n        entrance {\n          distance\n          lon\n          lat\n          relativeDirection\n          absoluteDirection\n          streetName\n          exit\n          stayOn\n          area\n          bogusName\n          walkingBike\n        }\n        exit {\n          distance\n          lon\n          lat\n          relativeDirection\n          absoluteDirection\n          streetName\n          exit\n          stayOn\n          area\n          bogusName\n          walkingBike\n        }\n        duration\n        startTime\n        endTime\n        from {\n          name\n          lat\n          lon\n          departureTime\n          arrivalTime\n          stop {\n            code\n            gtfsId\n            platformCode\n          }\n        }\n        to {\n          name\n          lat\n          lon\n          departureTime\n          arrivalTime\n          stop {\n            code\n            gtfsId\n            platformCode\n          }\n        }\n        route {\n          gtfsId\n          longName\n          trips {\n            gtfsId\n          }\n          shortName\n          color\n          agency {\n            gtfsId\n            name\n          }\n        }\n        legGeometry {\n          points\n        }\n        fareProducts {\n          id\n        }\n      }\n    }\n  }\n}\n",
      "hash": "581feaa307e949659083554f53c010d88eb9b6e2a5e9bfced06a63f96bae5df8",
      "size": 1720
    },
    "/lib/mobility-core/auto-generated/Kernel/External/MultiModal/OpenTripPlanner/schema.gql": {
      "type": "content",
      "content": "input InputCoordinates\n {\n  lat: Float!\n  lon: Float!\n}\n\ninput TransportMode {\n  mode: String!\n}\n\ntype Plan {\n  itineraries: [Itinerary]!\n}\n\ntype Itinerary {\n  duration: Float\n  startTime: Float\n  endTime: Float\n  legs: [Leg]!\n}\n\nenum Mode {\n    AIRPLANE\n    BICYCLE\n    BUS\n    CABLE_CAR\n    CAR\n    COACH\n    FERRY\n    FLEX\n    FUNICULAR\n    GONDOLA\n    RAIL\n    SCOOTER\n    SUBWAY\n    TRAM\n    CARPOOL\n    TAXI\n    TRANSIT\n    WALK\n    TROLLEYBUS\n    MONORAIL\n}\n\ntype step {\n    distance: Float\n    lon: Float\n    lat: Float\n    relativeDirection: RelativeDirection\n    absoluteDirection: AbsoluteDirection\n    streetName: String\n    exit: String\n    stayOn: Boolean\n    area: Boolean\n    bogusName: Boolean\n    walkingBike: Boolean\n}\n\ntype Leg {\n  distance: Float\n  duration: Float\n  legGeometry: Geometry\n  entrance: step\n  exit: step\n  mode: Mode\n  startTime: Float\n  pickupType: String\n  endTime: Float\n  fareProducts: [FareProductUse]\n  from: Place!\n  to: Place!\n  route: Route\n}\n\ntype Geometry {\n  points: String\n}\n\ntype FareProductUse {\n  id: String!\n  product: FareProduct\n}\n\ntype FareProduct {\n  id: String!\n  name: String!\n}\n\ntype Place {\n  name: String\n  lat: Float!\n  lon: Float!\n  departureTime: Float!\n  arrivalTime: Float!\n  stop : Stop\n}\n\ntype Route {\n  agency: Agency\n  gtfsId: String!\n  longName: String\n  shortName: String\n  color: String\n  trips: [Trip]\n}\n\ntype Trip {\n  gtfsId: String!\n}\n\ntype Agency {\n  name: String!\n  gtfsId: String!\n}\n\ntype Stop {\n  gtfsId: String!\n  code: String\n  platformCode: String\n}\n\nenum RelativeDirection {\n  DEPART\n  HARD_LEFT\n  LEFT\n  SLIGHTLY_LEFT\n  CONTINUE\n  SLIGHTLY_RIGHT\n  RIGHT\n  HARD_RIGHT\n  CIRCLE_CLOCKWISE\n  CIRCLE_COUNTERCLOCKWISE\n  ELEVATOR\n  UTURN_LEFT\n  UTURN_RIGHT\n  ENTER_STATION\n  EXIT_STATION\n  FOLLOW_SIGNS\n}\n\nenum AbsoluteDirection {\n  NORTH\n  NORTHEAST\n  EAST\n  SOUTHEAST\n  SOUTH\n  SOUTHWEST\n  WEST\n  NORTHWEST\n}\n\ntype Query {\n  plan(\n    from: InputCoordinates!\n    to: InputCoordinates!\n    transportModes: [TransportMode]\n    date: String\n    time: String\n    numItineraries: Int\n  ): Plan!\n}\n",
      "hash": "978129ff6d76bb942249e49c8cdb3a7bfad1cedf93602a11e8e9809918824ef4",
      "size": 2073
    },
    "/lib/mobility-core/mobility-core.cabal": {
      "type": "content",
      "content": "cabal-version: 1.12\n\n-- This file has been generated from package.yaml by hpack version 0.35.2.\n--\n-- see: https://github.com/sol/hpack\n\nname:           mobility-core\nversion:        0.1.0.0\ndescription:    Please see the README on GitHub at <https://github.com/nammayatri/shared-kernel/blob/main/README.md>\nhomepage:       https://github.com/nammayatri/shared-kernel#readme\nbug-reports:    https://github.com/nammayatri/shared-kernel/issues\nauthor:         nammayatri\nmaintainer:     nammayatri\ncopyright:      nammayatri.in\nlicense:        AGPL\nbuild-type:     Simple\n\nsource-repository head\n  type: git\n  location: https://github.com/nammayatri/shared-kernel\n\nlibrary\n  exposed-modules:\n      Kernel.Beam.Connection.EnvVars\n      Kernel.Beam.Connection.Flow\n      Kernel.Beam.Connection.Postgres\n      Kernel.Beam.Connection.Redis\n      Kernel.Beam.Connection.Types\n      Kernel.Beam.Functions\n      Kernel.Beam.Lib.SqlObjectInstances\n      Kernel.Beam.Lib.Utils\n      Kernel.Beam.Lib.UtilsTH\n      Kernel.Beam.Types\n      Kernel.Exit\n      Kernel.External.AadhaarVerification\n      Kernel.External.AadhaarVerification.Gridline.API\n      Kernel.External.AadhaarVerification.Gridline.Client\n      Kernel.External.AadhaarVerification.Gridline.Config\n      Kernel.External.AadhaarVerification.Gridline.Error\n      Kernel.External.AadhaarVerification.Gridline.Types\n      Kernel.External.AadhaarVerification.Interface\n      Kernel.External.AadhaarVerification.Interface.Gridline\n      Kernel.External.AadhaarVerification.Interface.Types\n      Kernel.External.AadhaarVerification.Types\n      Kernel.External.BackgroundVerification\n      Kernel.External.BackgroundVerification.Checkr.Config\n      Kernel.External.BackgroundVerification.Checkr.Error\n      Kernel.External.BackgroundVerification.Checkr.Flow\n      Kernel.External.BackgroundVerification.Checkr.Types\n      Kernel.External.BackgroundVerification.Interface\n      Kernel.External.BackgroundVerification.Interface.Checkr\n      Kernel.External.BackgroundVerification.Interface.Types\n      Kernel.External.BackgroundVerification.Types\n      Kernel.External.Call\n      Kernel.External.Call.Exotel.Client\n      Kernel.External.Call.Exotel.Config\n      Kernel.External.Call.Exotel.Types\n      Kernel.External.Call.Interface\n      Kernel.External.Call.Interface.Exotel\n      Kernel.External.Call.Interface.TataClickToCall\n      Kernel.External.Call.Interface.Types\n      Kernel.External.Call.TataClickToCall.Client\n      Kernel.External.Call.TataClickToCall.Config\n      Kernel.External.Call.TataClickToCall.Types\n      Kernel.External.Call.Twillio.Config\n      Kernel.External.Call.Types\n      Kernel.External.Encryption\n      Kernel.External.GoogleTranslate.API\n      Kernel.External.GoogleTranslate.Client\n      Kernel.External.GoogleTranslate.Types\n      Kernel.External.IncidentReport\n      Kernel.External.IncidentReport.ERSS.Config\n      Kernel.External.IncidentReport.ERSS.Flow\n      Kernel.External.IncidentReport.ERSS.Types\n      Kernel.External.IncidentReport.Interface\n      Kernel.External.IncidentReport.Interface.Error\n      Kernel.External.IncidentReport.Interface.ERSS\n      Kernel.External.IncidentReport.Interface.Types\n      Kernel.External.IncidentReport.Types\n      Kernel.External.Infobip.API.SendSms\n      Kernel.External.Infobip.API.WebengageWebhook\n      Kernel.External.Infobip.Flow\n      Kernel.External.Infobip.Types\n      Kernel.External.Insurance.Acko.Flow\n      Kernel.External.Insurance.Acko.Types\n      Kernel.External.Insurance.Interface\n      Kernel.External.Insurance.Interface.Acko\n      Kernel.External.Insurance.Interface.Types\n      Kernel.External.Insurance.Types\n      Kernel.External.Maps\n      Kernel.External.Maps.Google.Config\n      Kernel.External.Maps.Google.MapsClient\n      Kernel.External.Maps.Google.MapsClient.Types\n      Kernel.External.Maps.Google.PolyLinePoints\n      Kernel.External.Maps.Google.RoadsClient\n      Kernel.External.Maps.HasCoordinates\n      Kernel.External.Maps.Interface\n      Kernel.External.Maps.Interface.Google\n      Kernel.External.Maps.Interface.MMI\n      Kernel.External.Maps.Interface.NextBillion\n      Kernel.External.Maps.Interface.OSRM\n      Kernel.External.Maps.Interface.Types\n      Kernel.External.Maps.MMI.AutoSuggest\n      Kernel.External.Maps.MMI.Config\n      Kernel.External.Maps.MMI.DistanceMatrix\n      Kernel.External.Maps.MMI.Geocode\n      Kernel.External.Maps.MMI.MMIAuthToken\n      Kernel.External.Maps.MMI.PlaceDetails\n      Kernel.External.Maps.MMI.ReverseGeocoding\n      Kernel.External.Maps.MMI.Routes\n      Kernel.External.Maps.MMI.SnapToRoad\n      Kernel.External.Maps.MMI.Types\n      Kernel.External.Maps.NextBillion.Config\n      Kernel.External.Maps.NextBillion.Route\n      Kernel.External.Maps.NextBillion.Types\n      Kernel.External.Maps.OSRM.Config\n      Kernel.External.Maps.OSRM.RoadsClient\n      Kernel.External.Maps.Types\n      Kernel.External.Maps.Utils\n      Kernel.External.MultiModal\n      Kernel.External.MultiModal.Interface\n      Kernel.External.MultiModal.Interface.Google\n      Kernel.External.MultiModal.Interface.OpenTripPlanner\n      Kernel.External.MultiModal.Interface.Types\n      Kernel.External.MultiModal.OpenTripPlanner.Config\n      Kernel.External.MultiModal.Types\n      Kernel.External.MultiModal.Utils\n      Kernel.External.Notification\n      Kernel.External.Notification.FCM.Error\n      Kernel.External.Notification.FCM.Flow\n      Kernel.External.Notification.FCM.Types\n      Kernel.External.Notification.GRPC.Flow\n      Kernel.External.Notification.GRPC.Types\n      Kernel.External.Notification.Interface\n      Kernel.External.Notification.Interface.FCM\n      Kernel.External.Notification.Interface.GRPC\n      Kernel.External.Notification.Interface.PayTM\n      Kernel.External.Notification.Interface.Types\n      Kernel.External.Notification.PayTM.API\n      Kernel.External.Notification.PayTM.Client\n      Kernel.External.Notification.PayTM.Types\n      Kernel.External.Notification.Types\n      Kernel.External.Payment.Interface\n      Kernel.External.Payment.Interface.Juspay\n      Kernel.External.Payment.Interface.Stripe\n      Kernel.External.Payment.Interface.Types\n      Kernel.External.Payment.Juspay.Config\n      Kernel.External.Payment.Juspay.Flow\n      Kernel.External.Payment.Juspay.Types\n      Kernel.External.Payment.Juspay.Types.Common\n      Kernel.External.Payment.Juspay.Types.CreateCustomer\n      Kernel.External.Payment.Juspay.Types.CreateOrder\n      Kernel.External.Payment.Juspay.Types.Mandate\n      Kernel.External.Payment.Juspay.Types.Offer\n      Kernel.External.Payment.Juspay.Types.UpdateOrder\n      Kernel.External.Payment.Juspay.Types.Webhook\n      Kernel.External.Payment.Juspay.Webhook\n      Kernel.External.Payment.Stripe.Config\n      Kernel.External.Payment.Stripe.Flow\n      Kernel.External.Payment.Stripe.Types\n      Kernel.External.Payment.Stripe.Types.Accounts\n      Kernel.External.Payment.Stripe.Types.Card\n      Kernel.External.Payment.Stripe.Types.Common\n      Kernel.External.Payment.Stripe.Types.Customer\n      Kernel.External.Payment.Stripe.Types.Error\n      Kernel.External.Payment.Stripe.Types.PaymentIntent\n      Kernel.External.Payment.Stripe.Types.SetupIntent\n      Kernel.External.Payment.Types\n      Kernel.External.Payout.Interface\n      Kernel.External.Payout.Interface.Juspay\n      Kernel.External.Payout.Interface.Types\n      Kernel.External.Payout.Juspay.Config\n      Kernel.External.Payout.Juspay.Flow\n      Kernel.External.Payout.Juspay.Types\n      Kernel.External.Payout.Juspay.Types.Payout\n      Kernel.External.Payout.Juspay.Types.Webhook\n      Kernel.External.Payout.Juspay.Webhook\n      Kernel.External.Payout.Types\n      Kernel.External.SharedLogic.HyperVerge.Error\n      Kernel.External.SharedLogic.HyperVerge.Functions\n      Kernel.External.Slack.Flow\n      Kernel.External.Slack.Types\n      Kernel.External.SMS\n      Kernel.External.SMS.DigoEngage.API\n      Kernel.External.SMS.DigoEngage.Config\n      Kernel.External.SMS.DigoEngage.Flow\n      Kernel.External.SMS.DigoEngage.Types\n      Kernel.External.SMS.ExotelSms.API\n      Kernel.External.SMS.ExotelSms.Config\n      Kernel.External.SMS.ExotelSms.Flow\n      Kernel.External.SMS.ExotelSms.Types\n      Kernel.External.SMS.GupShup.API\n      Kernel.External.SMS.GupShup.Config\n      Kernel.External.SMS.GupShup.Flow\n      Kernel.External.SMS.GupShup.Types\n      Kernel.External.SMS.Interface\n      Kernel.External.SMS.Interface.DigoEngageSms\n      Kernel.External.SMS.Interface.ExotelSms\n      Kernel.External.SMS.Interface.GupShup\n      Kernel.External.SMS.Interface.MyValueFirst\n      Kernel.External.SMS.Interface.TwillioSms\n      Kernel.External.SMS.Interface.Types\n      Kernel.External.SMS.MyValueFirst.API\n      Kernel.External.SMS.MyValueFirst.Config\n      Kernel.External.SMS.MyValueFirst.Flow\n      Kernel.External.SMS.MyValueFirst.Types\n      Kernel.External.SMS.TwillioSms.API\n      Kernel.External.SMS.TwillioSms.Config\n      Kernel.External.SMS.TwillioSms.Flow\n      Kernel.External.SMS.TwillioSms.Types\n      Kernel.External.SMS.Types\n      Kernel.External.Ticket.Interface\n      Kernel.External.Ticket.Interface.Kapture\n      Kernel.External.Ticket.Interface.Types\n      Kernel.External.Ticket.Kapture.Config\n      Kernel.External.Ticket.Kapture.Flow\n      Kernel.External.Ticket.Kapture.Types\n      Kernel.External.Ticket.Types\n      Kernel.External.Tokenize\n      Kernel.External.Tokenize.Gullak.Flow\n      Kernel.External.Tokenize.Gullak.Types\n      Kernel.External.Tokenize.HyperVerge.Flow\n      Kernel.External.Tokenize.HyperVerge.Types\n      Kernel.External.Tokenize.Interface\n      Kernel.External.Tokenize.Interface.Error\n      Kernel.External.Tokenize.Interface.Gullak\n      Kernel.External.Tokenize.Interface.HyperVerge\n      Kernel.External.Tokenize.Interface.JourneyMonitoring\n      Kernel.External.Tokenize.Interface.Types\n      Kernel.External.Tokenize.JourneyMonitoring.Error\n      Kernel.External.Tokenize.JourneyMonitoring.Flow\n      Kernel.External.Tokenize.JourneyMonitoring.Types\n      Kernel.External.Tokenize.Types\n      Kernel.External.Types\n      Kernel.External.Verification\n      Kernel.External.Verification.GovtData.Client\n      Kernel.External.Verification.GovtData.Storage.Beam\n      Kernel.External.Verification.GovtData.Storage.Query\n      Kernel.External.Verification.GovtData.Types\n      Kernel.External.Verification.HyperVerge.Flow\n      Kernel.External.Verification.HyperVerge.Types\n      Kernel.External.Verification.Idfy.Auth\n      Kernel.External.Verification.Idfy.Client\n      Kernel.External.Verification.Idfy.Config\n      Kernel.External.Verification.Idfy.Flow\n      Kernel.External.Verification.Idfy.Types\n      Kernel.External.Verification.Idfy.Types.Error\n      Kernel.External.Verification.Idfy.Types.Request\n      Kernel.External.Verification.Idfy.Types.Response\n      Kernel.External.Verification.Idfy.WebhookHandler\n      Kernel.External.Verification.Interface\n      Kernel.External.Verification.Interface.HyperVerge\n      Kernel.External.Verification.Interface.Idfy\n      Kernel.External.Verification.Interface.InternalScripts\n      Kernel.External.Verification.Interface.SafetyPortal\n      Kernel.External.Verification.Interface.Types\n      Kernel.External.Verification.InternalScripts.Error\n      Kernel.External.Verification.InternalScripts.FaceVerification\n      Kernel.External.Verification.InternalScripts.Types\n      Kernel.External.Verification.SafetyPortal.API\n      Kernel.External.Verification.SafetyPortal.Client\n      Kernel.External.Verification.SafetyPortal.Config\n      Kernel.External.Verification.SafetyPortal.Error\n      Kernel.External.Verification.SafetyPortal.Types\n      Kernel.External.Verification.Types\n      Kernel.External.Whatsapp.GupShup.Config\n      Kernel.External.Whatsapp.GupShup.Flow\n      Kernel.External.Whatsapp.GupShup.Types\n      Kernel.External.Whatsapp.Interface\n      Kernel.External.Whatsapp.Interface.GupShup\n      Kernel.External.Whatsapp.Interface.TataCommunications\n      Kernel.External.Whatsapp.Interface.Types\n      Kernel.External.Whatsapp.TataCommunications.Config\n      Kernel.External.Whatsapp.TataCommunications.Flow\n      Kernel.External.Whatsapp.TataCommunications.Types\n      Kernel.External.Whatsapp.Types\n      Kernel.InternalAPI.Auth.API\n      Kernel.InternalAPI.Auth.Client\n      Kernel.Mock.App\n      Kernel.Mock.Exceptions\n      Kernel.Mock.ExternalAPI\n      Kernel.Mock.Utils\n      Kernel.Prelude\n      Kernel.Prelude.OrphanInstances\n      Kernel.Product.Validation.Context\n      Kernel.Randomizer\n      Kernel.ServantMultipart\n      Kernel.Serviceability\n      Kernel.Sms.Config\n      Kernel.Storage.Beam.BecknRequest\n      Kernel.Storage.Beam.SystemConfigs\n      Kernel.Storage.Clickhouse.Config\n      Kernel.Storage.Clickhouse.Operators\n      Kernel.Storage.Clickhouse.Queries\n      Kernel.Storage.Clickhouse.Types\n      Kernel.Storage.ClickhouseV2\n      Kernel.Storage.ClickhouseV2.ClickhouseDb\n      Kernel.Storage.ClickhouseV2.ClickhouseTable\n      Kernel.Storage.ClickhouseV2.ClickhouseValue\n      Kernel.Storage.ClickhouseV2.Internal.ClickhouseColumns\n      Kernel.Storage.ClickhouseV2.Internal.ClickhouseQuery\n      Kernel.Storage.ClickhouseV2.Internal.Types\n      Kernel.Storage.ClickhouseV2.Operators\n      Kernel.Storage.ClickhouseV2.Queries\n      Kernel.Storage.ClickhouseV2.UtilsTH\n      Kernel.Storage.Esqueleto\n      Kernel.Storage.Esqueleto.Class\n      Kernel.Storage.Esqueleto.Config\n      Kernel.Storage.Esqueleto.DTypeBuilder\n      Kernel.Storage.Esqueleto.Functions\n      Kernel.Storage.Esqueleto.Logger\n      Kernel.Storage.Esqueleto.Migration\n      Kernel.Storage.Esqueleto.Queries\n      Kernel.Storage.Esqueleto.SqlDB\n      Kernel.Storage.Esqueleto.Transactionable\n      Kernel.Storage.Esqueleto.Types\n      Kernel.Storage.Hedis\n      Kernel.Storage.Hedis.AppPrefixes\n      Kernel.Storage.Hedis.Config\n      Kernel.Storage.Hedis.Error\n      Kernel.Storage.Hedis.Queries\n      Kernel.Storage.Queries.BecknRequest\n      Kernel.Storage.Queries.SystemConfigs\n      Kernel.Streaming.Kafka.Commons\n      Kernel.Streaming.Kafka.Consumer\n      Kernel.Streaming.Kafka.Consumer.Types\n      Kernel.Streaming.Kafka.HasKafkaTopics\n      Kernel.Streaming.Kafka.Producer\n      Kernel.Streaming.Kafka.Producer.Types\n      Kernel.Streaming.Kafka.Topic.BusinessEvent\n      Kernel.Streaming.Kafka.Topic.BusinessEvent.Environment\n      Kernel.Streaming.Kafka.Topic.BusinessEvent.Functions\n      Kernel.Streaming.Kafka.Topic.BusinessEvent.Types\n      Kernel.Streaming.Kafka.Topic.PublicTransportQuoteList\n      Kernel.Streaming.Kafka.Topic.PublicTransportQuoteList.Functions\n      Kernel.Streaming.Kafka.Topic.PublicTransportQuoteList.Types\n      Kernel.Streaming.Kafka.Topic.PublicTransportSearch\n      Kernel.Streaming.Kafka.Topic.PublicTransportSearch.Functions\n      Kernel.Streaming.Kafka.Topic.PublicTransportSearch.Types\n      Kernel.Streaming.MonadConsumer\n      Kernel.Streaming.MonadProducer\n      Kernel.Tools.ARTUtils\n      Kernel.Tools.Logging\n      Kernel.Tools.LoopGracefully\n      Kernel.Tools.Metrics.AppMetrics\n      Kernel.Tools.Metrics.CoreMetrics\n      Kernel.Tools.Metrics.CoreMetrics.Types\n      Kernel.Tools.Metrics.Init\n      Kernel.Tools.Slack\n      Kernel.Tools.Slack.Internal\n      Kernel.Tools.Slack.Middleware\n      Kernel.Tools.SystemEnv\n      Kernel.Types.APISuccess\n      Kernel.Types.App\n      Kernel.Types.Base64\n      Kernel.Types.Beckn.Ack\n      Kernel.Types.Beckn.City\n      Kernel.Types.Beckn.Context\n      Kernel.Types.Beckn.Country\n      Kernel.Types.Beckn.DecimalValue\n      Kernel.Types.Beckn.Domain\n      Kernel.Types.Beckn.Error\n      Kernel.Types.Beckn.Gps\n      Kernel.Types.Beckn.IndianState\n      Kernel.Types.Beckn.ReqTypes\n      Kernel.Types.BecknRequest\n      Kernel.Types.Cac\n      Kernel.Types.Cache\n      Kernel.Types.CacheFlow\n      Kernel.Types.Centesimal\n      Kernel.Types.Common\n      Kernel.Types.Confidence\n      Kernel.Types.Credentials\n      Kernel.Types.Distance\n      Kernel.Types.Documents\n      Kernel.Types.Error\n      Kernel.Types.Error.BaseError\n      Kernel.Types.Error.BaseError.HTTPError\n      Kernel.Types.Error.BaseError.HTTPError.APIError\n      Kernel.Types.Error.BaseError.HTTPError.BecknAPIError\n      Kernel.Types.Error.BaseError.HTTPError.CallAPIError\n      Kernel.Types.Error.BaseError.HTTPError.FromResponse\n      Kernel.Types.Error.BaseError.HTTPError.HttpCode\n      Kernel.Types.Field\n      Kernel.Types.Flow\n      Kernel.Types.Forkable\n      Kernel.Types.FromField\n      Kernel.Types.Geofencing\n      Kernel.Types.GuidLike\n      Kernel.Types.HideSecrets\n      Kernel.Types.Id\n      Kernel.Types.Logging\n      Kernel.Types.MonadGuid\n      Kernel.Types.Predicate\n      Kernel.Types.Price\n      Kernel.Types.Registry\n      Kernel.Types.Registry.API\n      Kernel.Types.Registry.Routes\n      Kernel.Types.Registry.Subscriber\n      Kernel.Types.Servant\n      Kernel.Types.SharedRedisKeys\n      Kernel.Types.SlidingWindowCounters\n      Kernel.Types.SlidingWindowLimiter\n      Kernel.Types.SystemConfigs\n      Kernel.Types.Time\n      Kernel.Types.TimeBound\n      Kernel.Types.TimeRFC339\n      Kernel.Types.Validation\n      Kernel.Types.Value\n      Kernel.Types.Version\n      Kernel.Utils.App\n      Kernel.Utils.CalculateDistance\n      Kernel.Utils.Callback\n      Kernel.Utils.Common\n      Kernel.Utils.ComputeIntersection\n      Kernel.Utils.Context\n      Kernel.Utils.DatastoreLatencyCalculator\n      Kernel.Utils.Dhall\n      Kernel.Utils.Error\n      Kernel.Utils.Error.BaseError.HTTPError.APIError\n      Kernel.Utils.Error.BaseError.HTTPError.BecknAPIError\n      Kernel.Utils.Error.DB\n      Kernel.Utils.Error.FlowHandling\n      Kernel.Utils.Error.Hierarchy\n      Kernel.Utils.Error.Throwing\n      Kernel.Utils.Example\n      Kernel.Utils.ExternalAPICallLogging\n      Kernel.Utils.FlowLogging\n      Kernel.Utils.GenericPretty\n      Kernel.Utils.Geometry\n      Kernel.Utils.IOLogging\n      Kernel.Utils.JSON\n      Kernel.Utils.JWT\n      Kernel.Utils.Logging\n      Kernel.Utils.Monitoring.Prometheus.Servant\n      Kernel.Utils.NonEmpty\n      Kernel.Utils.Predicates\n      Kernel.Utils.Registry\n      Kernel.Utils.Schema\n      Kernel.Utils.Servant.API\n      Kernel.Utils.Servant.BaseUrl\n      Kernel.Utils.Servant.BasicAuth\n      Kernel.Utils.Servant.Client\n      Kernel.Utils.Servant.HeaderAuth\n      Kernel.Utils.Servant.HTML\n      Kernel.Utils.Servant.JSONBS\n      Kernel.Utils.Servant.Server\n      Kernel.Utils.Servant.SignatureAuth\n      Kernel.Utils.Service\n      Kernel.Utils.Shutdown\n      Kernel.Utils.SignatureAuth\n      Kernel.Utils.SlidingWindowCounters\n      Kernel.Utils.SlidingWindowLimiter\n      Kernel.Utils.Text\n      Kernel.Utils.TH\n      Kernel.Utils.Time\n      Kernel.Utils.Validation\n      Kernel.Utils.Version\n      Kernel.Utils.XML\n      Kernel.External.MultiModal.OpenTripPlanner.Types\n  other-modules:\n      Paths_mobility_core\n  hs-source-dirs:\n      src\n      auto-generated\n  default-extensions:\n      ConstraintKinds\n      DataKinds\n      DefaultSignatures\n      DeriveAnyClass\n      DeriveFunctor\n      DeriveGeneric\n      DuplicateRecordFields\n      ExplicitNamespaces\n      FlexibleContexts\n      FlexibleInstances\n      FunctionalDependencies\n      GADTs\n      LambdaCase\n      MultiParamTypeClasses\n      MultiWayIf\n      NamedFieldPuns\n      NoImplicitPrelude\n      OverloadedLabels\n      OverloadedStrings\n      PatternSynonyms\n      PolyKinds\n      RankNTypes\n      RecordWildCards\n      ScopedTypeVariables\n      TupleSections\n      TypeApplications\n      TypeFamilies\n      TypeOperators\n      ViewPatterns\n      BlockArguments\n      TypeSynonymInstances\n      UndecidableInstances\n  ghc-options: -fwrite-ide-info -hiedir=.hie -Wall -Wcompat -Widentities -fhide-source-paths -Werror -fplugin=RecordDotPreprocessor -Wwarn=ambiguous-fields\n  build-depends:\n      aeson\n    , aeson-casing\n    , base >=4.7 && <5\n    , base64\n    , base64-bytestring\n    , beam-core\n    , beam-mysql\n    , beam-postgres\n    , bytestring\n    , case-insensitive\n    , casing\n    , cereal\n    , clickhouse-haskell\n    , clock\n    , concurrency\n    , containers\n    , cryptonite\n    , data-default-class\n    , deriving-aeson\n    , dhall\n    , directory\n    , double-conversion\n    , either\n    , esqueleto\n    , euler-hs\n    , exceptions\n    , extra\n    , fast-logger\n    , filepath\n    , fmt\n    , formatting\n    , generic-lens\n    , geojson\n    , hashable\n    , hedis\n    , hex-text\n    , hspec\n    , http-api-data\n    , http-client\n    , http-client-tls\n    , http-media\n    , http-types\n    , hw-kafka-client\n    , insert-ordered-containers\n    , jwt\n    , kleene\n    , lattices\n    , lens\n    , memory\n    , monad-logger\n    , morpheus-graphql-client\n    , mtl\n    , network\n    , openapi3\n    , parsec\n    , passetto-client\n    , persistent\n    , persistent-postgresql\n    , postgresql-migration\n    , postgresql-simple\n    , process\n    , prometheus-client\n    , prometheus-metrics-ghc\n    , prometheus-proc\n    , random\n    , random-strings\n    , record-dot-preprocessor\n    , record-hasfield\n    , regex-compat\n    , resource-pool\n    , safe\n    , safe-exceptions\n    , safe-money\n    , scientific\n    , sequelize\n    , servant\n    , servant-client\n    , servant-client-core\n    , servant-multipart\n    , servant-multipart-api\n    , servant-multipart-client\n    , servant-openapi3\n    , servant-server\n    , singletons-th\n    , slack-web\n    , split\n    , stm\n    , string-conversions\n    , tasty\n    , tasty-hunit\n    , template-haskell\n    , text\n    , text-conversions\n    , time\n    , tinylog\n    , transformers\n    , universum\n    , unix\n    , unliftio\n    , unliftio-core\n    , unordered-containers\n    , uuid\n    , vector\n    , wai\n    , wai-app-static\n    , wai-middleware-prometheus\n    , warp\n    , xmlbf\n  default-language: Haskell2010\n\ntest-suite mobility-core-tests\n  type: exitcode-stdio-1.0\n  main-is: Main.hs\n  other-modules:\n      APIExceptions\n      Centesimal\n      ComputeIntersectionTests\n      DistanceCalculation\n      SignatureAuth\n      SlidingWindowLimiter\n      SnippetsCheck\n      TestSilentIOLogger\n      Utils.Numeric\n      Version\n      Paths_mobility_core\n  hs-source-dirs:\n      test/app\n      test/src\n  default-extensions:\n      ConstraintKinds\n      DataKinds\n      DefaultSignatures\n      DeriveAnyClass\n      DeriveFunctor\n      DeriveGeneric\n      DuplicateRecordFields\n      ExplicitNamespaces\n      FlexibleContexts\n      FlexibleInstances\n      FunctionalDependencies\n      GADTs\n      LambdaCase\n      MultiParamTypeClasses\n      MultiWayIf\n      NamedFieldPuns\n      NoImplicitPrelude\n      OverloadedLabels\n      OverloadedStrings\n      PatternSynonyms\n      PolyKinds\n      RankNTypes\n      RecordWildCards\n      ScopedTypeVariables\n      TupleSections\n      TypeApplications\n      TypeFamilies\n      TypeOperators\n      ViewPatterns\n      BlockArguments\n      TypeSynonymInstances\n      UndecidableInstances\n  ghc-options: -fwrite-ide-info -hiedir=.hie -Wall -Wcompat -Widentities -fhide-source-paths -Werror -fplugin=RecordDotPreprocessor -Wwarn=ambiguous-fields\n  build-depends:\n      aeson\n    , aeson-casing\n    , base >=4.7 && <5\n    , base64\n    , base64-bytestring\n    , beam-core\n    , beam-mysql\n    , beam-postgres\n    , bytestring\n    , case-insensitive\n    , casing\n    , cereal\n    , clickhouse-haskell\n    , clock\n    , concurrency\n    , containers\n    , cryptonite\n    , data-default-class\n    , deriving-aeson\n    , dhall\n    , directory\n    , double-conversion\n    , either\n    , esqueleto\n    , euler-hs\n    , exceptions\n    , extra\n    , fast-logger\n    , filepath\n    , fmt\n    , formatting\n    , generic-lens\n    , geojson\n    , hashable\n    , hedis\n    , hex-text\n    , hspec\n    , http-api-data\n    , http-client\n    , http-client-tls\n    , http-media\n    , http-types\n    , hw-kafka-client\n    , insert-ordered-containers\n    , jwt\n    , kleene\n    , lattices\n    , lens\n    , memory\n    , mobility-core\n    , monad-logger\n    , morpheus-graphql-client\n    , mtl\n    , network\n    , openapi3\n    , parsec\n    , passetto-client\n    , persistent\n    , persistent-postgresql\n    , postgresql-migration\n    , postgresql-simple\n    , process\n    , prometheus-client\n    , prometheus-metrics-ghc\n    , prometheus-proc\n    , random\n    , random-strings\n    , record-dot-preprocessor\n    , record-hasfield\n    , regex-compat\n    , resource-pool\n    , safe\n    , safe-exceptions\n    , safe-money\n    , scientific\n    , sequelize\n    , servant\n    , servant-client\n    , servant-client-core\n    , servant-multipart\n    , servant-multipart-api\n    , servant-multipart-client\n    , servant-openapi3\n    , servant-server\n    , singletons-th\n    , slack-web\n    , split\n    , stm\n    , string-conversions\n    , tasty\n    , tasty-hunit\n    , template-haskell\n    , text\n    , text-conversions\n    , time\n    , tinylog\n    , transformers\n    , universum\n    , unix\n    , unliftio\n    , unliftio-core\n    , unordered-containers\n    , uuid\n    , vector\n    , wai\n    , wai-app-static\n    , wai-middleware-prometheus\n    , warp\n    , xmlbf\n  default-language: Haskell2010\n",
      "hash": "c990349c24f25d22bdbe9eede83446dc9c095d068dc061bd7cabbc3737d0a726",
      "size": 25053
    },
    "/lib/mobility-core/package.yaml": {
      "type": "content",
      "content": "name: mobility-core\nversion: 0.1.0.0\ngithub: \"nammayatri/shared-kernel\" # update if needed\nlicense: AGPL\nauthor: \"nammayatri\"\nmaintainer: \"nammayatri\"\ncopyright: \"nammayatri.in\"\n\n# Metadata used when publishing your package\n# synopsis:            Short description of your package\n# category:            Web\n\n# To avoid duplicated efforts in documentation and dealing with the\n# complications of embedding Haddock markup inside cabal files, it is\n# common to point users to the README.md file.\ndescription: Please see the README on GitHub at <https://github.com/nammayatri/shared-kernel/blob/main/README.md> # insert github link\n\ndefault-extensions:\n  - ConstraintKinds\n  - DataKinds\n  - DefaultSignatures\n  - DeriveAnyClass\n  - DeriveFunctor\n  - DeriveGeneric\n  - DuplicateRecordFields\n  - ExplicitNamespaces\n  - FlexibleContexts\n  - FlexibleInstances\n  - FunctionalDependencies\n  - GADTs\n  - LambdaCase\n  - MultiParamTypeClasses\n  - MultiWayIf\n  - NamedFieldPuns\n  - NoImplicitPrelude\n  - OverloadedLabels\n  - OverloadedStrings\n  - PatternSynonyms\n  - PolyKinds\n  - RankNTypes\n  - RecordWildCards\n  - ScopedTypeVariables\n  - TupleSections\n  - TypeApplications\n  - TypeFamilies\n  - TypeOperators\n  - ViewPatterns\n  - BlockArguments\n  - TypeSynonymInstances\n  - UndecidableInstances\n\ndependencies:\n  - aeson\n  - aeson-casing\n  - base >= 4.7 && < 5\n  - bytestring\n  - clock\n  - case-insensitive\n  - containers\n  - cryptonite\n  - data-default-class\n  - double-conversion\n  - directory\n  - exceptions\n  - euler-hs\n  - formatting\n  - filepath\n  - hex-text\n  - hspec\n  - xmlbf\n  - http-api-data\n  - http-client\n  - regex-compat\n  - http-client-tls\n  - http-types\n  - http-media\n  - kleene\n  - lattices\n  - process\n  - postgresql-simple\n  - postgresql-migration\n  - prometheus-client\n  - prometheus-proc\n  - wai-middleware-prometheus\n  - prometheus-metrics-ghc\n  - jwt\n  - hashable\n  - lens\n  - memory\n  - morpheus-graphql-client\n  - network\n  - parsec\n  - passetto-client\n  - random-strings\n  - safe-exceptions\n  - servant\n  - servant-client\n  - servant-client-core\n  - servant-server\n  - servant-openapi3\n  - singletons-th\n  - text\n  - wai\n  - warp\n  - time\n  - template-haskell\n  - generic-lens\n  - base64-bytestring\n  - unordered-containers\n  - geojson\n  - safe-money\n  - dhall\n  - tasty\n  - tasty-hunit\n  - either\n  - mtl\n  - uuid\n  - stm\n  - unix\n  - record-hasfield\n  - record-dot-preprocessor\n  - openapi3\n  - fast-logger\n  - persistent\n  - persistent-postgresql\n  - esqueleto\n  - monad-logger\n  - unliftio-core\n  - resource-pool\n  - universum\n  - scientific\n  - vector\n  - unliftio\n  - string-conversions\n  - hedis\n  - transformers\n  - extra\n  - random\n  - hw-kafka-client\n  - fmt\n  - text-conversions\n  - deriving-aeson\n  - base64\n  - safe\n  - tinylog\n  - wai-app-static\n  - servant-multipart\n  - servant-multipart-api\n  - servant-multipart-client\n  - clickhouse-haskell\n  - beam-postgres\n  - beam-core\n  - cereal\n  - beam-mysql\n  - sequelize\n  - concurrency\n  - casing\n  - slack-web\n  - insert-ordered-containers\n  - split\n\nghc-options:\n  - -fwrite-ide-info\n  - -hiedir=.hie\n  - -Wall\n  - -Wcompat\n  - -Widentities\n  - -fhide-source-paths\n  - -Werror\n  - -fplugin=RecordDotPreprocessor\n  - -Wwarn=ambiguous-fields\n\nlibrary:\n  source-dirs:\n    - src\n    - auto-generated\n\ntests:\n  mobility-core-tests:\n    main: Main.hs\n    source-dirs:\n      - test/app\n      - test/src\n    dependencies:\n      - mobility-core\n",
      "hash": "04b9c8b535a3f7d1cf31b16caa4180736795ad53176cf71b2d03ad2eafdc9023",
      "size": 3415,
      "json": {
        "name": "mobility-core",
        "version": "0.1.0.0",
        "github": "nammayatri/shared-kernel",
        "license": "AGPL",
        "author": "nammayatri",
        "maintainer": "nammayatri",
        "copyright": "nammayatri.in",
        "description": "Please see the README on GitHub at <https://github.com/nammayatri/shared-kernel/blob/main/README.md>",
        "default-extensions": [
          "ConstraintKinds",
          "DataKinds",
          "DefaultSignatures",
          "DeriveAnyClass",
          "DeriveFunctor",
          "DeriveGeneric",
          "DuplicateRecordFields",
          "ExplicitNamespaces",
          "FlexibleContexts",
          "FlexibleInstances",
          "FunctionalDependencies",
          "GADTs",
          "LambdaCase",
          "MultiParamTypeClasses",
          "MultiWayIf",
          "NamedFieldPuns",
          "NoImplicitPrelude",
          "OverloadedLabels",
          "OverloadedStrings",
          "PatternSynonyms",
          "PolyKinds",
          "RankNTypes",
          "RecordWildCards",
          "ScopedTypeVariables",
          "TupleSections",
          "TypeApplications",
          "TypeFamilies",
          "TypeOperators",
          "ViewPatterns",
          "BlockArguments",
          "TypeSynonymInstances",
          "UndecidableInstances"
        ],
        "dependencies": [
          "aeson",
          "aeson-casing",
          "base >= 4.7 && < 5",
          "bytestring",
          "clock",
          "case-insensitive",
          "containers",
          "cryptonite",
          "data-default-class",
          "double-conversion",
          "directory",
          "exceptions",
          "euler-hs",
          "formatting",
          "filepath",
          "hex-text",
          "hspec",
          "xmlbf",
          "http-api-data",
          "http-client",
          "regex-compat",
          "http-client-tls",
          "http-types",
          "http-media",
          "kleene",
          "lattices",
          "process",
          "postgresql-simple",
          "postgresql-migration",
          "prometheus-client",
          "prometheus-proc",
          "wai-middleware-prometheus",
          "prometheus-metrics-ghc",
          "jwt",
          "hashable",
          "lens",
          "memory",
          "morpheus-graphql-client",
          "network",
          "parsec",
          "passetto-client",
          "random-strings",
          "safe-exceptions",
          "servant",
          "servant-client",
          "servant-client-core",
          "servant-server",
          "servant-openapi3",
          "singletons-th",
          "text",
          "wai",
          "warp",
          "time",
          "template-haskell",
          "generic-lens",
          "base64-bytestring",
          "unordered-containers",
          "geojson",
          "safe-money",
          "dhall",
          "tasty",
          "tasty-hunit",
          "either",
          "mtl",
          "uuid",
          "stm",
          "unix",
          "record-hasfield",
          "record-dot-preprocessor",
          "openapi3",
          "fast-logger",
          "persistent",
          "persistent-postgresql",
          "esqueleto",
          "monad-logger",
          "unliftio-core",
          "resource-pool",
          "universum",
          "scientific",
          "vector",
          "unliftio",
          "string-conversions",
          "hedis",
          "transformers",
          "extra",
          "random",
          "hw-kafka-client",
          "fmt",
          "text-conversions",
          "deriving-aeson",
          "base64",
          "safe",
          "tinylog",
          "wai-app-static",
          "servant-multipart",
          "servant-multipart-api",
          "servant-multipart-client",
          "clickhouse-haskell",
          "beam-postgres",
          "beam-core",
          "cereal",
          "beam-mysql",
          "sequelize",
          "concurrency",
          "casing",
          "slack-web",
          "insert-ordered-containers",
          "split"
        ],
        "ghc-options": [
          "-fwrite-ide-info",
          "-hiedir=.hie",
          "-Wall",
          "-Wcompat",
          "-Widentities",
          "-fhide-source-paths",
          "-Werror",
          "-fplugin=RecordDotPreprocessor",
          "-Wwarn=ambiguous-fields"
        ],
        "library": {
          "source-dirs": [
            "src",
            "auto-generated"
          ]
        },
        "tests": {
          "mobility-core-tests": {
            "main": "Main.hs",
            "source-dirs": [
              "test/app",
              "test/src"
            ],
            "dependencies": [
              "mobility-core"
            ]
          }
        }
      }
    },
    "/lib/mobility-core/src/Kernel/Beam/Connection/EnvVars.hs": {
      "type": "content",
      "content": "module Kernel.Beam.Connection.EnvVars where\n\nimport Data.Char (toLower, toUpper)\nimport qualified Data.Text as T\nimport EulerHS.Prelude\nimport System.Environment (lookupEnv)\n\npostgresConnectionName :: IO Text\npostgresConnectionName = T.pack . fromMaybe \"postgres\" <$> lookupEnv \"POSTGRES_CONNECTION_NAME\"\n\npostgresR1ConnectionName :: IO Text\npostgresR1ConnectionName = T.pack . fromMaybe \"postgresR1\" <$> lookupEnv \"POSTGRES_R1_CONNECTION_NAME\"\n\ngetPostgresPoolStripes :: IO Int\ngetPostgresPoolStripes = fromMaybe 1 . (readMaybe =<<) <$> lookupEnv \"POSTGRES_POOL_STRIPES\"\n\ngetPostgresPoolIdleTime :: IO Integer\ngetPostgresPoolIdleTime = fromMaybe 20000 . (readMaybe =<<) <$> lookupEnv \"POSTGRES_POOL_IDLE_TIME\"\n\ngetPostgresPoolMax :: IO Int\ngetPostgresPoolMax = fromMaybe 5 . (readMaybe =<<) <$> lookupEnv \"POSTGRES_POOL_MAX\"\n\npostgresLocationDBConnectionName :: IO Text\npostgresLocationDBConnectionName = T.pack . fromMaybe \"postgresLocationDB\" <$> lookupEnv \"POSTGRES_LOCATION_DB_CONNECTION_NAME\"\n\npostgresLocationDBReplicaConnectionName :: IO Text\npostgresLocationDBReplicaConnectionName = T.pack . fromMaybe \"postgresLocationDBReplica\" <$> lookupEnv \"POSTGRES_LOCATION_DB_REPLICA_CONNECTION_NAME\"\n\ntoTitle :: String -> String\ntoTitle \"\" = \"\"\ntoTitle (x : xs) = toUpper x : map toLower xs\n\ngetPreparePosgreSqlConnection :: IO Bool\ngetPreparePosgreSqlConnection = do\n  envVal <- lookupEnv \"PREPARE_POSGRESQL_CONNECTION\"\n  pure (Just False /= (readMaybe . toTitle =<< envVal))\n\ngetPreparePosgreSqlR1Connection :: IO Bool\ngetPreparePosgreSqlR1Connection = do\n  envVal <- lookupEnv \"PREPARE_POSGRESQL_R1_CONNECTION\"\n  pure (Just False /= (readMaybe . toTitle =<< envVal))\n\ngetPrepareRedisClusterConnection :: IO Bool\ngetPrepareRedisClusterConnection = do\n  envVal <- lookupEnv \"PREPARE_REDIS_CLUSTER_CONNECTION\"\n  pure (Just False /= (readMaybe . toTitle =<< envVal))\n\ngetPrepareLocationDBConnection :: IO Bool\ngetPrepareLocationDBConnection = do\n  envVal <- lookupEnv \"PREPARE_LOCATION_DB_CONNECTION\"\n  pure (Just False /= (readMaybe . toTitle =<< envVal))\n\ngetPrepareLocationDBReplicaConnection :: IO Bool\ngetPrepareLocationDBReplicaConnection = do\n  envVal <- lookupEnv \"PREPARE_LOCATION_DB_REPLICA_CONNECTION\"\n  pure (Just False /= (readMaybe . toTitle =<< envVal))\n",
      "hash": "2e09beb3b692dd09d22a0e81cf506f2a2bf2248f9c165941105cef3a4594d397",
      "size": 2269
    },
    "/lib/mobility-core/src/Kernel/Beam/Connection/Flow.hs": {
      "type": "content",
      "content": "module Kernel.Beam.Connection.Flow where\n\nimport qualified EulerHS.Language as L\nimport qualified Kernel.Beam.Connection.Postgres as PGC\nimport qualified Kernel.Beam.Connection.Redis as RC\nimport qualified Kernel.Beam.Connection.Types as ECT\nimport Kernel.Beam.Types\nimport Kernel.Prelude\n\nprepareConnectionDriver :: L.MonadFlow m => ECT.ConnectionConfigDriver -> Int -> m ()\nprepareConnectionDriver conf kvConfigUpdateFrequency = do\n  PGC.prepareDBConnectionsDriver conf\n  RC.prepareRedisConnectionsDriver conf\n  PGC.setKvConfigUpdateFrequency kvConfigUpdateFrequency\n  L.setOptionLocal ReplicaEnabled False\n\nprepareConnectionRider :: L.MonadFlow m => ECT.ConnectionConfigRider -> Int -> m ()\nprepareConnectionRider conf kvConfigUpdateFrequency = do\n  PGC.prepareDBConnectionsRider conf\n  RC.prepareRedisConnectionsRider conf\n  PGC.setKvConfigUpdateFrequency kvConfigUpdateFrequency\n  L.setOptionLocal ReplicaEnabled False\n\nprepareConnectionDashboard :: L.MonadFlow m => ECT.ConnectionConfigDashboard -> Int -> m ()\nprepareConnectionDashboard conf kvConfigUpdateFrequency = do\n  PGC.prepareDBConnectionsDashboard conf\n  RC.prepareRedisConnectionsDashboard conf\n  PGC.setKvConfigUpdateFrequency kvConfigUpdateFrequency\n  L.setOptionLocal ReplicaEnabled False\n",
      "hash": "699befd9191fbe9d24b513d8011446a0f20bf57e4cb76db2a3da0abb50819a26",
      "size": 1259
    },
    "/lib/mobility-core/src/Kernel/Beam/Connection/Postgres.hs": {
      "type": "content",
      "content": "module Kernel.Beam.Connection.Postgres where\n\nimport qualified Data.Text as T\nimport qualified Database.Beam.Postgres as BP\nimport qualified EulerHS.Language as L\nimport EulerHS.Prelude\nimport qualified EulerHS.Types as ET\nimport qualified Kernel.Beam.Connection.EnvVars as EnvVars\nimport qualified Kernel.Beam.Connection.Types as ECT\nimport Kernel.Beam.Types\nimport qualified Kernel.Beam.Types as KBT\nimport qualified Kernel.Storage.Esqueleto.Config as KSEC\nimport qualified Kernel.Types.Common as KTC\n\nprepareDBConnectionsDriver :: L.MonadFlow m => ECT.ConnectionConfigDriver -> m ()\nprepareDBConnectionsDriver ECT.ConnectionConfigDriver {..} = do\n  preparePosgreSqlConnection <- L.runIO EnvVars.getPreparePosgreSqlConnection\n  when preparePosgreSqlConnection (preparePsqlMasterConnection esqDBCfg)\n\n  preparePosgreSqlR1Connection <- L.runIO EnvVars.getPreparePosgreSqlR1Connection\n  when preparePosgreSqlR1Connection (preparePsqlR1Connection esqDBReplicaCfg)\n\nprepareDBConnectionsRider :: L.MonadFlow m => ECT.ConnectionConfigRider -> m ()\nprepareDBConnectionsRider ECT.ConnectionConfigRider {..} = do\n  preparePosgreSqlConnection <- L.runIO EnvVars.getPreparePosgreSqlConnection\n  when preparePosgreSqlConnection (preparePsqlMasterConnection esqDBCfg)\n\n  preparePosgreSqlR1Connection <- L.runIO EnvVars.getPreparePosgreSqlR1Connection\n  when preparePosgreSqlR1Connection (preparePsqlR1Connection esqDBReplicaCfg)\n\nprepareDBConnectionsDashboard :: L.MonadFlow m => ECT.ConnectionConfigDashboard -> m ()\nprepareDBConnectionsDashboard ECT.ConnectionConfigDashboard {..} = do\n  preparePosgreSqlConnection <- L.runIO EnvVars.getPreparePosgreSqlConnection\n  when preparePosgreSqlConnection (preparePsqlMasterConnection esqDBCfg)\n\n  preparePosgreSqlR1Connection <- L.runIO EnvVars.getPreparePosgreSqlR1Connection\n  when preparePosgreSqlR1Connection (preparePsqlR1Connection esqDBReplicaCfg)\n\nprepareTables :: L.MonadFlow m => KTC.Tables -> m ()\nprepareTables tables' = do\n  L.setOption KBT.Tables tables'\n  L.setOptionLocal ReplicaEnabled False\n\nsetKvConfigUpdateFrequency :: L.MonadFlow m => Int -> m ()\nsetKvConfigUpdateFrequency kvConfigUpdateFrequency = do\n  L.setOption KBT.KvConfigUpdateFrequency kvConfigUpdateFrequency\n\n--   when EnvVars.getPrepareRedisClusterConnection prepareRedisClusterConnection\n\npreparePsqlMasterConnection :: L.MonadFlow m => KSEC.EsqDBConfig -> m ()\npreparePsqlMasterConnection conf = do\n  pgConnName <- L.runIO EnvVars.postgresConnectionName\n  preparePSqlConnection pgConnName KBT.PsqlDbCfg conf\n\npreparePsqlR1Connection :: L.MonadFlow m => KSEC.EsqDBConfig -> m ()\npreparePsqlR1Connection conf = do\n  pgConnName <- L.runIO EnvVars.postgresR1ConnectionName\n  preparePSqlConnection pgConnName KBT.PsqlDbCfgR1 conf\n\nprepareLocDbConn :: L.MonadFlow m => KSEC.EsqDBConfig -> m ()\nprepareLocDbConn conf = do\n  pgConnName <- L.runIO EnvVars.postgresLocationDBConnectionName\n  preparePSqlConnection pgConnName KBT.PsqlLocDbCfg conf\n\nprepareLocDbReplicaConn :: L.MonadFlow m => KSEC.EsqDBConfig -> m ()\nprepareLocDbReplicaConn conf = do\n  pgConnName <- L.runIO EnvVars.postgresLocationDBReplicaConnectionName\n  preparePSqlConnection pgConnName KBT.PsqlLocReplicaDbCfg conf\n\npreparePSqlConnection :: L.MonadFlow m => (ET.OptionEntity a (ET.DBConfig BP.Pg)) => Text -> a -> KSEC.EsqDBConfig -> m ()\npreparePSqlConnection pgConnName psqlDBCfgId KSEC.EsqDBConfig {..} = do\n  poolConf <- L.runIO postgresPoolConfig\n  let psqlDbCfg = ET.mkPostgresPoolConfig pgConnName pgConf poolConf\n  ePoolPsql <- L.initSqlDBConnection psqlDbCfg\n  L.setOption psqlDBCfgId psqlDbCfg\n  L.throwOnFailedWithLog ePoolPsql L.SqlDBConnectionFailedException \"Failed to connect to PSQL DB.\"\n  where\n    pgConf =\n      ET.PostgresConfig\n        { connectHost = T.unpack connectHost,\n          connectPort = connectPort,\n          connectUser = T.unpack connectUser,\n          connectPassword = T.unpack connectPassword,\n          connectDatabase = T.unpack connectDatabase\n        }\n\npostgresPoolConfig :: IO ET.PoolConfig\npostgresPoolConfig = do\n  stripes <- EnvVars.getPostgresPoolStripes\n  keepAlive <- fromInteger <$> EnvVars.getPostgresPoolIdleTime\n  resourcesPerStripe <- EnvVars.getPostgresPoolMax\n  pure $ ET.PoolConfig {..}\n",
      "hash": "d1657fdc768c8d331f606e3aa65bc7accd623ec39914aa8605e7c7fd0a652657",
      "size": 4226
    },
    "/lib/mobility-core/src/Kernel/Beam/Connection/Redis.hs": {
      "type": "content",
      "content": "module Kernel.Beam.Connection.Redis where\n\nimport qualified EulerHS.Language as L\nimport EulerHS.Prelude\nimport qualified EulerHS.Types as ET\nimport qualified Kernel.Beam.Connection.EnvVars as EnvVars\nimport qualified Kernel.Beam.Connection.Types as ECT\nimport qualified Kernel.Storage.Hedis.Config as KSHC\n\nprepareRedisConnectionsDriver :: L.MonadFlow m => ECT.ConnectionConfigDriver -> m ()\nprepareRedisConnectionsDriver ECT.ConnectionConfigDriver {..} = do\n  preparePosgreSqlConnection <- L.runIO EnvVars.getPreparePosgreSqlConnection\n  when preparePosgreSqlConnection (prepareRedisClusterConnection hedisClusterCfg)\n\nprepareRedisConnectionsRider :: L.MonadFlow m => ECT.ConnectionConfigRider -> m ()\nprepareRedisConnectionsRider ECT.ConnectionConfigRider {..} = do\n  preparePosgreSqlConnection <- L.runIO EnvVars.getPreparePosgreSqlConnection\n  when preparePosgreSqlConnection (prepareRedisClusterConnection hedisClusterCfg)\n\nprepareRedisConnectionsDashboard :: L.MonadFlow m => ECT.ConnectionConfigDashboard -> m ()\nprepareRedisConnectionsDashboard ECT.ConnectionConfigDashboard {..} = do\n  preparePosgreSqlConnection <- L.runIO EnvVars.getPreparePosgreSqlConnection\n  when preparePosgreSqlConnection (prepareRedisClusterConnection hedisClusterCfg)\n\nkvRedis :: Text\nkvRedis = \"KVRedis\"\n\nprepareRedisClusterConnection :: (HasCallStack, L.MonadFlow m) => KSHC.HedisCfg -> m ()\nprepareRedisClusterConnection KSHC.HedisCfg {..} = do\n  L.logDebug @Text \"prepareDBConnections\" (\"kvdbConfig:\" <> show hedisClusterConf)\n  kvRedisCon <- L.initKVDBConnection (ET.mkKVDBClusterConfig kvRedis hedisClusterConf)\n  L.throwOnFailedWithLog kvRedisCon L.KVDBConnectionFailedException \"Failed to connect to Redis Cluster DB.\"\n  where\n    hedisClusterConf =\n      ET.RedisConfig\n        { connectHost = connectHost,\n          connectPort = connectPort,\n          connectAuth = connectAuth,\n          connectDatabase = connectDatabase,\n          connectMaxConnections = connectMaxConnections,\n          connectReadOnly = connectReadOnly,\n          connectMaxIdleTime = connectMaxIdleTime,\n          connectTimeout = connectTimeout\n        }\n",
      "hash": "15a440438ee179689e9c134f41acaf4eeddbd3e32ff61e315037d9de2e6661b9",
      "size": 2126
    },
    "/lib/mobility-core/src/Kernel/Beam/Connection/Types.hs": {
      "type": "content",
      "content": "module Kernel.Beam.Connection.Types where\n\nimport Kernel.Storage.Esqueleto.Config\nimport Kernel.Storage.Hedis.Config\n\ndata ConnectionConfigDriver = ConnectionConfigDriver\n  { esqDBCfg :: EsqDBConfig,\n    esqDBReplicaCfg :: EsqDBConfig,\n    hedisClusterCfg :: HedisCfg\n  }\n\ndata ConnectionConfigRider = ConnectionConfigRider\n  { esqDBCfg :: EsqDBConfig,\n    esqDBReplicaCfg :: EsqDBConfig,\n    hedisClusterCfg :: HedisCfg\n  }\n\ndata ConnectionConfigDashboard = ConnectionConfigDashboard\n  { esqDBCfg :: EsqDBConfig,\n    esqDBReplicaCfg :: EsqDBConfig,\n    hedisClusterCfg :: HedisCfg\n  }\n",
      "hash": "fc313759554770a3aa3b393815d91b5785a9d41544fb07c752c0688775b34adf",
      "size": 586
    },
    "/lib/mobility-core/src/Kernel/Beam/Functions.hs": {
      "type": "content",
      "content": "module Kernel.Beam.Functions\n  ( FromTType' (..),\n    ToTType' (..),\n    FromTType'' (..),\n    ToTType'' (..),\n    FromCacType (..),\n    meshConfig,\n    runInReplica,\n    runInMasterDb,\n    getMasterBeamConfig,\n    getLocationDbBeamConfig,\n    findOneWithKV,\n    findOneWithKVScheduler,\n    findAllWithKV,\n    findAllWithKVScheduler,\n    findAllWithOptionsKV,\n    findAllWithOptionsKV',\n    findAllWithOptionsKVScheduler,\n    findOneWithDb, -- not used\n    findAllWithDb,\n    findAllWithOptionsDb,\n    updateWithKV,\n    updateWithKVScheduler,\n    updateOneWithKV,\n    createWithKV,\n    createWithKVScheduler,\n    deleteWithKV,\n    deleteWithDb, -- not used\n    findAllWithKVAndConditionalDB,\n    findOneWithKVRedis,\n    logQueryData,\n    findAllFromKvRedis,\n    createWithKVWithOptions,\n    createWithKVSchedulerWithOptions,\n    updateWithKVWithOptions,\n    updateWithKVSchedulerWithOptions,\n    updateOneWithKVWithOptions,\n    getReplicaBeamConfig,\n    runInMasterRedis,\n    runInMasterDbAndRedis,\n  )\nwhere\n\nimport Data.Aeson\nimport Data.Default.Class\nimport qualified Data.HashMap.Strict as HM\nimport qualified Data.Serialize as Serialize\nimport Database.Beam hiding (timestamp)\nimport Database.Beam.MySQL ()\nimport Database.Beam.Postgres\nimport EulerHS.Extra.Monitoring.Types (UseMasterRedis (..))\nimport qualified EulerHS.KVConnector.Flow as KV\nimport EulerHS.KVConnector.Types (KVConnector (..), MeshConfig (..), MeshMeta, TableMappings)\nimport EulerHS.KVConnector.Utils\nimport qualified EulerHS.Language as L\nimport EulerHS.Types hiding (Log, V1)\nimport Kernel.Beam.Lib.Utils\nimport Kernel.Beam.Types\nimport qualified Kernel.Beam.Types as KBT\nimport Kernel.Prelude\nimport qualified Kernel.Tools.ARTUtils as A\nimport Kernel.Types.CacheFlow (CacheFlow)\nimport Kernel.Types.Common\nimport Kernel.Types.Error\nimport Kernel.Utils.Error.Throwing (throwError)\nimport Kernel.Utils.Logging (logDebug)\nimport Sequelize\n\n-- classes for converting from beam types to ttypes and vice versa\nclass\n  FromTType' t a\n    | t -> a\n  where\n  fromTType' :: (MonadFlow m, CacheFlow m r, EsqDBFlow m r) => t -> m (Maybe a)\n\nclass\n  ToTType' t a\n    | a -> t\n  where\n  toTType' :: a -> t\n\n-- Below class FromTType'' and ToTType'' are only to be used with scheduler\nclass\n  FromTType'' t a\n    | a -> t\n  where\n  fromTType'' :: (MonadThrow m, Log m, L.MonadFlow m) => t -> m (Maybe a)\n\n-- Below class FromCacType'' are only to be used with cac.\nclass\n  FromCacType t a\n    | t -> a\n  where\n  fromCacType :: (MonadFlow m, CacheFlow m r, EsqDBFlow m r) => t -> m (Maybe a)\n\nclass\n  ToTType'' t a\n    | a -> t\n  where\n  toTType'' :: a -> t\n\nmeshConfig :: MeshConfig\nmeshConfig =\n  MeshConfig\n    { meshEnabled = False,\n      memcacheEnabled = False,\n      meshDBName = \"postgres\",\n      ecRedisDBStream = \"driver-db-sync-stream\",\n      kvRedis = \"KVRedis\",\n      redisTtl = 18000,\n      kvHardKilled = True,\n      cerealEnabled = False,\n      tableShardModRange = (0, 128),\n      redisKeyPrefix = \"\",\n      forceDrainToDB = False\n    }\n\nrunInReplica :: (L.MonadFlow m, Log m) => m a -> m a\nrunInReplica m = do\n  L.setOptionLocal ReplicaEnabled True\n  res <- m\n  L.setOptionLocal ReplicaEnabled False\n  pure res\n\nrunInMasterRedis :: (L.MonadFlow m, Log m) => m a -> m a\nrunInMasterRedis m = do\n  L.setOptionLocal UseMasterRedis True\n  res <- m\n  L.setOptionLocal UseMasterRedis False\n  pure res\n\nrunInMasterDb :: (L.MonadFlow m, Log m) => m a -> m a\nrunInMasterDb m = do\n  L.setOptionLocal MasterReadEnabled True\n  res <- m\n  L.setOptionLocal MasterReadEnabled False\n  pure res\n\nrunInMasterDbAndRedis :: (L.MonadFlow m, Log m) => m a -> m a\nrunInMasterDbAndRedis m = do\n  L.setOptionLocal MasterReadEnabled True\n  L.setOptionLocal UseMasterRedis True\n  res <- m\n  L.setOptionLocal MasterReadEnabled False\n  L.setOptionLocal UseMasterRedis False\n  pure res\n\nallowedSchema :: [Text]\nallowedSchema = [\"atlas_driver_offer_bpp\", \"atlas_app\"]\n\nsetMeshConfig :: (L.MonadFlow m, HasCallStack) => Text -> Maybe Text -> MeshConfig -> m MeshConfig\nsetMeshConfig modelName mSchema meshConfig' = do\n  schema <- maybe (L.throwException $ InternalError \"Schema not found in setMeshConfig\") pure mSchema\n  if schema `notElem` allowedSchema\n    then pure meshConfig'\n    else do\n      let redisStream = if schema == \"atlas_driver_offer_bpp\" then \"driver-db-sync-stream\" else \"rider-db-sync-stream\" -- lets change when we enable for dashboards\n      tables' <- L.getOption KBT.Tables >>= maybe (L.throwException $ InternalError \"Tables not found in setMeshConfig\") pure\n      if modelName `elem` tables'.disableForKV || allTablesDisabled tables' == Just True\n        then pure $ meshConfig' {ecRedisDBStream = redisStream}\n        else do\n          let redisTtl' = HM.lookupDefault meshConfig'.redisTtl modelName tables'.kvTablesTtl\n          let tableShardModRange' = HM.lookupDefault (0, tables'.defaultShardMod) modelName tables'.tableShardModRange\n          let redisKeyPrefix' = HM.lookupDefault meshConfig'.redisKeyPrefix modelName tables'.tableRedisKeyPrefix\n          pure $ meshConfig' {meshEnabled = True, kvHardKilled = False, ecRedisDBStream = redisStream, redisTtl = redisTtl', tableShardModRange = tableShardModRange', redisKeyPrefix = redisKeyPrefix'}\n\nwithUpdatedMeshConfig :: forall table m a. (L.MonadFlow m, HasCallStack, ModelMeta table) => Proxy table -> (MeshConfig -> m a) -> m a\nwithUpdatedMeshConfig _ mkAction = do\n  updatedMeshConfig <- setMeshConfig (modelTableName @table) (modelSchemaName @table) meshConfig\n  mkAction updatedMeshConfig\n\ngetMasterDBConfig :: (HasCallStack, L.MonadFlow m) => m (DBConfig Pg)\ngetMasterDBConfig = do\n  dbConf <- L.getOption KBT.PsqlDbCfg\n  case dbConf of\n    Just dbCnf' -> pure dbCnf'\n    Nothing -> L.throwException $ InternalError \"masterDb Config not found\"\n\ngetLocDbConfig :: (HasCallStack, L.MonadFlow m) => m (DBConfig Pg)\ngetLocDbConfig = do\n  dbConf <- L.getOption KBT.PsqlLocDbCfg\n  case dbConf of\n    Just dbCnf' -> pure dbCnf'\n    Nothing -> L.throwException $ InternalError \"LocationDb Config not found\"\n\ngetMasterBeamConfig :: (HasCallStack, L.MonadFlow m) => m (SqlConn Pg)\ngetMasterBeamConfig = do\n  inReplica <- L.getOptionLocal ReplicaEnabled\n  dbConf <- maybe getMasterDBConfig (\\inReplica' -> if inReplica' then getReplicaDbConfig else getMasterDBConfig) inReplica\n  conn <- L.getOrInitSqlConn dbConf\n  case conn of\n    Right conn' -> pure conn'\n    Left _ -> L.throwException $ InternalError \"MasterDb Beam Config not found\"\n\ngetReplicaBeamConfig :: (HasCallStack, L.MonadFlow m) => m (SqlConn Pg)\ngetReplicaBeamConfig = do\n  dbConf <- getReplicaDbConfig\n  conn <- L.getOrInitSqlConn dbConf\n  case conn of\n    Right conn' -> pure conn'\n    Left _ -> L.throwException $ InternalError \"ReplicaDb Beam Config not found\"\n\ngetLocationDbBeamConfig :: (HasCallStack, L.MonadFlow m) => m (SqlConn Pg)\ngetLocationDbBeamConfig = do\n  inReplica <- L.getOptionLocal ReplicaEnabled\n  dbConf <- maybe getLocDbConfig (\\inReplica' -> if inReplica' then getReplicaLocationDbConfig else getLocDbConfig) inReplica\n  conn <- L.getOrInitSqlConn dbConf\n  case conn of\n    Right conn' -> pure conn'\n    Left _ -> L.throwException $ InternalError \"LocationDb Beam Config not found\"\n\n----- replica db functions---------------\n\ngetReplicaDbConfig :: (HasCallStack, L.MonadFlow m) => m (DBConfig Pg)\ngetReplicaDbConfig = do\n  dbConf <- L.getOption KBT.PsqlDbCfgR1\n  case dbConf of\n    Just dbCnf' -> pure dbCnf'\n    Nothing -> L.throwException $ InternalError \"ReplicaDb Config not found\"\n\ngetReplicaLocationDbConfig :: (HasCallStack, L.MonadFlow m) => m (DBConfig Pg)\ngetReplicaLocationDbConfig = do\n  dbConf <- L.getOption KBT.PsqlLocReplicaDbCfg\n  case dbConf of\n    Just dbCnf' -> pure dbCnf'\n    Nothing -> L.throwException $ InternalError \"Replica LocationDB Config not found\"\n\ntype BeamTableFlow table m =\n  ( HasCallStack,\n    BeamTable table,\n    MonadFlow m\n  )\n\ntype BeamTable table =\n  ( Model Postgres table,\n    MeshMeta Postgres table,\n    KVConnector (table Identity),\n    FromJSON (table Identity),\n    ToJSON (table Identity),\n    TableMappings (table Identity),\n    Serialize.Serialize (table Identity),\n    Show (table Identity)\n  )\n\n-- findOne --\n\nfindOneWithKV ::\n  forall table m r a.\n  ( BeamTableFlow table m,\n    CacheFlow m r,\n    EsqDBFlow m r,\n    FromTType' (table Identity) a\n  ) =>\n  Where Postgres table ->\n  m (Maybe a)\nfindOneWithKV where' = withUpdatedMeshConfig (Proxy @table) $ \\updatedMeshConfig -> do\n  findOneInternal updatedMeshConfig fromTType' where'\n\nfindOneWithKVRedis ::\n  forall table m r a.\n  ( BeamTableFlow table m,\n    CacheFlow m r,\n    EsqDBFlow m r,\n    FromTType' (table Identity) a\n  ) =>\n  Where Postgres table ->\n  m (Maybe a)\nfindOneWithKVRedis where' = do\n  updatedMeshConfig <- setMeshConfig (modelTableName @table) (modelSchemaName @table) meshConfig\n  dbConf' <- getReadDBConfigInternal (modelTableName @table)\n  result <- KV.findOneFromKvRedis dbConf' updatedMeshConfig where'\n  case result of\n    Right (Just res) -> fromTType' res\n    Right Nothing -> pure Nothing\n    Left err -> throwError $ InternalError $ show err\n\nfindOneWithKVScheduler ::\n  forall table m r a.\n  ( BeamTableFlow table m,\n    EsqDBFlow m r,\n    FromTType'' (table Identity) a\n  ) =>\n  Where Postgres table ->\n  m (Maybe a)\nfindOneWithKVScheduler where' = withUpdatedMeshConfig (Proxy @table) $ \\updatedMeshConfig -> do\n  findOneInternal updatedMeshConfig fromTType'' where'\n\nfindOneWithDb ::\n  forall table m r a.\n  ( BeamTableFlow table m,\n    CacheFlow m r,\n    EsqDBFlow m r,\n    FromTType' (table Identity) a\n  ) =>\n  Where Postgres table ->\n  m (Maybe a)\nfindOneWithDb = findOneInternal meshConfig fromTType'\n\n-- findAll --\n\nfindAllWithKV ::\n  forall table m r a.\n  ( BeamTableFlow table m,\n    CacheFlow m r,\n    EsqDBFlow m r,\n    FromTType' (table Identity) a\n  ) =>\n  Where Postgres table ->\n  m [a]\nfindAllWithKV where' = withUpdatedMeshConfig (Proxy @table) $ \\updatedMeshConfig -> do\n  findAllInternal updatedMeshConfig fromTType' where'\n\nfindAllWithKVScheduler ::\n  forall table m r a.\n  ( BeamTableFlow table m,\n    EsqDBFlow m r,\n    FromTType'' (table Identity) a\n  ) =>\n  Where Postgres table ->\n  m [a]\nfindAllWithKVScheduler where' = withUpdatedMeshConfig (Proxy @table) $ \\updatedMeshConfig -> do\n  findAllInternal updatedMeshConfig fromTType'' where'\n\nfindAllWithDb ::\n  forall table m r a.\n  ( BeamTableFlow table m,\n    CacheFlow m r,\n    EsqDBFlow m r,\n    FromTType' (table Identity) a\n  ) =>\n  Where Postgres table ->\n  m [a]\nfindAllWithDb = findAllInternal meshConfig fromTType'\n\nfindAllWithKVAndConditionalDB ::\n  forall table m r a.\n  ( BeamTableFlow table m,\n    CacheFlow m r,\n    EsqDBFlow m r,\n    FromTType' (table Identity) a\n  ) =>\n  Where Postgres table ->\n  Maybe (OrderBy table) ->\n  m [a]\nfindAllWithKVAndConditionalDB where' orderBy = do\n  updatedMeshConfig <- setMeshConfig (modelTableName @table) (modelSchemaName @table) meshConfig\n  dbConf' <- getReadDBConfigInternal (modelTableName @table)\n  result <- KV.findAllWithKVAndConditionalDBInternal dbConf' updatedMeshConfig where' orderBy\n  case result of\n    Right res -> do\n      res' <- mapM fromTType' res\n      pure $ catMaybes res'\n    Left err -> throwError $ InternalError $ show err\n\nfindAllFromKvRedis ::\n  forall table m r a.\n  ( BeamTableFlow table m,\n    CacheFlow m r,\n    EsqDBFlow m r,\n    FromTType' (table Identity) a\n  ) =>\n  Where Postgres table ->\n  Maybe (OrderBy table) ->\n  m [a]\nfindAllFromKvRedis where' orderBy = do\n  updatedMeshConfig <- setMeshConfig (modelTableName @table) (modelSchemaName @table) meshConfig\n  dbConf' <- getReadDBConfigInternal (modelTableName @table)\n  result <- KV.findAllFromKvRedis dbConf' updatedMeshConfig where' orderBy\n  case result of\n    Right res -> do\n      res' <- mapM fromTType' res\n      pure $ catMaybes res'\n    Left err -> throwError $ InternalError $ show err\n\n-- findAllWithOptions --\n\nfindAllWithOptionsKV ::\n  forall table m r a.\n  ( BeamTableFlow table m,\n    CacheFlow m r,\n    EsqDBFlow m r,\n    FromTType' (table Identity) a\n  ) =>\n  Where Postgres table ->\n  OrderBy table ->\n  Maybe Int ->\n  Maybe Int ->\n  m [a]\nfindAllWithOptionsKV where' orderBy mbLimit mbOffset = withUpdatedMeshConfig (Proxy @table) $ \\updatedMeshConfig -> do\n  findAllWithOptionsInternal updatedMeshConfig fromTType' where' orderBy mbLimit mbOffset\n\nfindAllWithOptionsKV' ::\n  forall table m r a.\n  ( BeamTableFlow table m,\n    CacheFlow m r,\n    EsqDBFlow m r,\n    FromTType' (table Identity) a\n  ) =>\n  Where Postgres table ->\n  Maybe Int ->\n  Maybe Int ->\n  m [a]\nfindAllWithOptionsKV' where' mbLimit mbOffset = do\n  updatedMeshConfig <- setMeshConfig (modelTableName @table) (modelSchemaName @table) meshConfig\n  dbConf' <- getReadDBConfigInternal (modelTableName @table)\n  result <- KV.findAllWithOptionsKVConnector' dbConf' updatedMeshConfig where' mbLimit mbOffset\n  case result of\n    Right res -> do\n      res' <- mapM fromTType' res\n      pure $ catMaybes res'\n    Left err -> throwError $ InternalError $ show err\n\nfindAllWithOptionsKVScheduler ::\n  forall table m r a.\n  ( BeamTableFlow table m,\n    EsqDBFlow m r,\n    FromTType'' (table Identity) a\n  ) =>\n  Where Postgres table ->\n  OrderBy table ->\n  Maybe Int ->\n  Maybe Int ->\n  m [a]\nfindAllWithOptionsKVScheduler where' orderBy mbLimit mbOffset = withUpdatedMeshConfig (Proxy @table) $ \\updatedMeshConfig -> do\n  findAllWithOptionsInternal updatedMeshConfig fromTType'' where' orderBy mbLimit mbOffset\n\nfindAllWithOptionsDb ::\n  forall table m r a.\n  ( BeamTableFlow table m,\n    CacheFlow m r,\n    EsqDBFlow m r,\n    FromTType' (table Identity) a\n  ) =>\n  Where Postgres table ->\n  OrderBy table ->\n  Maybe Int ->\n  Maybe Int ->\n  m [a]\nfindAllWithOptionsDb = findAllWithOptionsInternal meshConfig fromTType'\n\n-- update --\n\nupdateWithKV ::\n  forall table m r.\n  (BeamTableFlow table m, EsqDBFlow m r) =>\n  [Set Postgres table] ->\n  Where Postgres table ->\n  m ()\nupdateWithKV setClause whereClause = withUpdatedMeshConfig (Proxy @table) $ \\updatedMeshConfig -> do\n  updateInternal updatedMeshConfig setClause whereClause\n\nupdateWithKVWithOptions ::\n  forall table m r.\n  (BeamTableFlow table m, EsqDBFlow m r) =>\n  Maybe Integer ->\n  Bool ->\n  [Set Postgres table] ->\n  Where Postgres table ->\n  m ()\nupdateWithKVWithOptions ttl forceDrain setClause whereClause = withUpdatedMeshConfig (Proxy @table) $ \\updatedMeshConfig -> do\n  let updatedMeshConfig' = updatedMeshConfig {redisTtl = fromMaybe (redisTtl updatedMeshConfig) ttl, forceDrainToDB = forceDrain}\n  updateInternal updatedMeshConfig' setClause whereClause\n\nupdateWithKVScheduler ::\n  forall table m r.\n  (BeamTableFlow table m, EsqDBFlow m r) =>\n  [Set Postgres table] ->\n  Where Postgres table ->\n  m ()\nupdateWithKVScheduler setClause whereClause = withUpdatedMeshConfig (Proxy @table) $ \\updatedMeshConfig -> do\n  updateInternal updatedMeshConfig setClause whereClause\n\nupdateWithKVSchedulerWithOptions ::\n  forall table m r.\n  (BeamTableFlow table m, EsqDBFlow m r) =>\n  Maybe Integer ->\n  Bool ->\n  [Set Postgres table] ->\n  Where Postgres table ->\n  m ()\nupdateWithKVSchedulerWithOptions ttl forceDrain setClause whereClause = withUpdatedMeshConfig (Proxy @table) $ \\updatedMeshConfig -> do\n  let updatedMeshConfig' = updatedMeshConfig {redisTtl = fromMaybe (redisTtl updatedMeshConfig) ttl, forceDrainToDB = forceDrain}\n  updateInternal updatedMeshConfig' setClause whereClause\n\n-- updateOne --\n\nupdateOneWithKV ::\n  forall table m r.\n  (BeamTableFlow table m, EsqDBFlow m r) =>\n  [Set Postgres table] ->\n  Where Postgres table ->\n  m ()\nupdateOneWithKV setClause whereClause = withUpdatedMeshConfig (Proxy @table) $ \\updatedMeshConfig -> do\n  updateOneInternal updatedMeshConfig setClause whereClause\n\nupdateOneWithKVWithOptions ::\n  forall table m r.\n  (BeamTableFlow table m, EsqDBFlow m r) =>\n  Maybe Integer ->\n  Bool ->\n  [Set Postgres table] ->\n  Where Postgres table ->\n  m ()\nupdateOneWithKVWithOptions ttl forceDrain setClause whereClause = withUpdatedMeshConfig (Proxy @table) $ \\updatedMeshConfig -> do\n  let updatedMeshConfig' = updatedMeshConfig {redisTtl = fromMaybe (redisTtl updatedMeshConfig) ttl, forceDrainToDB = forceDrain}\n  updateOneInternal updatedMeshConfig' setClause whereClause\n\n-- create --\n\ncreateWithKV ::\n  forall table m r a.\n  ( BeamTableFlow table m,\n    EsqDBFlow m r,\n    ToTType' (table Identity) a\n  ) =>\n  a ->\n  m ()\ncreateWithKV a = withUpdatedMeshConfig (Proxy @table) $ \\updatedMeshConfig -> do\n  createInternal updatedMeshConfig toTType' a\n\ncreateWithKVWithOptions ::\n  forall table m r a.\n  ( BeamTableFlow table m,\n    EsqDBFlow m r,\n    ToTType' (table Identity) a\n  ) =>\n  Maybe Integer ->\n  Bool ->\n  a ->\n  m ()\ncreateWithKVWithOptions ttl forceDrain a = withUpdatedMeshConfig (Proxy @table) $ \\updatedMeshConfig -> do\n  let updatedMeshConfig' = updatedMeshConfig {redisTtl = fromMaybe (redisTtl updatedMeshConfig) ttl, forceDrainToDB = forceDrain}\n  createInternal updatedMeshConfig' toTType' a\n\ncreateWithKVScheduler ::\n  forall table m r a.\n  ( BeamTableFlow table m,\n    EsqDBFlow m r,\n    ToTType'' (table Identity) a\n  ) =>\n  a ->\n  m ()\ncreateWithKVScheduler a = withUpdatedMeshConfig (Proxy @table) $ \\updatedMeshConfig -> do\n  createInternal updatedMeshConfig toTType'' a\n\ncreateWithKVSchedulerWithOptions ::\n  forall table m r a.\n  ( BeamTableFlow table m,\n    EsqDBFlow m r,\n    ToTType'' (table Identity) a\n  ) =>\n  Maybe Integer ->\n  Bool ->\n  a ->\n  m ()\ncreateWithKVSchedulerWithOptions ttl forceDrain a = withUpdatedMeshConfig (Proxy @table) $ \\updatedMeshConfig -> do\n  let updatedMeshConfig' = updatedMeshConfig {redisTtl = fromMaybe (redisTtl updatedMeshConfig) ttl, forceDrainToDB = forceDrain}\n  createInternal updatedMeshConfig' toTType'' a\n\n-- delete --\n\ndeleteWithKV ::\n  forall table m r.\n  (BeamTableFlow table m, EsqDBFlow m r) =>\n  Where Postgres table ->\n  m ()\ndeleteWithKV whereClause = withUpdatedMeshConfig (Proxy @table) $ \\updatedMeshConfig -> do\n  deleteInternal updatedMeshConfig whereClause\n\ndeleteWithDb ::\n  forall table m r.\n  (BeamTableFlow table m, EsqDBFlow m r) =>\n  Where Postgres table ->\n  m ()\ndeleteWithDb = deleteInternal meshConfig\n\n-- internal --\n\nfindOneInternal ::\n  forall table m r a.\n  (BeamTableFlow table m, EsqDBFlow m r) =>\n  MeshConfig ->\n  (table Identity -> m (Maybe a)) ->\n  Where Postgres table ->\n  m (Maybe a)\nfindOneInternal updatedMeshConfig fromTType where' = do\n  dbConf' <- getReadDBConfigInternal (modelTableName @table)\n  result <- KV.findWithKVConnector dbConf' updatedMeshConfig where'\n  case result of\n    Right (Just res) -> fromTType res\n    Right Nothing -> pure Nothing\n    Left err -> throwError $ InternalError $ show err\n\nfindAllInternal ::\n  forall table m r a.\n  (BeamTableFlow table m, EsqDBFlow m r) =>\n  MeshConfig ->\n  (table Identity -> m (Maybe a)) ->\n  Where Postgres table ->\n  m [a]\nfindAllInternal updatedMeshConfig fromTType where' = do\n  dbConf' <- getReadDBConfigInternal (modelTableName @table)\n  result <- KV.findAllWithKVConnector dbConf' updatedMeshConfig where'\n  case result of\n    Right res -> do\n      res' <- mapM fromTType res\n      pure $ catMaybes res'\n    Left err -> throwError $ InternalError $ show err\n\nfindAllWithOptionsInternal ::\n  forall table m r a.\n  (BeamTableFlow table m, EsqDBFlow m r) =>\n  MeshConfig ->\n  (table Identity -> m (Maybe a)) ->\n  Where Postgres table ->\n  OrderBy table ->\n  Maybe Int ->\n  Maybe Int ->\n  m [a]\nfindAllWithOptionsInternal updatedMeshConfig fromTType where' orderBy mbLimit mbOffset = do\n  dbConf' <- getReadDBConfigInternal (modelTableName @table)\n  result <- KV.findAllWithOptionsKVConnector dbConf' updatedMeshConfig where' orderBy mbLimit mbOffset\n  case result of\n    Right res -> do\n      res' <- mapM fromTType res\n      pure $ catMaybes res'\n    Left err -> throwError $ InternalError $ show err\n\ngetReadDBConfigInternal :: (HasCallStack, L.MonadFlow m) => Text -> m (DBConfig Pg)\ngetReadDBConfigInternal modelName = do\n  tables <- L.getOption KBT.Tables\n  let dbConfig = maybe getReplicaDbConfig (\\tables' -> if modelName `elem` tables'.readFromMasterDb then getMasterDBConfig else getReplicaDbConfig) tables\n  isMasterReadEnabled <- L.getOptionLocal MasterReadEnabled\n  maybe dbConfig (\\isMasterReadEnabled' -> if isMasterReadEnabled' then getMasterDBConfig else getReplicaDbConfig) isMasterReadEnabled\n\nupdateInternal ::\n  forall table m r.\n  (BeamTableFlow table m, EsqDBFlow m r) =>\n  MeshConfig ->\n  [Set Postgres table] ->\n  Where Postgres table ->\n  m ()\nupdateInternal updatedMeshConfig setClause whereClause = runInMasterRedis $ do\n  dbConf <- getMasterDBConfig\n  res <- KV.updateAllReturningWithKVConnector dbConf updatedMeshConfig setClause whereClause\n  case res of\n    Right res' -> do\n      if updatedMeshConfig.meshEnabled && not updatedMeshConfig.kvHardKilled\n        then logDebug $ \"Updated rows KV: \" <> show res'\n        else do\n          topicName <- getKafkaTopic (modelSchemaName @table) (modelTableName @table)\n          let mappings = getMappings res'\n          handle (\\(e :: SomeException) -> L.logError (\"KAFKA_PUSH_FAILED\" :: Text) $ \"Kafka push error while update:  \" <> show e <> \"in topic\" <> topicName) $\n            mapM_ (\\object' -> void $ pushToKafka (replaceMappings (toJSON object') mappings) topicName (getKeyForKafka updatedMeshConfig.tableShardModRange $ getLookupKeyByPKey updatedMeshConfig.redisKeyPrefix object')) res'\n          logDebug $\n            \"Updated rows DB: \" <> show res'\n    Left err -> throwError $ InternalError $ show err\n\nupdateOneInternal ::\n  forall table m r.\n  (BeamTableFlow table m, EsqDBFlow m r) =>\n  MeshConfig ->\n  [Set Postgres table] ->\n  Where Postgres table ->\n  m ()\nupdateOneInternal updatedMeshConfig setClause whereClause = runInMasterRedis $ do\n  dbConf <- getMasterDBConfig\n  res <- KV.updateWithKVConnector dbConf updatedMeshConfig setClause whereClause\n  case res of\n    Right obj -> do\n      if updatedMeshConfig.meshEnabled && not updatedMeshConfig.kvHardKilled\n        then logDebug $ \"Updated row KV: \" <> show obj\n        else do\n          whenJust obj $ \\object' -> do\n            topicName <- getKafkaTopic (modelSchemaName @table) (modelTableName @table)\n            let newObject = replaceMappings (toJSON object') (getMappings [object'])\n            handle (\\(e :: SomeException) -> L.logError (\"KAFKA_PUSH_FAILED\" :: Text) $ \"Kafka push error while update: \" <> show e <> \"in topic\" <> topicName) $\n              void $ pushToKafka newObject topicName (getKeyForKafka updatedMeshConfig.tableShardModRange $ getLookupKeyByPKey updatedMeshConfig.redisKeyPrefix object')\n            logDebug $\n              \"Updated row DB: \" <> show obj\n    Left err -> throwError $ InternalError $ show err\n\ncreateInternal ::\n  forall table m r a.\n  (BeamTableFlow table m, EsqDBFlow m r) =>\n  MeshConfig ->\n  (a -> table Identity) ->\n  a ->\n  m ()\ncreateInternal updatedMeshConfig toTType a = do\n  let tType = toTType a\n  dbConf' <- getMasterDBConfig\n  result <- KV.createWoReturingKVConnector dbConf' updatedMeshConfig tType\n  case result of\n    Right _ -> do\n      if updatedMeshConfig.meshEnabled && not updatedMeshConfig.kvHardKilled\n        then logDebug $ \"Created row in KV: \" <> show tType\n        else do\n          topicName <- getKafkaTopic (modelSchemaName @table) (modelTableName @table)\n          let newObject = replaceMappings (toJSON tType) (getMappings [tType])\n          handle (\\(e :: SomeException) -> L.logError (\"KAFKA_PUSH_FAILED\" :: Text) $ \"Kafka push error while create: \" <> show e <> \"in topic\" <> topicName) $\n            void $ pushToKafka newObject topicName (getKeyForKafka updatedMeshConfig.tableShardModRange $ getLookupKeyByPKey updatedMeshConfig.redisKeyPrefix tType)\n          logDebug $\n            \"Created row in DB: \" <> show tType\n    Left err -> throwError $ InternalError $ show err\n\ndeleteInternal ::\n  forall table m r.\n  (BeamTableFlow table m, EsqDBFlow m r) =>\n  MeshConfig ->\n  Where Postgres table ->\n  m ()\ndeleteInternal updatedMeshConfig whereClause = runInMasterRedis $ do\n  dbConf <- getMasterDBConfig\n  res <- KV.deleteAllReturningWithKVConnector dbConf updatedMeshConfig whereClause\n  case res of\n    Right _ -> do\n      if updatedMeshConfig.meshEnabled && not updatedMeshConfig.kvHardKilled\n        then logDebug $ \"Deleted rows in KV: \" <> show res\n        else logDebug $ \"Deleted rows in DB: \" <> show res\n    Left err -> throwError $ InternalError $ show err\n\nlogQueryData ::\n  (MonadFlow m, EsqDBFlow m r) =>\n  Text ->\n  Text ->\n  Text ->\n  Text ->\n  Bool ->\n  Text ->\n  m ()\nlogQueryData queryType whereClause setClause tableObject kvEnabled table = do\n  shouldLogRequestId <- asks (.shouldLogRequestId)\n  timestamp <- getCurrentTime\n  when shouldLogRequestId $\n    fork \"ArtData\" $ do\n      kafkaConn <- L.getOption KBT.KafkaConn\n      requestId <- fromMaybe \"\" <$> asks (.requestId)\n      let queryData = A.QueryData {..}\n      handle (\\(e :: SomeException) -> L.logError (\"ART_QUERY_LOG_FAILED\" :: Text) $ \"Error while logging query data: \" <> show e) $ do\n        liftIO $ A.pushToKafka kafkaConn (encode def {A.requestId = requestId, A.queryData = Just queryData, A.timestamp = Just timestamp}) \"ART-Logs\" requestId\n",
      "hash": "72ea7844d9b560f77df43d09c20caf4d9b46d6ecfb13d76fffa3908057a0a158",
      "size": 25218
    },
    "/lib/mobility-core/src/Kernel/Beam/Lib/SqlObjectInstances.hs": {
      "type": "content",
      "content": "{-# OPTIONS_GHC -Wno-orphans #-}\n\nmodule Kernel.Beam.Lib.SqlObjectInstances where\n\nimport qualified Data.Aeson as A\nimport Kernel.External.Encryption (DbHash (..))\nimport Kernel.Prelude\nimport Sequelize.SQLObject (SQLObject (..), ToSQLObject (convertToSQLObject))\nimport Text.Hex (encodeHex)\n\ninstance {-# OVERLAPPING #-} ToSQLObject DbHash where\n  convertToSQLObject = SQLObjectValue . show . (\"\\\\x\" <>) . encodeHex . unDbHash\n\ninstance {-# OVERLAPPING #-} ToSQLObject A.Value where\n  convertToSQLObject = SQLObjectValue . show . A.encode\n",
      "hash": "3384344e3de4c5705962b504644ab87ae40c768b3a5fb711720ac23630639270",
      "size": 540
    },
    "/lib/mobility-core/src/Kernel/Beam/Lib/Utils.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n\nmodule Kernel.Beam.Lib.Utils where\n\nimport Data.Aeson as A\nimport qualified Data.Aeson.Key as AesonKey\nimport qualified Data.Aeson.KeyMap as AKM\nimport qualified Data.ByteString.Lazy as LBS\nimport qualified Data.HashMap.Strict as HM\nimport Data.Text as T hiding (elem, map)\nimport qualified Data.Text.Encoding as TE\nimport Data.Time\nimport Data.Time.Clock.POSIX (utcTimeToPOSIXSeconds)\nimport qualified EulerHS.KVConnector.Types as KV\nimport EulerHS.KVConnector.Utils (getShardedHashTag)\nimport qualified EulerHS.Language as L\nimport EulerHS.Prelude\nimport qualified Kafka.Producer as KafkaProd\nimport Kernel.Beam.Types (KafkaConn (..))\nimport Kernel.Types.App\nimport Kernel.Types.Error\nimport Kernel.Utils.Error.Throwing (throwError)\nimport Text.Casing (camel, quietSnake)\n\ntextToSnakeCaseText :: Text -> Text\ntextToSnakeCaseText = T.pack . quietSnake . T.unpack\n\nreplaceMappings :: A.Value -> HM.HashMap Text Text -> A.Value\nreplaceMappings (A.Object obj) mapp =\n  A.Object $\n    AKM.fromList $\n      map (\\(key, val) -> (AesonKey.fromText (textToSnakeCaseText $ fromMaybe (AesonKey.toText key) (HM.lookup (AesonKey.toText key) mapp)), convertIntoValidValForCkh val)) $\n        AKM.toList obj\nreplaceMappings x _ = x\n\nconvertIntoValidValForCkh :: A.Value -> A.Value\nconvertIntoValidValForCkh dbValue = case dbValue of\n  A.String text' -> case parseTimeM True defaultTimeLocale \"%Y-%m-%dT%H:%M:%S%QZ\" (T.unpack text')\n    <|> parseTimeM True defaultTimeLocale \"%Y-%m-%dT%H:%M:%S%Q\" (T.unpack text') of\n    Nothing -> A.String text'\n    Just x -> A.Number $ fromInteger $ round (realToFrac (utcTimeToPOSIXSeconds x) :: Double)\n  A.Bool val -> if val then A.String \"True\" else A.String \"False\"\n  _ -> dbValue\n\ngetMappings ::\n  forall table.\n  KV.TableMappings (table Identity) =>\n  [table Identity] ->\n  HashMap Text Text\ngetMappings _ = HM.fromList (map (bimap T.pack T.pack) (KV.getTableMappings @(table Identity)))\n\npushToKafka :: (MonadFlow m, ToJSON a) => a -> Text -> Text -> m ()\npushToKafka messageRecord topic key = do\n  kafkaProducerTools <- L.getOption KafkaConn\n  case kafkaProducerTools of\n    Nothing -> throwError $ InternalError \"Kafka producer tools not found\"\n    Just kafkaProducerTools' -> do\n      mbErr <- KafkaProd.produceMessage kafkaProducerTools'.producer (kafkaMessage topic messageRecord key)\n      whenJust mbErr (throwError . KafkaUnableToProduceMessage)\n\nkafkaMessage :: ToJSON a => Text -> a -> Text -> KafkaProd.ProducerRecord\nkafkaMessage topicName event key =\n  KafkaProd.ProducerRecord\n    { prTopic = KafkaProd.TopicName topicName,\n      prPartition = KafkaProd.UnassignedPartition,\n      prKey = Just $ TE.encodeUtf8 key,\n      prValue = Just . LBS.toStrict $ encode event\n    }\n\ngetKafkaTopic :: (MonadFlow m) => Maybe Text -> Text -> m Text\ngetKafkaTopic mSchema model = do\n  let topicName = T.toLower $ T.pack (camel (T.unpack model))\n  modelName <- maybe (L.throwException $ InternalError \"Schema not found\") pure mSchema\n  case modelName of\n    \"atlas_driver_offer_bpp\" -> pure (\"adob-sessionizer-\" <> topicName)\n    \"atlas_app\" -> pure (\"aap-sessionizer-\" <> topicName)\n    \"atlas_bpp_dashboard\" -> pure (\"abd-sessionizer-\" <> topicName)\n    \"atlas_bap_dashboard\" -> pure (\"aad-sessionizer-\" <> topicName)\n    r -> pure (r <> \"-sessionizer-\" <> topicName)\n\ngetKeyForKafka :: (Int, Int) -> Text -> Text\ngetKeyForKafka tableShardModRange pKeyText = do\n  let shard = getShardedHashTag tableShardModRange pKeyText\n  pKeyText <> shard\n\n-- commenting in case we need it in future\n-- tableInKafka :: L.MonadFlow m => Text -> m Bool\n-- tableInKafka modelName = do\n--   tables <- L.getOption KBT.Tables\n--   case tables of\n--     Nothing -> pure False\n--     Just tables' -> pure $ modelName `elem` (tables'.kafkaNonKVTables)\n",
      "hash": "fc29cfaa5beca8ca2fe619a485d5dd35860bdb3ac82f21a917e3466e29069938",
      "size": 4454
    },
    "/lib/mobility-core/src/Kernel/Beam/Lib/UtilsTH.hs": {
      "type": "content",
      "content": "{-# LANGUAGE TemplateHaskell #-}\n{-# OPTIONS_GHC -Wno-orphans #-}\n\nmodule Kernel.Beam.Lib.UtilsTH\n  ( enableKVPG,\n    HasSchemaName (..),\n    mkTableInstances,\n    mkTableInstancesWithTModifier,\n    mkTableInstancesGenericSchema,\n    mkTableInstancesGenericSchemaWithTModifier,\n    mkBeamInstancesForEnum,\n    mkBeamInstancesForList,\n    mkBeamInstancesForEnumAndList,\n    mkBeamInstancesForJSON,\n    mkCustomMappings,\n  )\nwhere\n\nimport qualified Data.Aeson as A\nimport qualified Data.HashMap.Internal as HMI\nimport qualified Data.HashMap.Strict as HM\nimport Data.List (init, lookup, (!!))\nimport Data.List.Extra (anySame)\nimport qualified Data.Map.Strict as M\nimport qualified Data.Serialize as Serialize\nimport qualified Data.Text as T\nimport qualified Data.Vector as V\nimport qualified Database.Beam as B\nimport Database.Beam.Backend\nimport Database.Beam.Postgres (Postgres)\nimport qualified Database.Beam.Schema.Tables as B\nimport Database.PostgreSQL.Simple.FromField (FromField (fromField), ResultError (UnexpectedNull))\nimport qualified Database.PostgreSQL.Simple.FromField as DPSF\nimport qualified EulerHS.KVConnector.Types as KV\nimport EulerHS.Prelude hiding (Type, words)\nimport Kernel.Beam.Lib.SqlObjectInstances ()\nimport Kernel.Types.Common ()\nimport Kernel.Types.FromField (fromFieldEnum, fromFieldJSON)\nimport Kernel.Utils.Text (encodeToText)\nimport Language.Haskell.TH\nimport qualified Sequelize as S\nimport Sequelize.SQLObject (SQLObject (..), ToSQLObject (convertToSQLObject))\nimport Text.Casing (camel, quietSnake)\nimport Prelude (head)\nimport qualified Prelude as P\n\n-- | WARNING! Instances should be defined in application itself to avoid overlapping\nclass HasSchemaName tn where\n  schemaName :: Proxy tn -> Text\n\n--- templates ---\n\nemptyTextHashMap :: HMI.HashMap Text Text\nemptyTextHashMap = HMI.empty\n\nemptyValueHashMap :: M.Map Text (A.Value -> A.Value)\nemptyValueHashMap = M.empty\n\nenableKVPG :: Name -> [Name] -> [[Name]] -> Q [Dec]\nenableKVPG name pKeyN sKeysN = do\n  [tModeMeshSig, tModeMeshDec] <- tableTModMeshD name\n  [kvConnectorDec] <- kvConnectorInstancesD name pKeyN sKeysN\n  [meshMetaDec] <- meshMetaInstancesDPG name\n  sqlObjectToJSONInstance <- mkSQLObjectToJSONInstance name\n  pure [tModeMeshSig, tModeMeshDec, meshMetaDec, kvConnectorDec, sqlObjectToJSONInstance] -- ++ cerealDec\n  -- DB.OrderReferenceT (B.FieldModification (B.TableField DB.OrderReferenceT)) add signature\n\ntableTModMeshD :: Name -> Q [Dec]\ntableTModMeshD name = do\n  let tableTModMeshN = mkName $ camel (nameBase name) <> \"ModMesh\"\n  names <- extractRecFields . head . extractConstructors <$> reify name\n  let recExps = (\\name' -> (name', AppE (VarE 'B.fieldNamed) (LitE $ StringL $ nameBase name'))) <$> names\n  return\n    [ SigD tableTModMeshN (AppT (ConT name) (AppT (ConT ''B.FieldModification) (AppT (ConT ''B.TableField) (ConT name)))),\n      FunD tableTModMeshN [Clause [] (NormalB (RecUpdE (VarE 'B.tableModification) recExps)) []]\n    ]\n\n------------------------------------------------------------------\n-- class KVConnector table where\n--   tableName :: Text\n--   keyMap :: HM.HashMap Text Bool -- True implies it is primary key and False implies secondary\n--   primaryKey :: table -> PrimaryKey\n--   secondaryKeys:: table -> [SecondaryKey]\nkvConnectorInstancesD :: Name -> [Name] -> [[Name]] -> Q [Dec]\nkvConnectorInstancesD name pKeyN sKeysN = do\n  let pKey = sortAndGetKey pKeyN\n      sKeys = filter (\\k -> pKey /= sortAndGetKey k) sKeysN\n      pKeyPair = TupE [Just $ LitE $ StringL pKey, Just $ ConE 'True]\n      sKeyPairs = map (\\k -> TupE [Just $ LitE $ StringL $ sortAndGetKey k, Just $ ConE 'False]) sKeys\n  let tableNameD = FunD 'KV.tableName [Clause [] (NormalB (LitE (StringL $ init $ camel (nameBase name)))) []]\n      keyMapD = FunD 'KV.keyMap [Clause [] (NormalB (AppE (VarE 'HM.fromList) (ListE (pKeyPair : sKeyPairs)))) []]\n      primaryKeyD = FunD 'KV.primaryKey [Clause [] (NormalB getPrimaryKeyE) []]\n      secondaryKeysD = FunD 'KV.secondaryKeys [Clause [] (NormalB getSecondaryKeysE) []]\n  mkSQLObjectD <- genMkSQLObjectD name\n  return [InstanceD Nothing [] (AppT (ConT ''KV.KVConnector) (AppT (ConT name) (ConT $ mkName \"Identity\"))) [tableNameD, keyMapD, primaryKeyD, secondaryKeysD, mkSQLObjectD]]\n  where\n    getPrimaryKeyE =\n      let obj = mkName \"obj\"\n       in LamE [VarP obj] (AppE (ConE 'KV.PKey) (ListE (map (\\n -> TupE [Just $ keyNameTextE n, Just $ getRecFieldE n obj]) pKeyN)))\n    getSecondaryKeysE =\n      if null sKeysN || sKeysN == [[]]\n        then LamE [WildP] (ListE [])\n        else do\n          let obj = mkName \"obj\"\n          LamE\n            [VarP obj]\n            ( ListE $\n                map\n                  (AppE (ConE 'KV.SKey) . ListE . map (\\n -> TupE [Just $ keyNameTextE n, Just $ getRecFieldE n obj]))\n                  sKeysN\n            )\n    getRecFieldE f obj =\n      let fieldName = (splitColon $ nameBase f)\n       in AppE (AppE (AppE (VarE 'utilTransform) (VarE 'emptyValueHashMap)) (LitE . StringL $ fieldName)) (AppE (VarE $ mkName fieldName) (VarE obj))\n    keyNameTextE n = AppE (VarE 'T.pack) (LitE $ StringL (splitColon $ nameBase n))\n\ngenMkSQLObjectD :: Name -> Q Dec\ngenMkSQLObjectD name = do\n  fieldNames <- extractRecFields . head . extractConstructors <$> reify name\n  let tName = mkName \"table\"\n  let fieldExps = fieldNames <&> (\\fieldName -> (fieldName, VarE 'convertToSQLObject `AppE` (VarE fieldName `AppE` VarE tName)))\n  pure $ FunD 'KV.mkSQLObject [Clause [VarP tName] (NormalB (VarE 'toJSON `AppTypeE` (ConT name `AppT` ConT ''SQLObject) `AppE` RecConE (mkName $ nameBase name) fieldExps)) []]\n\nsortAndGetKey :: [Name] -> String\nsortAndGetKey names = do\n  let sortedKeys = sort $ fmap (splitColon . nameBase) names\n  intercalate \"_\" sortedKeys\n\n--\"$sel:merchantId:OrderReference\" -> \"merchantId\"\nsplitColon :: String -> String\nsplitColon s = T.unpack $ T.splitOn \":\" (T.pack s) !! 1\n\n-------------------------------------------------------------------------------\nmeshMetaInstancesDPG :: Name -> Q [Dec]\nmeshMetaInstancesDPG name = do\n  names <- extractRecFields . head . extractConstructors <$> reify name\n  let modelTModMesh' = mkName $ camel (nameBase name) <> \"ModMesh\"\n  let meshModelFieldModificationD = FunD 'KV.meshModelFieldModification [Clause [] (NormalB (VarE modelTModMesh')) []]\n      valueMapperD = FunD 'KV.valueMapper [Clause [] (NormalB (VarE 'emptyValueHashMap)) []]\n  let parseFieldAndGetClauseD = getParseFieldAndGetClauseD name names\n      parseSetClauseD = getParseSetClauseD name names\n  return [InstanceD Nothing [] (AppT (AppT (ConT ''KV.MeshMeta) (ConT ''Postgres)) (ConT name)) [meshModelFieldModificationD, valueMapperD, parseFieldAndGetClauseD, parseSetClauseD]]\n\n--------------- parseFieldAndGetClause instance -------------------\ngetParseFieldAndGetClauseD :: Name -> [Name] -> Dec\ngetParseFieldAndGetClauseD name names = do\n  let obj = mkName \"obj\"\n      field = mkName \"fieldName\"\n  let patternMatches = (\\n -> Match (LitP $ StringL (nameBase n)) (NormalB (parseFieldAndGetClauseE name n)) []) <$> names\n      failExp = AppE (VarE 'fail) (LitE $ StringL (\"Where clause decoding failed for \" <> nameBase name <> \" - Unexpected column \" <> nameBase field))\n  let matchE = AppE (AppE (AppE (VarE 'HM.findWithDefault) (VarE field)) (VarE field)) (VarE 'emptyTextHashMap)\n      caseExp = CaseE matchE (patternMatches ++ [Match WildP (NormalB failExp) []])\n  FunD 'KV.parseFieldAndGetClause [Clause [VarP obj, VarP field] (NormalB caseExp) []]\n\nparseFieldAndGetClauseE :: Name -> Name -> Exp\nparseFieldAndGetClauseE name key = do\n  let v = mkName \"obj\"\n  let parseExp = AppE (AppE (VarE 'parseField) (LitE $ StringL $ nameBase name)) (AppE (AppE (modifyFieldToHS name) (LitE $ StringL $ nameBase key)) (VarE v))\n  AppE (AppE (VarE '(<$>)) (AppE (ConE 'KV.TermWrap) (VarE key))) parseExp\n\n--------------- parseSetClause instance -------------------\ngetParseSetClauseD :: Name -> [Name] -> Dec\ngetParseSetClauseD name names = do\n  let --fnName = mkName \"parseSetClause\"\n      obj = mkName \"obj\"\n      field = mkName \"fieldName\"\n      parseKeyAndValue = mkName \"parseKeyAndValue\"\n      setClause = mkName \"setClause\"\n  let patternMatches = (\\n -> Match (LitP $ StringL $ nameBase n) (NormalB (parseSetClauseE name n)) []) <$> names\n      failExp = AppE (VarE 'fail) (LitE $ StringL (\"Set clause decoding failed for \" <> nameBase name <> \" - Unexpected column \" <> nameBase field))\n  let matchE = AppE (AppE (AppE (VarE 'HM.findWithDefault) (VarE field)) (VarE field)) (VarE 'emptyTextHashMap)\n      caseExp = CaseE matchE (patternMatches ++ [Match WildP (NormalB failExp) []])\n  FunD\n    'KV.parseSetClause\n    [ Clause\n        [VarP setClause]\n        (NormalB (AppE (AppE (VarE 'mapM) (VarE parseKeyAndValue)) (VarE setClause)))\n        [FunD parseKeyAndValue [Clause [TupP [VarP field, VarP obj]] (NormalB caseExp) []]]\n    ]\n\nparseSetClauseE :: Name -> Name -> Exp\nparseSetClauseE name key = do\n  let v = mkName \"obj\"\n  let parseExp = AppE (AppE (VarE 'parseField) (LitE $ StringL $ nameBase name)) (AppE (AppE (modifyFieldToHS name) (LitE $ StringL $ nameBase key)) (VarE v))\n  AppE (AppE (VarE '(<$>)) (AppE (ConE 'S.Set) (VarE key))) parseExp\n\n------------------- Utils ------------------------\nparseField :: (FromJSON a, MonadFail f) => Text -> A.Value -> f a\nparseField modelName fieldObj = case A.fromJSON fieldObj of\n  A.Success res -> pure res\n  _ -> fail $ T.unpack $ \"Error while decoding - Unable to parse field for \" <> modelName <> \" model\"\n\n-- modifyFieldToHS k = M.findWithDefault P.id k txnDetailToHSModifiers\nmodifyFieldToHS :: Name -> Exp\nmodifyFieldToHS _ = do\n  let key = mkName \"keyToBeModified\"\n      val = mkName \"val\"\n  LamE [VarP key, VarP val] (AppE (AppE (AppE (AppE (VarE 'M.findWithDefault) (VarE 'P.id)) (VarE key)) (VarE 'emptyValueHashMap)) (VarE val))\n\nextractConstructors :: Info -> [Con]\nextractConstructors (TyConI (DataD _ _ _ _ cons _)) = cons\nextractConstructors (TyConI (NewtypeD _ _ _ _ cons _)) = [cons]\nextractConstructors _ = []\n\nextractRecFields :: Con -> [Name]\nextractRecFields (RecC _ bangs) = handleVarBang <$> bangs where handleVarBang (a, _, _) = a\nextractRecFields _ = []\n\nutilTransform :: (ToJSON a) => Map Text (A.Value -> A.Value) -> Text -> a -> Text\nutilTransform modifyMap field value = do\n  let res = case M.lookup field modifyMap of\n        Just fn -> fn . A.toJSON $ value\n        Nothing -> A.toJSON value\n  case res of\n    A.String r -> r\n    A.Number n -> T.pack $ show n\n    A.Bool b -> T.pack $ show b\n    A.Array l -> T.pack $ show l\n    A.Object o -> T.pack $ show o\n    A.Null -> T.pack \"\"\n\nmkEmod :: Name -> String -> Maybe String -> Q (Dec, Dec)\nmkEmod name table mbSchema = do\n  let schemaNameExp = mkSchemaNameExp name mbSchema\n      schemaNameContext = mkSchemaNameContext name mbSchema\n  let fnName = mkName $ (T.unpack . T.dropEnd 1 . T.pack $ camel (nameBase name)) <> \"Table\"\n      tableTModN = mkName $ camel (nameBase name) <> \"Mod\"\n      bodyExpr =\n        InfixE\n          (Just (AppE (VarE 'B.setEntitySchema) (AppE (ConE 'Just) schemaNameExp)))\n          (VarE '(<>))\n          ( Just\n              ( InfixE\n                  (Just (AppE (VarE 'B.setEntityName) (LitE $ StringL table)))\n                  (VarE '(<>))\n                  ( Just\n                      ( AppE\n                          (VarE 'B.modifyTableFields)\n                          (VarE tableTModN)\n                      )\n                  )\n              )\n          )\n  let beTypeVar = VarT $ mkName \"be\"\n      dbTypeVar = VarT $ mkName \"dn\"\n      fnTypeBody =\n        ForallT [] schemaNameContext $\n          ConT ''B.EntityModification\n            `AppT` (ConT ''B.DatabaseEntity `AppT` beTypeVar `AppT` dbTypeVar)\n            `AppT` beTypeVar\n            `AppT` (ConT ''B.TableEntity `AppT` ConT name)\n      fnSig = SigD fnName fnTypeBody\n      fnBody = FunD fnName [Clause [] (NormalB bodyExpr) []]\n  return (fnSig, fnBody)\n\nmkSchemaNameExp :: Name -> Maybe String -> Exp\nmkSchemaNameExp name = \\case\n  Nothing -> VarE 'schemaName `AppE` (ConE 'Proxy `AppTypeE` ConT name)\n  Just schema -> LitE $ StringL schema\n\nmkSchemaNameContext :: Name -> Maybe String -> Cxt\nmkSchemaNameContext name = \\case\n  Nothing -> [ConT ''HasSchemaName `AppT` ConT name]\n  Just _ -> []\n\nmkModelMetaInstances :: Name -> String -> Maybe String -> Q Dec\nmkModelMetaInstances name table mbSchema = do\n  let tableTModN = mkName $ camel (nameBase name) <> \"Mod\"\n      modelFMInstance = FunD 'S.modelFieldModification [Clause [] (NormalB (VarE tableTModN)) []]\n      modelNameInstance = FunD 'S.modelTableName [Clause [] (NormalB (LitE $ StringL table)) []]\n      schemaNameExp = mkSchemaNameExp name mbSchema\n      schemaNameContext = mkSchemaNameContext name mbSchema\n      modelSchemaInstance = FunD 'S.modelSchemaName [Clause [] (NormalB (AppE (ConE 'Just) schemaNameExp)) []]\n  return $ InstanceD Nothing schemaNameContext (AppT (ConT ''S.ModelMeta) (ConT name)) [modelFMInstance, modelNameInstance, modelSchemaInstance]\n\nmkTModFunction :: [(String, String)] -> Name -> Q (Dec, Dec)\nmkTModFunction tableFieldModifier name = do\n  let nameStr = nameBase name\n  mbTypeName <- lookupTypeName nameStr\n  typeName <- case mbTypeName of\n    Nothing -> fail $ nameStr <> \" should be type name\"\n    Just n -> pure n\n  tableTypeInfo <- reify typeName\n  fieldNames <- case tableTypeInfo of\n    TyConI dec -> do\n      case dec of\n        DataD _ _ _ _ [constructor] _ -> do\n          case constructor of\n            RecC _ records -> pure $ records <&> (\\(fieldName, _, _) -> fieldName)\n            _ -> fail $ nameStr <> \" should contain records\"\n        _ -> fail $ nameStr <> \" should be data type with one constructor\"\n    _ -> fail $ nameStr <> \" should be type name\"\n  let fieldNamesStr = nameBase <$> fieldNames\n  checkFieldModifier tableFieldModifier fieldNamesStr\n  let fieldExpressions =\n        fieldNames <&> \\fieldName -> do\n          let fieldNameStr = nameBase fieldName\n          let modifiedField = fromMaybe (quietSnake fieldNameStr) (lookup fieldNameStr tableFieldModifier)\n          (fieldName, VarE 'B.fieldNamed `AppE` LitE (StringL modifiedField))\n  let bodyExpr = RecUpdE (VarE 'B.tableModification) fieldExpressions\n      tableTModN = mkName $ camel (nameBase name) <> \"Mod\"\n      fnTypeBody =\n        ConT name\n          `AppT` (ConT ''B.FieldModification `AppT` (ConT ''B.TableField `AppT` ConT name))\n      fnSig = SigD tableTModN fnTypeBody\n      fnBody = FunD tableTModN [Clause [] (NormalB bodyExpr) []]\n  return (fnSig, fnBody)\n\ncheckFieldModifier :: [(String, String)] -> [String] -> Q ()\ncheckFieldModifier modifier fields = do\n  when (anySame (fst <$> modifier)) $\n    fail \"Duplicated fields in modifier\"\n  when (anySame (snd <$> modifier)) $\n    fail \"Duplicated fields after modifying\"\n  forM_ modifier $ \\(fieldBefore, _fieldAfter) -> do\n    unless (fieldBefore `elem` fields) $\n      fail (\"Field: \" <> fieldBefore <> \" does not exist\")\n\nmkSerialInstances :: Name -> Q Dec\nmkSerialInstances name = do\n  let putInstance = FunD 'Serialize.put [Clause [] (NormalB (AppE (VarE 'error) (LitE $ StringL \"\"))) []]\n      getInstance = FunD 'Serialize.get [Clause [] (NormalB (AppE (VarE 'error) (LitE $ StringL \"\"))) []]\n  return $ InstanceD Nothing [] (AppT (ConT ''Serialize.Serialize) (AppT (ConT name) (ConT $ mkName \"Identity\"))) [putInstance, getInstance]\n\nmkFromJSONInstance :: Name -> Q Dec\nmkFromJSONInstance name = do\n  let fromJSONFn = mkName \"parseJSON\"\n      fromJSONInstance = FunD fromJSONFn [Clause [] (NormalB (AppE (VarE 'A.genericParseJSON) (VarE 'A.defaultOptions))) []]\n  return $ InstanceD Nothing [] (AppT (ConT ''FromJSON) (AppT (ConT name) (ConT $ mkName \"Identity\"))) [fromJSONInstance]\n\nmkToJSONInstance :: Name -> Q Dec\nmkToJSONInstance name = do\n  let toJSONFn = mkName \"toJSON\"\n      toJSONInstance = FunD toJSONFn [Clause [] (NormalB (AppE (VarE 'A.genericToJSON) (VarE 'A.defaultOptions))) []]\n  return $ InstanceD Nothing [] (AppT (ConT ''ToJSON) (AppT (ConT name) (ConT $ mkName \"Identity\"))) [toJSONInstance]\n\nmkSQLObjectToJSONInstance :: Name -> Q Dec\nmkSQLObjectToJSONInstance name = do\n  let toJSONFn = mkName \"toJSON\"\n      toJSONInstance = FunD toJSONFn [Clause [] (NormalB (AppE (VarE 'A.genericToJSON) (VarE 'A.defaultOptions))) []]\n  return $ InstanceD Nothing [] (AppT (ConT ''ToJSON) (AppT (ConT name) (ConT ''SQLObject))) [toJSONInstance]\n\nmkShowInstance :: Name -> Q Dec\nmkShowInstance name = do\n  return $ StandaloneDerivD (Just StockStrategy) [] (AppT (ConT ''Show) (AppT (ConT name) (ConT $ mkName \"Identity\")))\n\nmkTableInstances :: Name -> String -> String -> Q [Dec]\nmkTableInstances name table schema = mkTableInstances' name table (Just schema) []\n\nmkTableInstancesWithTModifier :: Name -> String -> String -> [(String, String)] -> Q [Dec]\nmkTableInstancesWithTModifier name table schema = mkTableInstances' name table (Just schema)\n\nmkTableInstancesGenericSchema :: Name -> String -> Q [Dec]\nmkTableInstancesGenericSchema name table = mkTableInstances' name table Nothing []\n\nmkTableInstancesGenericSchemaWithTModifier :: Name -> String -> [(String, String)] -> Q [Dec]\nmkTableInstancesGenericSchemaWithTModifier name table = mkTableInstances' name table Nothing\n\nmkTableInstances' :: Name -> String -> Maybe String -> [(String, String)] -> Q [Dec]\nmkTableInstances' name table mbSchema tableFieldModifier = do\n  modelMetaInstances <- mkModelMetaInstances name table mbSchema\n  (eModSig, eModBody) <- mkEmod name table mbSchema\n  serialInstances <- mkSerialInstances name\n  fromJSONInstances <- mkFromJSONInstance name\n  toJSONInstances <- mkToJSONInstance name\n  customMappings <- mkCustomMappings name table tableFieldModifier\n  showInstances <- mkShowInstance name\n  (tModSig, tModBody) <- mkTModFunction tableFieldModifier name\n  pure ([tModSig, tModBody, modelMetaInstances, eModSig, eModBody, serialInstances, fromJSONInstances, toJSONInstances, showInstances] <> customMappings)\n\n------------------- instances for table row ---------------\n\nmkCustomMappings :: Name -> String -> [(String, String)] -> Q [Dec]\nmkCustomMappings name table valuePairs = do\n  let tableNameInstance = ValD (VarP 'KV.getTableName) (NormalB (LitE (StringL table))) []\n  let toJSONInstance = ValD (VarP 'KV.getTableMappings) (NormalB (ListE (map (\\(key, value) -> TupE [Just (LitE (StringL key)), Just (LitE (StringL value))]) valuePairs))) []\n  return [InstanceD Nothing [] (AppT (ConT ''KV.TableMappings) (AppT (ConT name) (ConT $ mkName \"Identity\"))) [toJSONInstance, tableNameInstance]]\n\n-- | A set of instances required for beam table row as enum.\nmkBeamInstancesForEnum :: Name -> Q [Dec]\nmkBeamInstancesForEnum name = do\n  let tyQ = pure (ConT name)\n  [d|\n    instance FromField $tyQ where\n      fromField = fromFieldEnum\n\n    instance HasSqlValueSyntax be String => HasSqlValueSyntax be $tyQ where\n      sqlValueSyntax = autoSqlValueSyntax\n\n    instance BeamSqlBackend be => B.HasSqlEqualityCheck be $tyQ\n\n    instance FromBackendRow Postgres $tyQ\n    |]\n\n-- | A set of instances required for beam table row as list.\nmkBeamInstancesForList :: Name -> Q [Dec]\nmkBeamInstancesForList name = do\n  let tyQ = pure (ConT name)\n  [d|\n    instance FromField [$tyQ] where\n      fromField f mbValue = case mbValue of\n        Nothing -> DPSF.returnError UnexpectedNull f mempty\n        Just _ -> V.toList <$> fromField f mbValue\n\n    instance FromField $tyQ where\n      fromField = fromFieldEnum\n\n    instance HasSqlValueSyntax be (V.Vector Text) => HasSqlValueSyntax be [$tyQ] where\n      sqlValueSyntax x = sqlValueSyntax (V.fromList (T.pack . show <$> x))\n\n    instance BeamSqlBackend be => B.HasSqlEqualityCheck be [$tyQ]\n\n    instance FromBackendRow Postgres [$tyQ]\n    |]\n\nmkBeamInstancesForEnumAndList :: Name -> Q [Dec]\nmkBeamInstancesForEnumAndList name = do\n  let tyQ = pure (ConT name)\n  [d|\n    instance FromField $tyQ where\n      fromField = fromFieldEnum\n\n    instance HasSqlValueSyntax be String => HasSqlValueSyntax be $tyQ where\n      sqlValueSyntax = autoSqlValueSyntax\n\n    instance BeamSqlBackend be => B.HasSqlEqualityCheck be $tyQ\n\n    instance FromBackendRow Postgres $tyQ\n\n    instance FromField [$tyQ] where\n      fromField f mbValue = case mbValue of\n        Nothing -> DPSF.returnError UnexpectedNull f mempty\n        Just _ -> V.toList <$> fromField f mbValue\n\n    instance HasSqlValueSyntax be (V.Vector Text) => HasSqlValueSyntax be [$tyQ] where\n      sqlValueSyntax x = sqlValueSyntax (V.fromList (T.pack . show <$> x))\n\n    instance BeamSqlBackend be => B.HasSqlEqualityCheck be [$tyQ]\n\n    instance FromBackendRow Postgres [$tyQ]\n    |]\n\n-- | A set of instances required for beam table row as json.\nmkBeamInstancesForJSON :: Name -> Q [Dec]\nmkBeamInstancesForJSON name = do\n  let tyQ = pure (ConT name)\n  [d|\n    instance FromField $tyQ where\n      fromField = fromFieldJSON\n\n    instance HasSqlValueSyntax be Text => HasSqlValueSyntax be $tyQ where\n      sqlValueSyntax = sqlValueSyntax . encodeToText\n\n    instance BeamSqlBackend be => B.HasSqlEqualityCheck be $tyQ\n\n    instance FromBackendRow Postgres $tyQ\n    |]\n",
      "hash": "164b9e22a9807e73d9bbcef2e521682728612fdb3963a3264f95b05d77631ad0",
      "size": 21078
    },
    "/lib/mobility-core/src/Kernel/Beam/Types.hs": {
      "type": "content",
      "content": "{-# HLINT ignore \"Use newtype instead of data\" #-}\n{-# LANGUAGE AllowAmbiguousTypes #-}\n{-# LANGUAGE DerivingStrategies #-}\n{-# OPTIONS_GHC -Wno-unrecognised-pragmas #-}\n\nmodule Kernel.Beam.Types where\n\nimport Data.Time.Clock\nimport qualified Database.Beam.Postgres as BP\nimport EulerHS.Prelude\nimport EulerHS.Types (DBConfig, OptionEntity)\nimport Kernel.Streaming.Kafka.Producer.Types\nimport qualified Kernel.Types.Common as KTC\n\ndata LogLevelLastUpdatedTime = LogLevelLastUpdatedTime\n  deriving stock (Generic, Typeable, Show, Eq, Ord)\n  deriving anyclass (ToJSON, FromJSON)\n\ninstance OptionEntity LogLevelLastUpdatedTime UTCTime\n\ndata DynamicLogLevelConfig = DynamicLogLevelConfig\n  deriving stock (Generic, Typeable, Show, Eq, Ord)\n  deriving anyclass (ToJSON, FromJSON)\n\ninstance OptionEntity DynamicLogLevelConfig (HashMap Text KTC.LogLevel)\n\ndata PsqlDbCfg = PsqlDbCfg\n  deriving stock (Generic, Typeable, Show, Eq)\n  deriving anyclass (ToJSON, FromJSON)\n\ninstance OptionEntity PsqlDbCfg (DBConfig BP.Pg)\n\ndata Tables = Tables\n  deriving stock (Generic, Typeable, Show, Eq)\n  deriving anyclass (ToJSON, FromJSON)\n\ninstance OptionEntity Tables KTC.Tables\n\ndata KvConfigLastUpdatedTime = KvConfigLastUpdatedTime\n  deriving stock (Generic, Typeable, Show, Eq, Ord)\n  deriving anyclass (ToJSON, FromJSON)\n\ninstance OptionEntity KvConfigLastUpdatedTime UTCTime\n\ndata KvConfigUpdateFrequency = KvConfigUpdateFrequency\n  deriving stock (Generic, Typeable, Show, Eq, Ord)\n  deriving anyclass (ToJSON, FromJSON)\n\ninstance OptionEntity KvConfigUpdateFrequency Int\n\ndata PsqlDbCfgR1 = PsqlDbCfgR1\n  deriving stock (Generic, Typeable, Show, Eq)\n  deriving anyclass (ToJSON, FromJSON)\n\ninstance OptionEntity PsqlDbCfgR1 (DBConfig BP.Pg)\n\nnewtype DatabaseError = DatabaseError\n  { errorMessage :: Text\n  }\n  deriving (Eq, Show, Generic)\n\ninstance Exception DatabaseError\n\ntype BeamFlow = ReaderT BeamState\n\ndata BeamState = BeamState\n  { dbConf :: DBConfig BP.Pg\n  }\n  deriving (Eq, Show, Generic)\n\ndata PsqlLocDbCfg = PsqlLocDbCfg\n  deriving stock (Generic, Typeable, Show, Eq)\n  deriving anyclass (ToJSON, FromJSON)\n\ninstance OptionEntity PsqlLocDbCfg (DBConfig BP.Pg)\n\ndata PsqlLocReplicaDbCfg = PsqlLocReplicaDbCfg\n  deriving stock (Generic, Typeable, Show, Eq)\n  deriving anyclass (ToJSON, FromJSON)\n\ninstance OptionEntity PsqlLocReplicaDbCfg (DBConfig BP.Pg)\n\ndata ReplicaEnabled = ReplicaEnabled\n  deriving stock (Generic, Typeable, Show, Eq)\n  deriving anyclass (ToJSON, FromJSON)\n\ninstance OptionEntity ReplicaEnabled Bool\n\ndata MasterReadEnabled = MasterReadEnabled\n  deriving stock (Generic, Typeable, Show, Eq)\n  deriving anyclass (ToJSON, FromJSON)\n\ninstance OptionEntity MasterReadEnabled Bool\n\ndata KafkaConn = KafkaConn\n  deriving stock (Generic, Typeable, Show, Eq)\n  deriving anyclass (ToJSON, FromJSON)\n\ninstance OptionEntity KafkaConn KafkaProducerTools\n",
      "hash": "a12b1da4304cfd8c08373e8335468d2b8ef0384876576b0e7740dea68d1001f7",
      "size": 2867
    },
    "/lib/mobility-core/src/Kernel/Exit.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n\nmodule Kernel.Exit where\n\nimport System.Exit (ExitCode (..))\n\nexitSuccess :: ExitCode\nexitSuccess = ExitSuccess\n\nexitAuthManagerPrepFailure :: ExitCode\nexitAuthManagerPrepFailure = ExitFailure 1\n\nexitDBConnPrepFailure :: ExitCode\nexitDBConnPrepFailure = ExitFailure 2\n\nexitDBMigrationFailure :: ExitCode\nexitDBMigrationFailure = ExitFailure 3\n\nexitLoadAllProvidersFailure :: ExitCode\nexitLoadAllProvidersFailure = ExitFailure 4\n\nexitRedisConnPrepFailure :: ExitCode\nexitRedisConnPrepFailure = ExitFailure 5\n\nexitConnCheckFailure :: ExitCode\nexitConnCheckFailure = ExitFailure 8\n\nexitBuildingAppEnvFailure :: ExitCode\nexitBuildingAppEnvFailure = ExitFailure 9\n",
      "hash": "8e9471cb9605b451718252ce2bb1e856c779795611577ddc31cea26ececd99f3",
      "size": 1353
    },
    "/lib/mobility-core/src/Kernel/External/AadhaarVerification.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n\nmodule Kernel.External.AadhaarVerification (module Reexport) where\n\nimport Kernel.External.AadhaarVerification.Interface as Reexport\n",
      "hash": "d2c299dc8371fbfa3544e8c535dee2b9fdf426bd15bba079fc377d9ab187c316",
      "size": 827
    },
    "/lib/mobility-core/src/Kernel/External/AadhaarVerification/Gridline/API.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n\nmodule Kernel.External.AadhaarVerification.Gridline.API\n  ( GenerateAadhaarOtpAPI,\n    generateAadhaarOtpAPI,\n    generateAadhaarOtp,\n    VerifyAadhaarOtpAPI,\n    verifyAadhaarOtpAPI,\n    verifyAadhaarOtp,\n  )\nwhere\n\nimport qualified EulerHS.Types as T\nimport qualified Kernel.External.AadhaarVerification.Gridline.Types as Gridline\nimport Kernel.Prelude\nimport Servant (Header, Post, ReqBody, (:>))\n\ntype GenerateAadhaarOtpAPI =\n  \"aadhaar-api\"\n    :> \"boson\"\n    :> \"generate-otp\"\n    :> Header \"X-API-Key\" Text\n    :> Header \"X-Auth-Type\" Text\n    :> ReqBody '[Gridline.AADHAARJSON] Gridline.GridlineAadhaarOtpReq\n    :> Post '[Gridline.AADHAARJSON] Gridline.GridlineVerifyAadhaarResp\n\ngenerateAadhaarOtpAPI :: Proxy GenerateAadhaarOtpAPI\ngenerateAadhaarOtpAPI = Proxy\n\ngenerateAadhaarOtp ::\n  Maybe Text ->\n  Maybe Text ->\n  Gridline.GridlineAadhaarOtpReq ->\n  T.EulerClient Gridline.GridlineVerifyAadhaarResp\ngenerateAadhaarOtp = T.client generateAadhaarOtpAPI\n\ntype VerifyAadhaarOtpAPI =\n  \"aadhaar-api\"\n    :> \"boson\"\n    :> \"submit-otp\"\n    :> Header \"X-API-Key\" Text\n    :> Header \"X-Auth-Type\" Text\n    :> Header \"X-Transaction-ID\" Text\n    :> ReqBody '[Gridline.AADHAARJSON] Gridline.GridlineAadhaarOtpVerifyReq\n    :> Post '[Gridline.AADHAARJSON] Gridline.GridlineSubmitResponse\n\nverifyAadhaarOtpAPI :: Proxy VerifyAadhaarOtpAPI\nverifyAadhaarOtpAPI = Proxy\n\nverifyAadhaarOtp ::\n  Maybe Text ->\n  Maybe Text ->\n  Maybe Text ->\n  Gridline.GridlineAadhaarOtpVerifyReq ->\n  T.EulerClient Gridline.GridlineSubmitResponse\nverifyAadhaarOtp = T.client verifyAadhaarOtpAPI\n",
      "hash": "28f29788b3d702ca05a6d7cca6cd639130cbe55b8e625a9484006c47a23a2f01",
      "size": 2270
    },
    "/lib/mobility-core/src/Kernel/External/AadhaarVerification/Gridline/Client.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n\nmodule Kernel.External.AadhaarVerification.Gridline.Client where\n\nimport qualified Data.Text as T\nimport qualified EulerHS.Types as ET\nimport Kernel.External.AadhaarVerification.Gridline.API as API\nimport Kernel.External.AadhaarVerification.Gridline.Config\nimport Kernel.External.AadhaarVerification.Gridline.Error\nimport qualified Kernel.External.AadhaarVerification.Gridline.Types as Gridline\nimport Kernel.Prelude\nimport Kernel.Tools.Metrics.CoreMetrics.Types\nimport Kernel.Types.Common\nimport Kernel.Utils.Common hiding (Error)\n\ngenerateAadhaarOtp ::\n  ( MonadFlow m,\n    CoreMetrics m\n  ) =>\n  BaseUrl ->\n  Text ->\n  Text ->\n  Gridline.GridlineAadhaarOtpReq ->\n  m Gridline.GridlineVerifyAadhaarResp\ngenerateAadhaarOtp url apiKey authType req = do\n  let client = API.generateAadhaarOtp (Just apiKey) (Just authType) req\n  callGridlineAPI url client \"generateAadhaarOtp\" API.generateAadhaarOtpAPI\n    >>= validateGenerateResponseStatus\n\nverifyAadhaarOtp ::\n  ( MonadFlow m,\n    CoreMetrics m\n  ) =>\n  BaseUrl ->\n  Text ->\n  Text ->\n  Text ->\n  Gridline.GridlineAadhaarOtpVerifyReq ->\n  m Gridline.GridlineSubmitResponse\nverifyAadhaarOtp url apiKey authType transactionId req = do\n  let client = API.verifyAadhaarOtp (Just apiKey) (Just authType) (Just transactionId) req\n  callGridlineAPI url client \"verifyAadhaarOtp\" API.verifyAadhaarOtpAPI\n    >>= validateVerifyResponseStatus\n\ncallGridlineAPI :: CallAPI env api res\ncallGridlineAPI = callApiUnwrappingApiError (identity @GridlineError) (Just $ ET.ManagerSelector $ T.pack gridlineHttpManagerKey) (Just \"GRIDLINE_ERROR\") Nothing\n\nvalidateGenerateResponseStatus :: (MonadThrow m, Log m) => Gridline.GridlineVerifyAadhaarResp -> m Gridline.GridlineVerifyAadhaarResp\nvalidateGenerateResponseStatus response = do\n  let code = response._data.code\n  case code of\n    \"1008\" -> throwError NoMobileNumberRegistered\n    \"1011\" -> throwError ExceedOtpGenerationLimit\n    \"1012\" -> throwError AadhaarNumberNotExist\n    _ -> pure response\n\nvalidateVerifyResponseStatus :: (MonadThrow m, Log m) => Gridline.GridlineSubmitResponse -> m Gridline.GridlineSubmitResponse\nvalidateVerifyResponseStatus response = do\n  let code = response._data.code\n  case code of\n    \"1003\" -> throwError SessionExpired\n    \"1005\" -> throwError OtpAttemptExceeded\n    _ -> pure response\n",
      "hash": "8e11fce874155e509b3858b785ae838bd5b0a6d2a059a748183e0a3e1800188f",
      "size": 3003
    },
    "/lib/mobility-core/src/Kernel/External/AadhaarVerification/Gridline/Config.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n{-# LANGUAGE DerivingStrategies #-}\n\nmodule Kernel.External.AadhaarVerification.Gridline.Config where\n\nimport qualified Data.HashMap.Internal as HMap\nimport qualified Data.Text as DT\nimport EulerHS.Prelude\nimport Kernel.External.Encryption\nimport Kernel.Prelude\nimport Network.HTTP.Client as Http\nimport Network.HTTP.Client.TLS as Http\n\ndata GridlineCfg = GridlineCfg\n  { apiKey :: EncryptedField 'AsEncrypted Text,\n    authType :: Text,\n    url :: BaseUrl\n  }\n  deriving stock (Show, Eq, Generic)\n  deriving anyclass (FromJSON, ToJSON)\n\nprepareGridlineHttpManager :: Int -> HMap.HashMap DT.Text Http.ManagerSettings\nprepareGridlineHttpManager timeout =\n  HMap.singleton (DT.pack gridlineHttpManagerKey) $\n    Http.tlsManagerSettings {Http.managerResponseTimeout = Http.responseTimeoutMicro (timeout * 1000)}\n\ngridlineHttpManagerKey :: String\ngridlineHttpManagerKey = \"gridline-http-manager\"\n",
      "hash": "1cfdbb95596a69cb102ebcabdd39d958fa21e00f2dce24e9d2fdd3b6ac93d858",
      "size": 1585
    },
    "/lib/mobility-core/src/Kernel/External/AadhaarVerification/Gridline/Error.hs": {
      "type": "content",
      "content": "{-\n Copyright 2022-23, Juspay India Pvt Ltd\n\n This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program\n\n is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n\n or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of\n\n the GNU Affero General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n{-# LANGUAGE DeriveAnyClass #-}\n{-# LANGUAGE TemplateHaskell #-}\n\nmodule Kernel.External.AadhaarVerification.Gridline.Error where\n\nimport Data.Aeson\nimport Kernel.Prelude\nimport Kernel.Types.Error.BaseError\nimport Kernel.Types.Error.BaseError.HTTPError\nimport Kernel.Types.Error.BaseError.HTTPError.FromResponse (FromResponse (fromResponse))\nimport Servant.Client (ResponseF (responseBody))\n\nnewtype GridlineErrorResp = GridlineErrorResp\n  { _error :: GridlineErrorRespBody\n  }\n  deriving (Eq, Generic, Show, ToJSON)\n\ninstance FromJSON GridlineErrorResp where\n  parseJSON = withObject \"GridlineErrorResp\" $ \\v -> do\n    _error <- v .: \"error\"\n    return (GridlineErrorResp _error)\n\nnewtype GridlineErrorRespBody = GridlineErrorRespBody\n  { code :: Text\n  }\n  deriving (Eq, Generic, Show, FromJSON, ToJSON)\n\ndata GridlineError\n  = InvalidAadhaar\n  | OtpAlreadySent\n  | InvalidRequest\n  | NoMobileNumberRegistered\n  | ExceedOtpGenerationLimit\n  | AadhaarNumberNotExist\n  | InvalidOtp\n  | NoShareCode\n  | WrongShareCode\n  | InvalidShareCode\n  | SessionExpired\n  | OtpAttemptExceeded\n  | UpstreamInternalServerError\n  | TransactionAlreadyCompleted\n  | SomethingWentWrong\n  deriving (Eq, Show, IsBecknAPIError)\n\ninstanceExceptionWithParent 'HTTPException ''GridlineError\n\ninstance FromResponse GridlineError where\n  fromResponse resp = do\n    let mRespBody = decode $ responseBody resp\n    case mRespBody of\n      Just (respBody :: GridlineErrorResp) ->\n        case respBody._error.code of\n          \"INVALID_AADHAAR\" -> Just InvalidAadhaar\n          \"OTP_ALREADY_SENT\" -> Just OtpAlreadySent\n          \"INVALID_OTP\" -> Just InvalidOtp\n          \"NO_SHARE_CODE\" -> Just NoShareCode\n          \"WRONG_SHARE_CODE\" -> Just WrongShareCode\n          \"INVALID_SHARE_CODE\" -> Just InvalidShareCode\n          \"UPSTREAM_INTERNAL_SERVER_ERROR\" -> Just UpstreamInternalServerError\n          \"TRANSACTION_ALREADY_COMPLETED\" -> Just TransactionAlreadyCompleted\n          _ -> Just InvalidRequest\n      Nothing -> Just SomethingWentWrong\n\ninstance IsBaseError GridlineError where\n  toMessage = \\case\n    InvalidAadhaar -> Just \"Invalid Aadhaar Number.\"\n    OtpAlreadySent -> Just \"OTP already sent. Please try after 60 seconds.\"\n    InvalidRequest -> Just \"Invalid Request\"\n    NoMobileNumberRegistered -> Just \"Aadhaar number does not have a mobile number registered with it.\"\n    ExceedOtpGenerationLimit -> Just \"Exceeded Maximum OTP generation Limit. Please try again in some time.\"\n    AadhaarNumberNotExist -> Just \"Aadhaar number does not exist.\"\n    InvalidOtp -> Just \"Invalid OTP\"\n    NoShareCode -> Just \"No share code provided\"\n    WrongShareCode -> Just \"Wrong share code\"\n    InvalidShareCode -> Just \"Invalid share code. Length should be 4 and should only contain numbers.\"\n    SessionExpired -> Just \"Session Expired. Please start the process again.\"\n    OtpAttemptExceeded -> Just \"OTP attempts exceeded. Please start the process again\"\n    UpstreamInternalServerError -> Just \"Upstream source/Government source internal server error. Please start the process again.\"\n    TransactionAlreadyCompleted -> Just \"Transaction already completed. Cannot do further operation on this transaction.\"\n    SomethingWentWrong -> Just \"Something went wrong\"\n\ninstance IsHTTPError GridlineError where\n  toErrorCode = \\case\n    InvalidAadhaar -> \"INVALID_AADHAAR\"\n    OtpAlreadySent -> \"OTP_ALREADY_SENT\"\n    InvalidRequest -> \"INVALID_REQUEST\"\n    NoMobileNumberRegistered -> \"NO_MOBILE_NUMBER_REGISTERED\"\n    ExceedOtpGenerationLimit -> \"EXCEED_OTP_GENERATION_LIMIT\"\n    AadhaarNumberNotExist -> \"AADHAAR_NUMBER_NOT_EXIST\"\n    InvalidOtp -> \"INVALID_OTP\"\n    NoShareCode -> \"NO_SHARE_CODE\"\n    WrongShareCode -> \"WRONG_SHARE_CODE\"\n    InvalidShareCode -> \"INVALID_SHARE_CODE\"\n    SessionExpired -> \"SESSION_EXPIRED\"\n    OtpAttemptExceeded -> \"OTP_ATTEMPT_EXCEEDED\"\n    UpstreamInternalServerError -> \"UPSTREAM_INTERNAL_SERVER_ERROR\"\n    TransactionAlreadyCompleted -> \"TRANSACTION_ALREADY_COMPLETED\"\n    SomethingWentWrong -> \"SOMETHING_WENT_WRONG\"\n\n  toHttpCode = \\case\n    InvalidAadhaar -> E400\n    OtpAlreadySent -> E400\n    InvalidRequest -> E400\n    NoMobileNumberRegistered -> E400\n    ExceedOtpGenerationLimit -> E400\n    AadhaarNumberNotExist -> E400\n    InvalidOtp -> E400\n    NoShareCode -> E400\n    WrongShareCode -> E400\n    InvalidShareCode -> E400\n    SessionExpired -> E400\n    OtpAttemptExceeded -> E400\n    UpstreamInternalServerError -> E400\n    TransactionAlreadyCompleted -> E400\n    SomethingWentWrong -> E500\n\ninstance IsAPIError GridlineError\n",
      "hash": "96ee836b273a2519d396d2332bb5f308dcf4f3a41a906f3a4f26714705a7fd99",
      "size": 5238
    },
    "/lib/mobility-core/src/Kernel/External/AadhaarVerification/Gridline/Types.hs": {
      "type": "content",
      "content": "{-\n Copyright 2022-23, Juspay India Pvt Ltd\n\n This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program\n\n is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n\n or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of\n\n the GNU Affero General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n{-# LANGUAGE DerivingStrategies #-}\n\nmodule Kernel.External.AadhaarVerification.Gridline.Types where\n\nimport Data.Aeson\nimport EulerHS.Prelude hiding (error, state)\nimport qualified Network.HTTP.Media as M\nimport qualified Servant.API as S\n\ndata AADHAARJSON deriving (Typeable)\n\ninstance S.Accept AADHAARJSON where\n  contentType _ = \"application\" M.// \"json\"\n\ninstance S.MimeRender AADHAARJSON GridlineAadhaarOtpReq where\n  mimeRender _ = encode\n\ninstance S.MimeUnrender AADHAARJSON GridlineAadhaarOtpReq where\n  mimeUnrender _ = eitherDecode\n\ninstance S.MimeRender AADHAARJSON GridlineSubmitResponse where\n  mimeRender _ = encode\n\ninstance S.MimeUnrender AADHAARJSON GridlineSubmitResponse where\n  mimeUnrender _ = eitherDecode\n\ninstance S.MimeRender AADHAARJSON GridlineVerifyAadhaarResp where\n  mimeRender _ = encode\n\ninstance S.MimeUnrender AADHAARJSON GridlineVerifyAadhaarResp where\n  mimeUnrender _ = eitherDecode\n\ninstance S.MimeRender AADHAARJSON GridlineAadhaarOtpVerifyReq where\n  mimeRender _ = encode\n\ninstance S.MimeUnrender AADHAARJSON GridlineAadhaarOtpVerifyReq where\n  mimeUnrender _ = eitherDecode\n\ndata GridlineAadhaarOtpReq = GridlineAadhaarOtpReq\n  { aadhaar_number :: Text,\n    consent :: Text\n  }\n  deriving (Generic, FromJSON, ToJSON, Show)\n\ndata GridlineVerifyAadhaarResp = GridlineVerifyAadhaarResp\n  { request_id :: Text,\n    status :: Int,\n    _data :: GridlineVerifyAadhaarData,\n    timestamp :: Int,\n    path :: Text\n  }\n  deriving (Show, Generic, ToJSON)\n\ndata GridlineVerifyAadhaarData = GridlineVerifyAadhaarData\n  { code :: Text,\n    message :: Text,\n    transaction_id :: Maybe Text\n  }\n  deriving (Show, Generic, ToJSON, FromJSON)\n\ninstance FromJSON GridlineVerifyAadhaarResp where\n  parseJSON = withObject \"GridlineVerifyAadhaarResp\" $ \\v -> do\n    request_id <- v .: \"request_id\"\n    path <- v .: \"path\"\n    status <- v .: \"status\"\n    timestamp <- v .: \"timestamp\"\n    _data <- v .: \"data\"\n    return (GridlineVerifyAadhaarResp request_id status _data timestamp path)\n\ndata GridlineAadhaarOtpVerifyReq = GridlineAadhaarOtpVerifyReq\n  { otp :: Int,\n    include_xml :: Bool,\n    share_code :: Text\n  }\n  deriving (Show, Generic, ToJSON, FromJSON)\n\ndata GridlineSubmitResponse = GridlineSubmitResponse\n  { _data :: GridlineSubmitAadhaarData,\n    request_id :: Text\n  }\n  deriving (Show, Generic, ToJSON)\n\ndata GridlineSubmitAadhaarData = GridlineSubmitAadhaarData\n  { aadhaar_data :: AadhaarData,\n    code :: Text,\n    transaction_id :: Text,\n    message :: Text,\n    share_code :: Text\n  }\n  deriving (Show, Generic, ToJSON, FromJSON)\n\ndata AadhaarData = AadhaarData\n  { name :: Text,\n    gender :: Text,\n    date_of_birth :: Text,\n    image :: Text\n  }\n  deriving (Show, Generic, ToJSON)\n\ninstance FromJSON GridlineSubmitResponse where\n  parseJSON = withObject \"GridlineSubmitResponse\" $ \\v -> do\n    _data <- v .: \"data\"\n    request_id <- v .: \"request_id\"\n    return (GridlineSubmitResponse _data request_id)\n\ninstance FromJSON AadhaarData where\n  parseJSON = withObject \"AadhaarData\" $ \\v -> do\n    name <- v .: \"name\"\n    gender <- v .: \"gender\"\n    date_of_birth <- v .: \"date_of_birth\"\n    image <- v .: \"photo_base64\"\n    return (AadhaarData name gender date_of_birth image)\n",
      "hash": "fe6d600a83e394334afcda936cfb3f4723396ee073e180b429d5d1c9ad04939b",
      "size": 3908
    },
    "/lib/mobility-core/src/Kernel/External/AadhaarVerification/Interface.hs": {
      "type": "content",
      "content": "{-\n Copyright 2022-23, Juspay India Pvt Ltd\n\n This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program\n\n is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n\n or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of\n\n the GNU Affero General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n\nmodule Kernel.External.AadhaarVerification.Interface\n  ( module Reexport,\n    generateAadhaarOtp,\n    verifyAadhaarOtp,\n  )\nwhere\n\nimport Kernel.External.AadhaarVerification.Gridline.Config as Reexport\nimport qualified Kernel.External.AadhaarVerification.Interface.Gridline as Gridline\nimport Kernel.External.AadhaarVerification.Interface.Types as Reexport\nimport Kernel.External.AadhaarVerification.Types as Reexport\nimport Kernel.Tools.Metrics.CoreMetrics.Types\nimport Kernel.Types.Common\n\ngenerateAadhaarOtp ::\n  ( EncFlow m r,\n    CoreMetrics m\n  ) =>\n  AadhaarVerificationServiceConfig ->\n  AadhaarOtpReq ->\n  m AadhaarVerificationResp\ngenerateAadhaarOtp serviceConfig req = case serviceConfig of\n  GridlineConfig cfg -> Gridline.generateAadhaarOtp cfg req\n\nverifyAadhaarOtp ::\n  ( EncFlow m r,\n    CoreMetrics m\n  ) =>\n  AadhaarVerificationServiceConfig ->\n  AadhaarOtpVerifyReq ->\n  m AadhaarOtpVerifyRes\nverifyAadhaarOtp serviceConfig req = case serviceConfig of\n  GridlineConfig cfg -> Gridline.verifyAadhaarOtp cfg req\n",
      "hash": "c0d97988caefe93883778f3d6191031c9a8a4d113cb2a6c7aeb077a163c2a822",
      "size": 1717
    },
    "/lib/mobility-core/src/Kernel/External/AadhaarVerification/Interface/Gridline.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n\nmodule Kernel.External.AadhaarVerification.Interface.Gridline where\n\nimport Kernel.External.AadhaarVerification.Gridline.Client as Gridline\nimport Kernel.External.AadhaarVerification.Gridline.Config\nimport qualified Kernel.External.AadhaarVerification.Gridline.Types as GT\nimport Kernel.External.AadhaarVerification.Interface.Types\nimport Kernel.External.Encryption\nimport Kernel.Prelude\nimport Kernel.Tools.Metrics.CoreMetrics (CoreMetrics)\n\ngenerateAadhaarOtp ::\n  ( EncFlow m r,\n    CoreMetrics m\n  ) =>\n  GridlineCfg ->\n  AadhaarOtpReq ->\n  m AadhaarVerificationResp\ngenerateAadhaarOtp cfg req = do\n  let url = cfg.url\n  apiKey <- decrypt cfg.apiKey\n  let authType = cfg.authType\n  let reqData =\n        GT.GridlineAadhaarOtpReq\n          { aadhaar_number = req.aadhaarNumber,\n            consent = req.consent\n          }\n  resp <- Gridline.generateAadhaarOtp url apiKey authType reqData\n  return $\n    AadhaarVerificationResp\n      { statusCode = resp._data.code,\n        message = resp._data.message,\n        transactionId = resp._data.transaction_id,\n        requestId = resp.request_id\n      }\n\nverifyAadhaarOtp ::\n  ( EncFlow m r,\n    CoreMetrics m\n  ) =>\n  GridlineCfg ->\n  AadhaarOtpVerifyReq ->\n  m AadhaarOtpVerifyRes\nverifyAadhaarOtp cfg req = do\n  let url = cfg.url\n  apiKey <- decrypt cfg.apiKey\n  let authType = cfg.authType\n  let transactionId = req.transactionId\n  let reqData =\n        GT.GridlineAadhaarOtpVerifyReq\n          { otp = req.otp,\n            include_xml = False,\n            share_code = req.shareCode\n          }\n  resp <- Gridline.verifyAadhaarOtp url apiKey authType transactionId reqData\n  return $\n    AadhaarOtpVerifyRes\n      { transactionId = resp._data.transaction_id,\n        message = resp._data.message,\n        code = resp._data.code,\n        name = resp._data.aadhaar_data.name,\n        gender = resp._data.aadhaar_data.gender,\n        date_of_birth = resp._data.aadhaar_data.date_of_birth,\n        share_code = resp._data.share_code,\n        image = resp._data.aadhaar_data.image,\n        request_id = resp.request_id\n      }\n",
      "hash": "ee6f7cd0cab386d790bd9cd1885e7d2ac95b4e04fef86e1de588dbca051b582d",
      "size": 2770
    },
    "/lib/mobility-core/src/Kernel/External/AadhaarVerification/Interface/Types.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n{-# LANGUAGE DerivingStrategies #-}\n\nmodule Kernel.External.AadhaarVerification.Interface.Types\n  ( module Kernel.External.AadhaarVerification.Interface.Types,\n  )\nwhere\n\nimport qualified Kernel.External.AadhaarVerification.Gridline.Config as Gridline\nimport Kernel.Prelude\n\nnewtype AadhaarVerificationServiceConfig = GridlineConfig Gridline.GridlineCfg\n  deriving stock (Show, Eq, Generic)\n  deriving anyclass (FromJSON, ToJSON)\n\ndata AadhaarVerificationResp = AadhaarVerificationResp\n  { statusCode :: Text,\n    message :: Text,\n    transactionId :: Maybe Text,\n    requestId :: Text\n  }\n  deriving (Show, Generic, ToSchema, ToJSON, FromJSON)\n\ndata AadhaarOtpReq = AadhaarOtpReq\n  { aadhaarNumber :: Text,\n    consent :: Text\n  }\n  deriving (Show, Generic, ToSchema, ToJSON, FromJSON)\n\ndata AadhaarOtpVerifyReq = AadhaarOtpVerifyReq\n  { otp :: Int,\n    shareCode :: Text,\n    transactionId :: Text\n  }\n  deriving (Show, Generic, ToSchema, ToJSON, FromJSON)\n\ndata AadhaarOtpVerifyRes = AadhaarOtpVerifyRes\n  { transactionId :: Text,\n    message :: Text,\n    code :: Text,\n    name :: Text,\n    gender :: Text,\n    date_of_birth :: Text,\n    share_code :: Text,\n    image :: Text,\n    request_id :: Text\n  }\n  deriving (Show, Generic, ToSchema, ToJSON, FromJSON)\n",
      "hash": "006e6e752c3c88e1e920ba4b3e7580fdd2f6603d898b4258ae3fe87abe836bc9",
      "size": 1956
    },
    "/lib/mobility-core/src/Kernel/External/AadhaarVerification/Types.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n{-# LANGUAGE InstanceSigs #-}\n{-# LANGUAGE TemplateHaskell #-}\n\nmodule Kernel.External.AadhaarVerification.Types\n  ( module Kernel.External.AadhaarVerification.Types,\n  )\nwhere\n\nimport qualified Data.Aeson as A\nimport Data.OpenApi\nimport Data.Text as T\nimport EulerHS.Prelude\nimport Kernel.Beam.Lib.UtilsTH (mkBeamInstancesForEnum)\nimport qualified Kernel.Prelude as KP\nimport Kernel.Storage.Esqueleto (derivePersistField)\n\ndata AadhaarVerificationService = Gridline\n  deriving (Show, Read, Eq, Ord, Generic, ToSchema)\n\ninstance FromJSON AadhaarVerificationService where -- remove this instance once you add more constructors to AadhaarVerificationService type.\n  parseJSON (A.String val) = maybe (fail (\"failed to parse String \" <> show val <> \" in AadhaarVerificationService type\")) pure (KP.readMaybe $ T.unpack val)\n  parseJSON (A.Array _) = pure Gridline\n  parseJSON e = fail $ \"unexpected type, expected String for AadhaarVerificationService\" <> show e\n\ninstance ToJSON AadhaarVerificationService where\n  toJSON Gridline = A.String (show Gridline)\n\n$(mkBeamInstancesForEnum ''AadhaarVerificationService)\n\navailableVerificationServices :: [AadhaarVerificationService]\navailableVerificationServices = [Gridline]\n\nderivePersistField \"AadhaarVerificationService\"\n",
      "hash": "9dc99aa4b430dbf6cae83b68e31274189fcfe2e267aa3414fde35d7809464c4d",
      "size": 1958
    },
    "/lib/mobility-core/src/Kernel/External/BackgroundVerification.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n\nmodule Kernel.External.BackgroundVerification (module Reexport) where\n\nimport Kernel.External.BackgroundVerification.Interface as Reexport\n",
      "hash": "b7c29759546c1ec8fe4647aa957874d022878de9bd56597ce780caaa0af53a9d",
      "size": 833
    },
    "/lib/mobility-core/src/Kernel/External/BackgroundVerification/Checkr/Config.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n{-# LANGUAGE DerivingStrategies #-}\n\nmodule Kernel.External.BackgroundVerification.Checkr.Config where\n\nimport Data.Aeson\nimport Kernel.External.Encryption\nimport Kernel.Prelude\n\ndata CheckrCfg = CheckrCfg\n  { apiKey :: EncryptedField 'AsEncrypted Text,\n    returnUrl :: BaseUrl,\n    url :: BaseUrl,\n    package :: Text\n  }\n  deriving stock (Show, Eq, Generic)\n  deriving anyclass (FromJSON, ToJSON)\n",
      "hash": "298a294e013655a5bd8a2e8beb71873bfc7601a58dc7668e85ba972cd13a170c",
      "size": 1093
    },
    "/lib/mobility-core/src/Kernel/External/BackgroundVerification/Checkr/Error.hs": {
      "type": "content",
      "content": "{-\n Copyright 2022-23, Juspay India Pvt Ltd\n\n This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program\n\n is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n\n or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of\n\n the GNU Affero General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n{-# LANGUAGE DeriveAnyClass #-}\n{-# LANGUAGE TemplateHaskell #-}\n\nmodule Kernel.External.BackgroundVerification.Checkr.Error where\n\nimport Data.Aeson\nimport Kernel.Prelude\nimport Kernel.Types.Error.BaseError\nimport Kernel.Types.Error.BaseError.HTTPError\nimport Kernel.Types.Error.BaseError.HTTPError.FromResponse (FromResponse (fromResponse))\nimport Servant.Client (ResponseF (responseBody))\n\nnewtype CheckrErrorResp = CheckrErrorResp\n  { _error :: [Text]\n  }\n  deriving (Eq, Generic, Show, ToJSON)\n\ninstance FromJSON CheckrErrorResp where\n  parseJSON = withObject \"CheckrErrorResp\" $ \\v -> do\n    _error <- v .: \"error\"\n    return (CheckrErrorResp _error)\n\ndata CheckrError\n  = InvalidSSN\n  | SSNAlreadyTaken\n  | InvalidZipcode\n  | InvalidEmail\n  | InvalidAge\n  | ReportLimitReached\n  | SomethingWentWrong Text\n  deriving (Eq, Show, IsBecknAPIError)\n\ninstanceExceptionWithParent 'HTTPException ''CheckrError\n\ninstance FromResponse CheckrError where\n  fromResponse resp = do\n    let mRespBody = decode $ responseBody resp\n    case mRespBody of\n      Just (respBody :: CheckrErrorResp) ->\n        case listToMaybe respBody._error of\n          Just \"SSN is invalid\" -> Just InvalidSSN\n          Just \"SSN is invalid. TIN was provided.\" -> Just InvalidSSN\n          Just \"SSN has already been taken\" -> Just SSNAlreadyTaken\n          Just \"Zipcode is invalid\" -> Just InvalidZipcode\n          Just \"Email is not a valid email address\" -> Just InvalidEmail\n          Just \"Candidate must be at least 18 years old\" -> Just InvalidAge\n          Just \"Candidate has reached the limit of Reports allowed\" -> Just ReportLimitReached\n          Just err -> Just $ SomethingWentWrong err\n          Nothing -> Just $ SomethingWentWrong \"UNKNOWN_ERROR\"\n      Nothing -> Just $ SomethingWentWrong \"UNKNOWN_ERROR\"\n\ninstance IsBaseError CheckrError where\n  toMessage = \\case\n    InvalidSSN -> Just \"SSN is invalid\"\n    SSNAlreadyTaken -> Just \"SSN has already been taken\"\n    InvalidZipcode -> Just \"Zipcode is invalid\"\n    InvalidEmail -> Just \"Email is not a valid email address\"\n    InvalidAge -> Just \"Candidate must be at least 18 years old\"\n    ReportLimitReached -> Just \"Candidate has reached the limit of Reports allowed\"\n    SomethingWentWrong err -> Just $ \"Something went wrong. Error: \" <> err\n\ninstance IsHTTPError CheckrError where\n  toErrorCode = \\case\n    InvalidSSN -> \"INVALID_SSN\"\n    SSNAlreadyTaken -> \"SSN_ALREADY_TAKEN\"\n    InvalidZipcode -> \"INVALID_ZIPCODE\"\n    InvalidEmail -> \"INVALID_EMAIL\"\n    InvalidAge -> \"INVALID_AGE\"\n    ReportLimitReached -> \"REPORT_LIMIT_REACHED\"\n    SomethingWentWrong _ -> \"SOMETHING_WENT_WRONG\"\n  toHttpCode = \\case\n    InvalidSSN -> E400\n    SSNAlreadyTaken -> E400\n    InvalidZipcode -> E400\n    InvalidEmail -> E400\n    InvalidAge -> E400\n    ReportLimitReached -> E400\n    SomethingWentWrong _ -> E500\n\ninstance IsAPIError CheckrError\n",
      "hash": "b32025f4fc6af7404a95513ee1520f98c1c7ab8a5f5411888a9552e0aa4c1eb4",
      "size": 3566
    },
    "/lib/mobility-core/src/Kernel/External/BackgroundVerification/Checkr/Flow.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n\nmodule Kernel.External.BackgroundVerification.Checkr.Flow where\n\nimport qualified Data.Text.Encoding as DT\nimport EulerHS.Prelude\nimport qualified EulerHS.Types as ET\nimport Kernel.External.BackgroundVerification.Checkr.Config\nimport Kernel.External.BackgroundVerification.Checkr.Error\nimport Kernel.External.BackgroundVerification.Checkr.Types\nimport Kernel.External.Encryption\nimport qualified Kernel.Tools.Metrics.CoreMetrics as Metrics\nimport Kernel.Utils.Common\nimport Servant\n\ncallCheckrAPI :: CallAPI' m api res res\ncallCheckrAPI = callApiUnwrappingApiError (identity @CheckrError) Nothing (Just \"CHECKR_ERROR\") Nothing\n\nmkBasicAuthData :: Text -> BasicAuthData\nmkBasicAuthData apiKey =\n  BasicAuthData\n    { basicAuthUsername = DT.encodeUtf8 apiKey,\n      basicAuthPassword = \"\"\n    }\n\ntype CreateCandidateAPI =\n  \"v1\" :> \"candidates\"\n    :> BasicAuth \"apikey-apitoken\" BasicAuthData\n    :> ReqBody '[FormUrlEncoded] CreateCandidateReq\n    :> Post '[JSON] CreateCandidateResp\n\ncreateCandidate ::\n  ( Metrics.CoreMetrics m,\n    MonadFlow m,\n    EncFlow m r\n  ) =>\n  CheckrCfg ->\n  CreateCandidateReq ->\n  m CreateCandidateResp\ncreateCandidate cfg CreateCandidateReq {..} = do\n  let proxy = Proxy @CreateCandidateAPI\n  apiKey <- decrypt cfg.apiKey\n  let eulerClient = ET.client proxy (mkBasicAuthData apiKey) (CreateCandidateReq {lastName = if maybe False ((> 2) . length) lastName then lastName else Nothing, ..})\n  callCheckrAPI cfg.url eulerClient \"create-candidate\" proxy\n\ntype CreateInvitationAPI =\n  \"v1\" :> \"invitations\"\n    :> BasicAuth \"apikey-apitoken\" BasicAuthData\n    :> ReqBody '[FormUrlEncoded] CreateInvitationReq\n    :> Post '[JSON] CreateInvitationResp\n\ncreateCheckrInvitation ::\n  ( Metrics.CoreMetrics m,\n    MonadFlow m,\n    EncFlow m r\n  ) =>\n  CheckrCfg ->\n  CreateInvitationReq ->\n  m CreateInvitationResp\ncreateCheckrInvitation cfg req = do\n  let proxy = Proxy @CreateInvitationAPI\n  apiKey <- decrypt cfg.apiKey\n  let eulerClient = ET.client proxy (mkBasicAuthData apiKey) req\n  callCheckrAPI cfg.url eulerClient \"create-invitation\" proxy\n\ntype GetInvitationAPI =\n  \"v1\" :> \"invitations\"\n    :> Capture \"invitationId\" Text\n    :> BasicAuth \"apikey-apitoken\" BasicAuthData\n    :> Get '[JSON] GetInvitationResp\n\ngetInvitationAPI :: Proxy GetInvitationAPI\ngetInvitationAPI = Proxy\n\ngetInvitation ::\n  ( Metrics.CoreMetrics m,\n    MonadFlow m,\n    EncFlow m r\n  ) =>\n  CheckrCfg ->\n  Text ->\n  m GetInvitationResp\ngetInvitation cfg invitationId = do\n  let proxy = Proxy @GetInvitationAPI\n  apiKey <- decrypt cfg.apiKey\n  let eulerClient = ET.client proxy invitationId (mkBasicAuthData apiKey)\n  callCheckrAPI cfg.url eulerClient \"get-invitation\" proxy\n\ntype GetReportAPI =\n  \"v1\" :> \"reports\"\n    :> Capture \"reportId\" Text\n    :> BasicAuth \"apikey-apitoken\" BasicAuthData\n    :> Get '[JSON] GetReportResp\n\ngetReport ::\n  ( Metrics.CoreMetrics m,\n    MonadFlow m,\n    EncFlow m r\n  ) =>\n  CheckrCfg ->\n  Text ->\n  m GetReportResp\ngetReport cfg reportId = do\n  let proxy = Proxy @GetReportAPI\n  apiKey <- decrypt cfg.apiKey\n  let eulerClient = ET.client proxy reportId (mkBasicAuthData apiKey)\n  callCheckrAPI cfg.url eulerClient \"get-report\" proxy\n",
      "hash": "4c2d355d346afee9d2eb4334e52c1ce4c7291f634f43f3501abcf445b0d432b8",
      "size": 4563
    },
    "/lib/mobility-core/src/Kernel/External/BackgroundVerification/Checkr/Types.hs": {
      "type": "content",
      "content": "{-# LANGUAGE DerivingStrategies #-}\n{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n{-# LANGUAGE OverloadedLists #-}\n\nmodule Kernel.External.BackgroundVerification.Checkr.Types where\n\nimport Data.Aeson\nimport qualified Data.Time as Time\nimport Kernel.Prelude\nimport Kernel.Types.Beckn.City\nimport Kernel.Types.Beckn.Country\nimport Kernel.Types.Beckn.IndianState\nimport Kernel.Utils.JSON\nimport Web.FormUrlEncoded (ToForm, toForm)\nimport Web.Internal.HttpApiData\n\ncastCityToCheckrCity :: City -> Text\ncastCityToCheckrCity Minneapolis = \"Minneapolis\"\ncastCityToCheckrCity _ = \"Minneapolis\"\n\ncastCountryToCheckrCountry :: Country -> Text\ncastCountryToCheckrCountry USA = \"US\"\ncastCountryToCheckrCountry _ = \"US\"\n\ncastStateToCheckrState :: IndianState -> Text\ncastStateToCheckrState Minnesota = \"MN\"\ncastStateToCheckrState _ = \"MN\"\n\ndata CreateCandidateReq = CreateCandidateReq\n  { email :: Text,\n    ssn :: Maybe Text,\n    firstName :: Text,\n    middleName :: Maybe Text,\n    lastName :: Maybe Text,\n    phone :: Maybe Text,\n    dob :: Maybe UTCTime,\n    workLocationCountry :: Country,\n    workLocationState :: IndianState,\n    workLocationCity :: City,\n    driverLicenseNumber :: Maybe Text,\n    driverLicenseState :: Maybe Text,\n    zipCode :: Maybe Text\n  }\n  deriving (Generic, Eq, Show)\n\ninstance ToForm CreateCandidateReq where\n  toForm CreateCandidateReq {..} =\n    [ (\"email\", toQueryParam email),\n      (\"first_name\", toQueryParam firstName),\n      (\"work_locations[][country]\", toQueryParam $ castCountryToCheckrCountry workLocationCountry),\n      (\"work_locations[][state]\", toQueryParam $ castStateToCheckrState workLocationState),\n      (\"work_locations[][city]\", toQueryParam $ castCityToCheckrCity workLocationCity)\n    ]\n      <> maybe [] (\\val -> [(\"ssn\", toQueryParam val)]) ssn\n      <> maybe [] (\\val -> [(\"middle_name\", toQueryParam val)]) middleName\n      <> maybe [] (\\val -> [(\"last_name\", toQueryParam val)]) lastName\n      <> maybe [] (\\val -> [(\"phone\", toQueryParam val)]) phone\n      <> maybe [] (\\val -> [(\"dob\", toQueryParam $ Time.formatTime Time.defaultTimeLocale \"%Y-%m-%d\" val)]) dob\n      <> maybe [] (\\val -> [(\"driver_license_number\", toQueryParam val)]) driverLicenseNumber\n      <> maybe [] (\\val -> [(\"driver_license_state\", toQueryParam val)]) driverLicenseState\n      <> maybe [] (\\val -> [(\"zipcode\", toQueryParam val)]) zipCode\n\nnewtype CreateCandidateResp = CreateCandidateResp\n  { id :: Text\n  }\n  deriving (Generic, Eq, Show)\n\ninstance FromJSON CreateCandidateResp where\n  parseJSON = genericParseJSON constructorsWithSnakeCase\n\ninstance ToJSON CreateCandidateResp where\n  toJSON = genericToJSON constructorsWithSnakeCase\n\ndata CreateInvitationReq = CreateInvitationReq\n  { candidateId :: Text,\n    package :: Text,\n    workLocationCountry :: Country,\n    workLocationState :: IndianState,\n    workLocationCity :: City\n  }\n  deriving (Generic, Eq, Show)\n\ninstance ToForm CreateInvitationReq where\n  toForm CreateInvitationReq {..} =\n    [ (\"candidate_id\", candidateId),\n      (\"package\", package),\n      (\"work_locations[][country]\", castCountryToCheckrCountry workLocationCountry),\n      (\"work_locations[][state]\", castStateToCheckrState workLocationState),\n      (\"work_locations[][city]\", castCityToCheckrCity workLocationCity)\n    ]\n\ndata CreateInvitationResp = CreateInvitationResp\n  { id :: Text,\n    invitationUrl :: BaseUrl,\n    expiresAt :: UTCTime\n  }\n  deriving (Generic, Eq, Show)\n\ninstance FromJSON CreateInvitationResp where\n  parseJSON = genericParseJSON constructorsWithSnakeCase\n\ninstance ToJSON CreateInvitationResp where\n  toJSON = genericToJSON constructorsWithSnakeCase\n\ndata GetInvitationResp = GetInvitationResp\n  { id :: Text,\n    invitationUrl :: BaseUrl,\n    status :: Text, -- \"pending | completed | expired\"\n    reportId :: Maybe Text,\n    expiresAt :: UTCTime\n  }\n  deriving (Generic, Eq, Show)\n\ninstance FromJSON GetInvitationResp where\n  parseJSON = genericParseJSON constructorsWithSnakeCase\n\ninstance ToJSON GetInvitationResp where\n  toJSON = genericToJSON constructorsWithSnakeCase\n\ndata GetReportResp = GetReportResp\n  { id :: Text,\n    adjudication :: Maybe Text, -- \"engaged | pre_adverse_action | post_adverse_action\"\n    status :: Text, -- \"pending | complete | suspended | dispute | canceled\"\n    assessment :: Maybe Text, -- \"eligible | review | escalated\"\n    reportId :: Maybe Text\n  }\n  deriving (Generic, Eq, Show)\n\ninstance FromJSON GetReportResp where\n  parseJSON = genericParseJSON constructorsWithSnakeCase\n\ninstance ToJSON GetReportResp where\n  toJSON = genericToJSON constructorsWithSnakeCase\n",
      "hash": "d95b6ee2d9529537ea4151fda2300ad1166bddfb8613ab82069e660115fadab5",
      "size": 5236
    },
    "/lib/mobility-core/src/Kernel/External/BackgroundVerification/Interface.hs": {
      "type": "content",
      "content": "module Kernel.External.BackgroundVerification.Interface\n  ( module Reexport,\n    module Kernel.External.BackgroundVerification.Interface,\n  )\nwhere\n\nimport Kernel.External.BackgroundVerification.Interface.Checkr as Checkr\nimport Kernel.External.BackgroundVerification.Interface.Types as Reexport\nimport Kernel.External.BackgroundVerification.Types\nimport Kernel.Prelude\nimport Kernel.Tools.Metrics.CoreMetrics\nimport Kernel.Types.Common\n\ncreateCandidate ::\n  ( EncFlow m r,\n    CoreMetrics m\n  ) =>\n  BackgroundVerificationServiceConfig ->\n  CreateCandidateReq ->\n  m CreateCandidateResp\ncreateCandidate serviceConfig req = case serviceConfig of\n  CheckrConfig cfg -> Checkr.createCandidate cfg req\n\ncreateInvitation ::\n  ( EncFlow m r,\n    CoreMetrics m\n  ) =>\n  BackgroundVerificationServiceConfig ->\n  CreateInvitationReqI ->\n  m CreateInvitationResp\ncreateInvitation serviceConfig req = case serviceConfig of\n  CheckrConfig cfg -> Checkr.createInvitation cfg req\n\ngetInvitation ::\n  ( EncFlow m r,\n    CoreMetrics m\n  ) =>\n  BackgroundVerificationServiceConfig ->\n  Text ->\n  m GetInvitationResp\ngetInvitation serviceConfig invitationId = case serviceConfig of\n  CheckrConfig cfg -> Checkr.getInvitation cfg invitationId\n\ngetReport ::\n  ( EncFlow m r,\n    CoreMetrics m\n  ) =>\n  BackgroundVerificationServiceConfig ->\n  Text ->\n  m GetReportResp\ngetReport serviceConfig reportId = case serviceConfig of\n  CheckrConfig cfg -> Checkr.getReport cfg reportId\n",
      "hash": "83d2de843008bfd1764b0ba93ed606623b3559a99bc97498dedaa84f6bb57df1",
      "size": 1459
    },
    "/lib/mobility-core/src/Kernel/External/BackgroundVerification/Interface/Checkr.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n\nmodule Kernel.External.BackgroundVerification.Interface.Checkr (module Reexport, module Kernel.External.BackgroundVerification.Interface.Checkr) where\n\nimport Kernel.External.BackgroundVerification.Checkr.Config\nimport Kernel.External.BackgroundVerification.Checkr.Flow as Reexport\nimport Kernel.External.BackgroundVerification.Interface.Types\nimport Kernel.External.Encryption\nimport qualified Kernel.Tools.Metrics.CoreMetrics as Metrics\nimport Kernel.Utils.Common\n\ncreateInvitation ::\n  ( Metrics.CoreMetrics m,\n    MonadFlow m,\n    EncFlow m r\n  ) =>\n  CheckrCfg ->\n  CreateInvitationReqI ->\n  m CreateInvitationResp\ncreateInvitation cfg CreateInvitationReqI {..} = createCheckrInvitation cfg CreateInvitationReq {package = cfg.package, ..}\n",
      "hash": "372f643da522faae1a4d51c96c2df4b3112df8559bd6815a2611cccbaaef6701",
      "size": 2131
    },
    "/lib/mobility-core/src/Kernel/External/BackgroundVerification/Interface/Types.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n{-# LANGUAGE DerivingStrategies #-}\n{-# LANGUAGE OverloadedLists #-}\n\nmodule Kernel.External.BackgroundVerification.Interface.Types (module Reexport, module Kernel.External.BackgroundVerification.Interface.Types) where\n\nimport Kernel.External.BackgroundVerification.Checkr.Types as Reexport\nimport Kernel.Prelude\nimport Kernel.Types.Beckn.City\nimport Kernel.Types.Beckn.Country\nimport Kernel.Types.Beckn.IndianState\n\ndata CreateInvitationReqI = CreateInvitationReqI\n  { candidateId :: Text,\n    workLocationCountry :: Country,\n    workLocationState :: IndianState,\n    workLocationCity :: City\n  }\n  deriving (Generic, Eq, Show)\n",
      "hash": "b28c4421f6756153813ed9e8f88cb2e6860e5c415eb434cf31a8ef27457e0244",
      "size": 1322
    },
    "/lib/mobility-core/src/Kernel/External/BackgroundVerification/Types.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n{-# LANGUAGE TemplateHaskell #-}\n\nmodule Kernel.External.BackgroundVerification.Types\n  ( module Reexport,\n    module Kernel.External.BackgroundVerification.Types,\n  )\nwhere\n\nimport Data.Aeson.Types\nimport EulerHS.Prelude\nimport Kernel.Beam.Lib.UtilsTH (mkBeamInstancesForEnumAndList)\nimport Kernel.External.BackgroundVerification.Checkr.Config as Reexport\nimport Kernel.Storage.Esqueleto (derivePersistField)\n\nnewtype BackgroundVerificationServiceConfig = CheckrConfig CheckrCfg\n  deriving (Show, Eq, Generic, ToJSON, FromJSON)\n\ndata BackgroundVerificationService = Checkr\n  deriving (Show, Read, Eq, Ord, Generic)\n\n$(mkBeamInstancesForEnumAndList ''BackgroundVerificationService)\nderivePersistField \"BackgroundVerificationService\"\n\n-- Generic instances for type with single value will not work\ninstance FromJSON BackgroundVerificationService where\n  parseJSON (String \"Checkr\") = pure Checkr\n  parseJSON (String _) = parseFail \"Expected \\\"Checkr\\\"\"\n  parseJSON e = typeMismatch \"String\" e\n\ninstance ToJSON BackgroundVerificationService where\n  toJSON = String . show\n",
      "hash": "54a59c3bfa9ab51ccb7918c6538d647024be7c9208b28adede01ae396cd6432f",
      "size": 1762
    },
    "/lib/mobility-core/src/Kernel/External/Call.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n\nmodule Kernel.External.Call (module Reexport) where\n\nimport Kernel.External.Call.Interface as Reexport\n",
      "hash": "9e61c83ac9599a6cd23af45a6f0ccb167c93bc6f6bf8f6ab1649a2b19ca6e281",
      "size": 797
    },
    "/lib/mobility-core/src/Kernel/External/Call/Exotel/Client.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n\nmodule Kernel.External.Call.Exotel.Client where\n\nimport Data.Maybe\nimport qualified Data.Text.Encoding as DT\nimport EulerHS.Prelude\nimport qualified EulerHS.Types as ET\nimport Kernel.External.Call.Exotel.Config\nimport Kernel.External.Call.Exotel.Types\nimport Kernel.External.Encryption (decrypt)\nimport Kernel.Tools.Metrics.CoreMetrics (CoreMetrics)\nimport Kernel.Types.Common\nimport Kernel.Types.Error\nimport Kernel.Utils.Common\nimport Servant hiding (throwError)\n\n-- | Exotel API interface\ntype InitiateCallAPI a =\n  \"v1\" :> \"Accounts\"\n    :> Capture \"ExotelAccountSID\" ExotelAccountSID\n    :> \"Calls\"\n    :> \"connect.json\"\n    :> BasicAuth \"apikey-apitoken\" BasicAuthData\n    :> ReqBody '[FormUrlEncoded] (ExotelInitiateCallReq a)\n    :> Post '[JSON] ExotelInitiateCallResp\n\ntype ExotelCallbackAPI a =\n  \"statusCallback\"\n    :> ReqBody '[JSON] (ExotelCallCallbackReq a)\n    :> Post '[JSON] ExotelCallCallbackResp\n\ninitiateCall ::\n  ( CoreMetrics m,\n    EncFlow m r,\n    MonadFlow m,\n    ToJSON a\n  ) =>\n  ExotelCfg ->\n  ExotelInitiateCallReq a ->\n  m ExotelInitiateCallResp\ninitiateCall ExotelCfg {..} exoRequest = do\n  apiKey_ <- decrypt apiKey\n  apiToken_ <- decrypt apiToken\n  withLogTag \"Exotel\" $ do\n    let authData =\n          BasicAuthData\n            (DT.encodeUtf8 $ getExotelApiKey apiKey_)\n            (DT.encodeUtf8 $ getExotelApiToken apiToken_)\n    callExotelAPI\n      exotelUrl\n      (callExotel accountSID authData)\n      \"initiateCall\"\n      (Proxy :: Proxy (InitiateCallAPI a))\n  where\n    callExotel sid authData = ET.client (Proxy :: Proxy (InitiateCallAPI a)) sid authData exoRequest\n\ncallExotelAPI :: CallAPI env api a\ncallExotelAPI =\n  callApiUnwrappingApiError\n    (identity @ExotelError)\n    Nothing\n    (Just \"EXOTEL_NOT_AVAILABLE\")\n    Nothing\n",
      "hash": "d9be5e3643bf66f39ca12cf48505e77eef42d18eb4695d87e31895c9d5b1b81f",
      "size": 2469
    },
    "/lib/mobility-core/src/Kernel/External/Call/Exotel/Config.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n{-# LANGUAGE DerivingStrategies #-}\n\nmodule Kernel.External.Call.Exotel.Config\n  ( ExotelCfg (..),\n    ExotelApiKey (..),\n    ExotelApiToken (..),\n    ExotelAccountSID (..),\n    ExotelCallerId (..),\n  )\nwhere\n\nimport Kernel.External.Call.Exotel.Types\nimport Kernel.External.Encryption\nimport Kernel.Prelude\n\n-- | Exotel Service config\ndata ExotelCfg = ExotelCfg\n  { exotelUrl :: BaseUrl,\n    callbackUrl :: BaseUrl,\n    url :: BaseUrl, -- applet url for Call Flow (IVR, greeting etc.)\n    apiKey :: EncryptedField 'AsEncrypted ExotelApiKey,\n    apiToken :: EncryptedField 'AsEncrypted ExotelApiToken,\n    accountSID :: ExotelAccountSID,\n    callerId :: ExotelCallerId\n  }\n  deriving (Show, Eq, Generic, ToJSON, FromJSON)\n",
      "hash": "cca782a44ea0c72df12a5edb84bde8439d7ebec8c77800085d8dcc09f7716e04",
      "size": 1414
    },
    "/lib/mobility-core/src/Kernel/External/Call/Exotel/Types.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n{-# LANGUAGE DeriveDataTypeable #-}\n{-# LANGUAGE DeriveGeneric #-}\n{-# LANGUAGE DerivingStrategies #-}\n{-# LANGUAGE GeneralizedNewtypeDeriving #-}\n{-# LANGUAGE OverloadedLists #-}\n{-# LANGUAGE OverloadedStrings #-}\n{-# LANGUAGE ScopedTypeVariables #-}\n{-# LANGUAGE StandaloneDeriving #-}\n{-# LANGUAGE TemplateHaskell #-}\n{-# LANGUAGE UndecidableInstances #-}\n\nmodule Kernel.External.Call.Exotel.Types where\n\nimport Control.Lens.TH\nimport Data.Aeson (encode)\nimport Data.Aeson.Casing\nimport Data.Aeson.TH\nimport Data.Aeson.Types\nimport qualified Data.Text as T\nimport Kernel.External.Encryption (DbHashable)\nimport Kernel.Prelude hiding (showBaseUrl)\nimport Kernel.Storage.Esqueleto (derivePersistField)\nimport Kernel.Types.Beckn.Ack (AckResponse)\nimport Kernel.Utils.JSON\nimport Kernel.Utils.TH\nimport Kernel.Utils.Text (decodeFromText)\nimport Servant.Client\nimport Web.FormUrlEncoded (ToForm, toForm)\nimport Web.Internal.HttpApiData\n\n-- | Exotel API token\nnewtype ExotelApiToken = ExotelApiToken\n  { getExotelApiToken :: Text\n  }\n  deriving newtype (Show, Eq, ToJSON, FromJSON, DbHashable)\n\n-- | Exotel API token\nnewtype ExotelApiKey = ExotelApiKey\n  { getExotelApiKey :: Text\n  }\n  deriving newtype (Show, Eq, ToJSON, FromJSON, DbHashable)\n\n-- | Exotel sid\nnewtype ExotelAccountSID = ExotelAccountSID\n  { getExotelAccountSID :: Text\n  }\n  deriving newtype (Show, ToHttpApiData, Eq, ToJSON, FromJSON)\n\n-- | Exotel caller id\nnewtype ExotelCallerId = ExotelCallerId\n  { getExotelCallerId :: Text\n  }\n  deriving newtype (Show, ToHttpApiData, Eq, ToJSON, FromJSON)\n\n-- | Exotel call sid\n-- an alpha-numeric unique identifier of the call\nnewtype ExotelCallSID = ExotelCallSID\n  { getExotelCallSID :: Text\n  }\n  deriving (Show)\n\nderiveIdentifierInstances ''ExotelCallSID\n\n-- | Exotel response body\ndata ExotelConnectCallReq a = ExotelConnectCallReq\n  { -- String; The phone number that will be called first.\n    -- Preferably in E.164 format. If not set, our system will try to\n    -- match it with a country and make a call.\n    -- If landline number, prefix it with STD code; Ex: 080XXXX2400\n    from :: Text,\n    -- String; Your customer's phone number.\n    -- If landline number, prefix it with STD code; Ex: 080XXXX2400\n    to :: Text,\n    -- String; This is your ExoPhone/Exotel Virtual Number\n    callerId :: ExotelCallerId,\n    -- \tString; An HTTP POST request will be made to this URL depending\n    --  on what events are subscribed using StatusCallbackEvents.\n    --  Refer here for complete list of parameters which will be sent to your endpoint.\n    statusCallbackUrl :: BaseUrl,\n    -- Any application specific value like order id that will be passed back\n    -- as a parameter in StatusCallback (only via 'terminal' StatusCallbackEvent)\n    customField :: a\n  }\n  deriving (Generic, Show, Eq)\n\ninstance ToJSON a => ToForm (ExotelConnectCallReq a) where\n  toForm ExotelConnectCallReq {..} =\n    [ (\"From\", toQueryParam from),\n      (\"To\", toQueryParam to),\n      (\"CallerId\", toQueryParam callerId),\n      (\"StatusCallback\", T.pack $ showBaseUrl statusCallbackUrl),\n      (\"StatusCallbackEvents[0]\", \"terminal\"),\n      (\"StatusCallbackContentType\", \"application/json\"),\n      (\"CustomField\", decodeUtf8 $ encode customField)\n    ]\n\n-- | Exotel Body to Connect to Call Flow (IVR or Greeting or other applets)\ndata ExotelConnectCallFlowReq a = ExotelConnectCallFlowReq\n  { --The phone number that will be called first. Preferably in E.164 format.\n    -- If not set, our system will try to match it with a country and make a call. If landline number, prefix it with STD code; Ex: 0XXXXXX2400\n    from :: Text,\n    -- String; This is your ExoPhone/Exotel Virtual Number\n    callerId :: ExotelCallerId,\n    -- http://my.exotel.com/{your_sid}/exoml/start_voice/{app_id} where app_id is the identier of the flow (or applet) that you want to connect\n    -- to once the From number picks up the call. You can get the app_id from your Exotel Dashboard\n    url :: BaseUrl,\n    -- \tString; An HTTP POST request will be made to this URL depending\n    --  on what events are subscribed using StatusCallbackEvents.\n    --  Refer here for complete list of parameters which will be sent to your endpoint.\n    statusCallbackUrl :: BaseUrl,\n    -- Any application specific value like order id that will be passed back\n    -- as a parameter in StatusCallback (only via 'terminal' StatusCallbackEvent)\n    customField :: a\n  }\n  deriving (Generic, Show, Eq)\n\ninstance ToJSON a => ToForm (ExotelConnectCallFlowReq a) where\n  toForm ExotelConnectCallFlowReq {..} =\n    [ (\"From\", toQueryParam from),\n      (\"CallerId\", toQueryParam callerId),\n      (\"Url\", T.pack $ showBaseUrl url),\n      (\"StatusCallback\", T.pack $ showBaseUrl statusCallbackUrl),\n      (\"CustomField\", decodeUtf8 $ encode customField)\n    ]\n\ndata ExotelInitiateCallReq a = ConnectCalls (ExotelConnectCallReq a) | ConnectToCallFlow (ExotelConnectCallFlowReq a)\n  deriving (Generic, Show, Eq)\n\ninstance ToJSON a => ToForm (ExotelInitiateCallReq a) where\n  toForm (ConnectCalls req) = toForm req\n  toForm (ConnectToCallFlow req) = toForm req\n\n-- | Overall call status\ndata ExotelCallStatus\n  = -- The call is ready and waiting in line before going out\n    QUEUED\n  | -- The call is ringing\n    RINGING\n  | -- The call was answered and is currently in progress\n    IN_PROGRESS\n  | -- The call was answered and has ended normally\n    COMPLETED\n  | -- The call could not be completed as dialled, most likely\n    -- because the phone number was non-existent\n    FAILED\n  | -- The caller received a busy signal\n    BUSY\n  | -- The call ended without being answered\n    NO_ANSWER\n  | -- The call is canceled\n    CANCELED\n  | -- Invalid call status\n    INVALID_STATUS\n  | -- Knowlarity status\n    CONNECTED\n  | NOT_CONNECTED\n  | MISSED\n  | ATTEMPTED\n  deriving (Show, Eq, Read, Generic, ToSchema, ToParamSchema)\n\ninstance FromHttpApiData ExotelCallStatus where\n  parseUrlPiece status =\n    pure case T.toLower status of\n      \"queued\" -> QUEUED\n      \"ringing\" -> RINGING\n      \"in-progress\" -> IN_PROGRESS\n      \"completed\" -> COMPLETED\n      \"busy\" -> BUSY\n      \"no-answer\" -> NO_ANSWER\n      \"failed\" -> FAILED\n      \"canceled\" -> CANCELED\n      \"connected\" -> CONNECTED\n      \"not-connected\" -> NOT_CONNECTED\n      \"missed\" -> MISSED\n      _ -> INVALID_STATUS\n\n$(deriveJSON constructorsWithHyphensToLowerOptions ''ExotelCallStatus)\n\nderivePersistField \"ExotelCallStatus\"\n\n-- | Call direction\ndata ExotelDirection\n  = -- Incoming call\n    INBOUND\n  | -- Outbound calls from Exotel dashboard\n    OUTBOUND_DIAL\n  | -- All other Outbound calls (API, campaign etc.)\n    OUTBOUND_API\n  deriving (Show, Eq, Read, Generic, ToSchema)\n\n$(deriveJSON constructorsWithHyphensToLowerOptions ''ExotelDirection)\n\n-- | Exotel response body\ndata ExotelInitiateCallRespBody = ExotelInitiateCallRespBody\n  { -- string; an alpha-numeric unique identifier of the call\n    exoSid :: ExotelCallSID,\n    -- Time in format YYYY-MM-DD HH:mm:ss\n    -- Date and time at which the user initiated the API\n    exoDateCreated :: Text,\n    -- Time in format YYYY-MM-DD HH:mm:ss\n    -- Date and time at which the status of the call\n    -- was last updated in our system\n    exoDateUpdated :: Text,\n    -- Exotel account SID\n    exoAccountSid :: ExotelAccountSID,\n    -- Your customer's phone number\n    exoTo :: Text,\n    -- The phone number that will be called first\n    exoFrom :: Text,\n    -- This is your ExoPhone/Exotel Virtual Number\n    exoPhoneNumberSid :: ExotelCallerId,\n    -- Overall call status\n    exoStatus :: ExotelCallStatus,\n    -- Time in format YYYY-MM-DD HH:mm:ss\n    -- Date and time when the call request was initiated to the operator\n    exoStartTime :: Text,\n    -- Time in format YYYY-MM-DD HH:mm:ss\n    -- Date and time when the call was completed\n    exoEndTime :: Maybe Text,\n    -- Call duration in seconds\n    exoDuration :: Maybe Text,\n    -- Double; If present, this will be the amount (in INR or USD) you have been charged for the call\n    exoPrice :: Maybe Text,\n    -- Call direction\n    exoDirection :: ExotelDirection,\n    -- human\n    exoAnsweredBy :: Maybe Text,\n    -- Uri is the path of the CallSid\n    exoUri :: Text,\n    -- Link to the call recording\n    exoRecordingUrl :: Maybe BaseUrl\n  }\n  deriving (Show, Generic)\n\n$(makeLenses ''ExotelInitiateCallRespBody)\n\n$(deriveFromJSON (aesonPrefix pascalCase) ''ExotelInitiateCallRespBody)\n$(deriveToJSON (aesonPrefix pascalCase) ''ExotelInitiateCallRespBody)\n\n-- | Exotel response on success\nnewtype ExotelInitiateCallResp = ExotelInitiateCallResp\n  { exoCall :: ExotelInitiateCallRespBody\n  }\n  deriving (Show, Generic)\n\n$(makeLenses ''ExotelInitiateCallResp)\n\n$(deriveFromJSON (aesonPrefix pascalCase) ''ExotelInitiateCallResp)\n$(deriveToJSON (aesonPrefix pascalCase) ''ExotelInitiateCallResp)\n\ndata ExotelCallCallbackReq a = ExotelCallCallbackReq\n  { -- string; an alpha-numeric unique identifier of the call\n    callSid :: Text,\n    eventType :: Text,\n    dateCreated :: Text,\n    dateUpdated :: Text,\n    -- The phone number that was attempted to be called first.\n    from :: Text,\n    -- Your customer's phone number as set in the API request. This number will be connected after `From`.\n    to :: Text,\n    -- Overall call status, which could be one of: 'completed', 'failed', 'busy' or 'no-answer'\n    status :: ExotelCallStatus,\n    phoneNumberSid :: Text,\n    startTime :: Text,\n    endTime :: Text,\n    direction :: ExotelDirection,\n    recordingUrl :: Text,\n    conversationDuration :: Int,\n    legs :: [ExotelLeg],\n    -- \tThe value that was passed in the CustomField (attachments here) parameter of the API (if set during the request) will be populated here.\n    customField :: a\n  }\n  deriving (Generic, Show)\n\nderiving instance ToSchema a => ToSchema (ExotelCallCallbackReq a)\n\ndata ExotelLeg = ExotelLeg\n  { onCallDuration :: Int,\n    status :: ExotelCallStatus\n  }\n  deriving (Generic, Eq, Show, ToJSON, ToSchema)\n\ninstance FromJSON a => FromJSON (ExotelCallCallbackReq a) where\n  parseJSON v =\n    withObject\n      \"ExotelCallCallbackReq\"\n      ( \\obj -> do\n          callSid <- obj .: \"CallSid\"\n          eventType <- obj .: \"EventType\"\n          dateCreated <- obj .: \"DateCreated\"\n          dateUpdated <- obj .: \"DateUpdated\"\n          from <- obj .: \"From\"\n          to <- obj .: \"To\"\n          status <- obj .: \"Status\"\n          phoneNumberSid <- obj .: \"PhoneNumberSid\"\n          startTime <- obj .: \"StartTime\"\n          endTime <- obj .: \"EndTime\"\n          direction <- obj .: \"Direction\"\n          recordingUrl <- obj .: \"RecordingUrl\"\n          conversationDuration <- obj .: \"ConversationDuration\"\n          customField <- obj .: \"CustomField\" >>= withText \"CustomField\" (parseCustomField v)\n          legs <- obj .: \"Legs\"\n\n          return (ExotelCallCallbackReq {..})\n      )\n      v\n\nparseCustomField :: FromJSON a => Value -> Text -> Parser a\nparseCustomField v txt = do\n  case decodeFromText txt of\n    Just exoAttch -> return exoAttch\n    Nothing -> typeMismatch \"CustomField\" v\n\ninstance FromJSON ExotelLeg where\n  parseJSON = withObject \"ExotelLeg\" $ \\obj -> do\n    onCallDuration <- obj .: \"OnCallDuration\"\n    status <- obj .: \"Status\"\n\n    return (ExotelLeg {..})\n\ntype ExotelCallCallbackResp = AckResponse\n",
      "hash": "e442f4d65af67cf4441d4415621acf0fe174f58750010cd69022876e40b88a36",
      "size": 11966
    },
    "/lib/mobility-core/src/Kernel/External/Call/Interface.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n\nmodule Kernel.External.Call.Interface\n  ( module Reexport,\n    module Kernel.External.Call.Interface,\n  )\nwhere\n\nimport EulerHS.Prelude\nimport Kernel.External.Call.Exotel.Config as Reexport\nimport qualified Kernel.External.Call.Interface.Exotel as Exotel\nimport qualified Kernel.External.Call.Interface.TataClickToCall as TataClickToCall\nimport Kernel.External.Call.Interface.Types as Reexport\nimport Kernel.External.Call.TataClickToCall.Config as Reexport\nimport Kernel.External.Call.Twillio.Config as Reexport\nimport Kernel.External.Call.Types as Reexport\nimport Kernel.Tools.Metrics.CoreMetrics (CoreMetrics)\nimport Kernel.Types.Common\nimport Kernel.Types.Error (GenericError (InternalError))\nimport Kernel.Utils.Error.Throwing (throwError)\n\nmkNotProvidedError :: Text -> CallService -> Text\nmkNotProvidedError functionName serviceName = \"Function \" <> functionName <> \" is not provided by service \" <> show serviceName\n\nthrowNotProvidedError :: (MonadFlow m) => Text -> CallService -> m a\nthrowNotProvidedError =\n  (throwError . InternalError) ... mkNotProvidedError\n\ninitiateCall ::\n  ( CoreMetrics m,\n    EncFlow m r,\n    ToJSON a\n  ) =>\n  CallServiceConfig ->\n  InitiateCallReq a ->\n  m InitiateCallResp\ninitiateCall config req = do\n  case config of\n    ExotelConfig ec -> Exotel.initiateCall ec req\n    TataClickToCallConfig ec -> TataClickToCall.initiateCall ec req\n    TwillioCallConfig _ -> throwNotProvidedError \"initiateCall\" TwillioCall\n",
      "hash": "6fa49c7d8e2c57940e6549dabb8266deb9cc797ee23d9025e6754a7d4d82f01a",
      "size": 2145
    },
    "/lib/mobility-core/src/Kernel/External/Call/Interface/Exotel.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n\nmodule Kernel.External.Call.Interface.Exotel where\n\nimport EulerHS.Prelude hiding (id)\nimport qualified Kernel.External.Call.Exotel.Client as Exotel\nimport Kernel.External.Call.Exotel.Config (ExotelCfg)\nimport Kernel.External.Call.Exotel.Types as Exotel\nimport Kernel.External.Call.Interface.Types as Interface\nimport Kernel.Prelude\nimport Kernel.Tools.Metrics.CoreMetrics (CoreMetrics)\nimport Kernel.Types.Common\nimport Kernel.Utils.Logging (logDebug)\n\ninitiateCall ::\n  ( CoreMetrics m,\n    EncFlow m r,\n    MonadFlow m,\n    ToJSON a\n  ) =>\n  ExotelCfg ->\n  InitiateCallReq a ->\n  m InitiateCallResp\ninitiateCall config InitiateCallReq {..} = do\n  url <- parseBaseUrl $ (showBaseUrl config.url) <> \"/\" <> fromMaybe \"\" appletId\n  logDebug $ \"URL for Exotel call: \" <> show url\n  let exotelReq = getExotelCallReq url\n  res <-\n    Exotel.initiateCall config exotelReq\n  return $\n    InitiateCallResp\n      { callId = res.exoCall.exoSid.getExotelCallSID,\n        callStatus = exotelStatusToInterfaceStatus res.exoCall.exoStatus\n      }\n  where\n    getExotelCallReq url = case toPhoneNum of\n      Just toPhoneNum_ ->\n        ConnectCalls $\n          ExotelConnectCallReq\n            { from = fromPhoneNum,\n              to = toPhoneNum_,\n              callerId = config.callerId,\n              statusCallbackUrl = config.callbackUrl,\n              customField = getAttachments attachments\n            }\n      Nothing ->\n        ConnectToCallFlow $\n          ExotelConnectCallFlowReq\n            { from = fromPhoneNum,\n              callerId = config.callerId,\n              url = url,\n              statusCallbackUrl = config.callbackUrl,\n              customField = getAttachments attachments\n            }\n\nexotelStatusToInterfaceStatus :: Exotel.ExotelCallStatus -> Interface.CallStatus\nexotelStatusToInterfaceStatus = \\case\n  Exotel.QUEUED -> Interface.QUEUED\n  Exotel.RINGING -> Interface.RINGING\n  Exotel.IN_PROGRESS -> Interface.IN_PROGRESS\n  Exotel.COMPLETED -> Interface.COMPLETED\n  Exotel.FAILED -> Interface.FAILED\n  Exotel.BUSY -> Interface.BUSY\n  Exotel.NO_ANSWER -> Interface.NO_ANSWER\n  Exotel.CANCELED -> Interface.CANCELED\n  Exotel.CONNECTED -> Interface.CONNECTED\n  Exotel.NOT_CONNECTED -> Interface.NOT_CONNECTED\n  Exotel.MISSED -> Interface.MISSED\n  Exotel.ATTEMPTED -> Interface.ATTEMPTED\n  Exotel.INVALID_STATUS -> Interface.INVALID_STATUS\n",
      "hash": "613bc288fd3d678fc8293f14b650f6312433ad3a29bacd7ce882d4b74a6580f1",
      "size": 3053
    },
    "/lib/mobility-core/src/Kernel/External/Call/Interface/TataClickToCall.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n\nmodule Kernel.External.Call.Interface.TataClickToCall where\n\nimport qualified Data.Text as T\nimport EulerHS.Prelude hiding (id)\nimport Kernel.External.Call.Interface.Types as Interface\nimport qualified Kernel.External.Call.TataClickToCall.Client as TataClickToCall\nimport Kernel.External.Call.TataClickToCall.Config\nimport Kernel.External.Call.TataClickToCall.Types as TataClickToCall\nimport Kernel.Prelude\nimport Kernel.Tools.Metrics.CoreMetrics (CoreMetrics)\nimport Kernel.Types.Common\nimport Kernel.Utils.Logging (logDebug)\n\ninitiateCall ::\n  ( CoreMetrics m,\n    EncFlow m r,\n    MonadFlow m,\n    ToJSON a\n  ) =>\n  TataClickToCallCfg ->\n  InitiateCallReq a ->\n  m InitiateCallResp\ninitiateCall config InitiateCallReq {..} = do\n  logDebug $ \"URL for TataClickToCall: \" <> show config.url\n  let tataClickToCallReq = getTataClickToCallReq\n  res <-\n    TataClickToCall.tataInitiateCall config tataClickToCallReq\n  return $\n    InitiateCallResp\n      { callId = fromMaybe T.empty (getField @\"call_id\" res),\n        callStatus = maybe Interface.FAILED clickToCallStatusToInterfaceStatus res.callStatus\n      }\n  where\n    getTataClickToCallReq =\n      ClickToCallConnectRequest\n        { agent_number = fromPhoneNum,\n          destination_number = fromMaybe T.empty toPhoneNum,\n          caller_id = config.caller_id,\n          get_call_id = config.get_call_id\n        }\n\nclickToCallStatusToInterfaceStatus :: TataClickToCall.ClickToCallStatus -> Interface.CallStatus\nclickToCallStatusToInterfaceStatus = \\case\n  TataClickToCall.QUEUED -> Interface.QUEUED\n  TataClickToCall.RINGING -> Interface.RINGING\n  TataClickToCall.IN_PROGRESS -> Interface.IN_PROGRESS\n  TataClickToCall.COMPLETED -> Interface.COMPLETED\n  TataClickToCall.FAILED -> Interface.FAILED\n  TataClickToCall.BUSY -> Interface.BUSY\n  TataClickToCall.NO_ANSWER -> Interface.NO_ANSWER\n  TataClickToCall.CANCELED -> Interface.CANCELED\n  TataClickToCall.CONNECTED -> Interface.CONNECTED\n  TataClickToCall.NOT_CONNECTED -> Interface.NOT_CONNECTED\n  TataClickToCall.MISSED -> Interface.MISSED\n  TataClickToCall.ATTEMPTED -> Interface.ATTEMPTED\n  TataClickToCall.INVALID_STATUS -> Interface.INVALID_STATUS\n",
      "hash": "6c307085fa3d3a1e0afd63d2e23354bfe67d43600b8eb822daf2225686973b31",
      "size": 2854
    },
    "/lib/mobility-core/src/Kernel/External/Call/Interface/Types.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n{-# LANGUAGE DerivingStrategies #-}\n{-# LANGUAGE StandaloneDeriving #-}\n{-# LANGUAGE TemplateHaskell #-}\n\nmodule Kernel.External.Call.Interface.Types where\n\nimport Kernel.Beam.Lib.UtilsTH (mkBeamInstancesForEnum)\nimport qualified Kernel.External.Call.Exotel.Config as Exotel\nimport qualified Kernel.External.Call.TataClickToCall.Config as TataClickToCall\nimport qualified Kernel.External.Call.Twillio.Config as Twillio\nimport Kernel.Prelude\nimport Kernel.Storage.Esqueleto (derivePersistField)\n\ndata CallServiceConfig = ExotelConfig Exotel.ExotelCfg | TwillioCallConfig Twillio.TwillioCallCfg | TataClickToCallConfig TataClickToCall.TataClickToCallCfg\n  deriving (Show, Eq, Generic, ToJSON, FromJSON)\n\ndata InitiateCallReq a = InitiateCallReq\n  { fromPhoneNum :: Text,\n    toPhoneNum :: Maybe Text,\n    attachments :: Attachments a,\n    appletId :: Maybe Text\n  }\n  deriving (Generic)\n\nnewtype Attachments a = Attachments\n  { getAttachments :: a\n  }\n  deriving (Generic)\n\ndata CallStatus\n  = -- The call is ready and waiting in line before going out\n    QUEUED\n  | -- The call is ringing\n    RINGING\n  | -- The call was answered and is currently in progress\n    IN_PROGRESS\n  | -- The call was answered and has ended normally\n    COMPLETED\n  | -- The call could not be completed as dialled, most likely\n    -- because the phone number was non-existent\n    FAILED\n  | -- The caller received a busy signal\n    BUSY\n  | -- The call ended without being answered\n    NO_ANSWER\n  | -- The call is canceled\n    CANCELED\n  | -- Invalid call status\n    INVALID_STATUS\n  | -- KNOWLARITY STATUS\n    CONNECTED\n  | NOT_CONNECTED\n  | ATTEMPTED\n  | MISSED\n  deriving stock (Show, Eq, Read, Ord, Generic)\n  deriving anyclass (FromJSON, ToJSON, ToSchema)\n\n$(mkBeamInstancesForEnum ''CallStatus)\n\nderivePersistField \"CallStatus\"\n\ndata InitiateCallResp = InitiateCallResp\n  { callId :: Text,\n    callStatus :: CallStatus\n  }\n  deriving (Generic)\n\ndata CallAttemptStatus = Attempted | Resolved | Failed | Pending\n  deriving (Show, Read, Eq, Ord, Generic, ToJSON, FromJSON, ToSchema)\n",
      "hash": "318bdad6cc09c0e7c231863145f2c84e66c53a22d25c1d5066189c2a757db453",
      "size": 2756
    },
    "/lib/mobility-core/src/Kernel/External/Call/TataClickToCall/Client.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n\nmodule Kernel.External.Call.TataClickToCall.Client where\n\nimport Data.Maybe\nimport qualified Data.Text as T\nimport EulerHS.Prelude\nimport qualified EulerHS.Types as ET\nimport Kernel.External.Call.TataClickToCall.Config\nimport Kernel.External.Call.TataClickToCall.Types\nimport Kernel.External.Encryption (decrypt)\nimport Kernel.Tools.Metrics.CoreMetrics (CoreMetrics)\nimport Kernel.Types.Common\nimport Kernel.Types.Error\nimport Kernel.Utils.Common\nimport Servant hiding (throwError)\n\ntype TataClickToCallAPI =\n  \"app\" :> \"cpaas\" :> \"pv\" :> \"v1\" :> \"click_to_call\"\n    :> Header \"Authorization\" Text\n    :> ReqBody '[JSON] ClickToCallConnectRequest\n    :> Post '[JSON] ClickToCallResponse\n\ntataClickToCallAPI :: Proxy TataClickToCallAPI\ntataClickToCallAPI = Proxy\n\ntataInitiateCall ::\n  ( CoreMetrics m,\n    MonadFlow m,\n    EncFlow m r\n  ) =>\n  TataClickToCallCfg ->\n  ClickToCallConnectRequest ->\n  m ClickToCallResponse\ntataInitiateCall tataClickToCallCfg req = do\n  apiKey_ <- decrypt tataClickToCallCfg.apiKey\n  logDebug $ \"logging tataClickToCallCfg request_ \" <> show req\n  let eulerClient = ET.client (Proxy @TataClickToCallAPI)\n  response <- callAPI tataClickToCallCfg.url (eulerClient (Just $ \"Bearer \" <> apiKey_) req) \"tataInitiateCall\" (Proxy @TataClickToCallAPI) >>= fromEitherM (ClickToCallGenericError . T.pack . show)\n  when (response.success == False) (logError $ \"logging tataClickToCallCfg response_ \" <> show response)\n  return response\n",
      "hash": "bdac450ddfa45be08e62dc3a353d5b90d2ca5239e9a817739440b388a1446029",
      "size": 2150
    },
    "/lib/mobility-core/src/Kernel/External/Call/TataClickToCall/Config.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n\nmodule Kernel.External.Call.TataClickToCall.Config where\n\nimport Kernel.External.Encryption\nimport Kernel.Prelude\n\ndata TataClickToCallCfg = TataClickToCallCfg\n  { caller_id :: Text,\n    get_call_id :: Int,\n    apiKey :: EncryptedField 'AsEncrypted Text,\n    url :: BaseUrl\n  }\n  deriving (Show, Eq, Generic, ToJSON, FromJSON)\n",
      "hash": "71143b8be0234e48d9a1bfd72c938a0a99627b3bd7bd2b586672c3f7cc7427c0",
      "size": 1021
    },
    "/lib/mobility-core/src/Kernel/External/Call/TataClickToCall/Types.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n{-# LANGUAGE DeriveDataTypeable #-}\n{-# LANGUAGE DeriveGeneric #-}\n{-# LANGUAGE DerivingStrategies #-}\n{-# LANGUAGE GeneralizedNewtypeDeriving #-}\n{-# LANGUAGE OverloadedLists #-}\n{-# LANGUAGE OverloadedStrings #-}\n{-# LANGUAGE ScopedTypeVariables #-}\n{-# LANGUAGE StandaloneDeriving #-}\n{-# LANGUAGE TemplateHaskell #-}\n{-# LANGUAGE UndecidableInstances #-}\n\nmodule Kernel.External.Call.TataClickToCall.Types where\n\nimport Data.Aeson.TH\nimport Data.Aeson.Types\nimport qualified Data.Text as T\nimport Kernel.Prelude hiding (showBaseUrl)\nimport Kernel.Utils.JSON\nimport Web.FormUrlEncoded (FromForm, ToForm)\nimport Web.Internal.HttpApiData\n\n-- Click-to-Call Request\ndata ClickToCallRequest = ClickToCallRequest\n  { agent_number :: Text,\n    destination_number :: Text\n  }\n  deriving (Show, Generic, ToJSON, FromJSON, ToForm, FromForm)\n\ndata ClickToCallConnectRequest = ClickToCallConnectRequest\n  { agent_number :: Text,\n    destination_number :: Text,\n    caller_id :: Text,\n    get_call_id :: Int\n  }\n  deriving (Show, Generic, ToJSON, FromJSON, ToForm, FromForm)\n\ndata ClickToCallStatus\n  = -- The call is ready and waiting in line before going out\n    QUEUED\n  | -- The call is ringing\n    RINGING\n  | -- The call was answered and is currently in progress\n    IN_PROGRESS\n  | -- The call was answered and has ended normally\n    COMPLETED\n  | -- The call could not be completed as dialled, most likely\n    -- because the phone number was non-existent\n    FAILED\n  | -- The caller received a busy signal\n    BUSY\n  | -- The call ended without being answered\n    NO_ANSWER\n  | -- The call is canceled\n    CANCELED\n  | -- Invalid call status\n    INVALID_STATUS\n  | -- Knowlarity status\n    CONNECTED\n  | NOT_CONNECTED\n  | MISSED\n  | ATTEMPTED\n  deriving (Show, Eq, Read, Generic, ToSchema, ToParamSchema)\n\ninstance FromHttpApiData ClickToCallStatus where\n  parseUrlPiece status =\n    pure case T.toLower status of\n      \"queued\" -> QUEUED\n      \"ringing\" -> RINGING\n      \"in-progress\" -> IN_PROGRESS\n      \"completed\" -> COMPLETED\n      \"busy\" -> BUSY\n      \"no-answer\" -> NO_ANSWER\n      \"failed\" -> FAILED\n      \"canceled\" -> CANCELED\n      \"connected\" -> CONNECTED\n      \"not-connected\" -> NOT_CONNECTED\n      \"missed\" -> MISSED\n      _ -> INVALID_STATUS\n\n$(deriveJSON constructorsWithHyphensToLowerOptions ''ClickToCallStatus)\n\n-- API Response (Adjust based on Tata's response format)\ndata ClickToCallResponse = ClickToCallResponse\n  { success :: Bool,\n    message :: Maybe Text,\n    call_id :: Maybe Text,\n    callStatus :: Maybe ClickToCallStatus\n  }\n  deriving (Show, Generic)\n\ninstance ToJSON ClickToCallResponse\n\ninstance FromJSON ClickToCallResponse\n",
      "hash": "f170c9a934695043c2ffe12d8eec95af78dbb8d603a715283382f8dd4fe45787",
      "size": 3353
    },
    "/lib/mobility-core/src/Kernel/External/Call/Twillio/Config.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n\nmodule Kernel.External.Call.Twillio.Config (TwillioCallCfg) where\n\nimport Kernel.External.Encryption\nimport Kernel.Prelude\n\ndata TwillioCallCfg = TwillioCallCfg\n  { apiKey :: EncryptedField 'AsEncrypted Text,\n    apiKeySecret :: EncryptedField 'AsEncrypted Text,\n    applicationSid :: Text,\n    accountSid :: Text,\n    pushCredentialSidAndroid :: Text,\n    pushCredentialSidIos :: Text\n  }\n  deriving (Show, Eq, Generic, FromJSON, ToJSON)\n",
      "hash": "46765c05a71bc746cff8d5370e60144b47df65e19bf2a5fbad53a20ef6737da3",
      "size": 1133
    },
    "/lib/mobility-core/src/Kernel/External/Call/Types.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n{-# LANGUAGE TemplateHaskell #-}\n\nmodule Kernel.External.Call.Types\n  ( module Kernel.External.Call.Types,\n  )\nwhere\n\nimport Data.OpenApi\nimport EulerHS.Prelude\nimport Kernel.Beam.Lib.UtilsTH (mkBeamInstancesForEnum)\nimport Kernel.Storage.Esqueleto (derivePersistField)\n\ndata CallService = Exotel | Knowlarity | TwillioCall | TataClickToCall\n  deriving (Show, Read, Eq, Ord, Generic, ToJSON, FromJSON, ToSchema)\n\n$(mkBeamInstancesForEnum ''CallService)\n\nderivePersistField \"CallService\"\n",
      "hash": "e16ab8d81d995ac6dc14255c2ec5471563ad63ac493e902a98cc7144b0d40005",
      "size": 1180
    },
    "/lib/mobility-core/src/Kernel/External/Encryption.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n{-# LANGUAGE AllowAmbiguousTypes #-}\n{-# LANGUAGE ApplicativeDo #-}\n{-# LANGUAGE DerivingStrategies #-}\n{-# LANGUAGE GeneralizedNewtypeDeriving #-}\n{-# LANGUAGE UndecidableInstances #-}\n{-# OPTIONS_GHC -Wno-orphans #-}\n\n-- | Utilities for encrypting secret and personal data with external service.\nmodule Kernel.External.Encryption\n  ( DbHash (..),\n    DbHashable (..),\n    EncKind (..),\n    Encrypted (..),\n    EncFlow,\n    EncryptedField,\n    EncryptedHashed (..),\n    EncryptedHashedField,\n    EncryptedBase64 (..),\n    EncTools (..),\n    HashSalt,\n    EncryptedItem' (..),\n    ShortHash (..),\n    ShortHashable,\n    Hashable,\n    encrypt,\n    encrypt',\n    decrypt,\n    getDbHash,\n    getHash,\n\n    -- * Re-exports\n    EncryptedItem (..),\n    genericEncryptItem,\n    genericDecryptItem,\n    mkDefPassettoContext,\n  )\nwhere\n\nimport qualified Crypto.Hash as Hash\nimport Crypto.Hash.Algorithms (SHA256)\nimport qualified Data.Aeson as Aeson\nimport qualified Data.ByteArray as BA\nimport qualified Data.ByteString.Lazy as LBS\nimport EulerHS.Prelude\nimport Kernel.Storage.Esqueleto (PersistField, PersistFieldSql)\nimport Kernel.Types.App\nimport Kernel.Types.Field\nimport Kernel.Utils.Dhall (FromDhall)\nimport Kernel.Utils.Servant.BaseUrl\nimport Passetto.Client (EncryptedBase64 (..), EncryptedItem (..), PassettoContext, cliDecrypt, cliEncrypt, genericDecryptItem, genericEncryptItem, mkDefPassettoContext, throwLeft)\nimport Passetto.Client.EncryptedItem (Encrypted (..))\nimport Text.Hex (decodeHex, encodeHex)\n\n-- * Encrypted fields\n\n-- | Specifies whether field is encrypted or not.\n--\n-- Esqueleto table schemas which have some fields encrypted are assumed to be\n-- polymorphic over type of this kind; it then should be included into\n-- 'EncryptedField' to affect a particular field.\ndata EncKind\n  = AsEncrypted\n  | AsUnencrypted\n\n-- ** Encrypted and hashed fields\n\n-- | Hash which we store in the database in order to be able to lookup on a\n-- value.\n--\n-- NOTE: we have decided on this temporary solution, in no way it is assumed\n-- to be secure.\n-- Implementation of this hash, as well as the overall need in it is to be\n-- revised later.\nnewtype DbHash = DbHash {unDbHash :: ByteString}\n  deriving stock (Eq, Ord)\n  deriving newtype (PersistField, PersistFieldSql, Show, Read)\n\n-- These json instances are necessary for Euler's ART system only\ninstance ToJSON DbHash where\n  toJSON = toJSON . encodeHex . unDbHash\n\ninstance FromJSON DbHash where\n  parseJSON = maybe (fail \"Bad hex\") (pure . DbHash) . decodeHex <=< parseJSON\n\ntype HashAlgo = SHA256\n\ntype HashSalt = Text\n\n-- | Typeclass for values which can be hashed.\nclass DbHashable a where\n  evalDbHash :: (a, HashSalt) -> DbHash\n  default evalDbHash :: ToJSON a => (a, HashSalt) -> DbHash\n  evalDbHash = evalDbHash . first toJSON\n\ninstance DbHashable ByteString where\n  evalDbHash = evalDbHash . first LBS.fromStrict\n\ninstance DbHashable LByteString where\n  evalDbHash (a, salt) =\n    DbHash . BA.convert @(Hash.Digest HashAlgo) $ Hash.hashlazy (encodeUtf8 salt <> a)\n\ninstance DbHashable Text where\n  evalDbHash = evalDbHash . first (encodeUtf8 @_ @ByteString)\n\ninstance DbHashable Aeson.Value where\n  evalDbHash = evalDbHash . first Aeson.encode\n\ndata EncryptedHashed a = EncryptedHashed\n  { encrypted :: Encrypted a,\n    hash :: DbHash\n  }\n  deriving stock (Generic)\n\ninstance\n  (ToJSON a, FromJSON a, DbHashable a) =>\n  EncryptedItem (EncryptedHashed a)\n  where\n  type Unencrypted (EncryptedHashed a) = (a, HashSalt)\n  encryptItem value = do\n    let hash = evalDbHash value\n    encrypted <- encryptItem $ fst value\n    return EncryptedHashed {..}\n  decryptItem mvalue = (,\"\") <$> decryptItem mvalue.encrypted\n\ntype family EncryptedField (e :: EncKind) (a :: Type) :: Type where\n  EncryptedField 'AsUnencrypted a = a\n  EncryptedField 'AsEncrypted a = Encrypted a\n\n-- | Mark a field as encrypted with hash or not, depending on @e@ argument.\n--\n-- The same considerations as for 'EncryptedField' apply here.\ntype family EncryptedHashedField (e :: EncKind) (a :: Type) :: Type where\n  EncryptedHashedField 'AsUnencrypted a = a\n  EncryptedHashedField 'AsEncrypted a = EncryptedHashed a\n\nclass (EncryptedItem e) => EncryptedItem' e where\n  type UnencryptedItem e :: Type\n  toUnencrypted :: UnencryptedItem e -> HashSalt -> Unencrypted e\n  fromUnencrypted :: Unencrypted e -> UnencryptedItem e\n\ninstance (ToJSON a, FromJSON a, DbHashable a) => EncryptedItem' (Encrypted a) where\n  type UnencryptedItem (Encrypted a) = a\n  toUnencrypted a _ = a\n  fromUnencrypted a = a\n\ninstance (ToJSON a, FromJSON a, DbHashable a) => EncryptedItem' (EncryptedHashed a) where\n  type UnencryptedItem (EncryptedHashed a) = a\n  toUnencrypted a salt = (a, salt)\n  fromUnencrypted a = fst a\n\n-- * Encryption methods\n\ndata EncTools = EncTools\n  { hashSalt :: HashSalt,\n    service :: (String, Word16)\n  }\n  deriving (Generic, FromDhall)\n\n-- FIXME! Modify passetto to use BaseUrl and use it too!\ntype EncFlow m r = (HasFlowEnv m r '[\"encTools\" ::: EncTools, \"passettoContext\" ::: PassettoContext])\n\n-- Helper which allows running passetto client operations in our monad.\nwithPassettoCtx :: MonadIO m => PassettoContext -> ReaderT PassettoContext IO a -> m a\nwithPassettoCtx passettoContext = liftIO . (flip runReaderT) passettoContext\n\n-- | Encrypt given value.\n--\n-- Note: this performs not more than one call to server, so try to avoid using\n-- multiple subsequent invocations of this method in favor of passing complex\n-- structures (e.g. tuples) through it.\nencrypt ::\n  forall (m :: Type -> Type) r e.\n  (EncFlow m r, EncryptedItem' e) =>\n  UnencryptedItem e ->\n  m e\nencrypt payload = do\n  encTools <- asks (.encTools)\n  passettoContext <- asks (.passettoContext)\n  encrypt' passettoContext encTools payload\n\n-- | Encrypt given value using provided tools.\n--\n-- Note: this performs not more than one call to server, so try to avoid using\n-- multiple subsequent invocations of this method in favor of passing complex\n-- structures (e.g. tuples) through it.\nencrypt' ::\n  forall (m :: Type -> Type) e.\n  (MonadIO m, EncryptedItem' e) =>\n  PassettoContext ->\n  EncTools ->\n  UnencryptedItem e ->\n  m e\nencrypt' passettoContext encTools payload = do\n  let unencrypted = toUnencrypted @e payload encTools.hashSalt\n  withPassettoCtx passettoContext $ throwLeft =<< cliEncrypt unencrypted\n\n-- | Decrypt given value.\ndecrypt ::\n  forall (m :: Type -> Type) r e.\n  (EncFlow m r, EncryptedItem' e) =>\n  e ->\n  m (UnencryptedItem e)\ndecrypt encrypted = do\n  passettoContext <- asks (.passettoContext)\n  item <- withPassettoCtx passettoContext $ throwLeft =<< cliDecrypt encrypted\n  return $ fromUnencrypted @e item\n\ngetDbHash ::\n  (EncFlow m r, DbHashable a) =>\n  a ->\n  m DbHash\ngetDbHash a = do\n  salt <- asks (.encTools.hashSalt)\n  return $ evalDbHash (a, salt)\n\n-----------------------------\n\nnewtype ShortHash = ShortHash {unShortHash :: ByteString}\n  deriving stock (Show, Eq)\n  deriving newtype (PersistField, PersistFieldSql)\n\ntype ShortAlgo = Hash.MD5\n\nclass ShortHashable a where\n  evalShortHash :: (a, HashSalt) -> ShortHash\n\ninstance ShortHashable ByteString where\n  evalShortHash = evalShortHash . first LBS.fromStrict\n\ninstance ShortHashable LByteString where\n  evalShortHash (a, salt) =\n    ShortHash . BA.convert @(Hash.Digest ShortAlgo) $ Hash.hashlazy (encodeUtf8 salt <> a)\n\ninstance ShortHashable Text where\n  evalShortHash = evalShortHash . first (encodeUtf8 @_ @ByteString)\n\ngetHash :: (EncFlow m r, ShortHashable a) => a -> m Text\ngetHash a = do\n  salt <- asks (.encTools.hashSalt)\n  return $ encodeHex $ unShortHash $ evalShortHash (a, salt)\n\ninstance Hashable BaseUrl where\n  hashWithSalt salt url = hashWithSalt salt (showBaseUrlText url)\n",
      "hash": "cef4358a346bac3d1418ce331c12aa5d032ecab188a2abd76d378b3d38e8098f",
      "size": 8386
    },
    "/lib/mobility-core/src/Kernel/External/GoogleTranslate/API.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n\nmodule Kernel.External.GoogleTranslate.API where\n\nimport EulerHS.Prelude\nimport EulerHS.Types (EulerClient, client)\nimport qualified Kernel.External.GoogleTranslate.Types as GoogleTranslate\nimport Kernel.Utils.Common\nimport Servant\n\ntype GoogleTranslateAPI =\n  \"language\" :> \"translate\" :> \"v2\"\n    :> MandatoryQueryParam \"key\" Text\n    :> MandatoryQueryParam \"source\" Text\n    :> MandatoryQueryParam \"target\" Text\n    :> MandatoryQueryParam \"q\" Text\n    :> Get '[JSON] GoogleTranslate.TranslateResp\n\ntranslate :: Text -> Text -> Text -> Text -> EulerClient GoogleTranslate.TranslateResp\ntranslate = client googleTranslateAPI\n\ngoogleTranslateAPI :: Proxy GoogleTranslateAPI\ngoogleTranslateAPI = Proxy\n",
      "hash": "f1a07bba0baedc7bf9d23cdef17d66c778a23cb7c7f43330ecb2518ba45fd64f",
      "size": 1395
    },
    "/lib/mobility-core/src/Kernel/External/GoogleTranslate/Client.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n\nmodule Kernel.External.GoogleTranslate.Client where\n\nimport EulerHS.Prelude\nimport qualified Kernel.External.GoogleTranslate.API as API\nimport qualified Kernel.External.GoogleTranslate.Types as GoogleTranslate\nimport Kernel.Tools.Metrics.CoreMetrics (CoreMetrics)\nimport Kernel.Types.Common\nimport Kernel.Types.Error\nimport Kernel.Utils.Common\nimport Servant.Client.Core (ClientError)\n\ntranslate ::\n  ( CoreMetrics m,\n    MonadFlow m\n  ) =>\n  BaseUrl ->\n  Text ->\n  Text ->\n  Text ->\n  Text ->\n  m GoogleTranslate.TranslateResp\ntranslate url apiKey source target query = do\n  callAPI url (API.translate apiKey source target query) \"translate\" API.googleTranslateAPI\n    >>= checkGoogleTranslateError url\n\ncheckGoogleTranslateError :: (MonadThrow m, Log m, HasField \"_error\" a (Maybe GoogleTranslate.TranslateError)) => BaseUrl -> Either ClientError a -> m a\ncheckGoogleTranslateError url res =\n  fromEitherM (googleTranslateError url) res >>= validateResponseStatus\n\ngoogleTranslateError :: BaseUrl -> ClientError -> ExternalAPICallError\ngoogleTranslateError = ExternalAPICallError (Just \"GOOGLE_TRANSLATE_API_ERROR\")\n\nvalidateResponseStatus :: (MonadThrow m, Log m, HasField \"_error\" a (Maybe GoogleTranslate.TranslateError)) => a -> m a\nvalidateResponseStatus response =\n  case response._error of\n    Nothing -> pure response\n    _ -> throwError GoogleTranslateInvalidRequest\n",
      "hash": "1ff98fe0de0813c95e854c06e95373fda8039a6e2caeacd77e0d7b7a38092feb",
      "size": 2072
    },
    "/lib/mobility-core/src/Kernel/External/GoogleTranslate/Types.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n{-# LANGUAGE DerivingVia #-}\n\nmodule Kernel.External.GoogleTranslate.Types where\n\nimport Kernel.Prelude\nimport Kernel.Utils.JSON\n\ntype HasGoogleTranslate m r = (MonadReader r m, HasField \"googleTranslateUrl\" r BaseUrl, HasField \"googleTranslateKey\" r Text)\n\ndata TranslateResp = TranslateResp\n  { _data :: Translations,\n    _error :: Maybe TranslateError\n  }\n  deriving (Generic, Show, ToSchema)\n\ninstance FromJSON TranslateResp where\n  parseJSON = genericParseJSON stripPrefixUnderscoreIfAny\n\ninstance ToJSON TranslateResp where\n  toJSON = genericToJSON stripPrefixUnderscoreIfAny\n\nnewtype TranslateError = TranslateError\n  { code :: Text\n  }\n  deriving (Generic, FromJSON, ToJSON, ToSchema, Show)\n\nnewtype Translations = Translation\n  { translations :: [TranslatedText]\n  }\n  deriving (Generic, ToJSON, FromJSON, ToSchema, Show)\n\nnewtype TranslatedText = TranslatedText\n  { translatedText :: Text\n  }\n  deriving (Generic, ToJSON, FromJSON, ToSchema, Show)\n",
      "hash": "183f6f54539a6031edd1e2621386afc9539adb8594e2eac395136c039959c03c",
      "size": 1651
    },
    "/lib/mobility-core/src/Kernel/External/IncidentReport.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n\nmodule Kernel.External.IncidentReport (module Reexport) where\n\nimport Kernel.External.IncidentReport.Interface as Reexport\n",
      "hash": "7da43f41fb4289b03fa93d01780b3cd0138e2424ac462bba9699bd36f4406ffe",
      "size": 817
    },
    "/lib/mobility-core/src/Kernel/External/IncidentReport/ERSS/Config.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n\nmodule Kernel.External.IncidentReport.ERSS.Config where\n\nimport Kernel.Prelude\n\ndata ERSSCfg = ERSSCfg\n  { url :: BaseUrl,\n    userName :: Text\n  }\n  deriving (Show, Eq, Generic, ToJSON, FromJSON)\n",
      "hash": "05b7493c39c065bf9f42ad71108ae2abd5d4a0ee7b8213621b6f7c49ed4bfd03",
      "size": 891
    },
    "/lib/mobility-core/src/Kernel/External/IncidentReport/ERSS/Flow.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n\nmodule Kernel.External.IncidentReport.ERSS.Flow\n  ( reportIncident,\n    reportIncidentUpdate,\n  )\nwhere\n\nimport qualified EulerHS.Types as ET\nimport qualified Kernel.External.IncidentReport.ERSS.Types as ERSS\nimport Kernel.External.IncidentReport.Interface.Error\nimport Kernel.Prelude\nimport Kernel.Tools.Metrics.CoreMetrics (CoreMetrics)\nimport Kernel.Types.Common\nimport Kernel.Utils.Common (callAPI, fromEitherM)\nimport Servant hiding (throwError)\n\ntype ERSSIncidentReportAPI =\n  \"WBJMONRestAPI\" :> \"rs\" :> \"v1\" :> \"master\" :> \"saveInitiateJourneyInfo_v1\"\n    :> Header \"Authorization\" Text\n    :> ReqBody '[JSON] ERSS.IncidentReportReq\n    :> Post '[JSON] ERSS.IncidentReportRes\n\nreportIncident ::\n  ( CoreMetrics m,\n    MonadFlow m\n  ) =>\n  ERSS.IncidentReportReq ->\n  BaseUrl ->\n  Text ->\n  m ERSS.IncidentReportRes\nreportIncident req url token = do\n  let eulerClient = ET.client (Proxy @ERSSIncidentReportAPI)\n  callAPI url (eulerClient (Just $ \"Bearer \" <> token) req) \"incidentReportAPI\" (Proxy @ERSSIncidentReportAPI)\n    >>= fromEitherM (FailedToCallIncidentReportAPI . show)\n\ntype ERSSIncidentReportUpdateAPI =\n  \"WBJMONRestAPI\" :> \"rs\" :> \"v1\" :> \"master\" :> \"updateJourneyLocation_v1\"\n    :> Header \"Authorization\" Text\n    :> ReqBody '[JSON] ERSS.IncidentReportUpdateReq\n    :> Post '[JSON] ERSS.IncidentReportUpdateRes\n\nreportIncidentUpdate ::\n  ( CoreMetrics m,\n    MonadFlow m\n  ) =>\n  ERSS.IncidentReportUpdateReq ->\n  BaseUrl ->\n  Text ->\n  m ERSS.IncidentReportUpdateRes\nreportIncidentUpdate req url token = do\n  let eulerClient = ET.client (Proxy @ERSSIncidentReportUpdateAPI)\n  callAPI url (eulerClient (Just $ \"Bearer \" <> token) req) \"incidentReportUpdateAPI\" (Proxy @ERSSIncidentReportUpdateAPI)\n    >>= fromEitherM (FailedToCallIncidentReportUpdateAPI . show)\n",
      "hash": "4bd22d918fbf59cf2a6afc109069cf2ae8254776c3da3a74d127e6343f12c91b",
      "size": 2481
    },
    "/lib/mobility-core/src/Kernel/External/IncidentReport/ERSS/Types.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n{-# LANGUAGE DerivingStrategies #-}\n\nmodule Kernel.External.IncidentReport.ERSS.Types\n  ( module Kernel.External.IncidentReport.ERSS.Types,\n  )\nwhere\n\nimport Data.Aeson\nimport Kernel.Prelude\nimport Kernel.Utils.JSON\n\ndata IncidentReportReq = IncidentReportReq\n  { contactNo :: Text,\n    latitude :: Double,\n    longitude :: Double,\n    userName :: Text,\n    mpin :: Text\n  }\n  deriving (Show, Eq, Generic)\n\ninstance ToJSON IncidentReportReq where\n  toJSON = genericToJSON constructorsWithSnakeCase\n\ndata IncidentReportData = IncidentReportData\n  { jmCode :: Text\n  }\n  deriving (Show, Eq, Generic)\n\ndata IncidentReportRes = IncidentReportRes\n  { version :: Text,\n    status :: Int,\n    message :: Text,\n    incidentData :: IncidentReportData\n  }\n  deriving (Show, Eq, Generic)\n\njsonOptions :: Options\njsonOptions =\n  defaultOptions\n    { fieldLabelModifier = \\case\n        \"incidentData\" -> \"data\"\n        other -> other\n    }\n\njsonOptionsData :: Options\njsonOptionsData =\n  defaultOptions\n    { fieldLabelModifier = \\case\n        \"jmCode\" -> \"jm_code\"\n        other -> other\n    }\n\ninstance FromJSON IncidentReportData where\n  parseJSON = genericParseJSON jsonOptionsData\n\ninstance ToJSON IncidentReportData where\n  toJSON = genericToJSON jsonOptionsData\n\ninstance FromJSON IncidentReportRes where\n  parseJSON = genericParseJSON jsonOptions\n\ninstance ToJSON IncidentReportRes where\n  toJSON = genericToJSON jsonOptions\n\ndata IncidentReportUpdateReq = IncidentReportUpdateReq\n  { jmCode :: Text,\n    latitude :: Double,\n    longitude :: Double\n  }\n  deriving (Show, Eq, Generic)\n\ninstance ToJSON IncidentReportUpdateReq where\n  toJSON = genericToJSON constructorsWithSnakeCase\n\ndata IncidentReportUpdateRes = IncidentReportUpdateRes\n  { version :: Text,\n    status :: Int,\n    message :: Text,\n    incidentData :: Maybe Text\n  }\n  deriving (Show, Eq, Generic)\n\ninstance FromJSON IncidentReportUpdateRes where\n  parseJSON = genericParseJSON jsonOptions\n\ninstance ToJSON IncidentReportUpdateRes where\n  toJSON = genericToJSON jsonOptions\n",
      "hash": "f790e74bc67fb4af46730b6ff9d255a821faeaf389f2a04c0ed1c7d924dc810c",
      "size": 2729
    },
    "/lib/mobility-core/src/Kernel/External/IncidentReport/Interface.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\nmodule Kernel.External.IncidentReport.Interface\n  ( reportIncident,\n    reportIncidentUpdate,\n  )\nwhere\n\nimport qualified Kernel.External.IncidentReport.Interface.ERSS as ERSSIntegration\nimport Kernel.External.IncidentReport.Interface.Types\nimport Kernel.Tools.Metrics.CoreMetrics (CoreMetrics)\nimport Kernel.Types.Common\n\nreportIncident ::\n  ( EncFlow m r,\n    CoreMetrics m\n  ) =>\n  IncidentReportServiceConfig ->\n  IncidentReportReq ->\n  m IncidentReportRes\nreportIncident serviceConfig req = case serviceConfig of\n  ERSSConfig cfg -> ERSSIntegration.reportIncident cfg req\n\nreportIncidentUpdate ::\n  ( EncFlow m r,\n    CoreMetrics m\n  ) =>\n  IncidentReportServiceConfig ->\n  IncidentReportUpdateReq ->\n  m IncidentReportUpdateRes\nreportIncidentUpdate serviceConfig req = case serviceConfig of\n  ERSSConfig cfg -> ERSSIntegration.reportIncidentUpdate cfg req\n",
      "hash": "f62b4fb4b7c86bccd320bff935cb31e0818643b26cb64a5b546bb06bb8e9c026",
      "size": 1555
    },
    "/lib/mobility-core/src/Kernel/External/IncidentReport/Interface/ERSS.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n\nmodule Kernel.External.IncidentReport.Interface.ERSS\n  ( reportIncident,\n    reportIncidentUpdate,\n  )\nwhere\n\nimport Kernel.External.Encryption\nimport Kernel.External.IncidentReport.ERSS.Config\nimport qualified Kernel.External.IncidentReport.ERSS.Flow as EF\nimport Kernel.External.IncidentReport.ERSS.Types as ERSS\nimport qualified Kernel.External.IncidentReport.Interface.Types as Interface\nimport Kernel.Prelude\nimport Kernel.Tools.Metrics.CoreMetrics (CoreMetrics)\n\nreportIncident ::\n  ( CoreMetrics m,\n    EncFlow m r\n  ) =>\n  ERSSCfg ->\n  Interface.IncidentReportReq ->\n  m Interface.IncidentReportRes\nreportIncident config req = do\n  erssRequest <- makeERSSRequest req config\n  erssResponse <- EF.reportIncident erssRequest config.url req.token\n  pure $ makeInterfaceResponse erssResponse\n  where\n    makeERSSRequest :: EncFlow m r => Interface.IncidentReportReq -> ERSSCfg -> m ERSS.IncidentReportReq\n    makeERSSRequest Interface.IncidentReportReq {..} cfg = do\n      pure $\n        ERSS.IncidentReportReq\n          { userName = cfg.userName,\n            ..\n          }\n    makeInterfaceResponse :: ERSS.IncidentReportRes -> Interface.IncidentReportRes\n    makeInterfaceResponse ERSS.IncidentReportRes {..} = Interface.IncidentReportRes {incidentData = cast incidentData, ..}\n      where\n        cast :: ERSS.IncidentReportData -> Interface.IncidentReportData\n        cast ERSS.IncidentReportData {..} = Interface.ReportData {..}\n\nreportIncidentUpdate ::\n  ( CoreMetrics m,\n    EncFlow m r\n  ) =>\n  ERSSCfg ->\n  Interface.IncidentReportUpdateReq ->\n  m Interface.IncidentReportUpdateRes\nreportIncidentUpdate config req = do\n  erssRequest <- makeERSSUpdateRequest req\n  erssResponse <- EF.reportIncidentUpdate erssRequest config.url req.token\n  pure $ makeInterfaceUpdateResponse erssResponse\n  where\n    makeERSSUpdateRequest :: EncFlow m r => Interface.IncidentReportUpdateReq -> m ERSS.IncidentReportUpdateReq\n    makeERSSUpdateRequest Interface.IncidentReportUpdateReq {..} = pure ERSS.IncidentReportUpdateReq {..}\n    makeInterfaceUpdateResponse :: ERSS.IncidentReportUpdateRes -> Interface.IncidentReportUpdateRes\n    makeInterfaceUpdateResponse ERSS.IncidentReportUpdateRes {..} = Interface.IncidentReportUpdateRes {..}\n",
      "hash": "1b20115a4e489091b1e0929146d0427eaaced867db4fc236b20b16341d795a67",
      "size": 2928
    },
    "/lib/mobility-core/src/Kernel/External/IncidentReport/Interface/Error.hs": {
      "type": "content",
      "content": "{-\n Copyright 2022-23, Juspay India Pvt Ltd\n\n This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program\n\n is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n\n or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of\n\n the GNU Affero General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n{-# LANGUAGE DeriveAnyClass #-}\n{-# LANGUAGE TemplateHaskell #-}\n\nmodule Kernel.External.IncidentReport.Interface.Error where\n\nimport Kernel.Prelude\nimport Kernel.Types.Error.BaseError\nimport Kernel.Types.Error.BaseError.HTTPError\n\ndata IncidentReportError\n  = FailedToCallIncidentReportAPI Text\n  | FailedToCallIncidentReportUpdateAPI Text\n  deriving (Eq, Show, IsBecknAPIError)\n\ninstanceExceptionWithParent 'HTTPException ''IncidentReportError\n\ninstance IsBaseError IncidentReportError where\n  toMessage = \\case\n    FailedToCallIncidentReportAPI err -> Just $ \"Failed to incident report API: \" <> err\n    FailedToCallIncidentReportUpdateAPI err -> Just $ \"Failed to incident report update API: \" <> err\n\ninstance IsHTTPError IncidentReportError where\n  toErrorCode = \\case\n    FailedToCallIncidentReportAPI _ -> \"FAILED_TO_CALL_INCIDENT_REPORT_API\"\n    FailedToCallIncidentReportUpdateAPI _ -> \"FAILED_TO_CALL_INCIDENT_REPORT_UPDATE_API\"\n  toHttpCode = \\case\n    FailedToCallIncidentReportAPI _ -> E400\n    FailedToCallIncidentReportUpdateAPI _ -> E400\n\ninstance IsAPIError IncidentReportError\n",
      "hash": "e0beb87d0a2f531458fbc6e15767660a3c862e86146a37e9eead15300d97c0b7",
      "size": 1783
    },
    "/lib/mobility-core/src/Kernel/External/IncidentReport/Interface/Types.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n{-# LANGUAGE DeriveGeneric #-}\n{-# LANGUAGE DerivingVia #-}\n\nmodule Kernel.External.IncidentReport.Interface.Types\n  ( module Reexport,\n    module Kernel.External.IncidentReport.Interface.Types,\n  )\nwhere\n\nimport Deriving.Aeson\nimport qualified Kernel.External.IncidentReport.ERSS.Config as ERSS\nimport Kernel.External.IncidentReport.Types as Reexport\nimport Kernel.Prelude\n\nnewtype IncidentReportServiceConfig = ERSSConfig ERSS.ERSSCfg\n  deriving (Show, Eq, Generic, ToJSON, FromJSON)\n\ndata IncidentReportReq = IncidentReportReq\n  { contactNo :: Text,\n    latitude :: Double,\n    longitude :: Double,\n    mpin :: Text,\n    token :: Text\n  }\n  deriving (Show, Eq, Generic, FromJSON, ToJSON)\n\ndata IncidentReportData = ReportData\n  { jmCode :: Text\n  }\n  deriving (Show, Eq, Generic, FromJSON, ToJSON)\n\ndata IncidentReportRes = IncidentReportRes\n  { version :: Text,\n    status :: Int,\n    message :: Text,\n    incidentData :: IncidentReportData\n  }\n  deriving (Show, Eq, Generic, FromJSON, ToJSON)\n\ndata IncidentReportUpdateReq = IncidentReportUpdateReq\n  { jmCode :: Text,\n    latitude :: Double,\n    longitude :: Double,\n    token :: Text\n  }\n  deriving (Show, Eq, Generic, FromJSON, ToJSON)\n\ndata IncidentReportUpdateRes = IncidentReportUpdateRes\n  { version :: Text,\n    status :: Int,\n    message :: Text,\n    incidentData :: Maybe Text\n  }\n  deriving (Show, Eq, Generic, FromJSON, ToJSON)\n",
      "hash": "150d2903848f12544da3f0eda1a67c44d7898a90c653051c2bf0386205b18897",
      "size": 2088
    },
    "/lib/mobility-core/src/Kernel/External/IncidentReport/Types.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n{-# LANGUAGE TemplateHaskell #-}\n\nmodule Kernel.External.IncidentReport.Types\n  ( module Kernel.External.IncidentReport.Types,\n  )\nwhere\n\nimport qualified Data.Aeson as A\nimport Data.OpenApi\nimport qualified Data.Text as T\nimport EulerHS.Prelude\nimport Kernel.Beam.Lib.UtilsTH (mkBeamInstancesForEnum)\nimport qualified Kernel.Prelude as KP\nimport Kernel.Storage.Esqueleto (derivePersistField)\n\ndata IncidentReportService = ERSS\n  deriving (Show, Read, Eq, Ord, Generic, ToSchema)\n\ninstance FromJSON IncidentReportService where -- remove this instance once you add more constructors to IncidentReportService type.\n  parseJSON (A.String val) = maybe (fail (\"failed to parse String \" <> show val <> \" in IncidentReportService type\")) pure (KP.readMaybe $ T.unpack val)\n  parseJSON (A.Array _) = pure ERSS\n  parseJSON e = fail $ \"unexpected type, expected String for IncidentReportService \" <> show e\n\ninstance ToJSON IncidentReportService where\n  toJSON ERSS = A.String (show ERSS)\n\n$(mkBeamInstancesForEnum ''IncidentReportService)\n\nderivePersistField \"IncidentReportService\"\n",
      "hash": "662d3fc846da5e419c8bd39c09cfb9ffb830b66df3ec84dadf8d061097896671",
      "size": 1767
    },
    "/lib/mobility-core/src/Kernel/External/Infobip/API/SendSms.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n\nmodule Kernel.External.Infobip.API.SendSms where\n\nimport EulerHS.Prelude\nimport qualified EulerHS.Types as ET\nimport Kernel.External.Infobip.Types\nimport Servant\n\ntype ServiceAPI =\n  \"sms\" :> \"1\" :> \"text\" :> \"query\"\n    :> QueryParam \"username\" Text\n    :> QueryParam \"password\" Text\n    :> QueryParam \"from\" Text\n    :> QueryParam \"to\" Text\n    :> QueryParam \"text\" Text\n    :> QueryParam \"indiaDltPrincipalEntityId\" Text\n    :> QueryParam \"indiaDltContentTemplateId\" Text\n    :> QueryParam \"notifyUrl\" Text\n    :> Post '[JSON] SMSRes\n\nserviceAPI :: Proxy ServiceAPI\nserviceAPI = Proxy\n\nsendSms :: Text -> Text -> Text -> Text -> Text -> Text -> Text -> Text -> ET.EulerClient SMSRes\nsendSms username password from to text indiaDltPrincipalEntityId indiaDltContentTemplateId url = ET.client serviceAPI (Just username) (Just password) (Just from) (Just to) (Just text) (Just indiaDltContentTemplateId) (Just indiaDltPrincipalEntityId) (Just url)\n",
      "hash": "5b3dfebcacd2c0cc63edc14aca4bfc7bbc60e5dbf334f2e0b15e73b646bad604",
      "size": 1641
    },
    "/lib/mobility-core/src/Kernel/External/Infobip/API/WebengageWebhook.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n\nmodule Kernel.External.Infobip.API.WebengageWebhook where\n\nimport EulerHS.Prelude\nimport qualified EulerHS.Types as ET\nimport Kernel.External.Infobip.Types\nimport Kernel.Types.APISuccess (APISuccess)\nimport Servant\n\ntype ServiceAPI =\n  \"tracking\"\n    :> \"privatessp-events\"\n    :> ReqBody '[JSON] WebengageRes\n    :> Post '[JSON] APISuccess\n\nserviceAPI :: Proxy ServiceAPI\nserviceAPI = Proxy\n\nsendStatus :: WebengageRes -> ET.EulerClient APISuccess\nsendStatus = ET.client serviceAPI\n",
      "hash": "7bf60c22c1e7003876507d4da5cae06107fd78bd75ed89411ef2fb452d39399a",
      "size": 1177
    },
    "/lib/mobility-core/src/Kernel/External/Infobip/Flow.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n\nmodule Kernel.External.Infobip.Flow where\n\nimport EulerHS.Prelude\nimport qualified Kernel.External.Infobip.API.SendSms as APISend\nimport qualified Kernel.External.Infobip.API.WebengageWebhook as APIStatus\nimport Kernel.External.Infobip.Types\nimport Kernel.Tools.Metrics.CoreMetrics (CoreMetrics)\nimport Kernel.Types.APISuccess (APISuccess)\nimport Kernel.Types.Common\nimport Kernel.Types.Error\nimport Kernel.Utils.Common\n\nsendSms ::\n  ( CoreMetrics m,\n    MonadFlow m\n  ) =>\n  InfoBIPConfig ->\n  Text ->\n  Text ->\n  Text ->\n  Text ->\n  m SMSRes\nsendSms smsCfg smsTemplate phoneNumber entityId templetId = do\n  let url = smsCfg.url\n  let userName = smsCfg.username\n  let password = smsCfg.password\n  let from = smsCfg.sender\n  let webhookurl = smsCfg.webhookurl\n  submitSms url userName password from phoneNumber smsTemplate entityId templetId webhookurl\n\nsubmitSms ::\n  ( CoreMetrics m,\n    MonadFlow m\n  ) =>\n  BaseUrl ->\n  Text ->\n  Text ->\n  Text ->\n  Text ->\n  Text ->\n  Text ->\n  Text ->\n  Text ->\n  m SMSRes\nsubmitSms url userName password from phoneNumber smsTemplate entityId templetId webhookurl = do\n  callAPI url (APISend.sendSms userName password from phoneNumber smsTemplate entityId templetId webhookurl) \"sendSms\" APISend.serviceAPI\n    >>= fromEitherM (ExternalAPICallError (Just \"UNABLE_TO_SEND_SMS\") url)\n\ncallWebengageWebhook ::\n  ( CoreMetrics m,\n    MonadFlow m\n  ) =>\n  WebengageConfig ->\n  WebengageRes ->\n  m APISuccess\ncallWebengageWebhook webCfg req = do\n  let url = webCfg.url\n  callAPI url (APIStatus.sendStatus req) \"success\" APIStatus.serviceAPI\n    >>= fromEitherM (ExternalAPICallError (Just \"UNABLE_TO_CALL_WEBHOOK\") url)\n",
      "hash": "24961fc9ba2863d7781d5902dfd832d23fcf6dd484c3ab007de5e7fec68136f6",
      "size": 2348
    },
    "/lib/mobility-core/src/Kernel/External/Infobip/Types.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n\nmodule Kernel.External.Infobip.Types where\n\nimport Kernel.Prelude\nimport Kernel.Utils.Dhall (FromDhall)\n\nnewtype SMSRes = SMSRes\n  { messages :: [Message]\n  }\n  deriving (Generic, FromJSON, ToJSON, Show, Eq, FromDhall)\n\ndata Message = Message\n  { to :: Text,\n    status :: SMSStatus,\n    messageId :: Text,\n    smsCount :: Integer\n  }\n  deriving (Generic, FromJSON, ToJSON, Show, Eq, FromDhall)\n\ndata SMSStatus = SMSStatus\n  { description :: Text,\n    groupId :: Int,\n    groupName :: Text,\n    id :: Int,\n    name :: Text\n  }\n  deriving (Generic, FromJSON, ToJSON, Show, Eq, FromDhall)\n\ndata WebengageRes = WebengageRes\n  { version :: Text,\n    messageId :: Text,\n    toNumber :: Text,\n    status :: Text,\n    statusCode :: Text\n  }\n  deriving (Generic, FromJSON, ToJSON, ToSchema)\n\ndata InfoBIPConfig = InfoBIPConfig\n  { username :: Text,\n    password :: Text,\n    url :: BaseUrl,\n    sender :: Text,\n    token :: Text,\n    webhookurl :: Text\n  }\n  deriving (Generic, FromJSON, ToJSON, Show, Eq, FromDhall)\n\nnewtype WebengageConfig = WebengageConfig\n  { url :: BaseUrl\n  }\n  deriving (Generic, FromJSON, ToJSON, Show, Eq, FromDhall)\n",
      "hash": "7924f4ab82b8fb766966789c0ab0855f132d2c924893be8310259340a7d5c591",
      "size": 1829
    },
    "/lib/mobility-core/src/Kernel/External/Insurance/Acko/Flow.hs": {
      "type": "content",
      "content": "module Kernel.External.Insurance.Acko.Flow where\n\nimport EulerHS.Types as Euler\nimport Kernel.External.Encryption\nimport Kernel.External.Insurance.Acko.Types\nimport Kernel.Prelude\nimport qualified Kernel.Tools.Metrics.CoreMetrics as Metrics\nimport Kernel.Types.Error\nimport Kernel.Utils.Common\nimport Servant hiding (throwError)\n\ntype CreateInsuranceAPI =\n  \"product\"\n    :> Capture \"partnerId\" Text\n    :> \"policies\"\n    :> Header \"Authorization\" Text\n    :> Header \"Content-Type\" Text\n    :> ReqBody '[JSON] AckoInsuranceRequest\n    :> Post '[JSON] [AckoInsuranceResponse]\n\ncreateInsurance :: (Metrics.CoreMetrics m, EncFlow m r) => BaseUrl -> Text -> AckoInsuranceRequest -> m [AckoInsuranceResponse]\ncreateInsurance url authHeader request = do\n  let proxy = Proxy @CreateInsuranceAPI\n      eulerClient = Euler.client proxy request.partner_id (Just authHeader) (Just \"application/json\") request\n  callAckoAPI url eulerClient \"create-insurance\" proxy\n\ncallAckoAPI :: CallAPI' m api res res\ncallAckoAPI url eulerClient description proxy = do\n  callAPI url eulerClient description proxy\n    >>= fromEitherM (\\err -> InternalError $ \"Failed to call \" <> description <> \" API: \" <> show err)\n",
      "hash": "9b6bb580b31884003afee3760671aa35cc08b715ba364e66738f3110c02802b4",
      "size": 1190
    },
    "/lib/mobility-core/src/Kernel/External/Insurance/Acko/Types.hs": {
      "type": "content",
      "content": "module Kernel.External.Insurance.Acko.Types where\n\nimport Data.Aeson\nimport Kernel.External.Encryption\nimport Kernel.Prelude\n\ndata AckoInsuranceRequest = AckoInsuranceRequest\n  { trip :: Trip,\n    category :: Text,\n    customer :: Customer,\n    plan_type :: Int,\n    reference_id :: Text,\n    plan :: Text,\n    partner_id :: Text\n  }\n  deriving (Show, Eq, Generic, ToJSON, FromJSON)\n\ndata Trip = Trip\n  { journey :: [Journey],\n    end_date :: UTCTime,\n    booking_id :: Text,\n    start_date :: UTCTime,\n    booking_date :: UTCTime\n  }\n  deriving (Show, Eq, Generic, ToJSON, FromJSON)\n\ndata Journey = Journey\n  { mode :: Maybe Text,\n    origin :: Location,\n    person :: [Person],\n    destination :: Location\n  }\n  deriving (Show, Eq, Generic, ToJSON, FromJSON)\n\ndata Location = Location\n  { city :: Text\n  }\n  deriving (Show, Eq, Generic, ToJSON, FromJSON)\n\ndata Person = Person\n  { insured :: Insured\n  }\n  deriving (Show, Eq, Generic, ToJSON, FromJSON)\n\ndata Insured = Insured\n  { name :: Text,\n    phone :: Text\n  }\n  deriving (Show, Eq, Generic, ToJSON, FromJSON)\n\ndata Customer = Customer\n  { id :: Text,\n    name :: Text,\n    phone :: Text,\n    state :: Text\n  }\n  deriving (Show, Eq, Generic, ToJSON, FromJSON)\n\ndata AckoInsuranceResponse = AckoInsuranceResponse\n  { policy_id :: Text,\n    reference_id :: Text,\n    plan_type :: Int,\n    start_date :: Maybe UTCTime,\n    end_date :: Maybe UTCTime,\n    policy_number :: Text,\n    certificate_pdf :: Text,\n    certificate_url :: Text,\n    person :: [PersonResponse],\n    premium :: Premium\n  }\n  deriving (Show, Eq, Generic, ToJSON, FromJSON)\n\ndata Premium = Premium\n  { amount :: Double,\n    gst :: Double,\n    sgst :: Double,\n    cgst :: Double,\n    igst :: Double,\n    breakup :: [Value]\n  }\n  deriving (Show, Eq, Generic, ToJSON, FromJSON)\n\ndata PersonResponse = PersonResponse\n  { insured :: InsuredResponse\n  }\n  deriving (Show, Eq, Generic, ToJSON, FromJSON)\n\ndata InsuredResponse = InsuredResponse\n  { name :: Text,\n    phone :: Text,\n    policy_number :: Text\n  }\n  deriving (Show, Eq, Generic, ToJSON, FromJSON)\n\ndata AckoInsuranceConfig = AckoInsuranceConfig\n  { url :: BaseUrl,\n    partnerId :: Text,\n    username :: Text,\n    state :: Text,\n    apiKey :: EncryptedField 'AsEncrypted Text\n  }\n  deriving (Show, Eq, Generic, ToJSON, FromJSON)\n",
      "hash": "417f644de990f09023ae3477a862fbe3c2e90cc54a17dd8a2ce47605edc3231a",
      "size": 2309
    },
    "/lib/mobility-core/src/Kernel/External/Insurance/Interface.hs": {
      "type": "content",
      "content": "module Kernel.External.Insurance.Interface\n  ( module Reexport,\n    module Kernel.External.Insurance.Interface,\n  )\nwhere\n\nimport qualified Kernel.External.Insurance.Interface.Acko as Acko\nimport Kernel.External.Insurance.Interface.Types\nimport Kernel.External.Insurance.Types as Reexport\nimport Kernel.Tools.Metrics.CoreMetrics (CoreMetrics)\nimport Kernel.Utils.Common\n\ncreateInsurance ::\n  ( EncFlow m r,\n    CoreMetrics m\n  ) =>\n  InsuranceConfig ->\n  InsuranceRequest ->\n  m InsuranceResponse\ncreateInsurance serviceConfig req = case serviceConfig of\n  AckoInsuranceConfig cfg -> Acko.createInsurance cfg req\n",
      "hash": "44591dcc9be21e5bdb1dba67f9bb9d278cb699a0c42e96ef64169e9a1f262e31",
      "size": 613
    },
    "/lib/mobility-core/src/Kernel/External/Insurance/Interface/Acko.hs": {
      "type": "content",
      "content": "module Kernel.External.Insurance.Interface.Acko where\n\nimport qualified Data.Text as T\nimport Data.Time.Format (defaultTimeLocale, formatTime)\nimport EulerHS.Language (MonadFlow)\nimport Kernel.External.Encryption\nimport qualified Kernel.External.Insurance.Acko.Flow as Acko\nimport qualified Kernel.External.Insurance.Acko.Types as AckoTypes\nimport Kernel.External.Insurance.Interface.Types\nimport Kernel.Prelude\nimport qualified Kernel.Tools.Metrics.CoreMetrics as Metrics\nimport Kernel.Types.Error\nimport Kernel.Types.Time (getCurrentTime)\nimport Kernel.Utils.Error.Throwing (throwError)\nimport Kernel.Utils.Logging (logError)\n\n--import Kernel.Utils.Text (encodeToText)\n\ncreateInsurance :: (Metrics.CoreMetrics m, EncFlow m r) => AckoTypes.AckoInsuranceConfig -> InsuranceRequest -> m InsuranceResponse\ncreateInsurance config request = do\n  let insuranceReq = toAckoInsuranceRequest request\n  authHeader <- mkAuthHeader config\n  -- logDebug $ \"Acko insurance request: \" <> (encodeToText insuranceReq)\n  resp <- Acko.createInsurance config.url authHeader insuranceReq\n  let resp' = headMay $ resp\n  case resp' of\n    Just resp'' -> do\n      -- logDebug $ \"Acko insurance response: \" <> (encodeToText resp'')\n      return $ fromAckoInsuranceResponse resp''\n    Nothing -> do\n      logError $ \"Acko insurance response is empty\"\n      throwError $ InternalError \"Acko insurance response is empty\"\n\nmkAuthHeader ::\n  ( Metrics.CoreMetrics m,\n    MonadFlow m,\n    EncFlow m r\n  ) =>\n  AckoTypes.AckoInsuranceConfig ->\n  m Text\nmkAuthHeader config = do\n  createdOn <- getCurrentTime\n  secret <- decrypt config.apiKey\n  let timestamp = T.pack $ formatTime defaultTimeLocale \"%Y-%m-%dT%H:%M:%S.%6qZ\" createdOn\n  let header = \"username=\" <> config.username <> \" algorithm=key_auth created_on=\" <> timestamp <> \" secret=\" <> secret\n  --logDebug $ \"Acko auth header: \" <> header\n  return header\n\n---------------------------------------- Conversion functions ----------------------------------------\n\ntoAckoInsuranceRequest :: InsuranceRequest -> AckoTypes.AckoInsuranceRequest\ntoAckoInsuranceRequest req =\n  AckoTypes.AckoInsuranceRequest\n    { trip = convertTrip req.trip,\n      category = req.category,\n      customer = convertCustomer req.customer,\n      plan_type = req.planType,\n      reference_id = req.referenceId,\n      plan = req.plan,\n      partner_id = req.partnerId\n    }\n\nfromAckoInsuranceResponse :: AckoTypes.AckoInsuranceResponse -> InsuranceResponse\nfromAckoInsuranceResponse resp =\n  InsuranceResponse\n    { policyId = resp.policy_id,\n      referenceId = resp.reference_id,\n      planType = Just resp.plan_type,\n      startDate = resp.start_date,\n      endDate = resp.end_date,\n      policyNumber = resp.policy_number,\n      certificatePdf = Just resp.certificate_pdf,\n      certificateUrl = Just resp.certificate_url,\n      person = Just $ map convertPersonResponse resp.person,\n      premium = Just $ convertPremium resp.premium\n    }\n\nconvertTrip :: Trip -> AckoTypes.Trip\nconvertTrip trip =\n  AckoTypes.Trip\n    { journey = map convertJourney trip.journey,\n      end_date = trip.endDate,\n      booking_id = trip.bookingId,\n      start_date = trip.startDate,\n      booking_date = trip.bookingDate\n    }\n\nconvertJourney :: Journey -> AckoTypes.Journey\nconvertJourney journey =\n  AckoTypes.Journey\n    { mode = journey.mode,\n      origin = convertLocation journey.origin,\n      person = map convertPerson journey.person,\n      destination = convertLocation journey.destination\n    }\n\nconvertLocation :: Location -> AckoTypes.Location\nconvertLocation location =\n  AckoTypes.Location\n    { city = location.city\n    }\n\nconvertPerson :: Person -> AckoTypes.Person\nconvertPerson person =\n  AckoTypes.Person\n    { insured = convertInsured person.insured\n    }\n\nconvertInsured :: Insured -> AckoTypes.Insured\nconvertInsured insured =\n  AckoTypes.Insured\n    { name = insured.name,\n      phone = insured.phone\n    }\n\nconvertCustomer :: Customer -> AckoTypes.Customer\nconvertCustomer customer =\n  AckoTypes.Customer\n    { id = customer.id,\n      name = customer.name,\n      phone = customer.phone,\n      state = customer.state\n    }\n\nconvertPersonResponse :: AckoTypes.PersonResponse -> PersonResponse\nconvertPersonResponse personResp =\n  PersonResponse\n    { insured = convertInsuredResponse personResp.insured\n    }\n\nconvertInsuredResponse :: AckoTypes.InsuredResponse -> InsuredResponse\nconvertInsuredResponse insuredResp =\n  InsuredResponse\n    { name = Just insuredResp.name,\n      phone = Just insuredResp.phone,\n      policyNumber = Just insuredResp.policy_number\n    }\n\nconvertPremium :: AckoTypes.Premium -> Premium\nconvertPremium premium =\n  Premium\n    { amount = premium.amount,\n      gst = Just premium.gst,\n      sgst = Just premium.sgst,\n      cgst = Just premium.cgst,\n      igst = Just premium.igst,\n      breakup = Just premium.breakup\n    }\n",
      "hash": "83f7f58868d699c9473e1b30497c63d9ed51e1e68ac21806418dc6b927165932",
      "size": 4859
    },
    "/lib/mobility-core/src/Kernel/External/Insurance/Interface/Types.hs": {
      "type": "content",
      "content": "module Kernel.External.Insurance.Interface.Types where\n\nimport Data.Aeson\nimport qualified Kernel.External.Insurance.Acko.Types as Acko\nimport Kernel.Prelude\n\ndata InsuranceRequest = InsuranceRequest\n  { trip :: Trip,\n    category :: Text,\n    customer :: Customer,\n    planType :: Int,\n    referenceId :: Text,\n    plan :: Text,\n    partnerId :: Text\n  }\n  deriving (Show, Eq, Generic, ToJSON, FromJSON)\n\ndata Trip = Trip\n  { journey :: [Journey],\n    endDate :: UTCTime,\n    bookingId :: Text,\n    startDate :: UTCTime,\n    bookingDate :: UTCTime\n  }\n  deriving (Show, Eq, Generic, ToJSON, FromJSON)\n\ndata Journey = Journey\n  { mode :: Maybe Text,\n    origin :: Location,\n    person :: [Person],\n    destination :: Location\n  }\n  deriving (Show, Eq, Generic, ToJSON, FromJSON)\n\ndata Location = Location\n  { city :: Text\n  }\n  deriving (Show, Eq, Generic, ToJSON, FromJSON)\n\ndata Person = Person\n  { insured :: Insured\n  }\n  deriving (Show, Eq, Generic, ToJSON, FromJSON)\n\ndata Insured = Insured\n  { name :: Text,\n    phone :: Text\n  }\n  deriving (Show, Eq, Generic, ToJSON, FromJSON)\n\ndata Customer = Customer\n  { id :: Text,\n    name :: Text,\n    phone :: Text,\n    state :: Text\n  }\n  deriving (Show, Eq, Generic, ToJSON, FromJSON)\n\ndata InsuranceConfig = AckoInsuranceConfig Acko.AckoInsuranceConfig deriving (Show, Eq, Generic, ToJSON, FromJSON)\n\ndata InsuranceResponse = InsuranceResponse\n  { policyId :: Text,\n    referenceId :: Text,\n    planType :: Maybe Int,\n    startDate :: Maybe UTCTime,\n    endDate :: Maybe UTCTime,\n    policyNumber :: Text,\n    certificatePdf :: Maybe Text,\n    certificateUrl :: Maybe Text,\n    person :: Maybe [PersonResponse],\n    premium :: Maybe Premium\n  }\n  deriving (Show, Eq, Generic, ToJSON, FromJSON)\n\ndata PersonResponse = PersonResponse\n  { insured :: InsuredResponse\n  }\n  deriving (Show, Eq, Generic, ToJSON, FromJSON)\n\ndata InsuredResponse = InsuredResponse\n  { name :: Maybe Text,\n    phone :: Maybe Text,\n    policyNumber :: Maybe Text\n  }\n  deriving (Show, Eq, Generic, ToJSON, FromJSON)\n\ndata Premium = Premium\n  { amount :: Double,\n    gst :: Maybe Double,\n    sgst :: Maybe Double,\n    cgst :: Maybe Double,\n    igst :: Maybe Double,\n    breakup :: Maybe [Value]\n  }\n  deriving (Show, Eq, Generic, ToJSON, FromJSON)\n",
      "hash": "52a7947a7453086368041a205ece0ab556f799f01bf4aedfa7876740c7deacf6",
      "size": 2272
    },
    "/lib/mobility-core/src/Kernel/External/Insurance/Types.hs": {
      "type": "content",
      "content": "{-# LANGUAGE TemplateHaskell #-}\n\nmodule Kernel.External.Insurance.Types where\n\nimport Data.Aeson.Types\nimport EulerHS.Prelude\nimport Kernel.Beam.Lib.UtilsTH (mkBeamInstancesForEnumAndList)\nimport Kernel.Storage.Esqueleto (derivePersistField)\n\ndata InsuranceService = Acko\n  deriving (Show, Read, Eq, Ord, Generic)\n\n$(mkBeamInstancesForEnumAndList ''InsuranceService)\nderivePersistField \"InsuranceService\"\n\n-- Generic instances for type with single value will not work\ninstance FromJSON InsuranceService where\n  parseJSON (String \"Acko\") = pure Acko\n  parseJSON (String _) = parseFail \"Expected \\\"Acko\\\"\"\n  parseJSON e = typeMismatch \"String\" e\n\ninstance ToJSON InsuranceService where\n  toJSON = String . show\n",
      "hash": "7ddceeb3e568c444cc473352302bf261c124e524b9e4bd2fee5f22b6ca9ff5f3",
      "size": 710
    },
    "/lib/mobility-core/src/Kernel/External/Maps.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n\nmodule Kernel.External.Maps (module Reexport) where\n\nimport Kernel.External.Maps.Interface as Reexport\nimport Kernel.External.Types as Reexport (Language (..))\n",
      "hash": "193382f0dad2a19baf21f4d675c017ad74aeba9ab0512cec3e834cd52609e85f",
      "size": 854
    },
    "/lib/mobility-core/src/Kernel/External/Maps/Google/Config.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n\nmodule Kernel.External.Maps.Google.Config where\n\nimport Kernel.External.Encryption\nimport Kernel.External.Maps.Google.MapsClient.Types\nimport Kernel.Prelude\nimport Kernel.Utils.Dhall (FromDhall)\n\ndata GoogleCfg = GoogleCfg\n  { googleMapsUrl :: BaseUrl,\n    googleRoadsUrl :: BaseUrl,\n    googleKey :: EncryptedField 'AsEncrypted Text,\n    useAdvancedDirections :: Bool,\n    googleRouteConfig :: GoogleRouteConfig,\n    googlePlaceNewUrl :: BaseUrl,\n    useNewPlaces :: Bool,\n    googleAutocompleteParams :: Maybe [Text]\n  }\n  deriving (Show, Eq, Generic, ToJSON, FromJSON)\n\ndata GoogleRouteConfig = GoogleRouteConfig\n  { computeAlternativeRoutes :: Bool,\n    routePreference :: RoutingPreference,\n    url :: BaseUrl\n  }\n  deriving (Show, Eq, Generic, ToJSON, FromJSON, ToSchema, FromDhall)\n",
      "hash": "0e7414cd00aeb6470577386ad677b3a9393aee22483232f462d51b3265e0f419",
      "size": 1483
    },
    "/lib/mobility-core/src/Kernel/External/Maps/Google/MapsClient.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n\nmodule Kernel.External.Maps.Google.MapsClient\n  ( module GoogleMaps,\n    GoogleMapsAPI,\n    AutocompleteAPI,\n    AutoCompleteV2API,\n    PlaceDetailsAPI,\n    PlaceNameAPI,\n    DistanceMatrixAPI,\n    DirectionsAPI,\n    AdvancedDirectionsAPI,\n    TransitDirectionsAPI,\n    advancedDirectionsAPI,\n    transitDirectionsAPI,\n    autoComplete,\n    getPlaceDetails,\n    getPlaceName,\n    distanceMatrix,\n    directions,\n    autoCompleteV2,\n  )\nwhere\n\nimport Data.Text as T\nimport EulerHS.Types (EulerClient, client)\nimport Kernel.External.Maps.Google.MapsClient.Types as GoogleMaps\nimport qualified Kernel.External.Maps.Interface.Types as MapsInterfaceTypes\nimport Kernel.External.Maps.Types\nimport Kernel.External.Types (Language)\nimport Kernel.Prelude\nimport Kernel.Streaming.Kafka.Producer.Types (HasKafkaProducer)\nimport Kernel.Tools.Metrics.CoreMetrics (CoreMetrics)\nimport Kernel.Types.Common\nimport Kernel.Types.Error\nimport Kernel.Utils.Common\nimport qualified Kernel.Utils.ExternalAPICallLogging as ApiCallLogger\nimport Servant hiding (throwError)\nimport Servant.Client.Core (ClientError)\n\ntype GoogleMapsAPI =\n  AutocompleteAPI\n    :<|> AutoCompleteV2API\n    :<|> PlaceDetailsAPI\n    :<|> PlaceNameAPI\n    :<|> DistanceMatrixAPI\n    :<|> DirectionsAPI\n    :<|> AdvancedDirectionsAPI\n    :<|> TransitDirectionsAPI\n\ntype AutocompleteAPI =\n  \"place\" :> \"autocomplete\" :> \"json\"\n    :> Header \"sessiontoken\" Text\n    :> MandatoryQueryParam \"key\" Text\n    :> MandatoryQueryParam \"input\" Text\n    :> MandatoryQueryParam \"location\" Text\n    :> MandatoryQueryParam \"radius\" Integer\n    :> MandatoryQueryParam \"components\" Text\n    :> MandatoryQueryParam \"language\" Language\n    :> QueryParam \"strictbounds\" Bool\n    :> QueryParam \"origin\" LatLong\n    :> QueryParam \"types\" Text\n    :> Get '[JSON] GoogleMaps.AutoCompleteResp\n\ntype AutoCompleteV2API =\n  \"places\" :> \":autocomplete\"\n    :> MandatoryHeader \"X-Goog-Api-Key\" Text\n    :> MandatoryQueryParam \"languageCode\" Language\n    :> ReqBody '[JSON] (GoogleMaps.AutoCompleteReqV2)\n    :> Post '[JSON] GoogleMaps.AutoCompleteRespV2\n\ntype PlaceDetailsAPI =\n  \"place\" :> \"details\" :> \"json\"\n    :> Header \"sessiontoken\" Text\n    :> MandatoryQueryParam \"key\" Text\n    :> MandatoryQueryParam \"place_id\" Text\n    :> MandatoryQueryParam \"fields\" Text\n    :> Get '[JSON] GoogleMaps.GetPlaceDetailsResp\n\ntype PlaceNameAPI =\n  \"geocode\" :> \"json\"\n    :> Header \"sessiontoken\" Text\n    :> MandatoryQueryParam \"key\" Text\n    :> QueryParam \"latlng\" LatLong -- Parameters order is important.\n    :> QueryParam \"place_id\" Text\n    :> QueryParam \"language\" Language\n    :> Get '[JSON] GoogleMaps.GetPlaceNameResp\n\ntype DistanceMatrixAPI =\n  \"distancematrix\" :> \"json\"\n    :> MandatoryQueryParam \"origins\" [GoogleMaps.Place]\n    :> MandatoryQueryParam \"destinations\" [GoogleMaps.Place]\n    :> MandatoryQueryParam \"key\" Text\n    :> QueryParam \"mode\" GoogleMaps.Mode\n    :> QueryParam \"avoid\" Text\n    :> Post '[JSON] GoogleMaps.DistanceMatrixResp\n\ntype DirectionsAPI =\n  \"directions\" :> \"json\"\n    :> MandatoryQueryParam \"origin\" GoogleMaps.Place\n    :> MandatoryQueryParam \"destination\" GoogleMaps.Place\n    :> MandatoryQueryParam \"key\" Text\n    :> QueryParam \"alternatives\" Bool\n    :> QueryParam \"mode\" GoogleMaps.Mode\n    :> QueryParam \"waypoints\" [GoogleMaps.Place]\n    :> QueryParam \"avoid\" Text\n    :> Get '[JSON] GoogleMaps.DirectionsResp\n\ntype AdvancedDirectionsAPI =\n  \"directions\" :> \"v2\" :> \":computeRoutes\"\n    :> MandatoryHeader \"X-Goog-Api-Key\" Text\n    :> MandatoryHeader \"X-Goog-FieldMask\" Text\n    :> ReqBody '[JSON] (GoogleMaps.AdvancedDirectionsReq)\n    :> Post '[JSON] GoogleMaps.AdvancedDirectionsResp\n\ntype TransitDirectionsAPI =\n  \"directions\" :> \"v2\" :> \":computeRoutes\"\n    :> MandatoryHeader \"X-Goog-Api-Key\" Text\n    :> MandatoryHeader \"X-Goog-FieldMask\" Text\n    :> ReqBody '[JSON] (GoogleMaps.TransitDirectionsReq)\n    :> Post '[JSON] GoogleMaps.AdvancedDirectionsResp\n\nautoCompleteClient :: Maybe Text -> Text -> Text -> Text -> Integer -> Text -> Language -> Maybe Bool -> Maybe LatLong -> Maybe Text -> EulerClient GoogleMaps.AutoCompleteResp\nautoCompleteV2Client :: Text -> Language -> GoogleMaps.AutoCompleteReqV2 -> EulerClient GoogleMaps.AutoCompleteRespV2\ngetPlaceDetailsClient :: Maybe Text -> Text -> Text -> Text -> EulerClient GoogleMaps.GetPlaceDetailsResp\ngetPlaceNameClient :: Maybe Text -> Text -> Maybe LatLong -> Maybe Text -> Maybe Language -> EulerClient GoogleMaps.GetPlaceNameResp\ndistanceMatrixClient ::\n  [GoogleMaps.Place] ->\n  [GoogleMaps.Place] ->\n  Text ->\n  Maybe GoogleMaps.Mode ->\n  Maybe Text ->\n  EulerClient GoogleMaps.DistanceMatrixResp\ndirectionsClient ::\n  GoogleMaps.Place ->\n  GoogleMaps.Place ->\n  Text ->\n  Maybe Bool ->\n  Maybe GoogleMaps.Mode ->\n  Maybe [GoogleMaps.Place] ->\n  Maybe Text ->\n  EulerClient GoogleMaps.DirectionsResp\nadvancedDirectionsClient ::\n  Text ->\n  Text ->\n  GoogleMaps.AdvancedDirectionsReq ->\n  EulerClient GoogleMaps.AdvancedDirectionsResp\ntransitDirectionsClient ::\n  Text ->\n  Text ->\n  GoogleMaps.TransitDirectionsReq ->\n  EulerClient GoogleMaps.AdvancedDirectionsResp\nautoCompleteClient :<|> autoCompleteV2Client :<|> getPlaceDetailsClient :<|> getPlaceNameClient :<|> distanceMatrixClient :<|> directionsClient :<|> advancedDirectionsClient :<|> transitDirectionsClient = client (Proxy :: Proxy GoogleMapsAPI)\n\nautoComplete ::\n  ( CoreMetrics m,\n    MonadFlow m,\n    MonadReader r m,\n    HasKafkaProducer r\n  ) =>\n  Maybe Text ->\n  MapsInterfaceTypes.AutoCompleteReq ->\n  BaseUrl ->\n  Text ->\n  Text ->\n  Maybe Text ->\n  Text ->\n  Integer ->\n  Text ->\n  Language ->\n  Maybe Bool ->\n  Maybe LatLong ->\n  Maybe Text ->\n  m GoogleMaps.AutoCompleteResp\nautoComplete entityId req url apiKey input sessiontoken location radius components lang strictBounds origin types = do\n  rsp <- callAPI url (autoCompleteClient sessiontoken apiKey input location radius components lang strictBounds origin types) \"autoComplete\" (Proxy :: Proxy GoogleMapsAPI)\n  fork (\"Logging external API Call of autoComplete Google \") $\n    ApiCallLogger.pushExternalApiCallDataToKafka \"autoComplete\" \"Google\" entityId (Just req) rsp\n  checkGoogleMapsError url rsp\n\nautoCompleteV2 ::\n  ( CoreMetrics m,\n    MonadFlow m,\n    MonadReader r m,\n    HasKafkaProducer r\n  ) =>\n  Maybe Text ->\n  BaseUrl ->\n  Text ->\n  Language ->\n  GoogleMaps.AutoCompleteReqV2 ->\n  m GoogleMaps.AutoCompleteRespV2\nautoCompleteV2 entityId url apiKey language req = do\n  rsp <- callAPI url (autoCompleteV2Client apiKey language req) \"autoCompleteV2\" (Proxy :: Proxy GoogleMapsAPI)\n  fork (\"Logging external API Call of autoCompleteV2 Google \") $\n    ApiCallLogger.pushExternalApiCallDataToKafka \"autoCompleteV2\" \"Google\" entityId (Just req) rsp\n  checkGooglePlaceError url rsp\n\ngetPlaceDetails ::\n  ( CoreMetrics m,\n    MonadFlow m,\n    MonadReader r m,\n    HasKafkaProducer r\n  ) =>\n  Maybe Text ->\n  MapsInterfaceTypes.GetPlaceDetailsReq ->\n  BaseUrl ->\n  Text ->\n  Maybe Text ->\n  Text ->\n  Text ->\n  m GoogleMaps.GetPlaceDetailsResp\ngetPlaceDetails entityId req url apiKey sessiontoken placeId fields = do\n  rsp <- callAPI url (getPlaceDetailsClient sessiontoken apiKey placeId fields) \"getPlaceDetails\" (Proxy :: Proxy GoogleMapsAPI)\n  fork (\"Logging external API Call of getPlaceDetails Google \") $\n    ApiCallLogger.pushExternalApiCallDataToKafka \"getPlaceDetails\" \"Google\" entityId (Just req) rsp\n  checkGoogleMapsError url rsp\n\ngetPlaceName ::\n  ( CoreMetrics m,\n    MonadFlow m,\n    MonadReader r m,\n    HasKafkaProducer r\n  ) =>\n  Maybe Text ->\n  MapsInterfaceTypes.GetPlaceNameReq ->\n  BaseUrl ->\n  Text ->\n  Maybe Text ->\n  Maybe Text ->\n  Maybe LatLong ->\n  Maybe Language ->\n  m GoogleMaps.GetPlaceNameResp\ngetPlaceName entityId req url apiKey sessiontoken mbByPlaceId mbByLatLong language = do\n  rsp <- callAPI url (getPlaceNameClient sessiontoken apiKey mbByLatLong mbByPlaceId language) \"getPlaceName\" (Proxy :: Proxy GoogleMapsAPI)\n  fork (\"Logging external API Call of getPlaceName Google \") $\n    ApiCallLogger.pushExternalApiCallDataToKafka \"getPlaceName\" \"Google\" entityId (Just req) rsp\n  checkGoogleMapsError url rsp\n\ndistanceMatrix ::\n  ( CoreMetrics m,\n    MonadFlow m,\n    ToJSON a,\n    ToJSON b,\n    MonadReader r m,\n    HasKafkaProducer r\n  ) =>\n  Maybe Text ->\n  MapsInterfaceTypes.GetDistancesReq a b ->\n  BaseUrl ->\n  Text ->\n  [GoogleMaps.Place] ->\n  [GoogleMaps.Place] ->\n  Maybe GoogleMaps.Mode ->\n  Bool ->\n  m GoogleMaps.DistanceMatrixResp\ndistanceMatrix entityId req url key origins destinations mode isAvoidTolls = do\n  let avoidToll = if isAvoidTolls then Just \"tolls\" else Nothing\n  let avoid = T.intercalate \"|\" $ catMaybes [avoidToll, Just \"ferries\"]\n  rsp <- callAPI url (distanceMatrixClient origins destinations key mode (Just avoid)) \"distanceMatrix\" (Proxy :: Proxy GoogleMapsAPI)\n  fork (\"Logging external API Call of distanceMatrix Google \") $\n    ApiCallLogger.pushExternalApiCallDataToKafka \"distanceMatrix\" \"Google\" entityId (Just req) rsp\n  checkGoogleMapsError url rsp\n    >>= \\resp -> do\n      mapM_ (mapM validateResponseStatus . (.elements)) resp.rows\n      return resp\n\ndirections ::\n  ( CoreMetrics m,\n    MonadFlow m,\n    MonadReader r m,\n    HasKafkaProducer r\n  ) =>\n  Maybe Text ->\n  MapsInterfaceTypes.GetRoutesReq ->\n  BaseUrl ->\n  Text ->\n  GoogleMaps.Place ->\n  GoogleMaps.Place ->\n  Maybe GoogleMaps.Mode ->\n  Maybe [GoogleMaps.Place] ->\n  Bool ->\n  m GoogleMaps.DirectionsResp\ndirections entityId req url key origin destination mode waypoints isAvoidTolls = do\n  let avoidToll = if isAvoidTolls then Just \"tolls\" else Nothing\n  let avoid = T.intercalate \"|\" $ catMaybes [avoidToll, Just \"ferries\"]\n  rsp <- callAPI url (directionsClient origin destination key (Just True) mode waypoints (Just avoid)) \"directionsAPI\" (Proxy :: Proxy GoogleMapsAPI)\n  fork (\"Logging external API Call of directions Google \") $\n    ApiCallLogger.pushExternalApiCallDataToKafka \"directions\" \"Google\" entityId (Just req) rsp\n  checkGoogleMapsError url rsp\n\ntransitDirectionsAPI ::\n  ( CoreMetrics m,\n    MonadFlow m,\n    MonadReader r m,\n    HasKafkaProducer r\n  ) =>\n  Maybe Text ->\n  BaseUrl ->\n  Text ->\n  GoogleMaps.WayPointV2 ->\n  GoogleMaps.WayPointV2 ->\n  Maybe GoogleMaps.ModeV2 ->\n  Bool ->\n  GoogleMaps.RoutingPreference ->\n  Maybe GoogleMaps.TransitPreferencesV2 ->\n  Maybe String ->\n  Maybe String ->\n  m GoogleMaps.AdvancedDirectionsResp\ntransitDirectionsAPI entityId url key origin destination mode computeAlternativeRoutes routingPreference transitPreferences arrivalTime departureTime = do\n  let travelMode = mode\n      routeModifiers = Nothing\n      req = GoogleMaps.TransitDirectionsReq {..}\n  rsp <- callAPI url (transitDirectionsClient key \"routes.*\" req) \"transitDirectionsAPI\" (Proxy :: Proxy GoogleMapsAPI)\n  fork (\"Logging external API Call of transitDirectionsAPI Google \") $\n    ApiCallLogger.pushExternalApiCallDataToKafka \"transitDirectionsAPI\" \"Google\" entityId (Just req) rsp\n  checkGoogleMapsError' url rsp\n\nadvancedDirectionsAPI ::\n  ( CoreMetrics m,\n    MonadFlow m,\n    MonadReader r m,\n    HasKafkaProducer r\n  ) =>\n  Maybe Text ->\n  BaseUrl ->\n  Text ->\n  GoogleMaps.WayPointV2 ->\n  GoogleMaps.WayPointV2 ->\n  Maybe GoogleMaps.ModeV2 ->\n  Maybe [GoogleMaps.WayPointV2] ->\n  Bool ->\n  Bool ->\n  GoogleMaps.RoutingPreference ->\n  m GoogleMaps.AdvancedDirectionsResp\nadvancedDirectionsAPI entityId url key origin destination mode intermediates isAvoidTolls computeAlternativeRoutes routingPreference = do\n  let routeModifiers = GoogleMaps.RouteModifiers {avoidTolls = if isAvoidTolls then Just True else Nothing, avoidFerries = True}\n      travelMode = mode\n      req = GoogleMaps.AdvancedDirectionsReq {..}\n  rsp <- callAPI url (advancedDirectionsClient key \"routes.legs.*,routes.distanceMeters,routes.duration,routes.staticDuration.*,routes.viewport.*,routes.polyline.*,routes.routeLabels.*\" req) \"advancedDirectionsAPI\" (Proxy :: Proxy GoogleMapsAPI)\n  fork (\"Logging external API Call of advancedDirectionsAPI Google \") $\n    ApiCallLogger.pushExternalApiCallDataToKafka \"advancedDirectionsAPI\" \"Google\" entityId (Just req) rsp\n  checkGoogleMapsError' url rsp\n\ncheckGoogleMapsError :: (MonadThrow m, Log m, HasField \"status\" a Text) => BaseUrl -> Either ClientError a -> m a\ncheckGoogleMapsError url res =\n  fromEitherM (googleMapsError url) res >>= validateResponseStatus\n\ncheckGooglePlaceError :: (MonadThrow m, Log m, HasField \"suggestions\" a [GoogleMaps.Suggestion]) => BaseUrl -> Either ClientError a -> m a\ncheckGooglePlaceError url res =\n  fromEitherM (googleMapsError url) res\n\ncheckGoogleMapsError' :: (MonadThrow m, Log m, HasField \"routes\" a [GoogleMaps.RouteV2]) => BaseUrl -> Either ClientError a -> m a\ncheckGoogleMapsError' url res =\n  fromEitherM (googleMapsError url) res\n\ngoogleMapsError :: BaseUrl -> ClientError -> ExternalAPICallError\ngoogleMapsError = ExternalAPICallError (Just \"GOOGLE_MAPS_API_ERROR\")\n\nvalidateResponseStatus :: (MonadThrow m, Log m, HasField \"status\" a Text) => a -> m a\nvalidateResponseStatus response =\n  case response.status of\n    \"OK\" -> pure response\n    \"ZERO_RESULTS\" -> pure response\n    \"INVALID_REQUEST\" -> throwError GoogleMapsInvalidRequest\n    _ -> throwError $ GoogleMapsCallError response.status\n",
      "hash": "93731d1b85aa2c43573ce5d2866650a0037b3f9e4126bcb52801c521f3976227",
      "size": 13907
    },
    "/lib/mobility-core/src/Kernel/External/Maps/Google/MapsClient/Types.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n{-# LANGUAGE DerivingVia #-}\n\nmodule Kernel.External.Maps.Google.MapsClient.Types where\n\nimport Data.Aeson\nimport qualified Data.ByteString.Lazy as BSL\nimport Data.Double.Conversion.Text (toFixed)\nimport qualified Data.Text as T\nimport qualified Data.Text.Encoding as DT\nimport Kernel.External.Maps.Google.PolyLinePoints (PolyLinePoints)\nimport Kernel.Prelude\nimport Kernel.Utils.Dhall (FromDhall)\nimport qualified Kernel.Utils.JSON as JS\nimport Servant (FromHttpApiData (parseUrlPiece), ToHttpApiData (toUrlPiece))\n\ndata AutoCompleteResp = AutoCompleteResp\n  { status :: Text,\n    predictions :: [Prediction]\n  }\n  deriving (Generic, ToJSON, FromJSON, ToSchema)\n\ndata Prediction = Prediction\n  { description :: Text,\n    place_id :: Maybe Text,\n    distance_meters :: Maybe Int,\n    types :: Maybe [Text]\n  }\n  deriving (Generic, ToJSON, FromJSON, ToSchema)\n\nnewtype AutoCompleteRespV2 = AutoCompleteRespV2\n  { suggestions :: [Suggestion]\n  }\n  deriving (Show, Generic, ToJSON, ToSchema)\n\ninstance FromJSON AutoCompleteRespV2 where\n  parseJSON (Object v) = do\n    suggestionsValue <- v .:? \"suggestions\" .!= []\n    return $ AutoCompleteRespV2 suggestionsValue\n  parseJSON _ = fail \"Expected an object for AutoCompleteRespV2\"\n\nnewtype Suggestion = Suggestion\n  { placePrediction :: PlacePrediction\n  }\n  deriving (Show, Generic, ToJSON, FromJSON, ToSchema)\n\ndata PlacePrediction = PlacePrediction\n  { text :: PlaceText,\n    placeId :: Maybe Text,\n    types :: Maybe [Text],\n    distanceMeters :: Maybe Int\n  }\n  deriving (Show, Generic, ToJSON, FromJSON, ToSchema)\n\nnewtype PlaceText = PlaceText\n  { text :: Text\n  }\n  deriving (Show, Generic, ToJSON, FromJSON, ToSchema)\n\ndata GetPlaceDetailsResp = GetPlaceDetailsResp\n  { status :: Text,\n    result :: PlaceDetailsResult\n  }\n  deriving (Generic, ToJSON, FromJSON, ToSchema)\n\nnewtype PlaceDetailsResult = PlaceDetailsResult\n  { geometry :: Geometry\n  }\n  deriving stock (Generic)\n  deriving anyclass (ToJSON, FromJSON, ToSchema)\n\nnewtype Geometry = Geometry\n  { location :: LocationS\n  }\n  deriving stock (Generic)\n  deriving anyclass (ToJSON, FromJSON, ToSchema)\n\ndata LocationS = LocationS\n  { lat :: Double,\n    lng :: Double\n  }\n  deriving (Generic, ToJSON, FromJSON, Show, ToSchema)\n\ninstance ToHttpApiData LocationS where\n  toUrlPiece (LocationS lat' lng') =\n    T.concat [toFixed precision lat', \",\", toFixed precision lng']\n    where\n      precision = 6 -- Precision beyond 6 decimal places is ignored.\n\ninstance FromHttpApiData LocationS where\n  parseUrlPiece param = do\n    let latLon = T.splitOn \",\" param\n    case latLon of\n      [latText, lonText] -> do\n        lat <- left T.pack . eitherDecode . BSL.fromStrict . DT.encodeUtf8 $ latText\n        lng <- left T.pack . eitherDecode . BSL.fromStrict . DT.encodeUtf8 $ lonText\n        Right LocationS {..}\n      _ -> Left \"location should contain lat and lon separated by a comma\"\n\ndata GetPlaceNameResp = GetPlaceNameResp\n  { status :: Text,\n    results :: [ResultsResp]\n  }\n  deriving (Generic, ToJSON, FromJSON, ToSchema)\n\ndata ResultsResp = ResultsResp\n  { formatted_address :: Maybe Text,\n    address_components :: [AddressResp],\n    plus_code :: Maybe PlusCodeResp,\n    geometry :: Geometry,\n    place_id :: Maybe Text\n  }\n  deriving stock (Generic)\n  deriving anyclass (ToJSON, FromJSON, ToSchema)\n\ndata AddressResp = AddressResp\n  { long_name :: Text,\n    short_name :: Text,\n    types :: [Text]\n  }\n  deriving stock (Generic, Show, Read)\n  deriving anyclass (ToJSON, FromJSON, ToSchema)\n\ndata PlusCodeResp = PlusCodeResp\n  { compound_code :: Maybe Text,\n    global_code :: Maybe Text\n  }\n  deriving stock (Generic, Show)\n  deriving anyclass (ToJSON, FromJSON, ToSchema)\n\ndata DirectionsResp = DirectionsResp\n  { routes :: [Route],\n    status :: Text\n  }\n  deriving (Generic, ToJSON, FromJSON, ToSchema)\n\nnewtype AdvancedDirectionsResp = AdvancedDirectionsResp\n  { routes :: [RouteV2]\n  }\n  deriving (Generic, ToJSON, FromJSON, ToSchema)\n\ndata AutoCompleteReqV2 = AutoCompleteReqV2\n  { input :: Text,\n    sessionToken :: Maybe Text,\n    origin :: Maybe LatLngV2,\n    includedPrimaryTypes :: Maybe Text,\n    includedRegionCodes :: [Text],\n    locationBias :: Maybe LocationBias,\n    locationRestriction :: Maybe LocationRestriction\n  }\n  deriving (Generic, FromJSON, ToJSON)\n\nnewtype LocationBias = LocationBias\n  { circle :: Circle --,\n  -- rectangle :: Maybe Rectangle  -----------can be used in future-----------\n  }\n  deriving (Show, Eq, Generic, FromJSON, ToJSON)\n\nnewtype LocationRestriction = LocationRestriction\n  { circle :: Circle --,\n  -- rectangle :: Maybe Rectangle  -----------can be used in future-----------\n  }\n  deriving (Show, Eq, Generic, FromJSON, ToJSON)\n\ndata Circle = Circle\n  { center :: LatLngV2,\n    radius :: Double\n  }\n  deriving (Show, Eq, Generic, FromJSON, ToJSON)\n\ndata Rectangle = Rectangle\n  { low :: LatLngV2,\n    high :: LatLngV2\n  }\n  deriving (Show, Eq, Generic, FromJSON, ToJSON)\n\ndata TransitPreferencesV2 = TransitPreferencesV2\n  { allowedTravelModes :: Maybe [TransitTravelModeV2],\n    routingPreference :: Maybe TransitRoutingPreferenceV2\n  }\n  deriving (Generic, ToJSON, FromJSON, ToSchema, Show)\n\ndata TransitDirectionsReq = TransitDirectionsReq\n  { origin :: WayPointV2,\n    destination :: WayPointV2,\n    routingPreference :: RoutingPreference,\n    travelMode :: Maybe ModeV2,\n    computeAlternativeRoutes :: Bool,\n    transitPreferences :: Maybe TransitPreferencesV2,\n    routeModifiers :: Maybe RouteModifiers,\n    arrivalTime :: Maybe String, -- yyyy-mm-ddThh:mm:ssZ\n    departureTime :: Maybe String\n  }\n  deriving (Generic, ToJSON, FromJSON, ToSchema)\n\ndata AdvancedDirectionsReq = AdvancedDirectionsReq\n  { origin :: WayPointV2,\n    destination :: WayPointV2,\n    intermediates :: Maybe [WayPointV2],\n    routingPreference :: RoutingPreference,\n    travelMode :: Maybe ModeV2,\n    computeAlternativeRoutes :: Bool,\n    routeModifiers :: RouteModifiers\n  }\n  -----------remove null fields-----------\n  deriving (Generic, ToJSON, FromJSON, ToSchema)\n\nnewtype WayPointV2 = WayPointV2\n  { ---- Union field location_type can be only one of the following:\n    location :: LocationV2\n    -- address :: Maybe Text --------if needed in future--------\n    -----End of list of possible types for union field location_type.\n  }\n  deriving (Generic, ToJSON, FromJSON, ToSchema, Show)\n\nnewtype LocationV2 = LocationV2\n  { latLng :: LatLngV2\n  }\n  deriving (Generic, ToJSON, FromJSON, ToSchema, Show)\n\ndata LatLngV2 = LatLngV2\n  { latitude :: Double,\n    longitude :: Double\n  }\n  deriving (Generic, Eq, ToJSON, FromJSON, ToSchema, Show)\n\ndata RouteModifiers = RouteModifiers\n  { avoidTolls :: Maybe Bool,\n    avoidFerries :: Bool --------default False--------\n    ------- Can be added in future if required ----------\n    -- avoidHighways :: Bool,\n    -- avoidIndoor :: Bool\n  }\n  deriving (Generic, ToJSON, FromJSON, ToSchema)\n\ndata Route = Route\n  { bounds :: Bounds,\n    legs :: [Leg]\n  }\n  deriving (Generic, ToJSON, FromJSON, ToSchema)\n\ndata Bounds = Bounds\n  { northeast :: LocationS,\n    southwest :: LocationS\n  }\n  deriving (Generic, ToJSON, FromJSON, ToSchema)\n\ndata Leg = Leg\n  { distance :: TextValue,\n    duration :: TextValue,\n    end_location :: LocationS,\n    start_location :: LocationS,\n    steps :: [Step]\n  }\n  deriving (Generic, ToJSON, FromJSON, ToSchema)\n\ndata Step = Step\n  { distance :: TextValue,\n    duration :: TextValue,\n    end_location :: LocationS,\n    polyline :: EncodedPointObject,\n    start_location :: LocationS,\n    travel_mode :: Mode\n  }\n  deriving (Generic, ToJSON, FromJSON, ToSchema)\n\ndata RouteV2 = RouteV2\n  { legs :: [LegV2],\n    viewport :: ViewPort,\n    distanceMeters :: Int,\n    duration :: Text,\n    staticDuration :: Maybe Text\n  }\n  deriving (Generic, ToJSON, FromJSON, ToSchema)\n\ndata ViewPort = ViewPort\n  { low :: LatLngV2,\n    high :: LatLngV2\n  }\n  deriving (Generic, ToJSON, FromJSON, ToSchema)\n\ndata LegV2 = LegV2\n  { distanceMeters :: Int,\n    duration :: Text,\n    endLocation :: LocationV2,\n    startLocation :: LocationV2,\n    steps :: [StepV2]\n  }\n  deriving (Generic, ToJSON, FromJSON, ToSchema)\n\ndata StepV2 = StepV2\n  { distanceMeters :: Int,\n    staticDuration :: Text,\n    endLocation :: LocationV2,\n    polyline :: Polyline,\n    startLocation :: LocationV2,\n    travelMode :: ModeV2,\n    transitDetails :: Maybe TransitDetailsV2\n  }\n  deriving (Generic, ToJSON, FromJSON, ToSchema)\n\ndata TransitDetailsV2 = TransitDetailsV2\n  { transitLine :: TransitLineV2,\n    stopDetails :: StopDetailsV2\n  }\n  deriving (Generic, FromJSON, ToJSON, ToSchema)\n\ndata StopDetailsV2 = StopDetailsV2\n  { arrivalTime :: Text,\n    departureTime :: Text,\n    arrivalStop :: TransitStopV2,\n    departureStop :: TransitStopV2\n  }\n  deriving (Generic, FromJSON, ToJSON, ToSchema)\n\ndata TransitStopV2 = TransitStopV2\n  { name :: Text,\n    location :: LocationV2\n  }\n  deriving (Generic, FromJSON, ToJSON, ToSchema)\n\ndata TransitLineV2 = TransitLineV2\n  { agencies :: [AgencyV2],\n    vehicle :: VehicleV2\n  }\n  deriving (Generic, FromJSON, ToJSON, ToSchema)\n\nnewtype AgencyV2 = AgencyV2\n  { name :: Text\n  }\n  deriving (Generic, FromJSON, ToJSON, ToSchema)\n\nnewtype VehicleV2 = VehicleV2\n  { _type :: TransitVehicleTypeV2\n  }\n  deriving (Generic, ToSchema)\n\ninstance FromJSON VehicleV2 where\n  parseJSON = genericParseJSON JS.stripPrefixUnderscoreIfAny\n\ninstance ToJSON VehicleV2 where\n  toJSON = genericToJSON JS.stripPrefixUnderscoreIfAny\n\nnewtype Polyline = Polyline\n  { encodedPolyline :: PolyLinePoints\n  }\n  deriving (Generic, ToJSON, FromJSON, ToSchema, Show)\n\nnewtype EncodedPointObject = EncodedPointObject {points :: PolyLinePoints}\n  deriving stock (Generic)\n  deriving anyclass (ToJSON, FromJSON, ToSchema)\n\ndata DistanceMatrixResp = DistanceMatrixResp\n  { destination_addresses :: [Text],\n    origin_addresses :: [Text],\n    rows :: [DistanceMatrixRow],\n    status :: Text\n  }\n  deriving (Generic, ToJSON, FromJSON)\n\nnewtype DistanceMatrixRow = DistanceMatrixRow {elements :: [DistanceMatrixElement]}\n  deriving stock (Generic)\n  deriving anyclass (ToJSON, FromJSON)\n\ndata DistanceMatrixElement = DistanceMatrixElement\n  { distance :: Maybe TextValue,\n    duration :: Maybe TextValue,\n    status :: Text\n  }\n  deriving (Generic, ToJSON, FromJSON)\n\ndata TextValue = TextValue\n  { text :: Text,\n    value :: Int\n  }\n  deriving (Generic, ToJSON, FromJSON, ToSchema)\n\ndata Place = Location LocationS | Address Text deriving (Show)\n\ninstance ToHttpApiData Place where\n  toUrlPiece (Location location) = toUrlPiece location\n  toUrlPiece (Address address) = address\n\ninstance FromHttpApiData Place where\n  parseUrlPiece piece = case parseUrlPiece piece of\n    Right location -> Right $ Location location\n    _ -> Right $ Address piece\n\ninstance ToHttpApiData [Place] where\n  toUrlPiece latLongList = T.intercalate \"|\" $ toUrlPiece <$> latLongList\n\ninstance FromHttpApiData [Place] where\n  parseUrlPiece piece = do\n    let places = T.splitOn \"|\" piece\n    forM places parseUrlPiece\n\ndata Mode = DRIVING | WALKING | BICYCLING\n  deriving (Eq, Show, Generic, ToJSON, FromJSON, ToSchema)\n\ninstance ToHttpApiData Mode where\n  toUrlPiece = T.toLower . show\n\ninstance FromHttpApiData Mode where\n  parseUrlPiece = left T.pack . eitherDecode .(\\str -> \"\\\"\" <> str <> \"\\\"\") . BSL.fromStrict . DT.encodeUtf8 . T.toUpper\n\ndata ModeV2\n  = TRAVEL_MODE_UNSPECIFIED -- No travel mode specified. Defaults to DRIVE.\n  | DRIVE --Travel by passenger car.\n  | BICYCLE -- Travel by bicycle.\n  | WALK -- Travel by walking.\n  | TWO_WHEELER -- Two-wheeled, motorized vehicle. For example, motorcycle. Note that this differs from the BICYCLE travel mode which covers human-powered mode.\n  | TRANSIT -- Travel by public transit.\n  deriving (Eq, Show, Generic, ToJSON, FromJSON, ToSchema)\n\ndata RoutingPreference = ROUTING_PREFERENCE_UNSPECIFIED | TRAFFIC_UNAWARE | TRAFFIC_AWARE | TRAFFIC_AWARE_OPTIMAL\n  deriving (Eq, Show, Generic, ToJSON, FromJSON, ToSchema, FromDhall)\n\ndata TransitTravelModeV2\n  = TRANSIT_TRAVEL_MODE_UNSPECIFIED\n  | BUS\n  | SUBWAY\n  | TRAIN\n  | LIGHT_RAIL\n  | RAIL\n  deriving (Eq, Show, Generic, ToJSON, FromJSON, ToSchema)\n\ndata TransitRoutingPreferenceV2\n  = TRANSIT_ROUTING_PREFERENCE_UNSPECIFIED\n  | LESS_WALKING\n  | FEWER_TRANSFERS\n  deriving (Eq, Show, Generic, ToJSON, FromJSON, ToSchema)\n\ndata TransitVehicleTypeV2\n  = VEHICLE_TYPE_TRANSIT_VEHICLE_TYPE_UNSPECIFIED\n  | VEHICLE_TYPE_BUS\n  | VEHICLE_TYPE_CABLE_CAR\n  | VEHICLE_TYPE_COMMUTER_TRAIN\n  | VEHICLE_TYPE_FERRY\n  | VEHICLE_TYPE_FUNICULAR\n  | VEHICLE_TYPE_GONDOLA_LIFT\n  | VEHICLE_TYPE_HEAVY_RAIL\n  | VEHICLE_TYPE_HIGH_SPEED_TRAIN\n  | VEHICLE_TYPE_INTERCITY_BUS\n  | VEHICLE_TYPE_LONG_DISTANCE_TRAIN\n  | VEHICLE_TYPE_METRO_RAIL\n  | VEHICLE_TYPE_MONORAIL\n  | VEHICLE_TYPE_OTHER\n  | VEHICLE_TYPE_RAIL\n  | VEHICLE_TYPE_SHARE_TAXI\n  | VEHICLE_TYPE_SUBWAY\n  | VEHICLE_TYPE_TRAM\n  | VEHICLE_TYPE_TROLLEYBUS\n  deriving (Eq, Show, Generic, ToSchema)\n\ninstance ToJSON TransitVehicleTypeV2 where\n  toJSON = \\case\n    VEHICLE_TYPE_TRANSIT_VEHICLE_TYPE_UNSPECIFIED -> \"TRANSIT_VEHICLE_TYPE_UNSPECIFIED\"\n    VEHICLE_TYPE_BUS -> \"BUS\"\n    VEHICLE_TYPE_CABLE_CAR -> \"CABLE_CAR\"\n    VEHICLE_TYPE_COMMUTER_TRAIN -> \"COMMUTER_TRAIN\"\n    VEHICLE_TYPE_FERRY -> \"FERRY\"\n    VEHICLE_TYPE_FUNICULAR -> \"FUNICULAR\"\n    VEHICLE_TYPE_GONDOLA_LIFT -> \"GONDOLA_LIFT\"\n    VEHICLE_TYPE_HEAVY_RAIL -> \"HEAVY_RAIL\"\n    VEHICLE_TYPE_HIGH_SPEED_TRAIN -> \"HIGH_SPEED_TRAIN\"\n    VEHICLE_TYPE_INTERCITY_BUS -> \"INTERCITY_BUS\"\n    VEHICLE_TYPE_LONG_DISTANCE_TRAIN -> \"LONG_DISTANCE_TRAIN\"\n    VEHICLE_TYPE_METRO_RAIL -> \"METRO_RAIL\"\n    VEHICLE_TYPE_MONORAIL -> \"MONORAIL\"\n    VEHICLE_TYPE_OTHER -> \"OTHER\"\n    VEHICLE_TYPE_RAIL -> \"RAIL\"\n    VEHICLE_TYPE_SHARE_TAXI -> \"SHARE_TAXI\"\n    VEHICLE_TYPE_SUBWAY -> \"SUBWAY\"\n    VEHICLE_TYPE_TRAM -> \"TRAM\"\n    VEHICLE_TYPE_TROLLEYBUS -> \"TROLLEYBUS\"\n\ninstance FromJSON TransitVehicleTypeV2 where\n  parseJSON = \\case\n    \"TRANSIT_VEHICLE_TYPE_UNSPECIFIED\" -> pure VEHICLE_TYPE_TRANSIT_VEHICLE_TYPE_UNSPECIFIED\n    \"BUS\" -> pure VEHICLE_TYPE_BUS\n    \"CABLE_CAR\" -> pure VEHICLE_TYPE_CABLE_CAR\n    \"COMMUTER_TRAIN\" -> pure VEHICLE_TYPE_COMMUTER_TRAIN\n    \"FERRY\" -> pure VEHICLE_TYPE_FERRY\n    \"FUNICULAR\" -> pure VEHICLE_TYPE_FUNICULAR\n    \"GONDOLA_LIFT\" -> pure VEHICLE_TYPE_GONDOLA_LIFT\n    \"HEAVY_RAIL\" -> pure VEHICLE_TYPE_HEAVY_RAIL\n    \"HIGH_SPEED_TRAIN\" -> pure VEHICLE_TYPE_HIGH_SPEED_TRAIN\n    \"INTERCITY_BUS\" -> pure VEHICLE_TYPE_INTERCITY_BUS\n    \"LONG_DISTANCE_TRAIN\" -> pure VEHICLE_TYPE_LONG_DISTANCE_TRAIN\n    \"METRO_RAIL\" -> pure VEHICLE_TYPE_METRO_RAIL\n    \"MONORAIL\" -> pure VEHICLE_TYPE_MONORAIL\n    \"OTHER\" -> pure VEHICLE_TYPE_OTHER\n    \"RAIL\" -> pure VEHICLE_TYPE_RAIL\n    \"SHARE_TAXI\" -> pure VEHICLE_TYPE_SHARE_TAXI\n    \"SUBWAY\" -> pure VEHICLE_TYPE_SUBWAY\n    \"TRAM\" -> pure VEHICLE_TYPE_TRAM\n    \"TROLLEYBUS\" -> pure VEHICLE_TYPE_TROLLEYBUS\n    v -> fail $ \"Invalid TransitVehicleTypeV2: \" <> show v\n\ndata DepartureTime = Now | FutureTime UTCTime\n\ninstance ToHttpApiData DepartureTime where\n  toUrlPiece Now = \"now\"\n  toUrlPiece (FutureTime time) = show time\n",
      "hash": "a8da6a555c824be7a7a4d3cd0326eba1530928f526085bbdce975e34098bf4ce",
      "size": 15748
    },
    "/lib/mobility-core/src/Kernel/External/Maps/Google/PolyLinePoints.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n\nmodule Kernel.External.Maps.Google.PolyLinePoints\n  ( PolyLinePoints,\n    LatLong (..),\n    encode,\n    decode,\n    stringToCoords,\n    oneCoordEnc,\n  )\nwhere\n\nimport Data.Bits\nimport qualified Data.ByteString as BS\nimport qualified Data.ByteString.Char8 as BSC\nimport Data.Char as C\nimport Data.Int (Int32)\nimport qualified Data.Text as T\nimport qualified Data.Text.Encoding as TE\nimport Kernel.External.Maps.Types\nimport Kernel.Prelude\n\ntype PolyLinePoints = Text\n\ntoInts :: BSC.ByteString -> [Int32]\ntoInts = map fromIntegral . BS.unpack\n\ntoChrs :: [Int32] -> T.Text\ntoChrs = T.pack . map (C.chr . fromIntegral)\n\nsub63 :: [Int32] -> [Int32]\nsub63 = map ((-63) +)\n\nadd63 :: [Int32] -> [Int32]\nadd63 = map (63 +)\n\nsplitChunk :: [Int32] -> ([Int32], [Int32])\nsplitChunk is =\n  let (a, b) = span (>= 0x20) is\n   in (a ++ [head b], tail b)\n\ndelimChunk :: [Int32] -> [Int32]\ndelimChunk is = map (.|. 0x20) (init is) ++ [last is]\n\ndechunk :: [Int32] -> Int32\ndechunk is =\n  let withShifts = zip is [0, 5 ..]\n   in sum $ map (\\(c, s) -> shift (c .&. 0x1F) s) withShifts\n\nenchunk :: Int32 -> [Int32]\nenchunk 0 = [0] -- Special case for 0.  Code below would result in an empty.\nenchunk i =\n  let shifts = [0, 5 ..]\n      shifted = takeWhile (> 0) $ map (\\s -> shift i (- s)) shifts\n   in map (.&. 0x1F) shifted\n\n-- Inverse of negEnc\nnegDec :: Int32 -> Int32\nnegDec i =\n  let x = shift i (-1)\n   in if testBit i 0 then complement x else x\n\nnegEnc :: Int32 -> Int32\nnegEnc i =\n  let x = shift i 1\n   in if i < 0 then complement x else x\n\ntoDouble :: Int32 -> Double\ntoDouble x = fromIntegral x / 1e5\n\nfromDouble :: Double -> Int32\nfromDouble x = round (x * 1e5)\n\noneCoordOp :: [Int32] -> Double\noneCoordOp = toDouble . negDec . dechunk\n\noneCoordEnc :: Double -> T.Text\noneCoordEnc = toChrs . add63 . delimChunk . enchunk . negEnc . fromDouble\n\nstringPrep :: BSC.ByteString -> [Int32]\nstringPrep = sub63 . toInts\n\ntoChunks :: [Int32] -> [[Int32]]\ntoChunks [] = []\ntoChunks xs =\n  let (c, cs) = splitChunk xs\n   in c : toChunks cs\n\nstringToCoords :: BSC.ByteString -> [Double]\nstringToCoords = map oneCoordOp . toChunks . stringPrep\n\nmakePairs :: [Double] -> [LatLong]\nmakePairs (d1 : d2 : ds) = LatLong d1 d2 : makePairs ds\nmakePairs [] = []\nmakePairs _ = []\n\ncatPairs :: [LatLong] -> [Double]\ncatPairs [] = []\ncatPairs (LatLong a b : xs) = a : b : catPairs xs\n\naddPair :: LatLong -> LatLong -> LatLong\naddPair (LatLong x1 y1) (LatLong x2 y2) = LatLong (x1 + x2) (y1 + y2)\n\nsubPair :: LatLong -> LatLong -> LatLong\nsubPair (LatLong x1 y1) (LatLong x2 y2) = LatLong (x1 - x2) (y1 - y2)\n\n-- inverse of ( scanl1 addPair )\nadjDiff :: [LatLong] -> [LatLong]\nadjDiff p = zipWith subPair p (LatLong 0 0 : p)\n\n-- | Decodes Google Polyline text to a sequence of Latitude/Longitude\n-- points.  Inverse of 'encode'.\ndecode :: PolyLinePoints -> [LatLong]\ndecode = scanl1 addPair . makePairs . stringToCoords . TE.encodeUtf8\n\n-- | Encodes a sequence of Latitude/Longitude points into Google\n-- Polyline text.  Inverse of 'decode'.\nencode :: [LatLong] -> PolyLinePoints\nencode = T.concat . fmap oneCoordEnc . catPairs . adjDiff\n",
      "hash": "980d0c611ac886acdda688a187463c3e2d0716224018fd684dfb57eeecf0831c",
      "size": 3798
    },
    "/lib/mobility-core/src/Kernel/External/Maps/Google/RoadsClient.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n{-# LANGUAGE DerivingStrategies #-}\n\nmodule Kernel.External.Maps.Google.RoadsClient where\n\nimport qualified Data.Text as T\nimport EulerHS.Types as Euler\nimport qualified Kernel.External.Maps.Interface.Types as MapsInterfaceTypes\nimport Kernel.External.Maps.Types\nimport Kernel.Prelude\nimport Kernel.Streaming.Kafka.Producer.Types (HasKafkaProducer)\nimport Kernel.Tools.Metrics.CoreMetrics as Metrics\nimport Kernel.Types.App (MandatoryQueryParam, MonadFlow)\nimport Kernel.Types.Error (GenericError (InternalError))\nimport Kernel.Utils.Common (callAPI, fork, fromEitherM, throwError)\nimport qualified Kernel.Utils.ExternalAPICallLogging as ApiCallLogger\nimport Servant hiding (throwError)\n\ntype SnapToRoadResponse = SnapToRoadResponse' LatLong\n\ndata SnapToRoadResponse' a = SnapToRoadResponse\n  { snappedPoints :: [SnappedPoint' a],\n    warningMessage :: Maybe Text\n  }\n  deriving stock (Generic)\n  deriving anyclass (FromJSON, ToJSON)\n\ntype SnappedPoint = SnappedPoint' LatLong\n\ndata SnappedPoint' a = SnappedPoint\n  { location :: a,\n    originalIndex :: Maybe Int,\n    placeId :: Text\n  }\n  deriving (Generic, FromJSON, ToJSON)\n\ndata SPLocation = SPLocation\n  { latitude :: Double,\n    longitude :: Double\n  }\n  deriving (Generic, FromJSON, ToJSON)\n\ntype SnapToRoadAPI =\n  \"v1\" :> \"snapToRoads\"\n    :> MandatoryQueryParam \"key\" Text\n    :> MandatoryQueryParam \"interpolate\" Bool\n    :> MandatoryQueryParam \"path\" Text\n    :> Get '[JSON] (SnapToRoadResponse' SPLocation)\n\nsnapToRoad ::\n  ( HasCallStack,\n    Metrics.CoreMetrics m,\n    MonadFlow m,\n    MonadReader r m,\n    HasKafkaProducer r\n  ) =>\n  Maybe Text ->\n  MapsInterfaceTypes.SnapToRoadReq ->\n  BaseUrl ->\n  Text ->\n  [LatLong] ->\n  m SnapToRoadResponse\nsnapToRoad entityId req roadsUrl apiKey pointsList = do\n  let eulerClient = Euler.client (Proxy @SnapToRoadAPI)\n      interpolate = True\n  eitherRes <- callAPI roadsUrl (eulerClient apiKey interpolate $ convertPointsList pointsList) \"snap-to-road\" (Proxy @SnapToRoadAPI)\n  fork (\"Logging external API Call of snapToRoad Google \") $\n    ApiCallLogger.pushExternalApiCallDataToKafka \"snapToRoad\" \"Google\" entityId (Just req) eitherRes\n  res <- fromEitherM (\\err -> InternalError $ \"Failed to call snap-to-road API: \" <> show err) eitherRes\n  maybe\n    (pure ())\n    (\\warning -> throwError $ InternalError (\"Snap-to-road API throwing warning\" <> warning))\n    res.warningMessage\n  return $ SnapToRoadResponse (map (\\sp -> sp {location = spLocToLatLong sp.location}) res.snappedPoints) res.warningMessage\n  where\n    convertPoint :: LatLong -> Text\n    convertPoint pt = mconcat [show pt.lat, \",\", show pt.lon]\n\n    convertPointsList :: [LatLong] -> Text\n    convertPointsList = T.intercalate \"|\" . map convertPoint\n\n    spLocToLatLong :: SPLocation -> LatLong\n    spLocToLatLong s =\n      LatLong\n        { lat = s.latitude,\n          lon = s.longitude\n        }\n",
      "hash": "b81226a34aabd84e93501145bcda3ec679df97457d0549ea5d76cd4b0abc9cdf",
      "size": 3567
    },
    "/lib/mobility-core/src/Kernel/External/Maps/HasCoordinates.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n\nmodule Kernel.External.Maps.HasCoordinates where\n\nimport qualified Kernel.External.Maps.Types as Types\nimport Kernel.Prelude\n\nclass HasCoordinates a where\n  getCoordinates :: a -> Types.LatLong\n  default getCoordinates :: (HasField \"lat\" a Double, HasField \"lon\" a Double) => a -> Types.LatLong\n  getCoordinates = getCoordinatessDefault\n\ngetCoordinatessDefault :: (HasField \"lat\" a Double, HasField \"lon\" a Double) => a -> Types.LatLong\ngetCoordinatessDefault loc = Types.LatLong loc.lat loc.lon\n\ninstance HasCoordinates Types.LatLong where\n  getCoordinates = identity\n",
      "hash": "fd524a57cf10d6fe8a1482a4953dac22aabf01d32e5e5c017c840b0eb42f41ac",
      "size": 1263
    },
    "/lib/mobility-core/src/Kernel/External/Maps/Interface.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n\nmodule Kernel.External.Maps.Interface\n  ( module Reexport,\n    getDistance,\n    getDistancesProvided,\n    getDistances,\n    getRoutesProvided,\n    getRoutes,\n    snapToRoadProvided,\n    snapToRoad,\n    snapToRoadWithFallback,\n    autoCompleteProvided,\n    autoComplete,\n    getPlaceDetailsProvided,\n    getPlaceDetails,\n    getPlaceNameProvided,\n    getPlaceName,\n  )\nwhere\n\nimport EulerHS.Prelude ((...))\nimport Kernel.External.Maps.Google.Config as Reexport\nimport Kernel.External.Maps.HasCoordinates as Reexport (HasCoordinates (..))\nimport qualified Kernel.External.Maps.Interface.Google as Google\nimport qualified Kernel.External.Maps.Interface.MMI as MMI\nimport qualified Kernel.External.Maps.Interface.NextBillion as NextBillion\nimport qualified Kernel.External.Maps.Interface.OSRM as OSRM\nimport Kernel.External.Maps.Interface.Types as Reexport\nimport Kernel.External.Maps.MMI.Config as Reexport\nimport Kernel.External.Maps.OSRM.Config as Reexport\nimport Kernel.External.Maps.Types as Reexport\nimport Kernel.Prelude\nimport Kernel.Storage.Hedis as Redis\nimport Kernel.Streaming.Kafka.Producer.Types (HasKafkaProducer)\nimport Kernel.Tools.Metrics.CoreMetrics (CoreMetrics)\nimport Kernel.Types.Common hiding (id)\nimport Kernel.Types.Error\nimport Kernel.Utils.CalculateDistance\nimport Kernel.Utils.Common hiding (id)\n\ngetDistance ::\n  ( EncFlow m r,\n    CoreMetrics m,\n    HasCoordinates a,\n    HasCoordinates b,\n    ToJSON a,\n    ToJSON b,\n    HasKafkaProducer r\n  ) =>\n  Maybe Text ->\n  MapsServiceConfig ->\n  GetDistanceReq a b ->\n  m (GetDistanceResp a b)\ngetDistance entityId serviceConfig GetDistanceReq {..} =\n  getDistances entityId serviceConfig getDistancesReq >>= \\case\n    (a :| []) -> return a\n    _ -> throwError (InternalError \"Exactly one getDistance result expected.\")\n  where\n    getDistancesReq =\n      GetDistancesReq\n        { origins = origin :| [],\n          destinations = destination :| [],\n          ..\n        }\n\nmkNotProvidedError :: Text -> MapsService -> Text\nmkNotProvidedError functionName serviceName = \"Function \" <> functionName <> \" is not provided by service \" <> show serviceName\n\nthrowNotProvidedError :: (MonadFlow m) => Text -> MapsService -> m a\nthrowNotProvidedError =\n  (throwError . InternalError) ... mkNotProvidedError\n\ngetDistancesProvided :: MapsService -> Bool\ngetDistancesProvided = \\case\n  Google -> True\n  OSRM -> False\n  MMI -> True\n  NextBillion -> False\n  SelfTuned -> False\n\n-- FIXME this logic is redundant, because we throw error always when getDistancesProvided service = False\ngetDistances ::\n  ( EncFlow m r,\n    CoreMetrics m,\n    HasCoordinates a,\n    HasCoordinates b,\n    ToJSON a,\n    ToJSON b,\n    HasKafkaProducer r\n  ) =>\n  Maybe Text ->\n  MapsServiceConfig ->\n  GetDistancesReq a b ->\n  m (GetDistancesResp a b)\ngetDistances entityId serviceConfig req = case serviceConfig of\n  GoogleConfig cfg -> Google.getDistances entityId cfg req\n  OSRMConfig cfg -> OSRM.getDistances entityId cfg req\n  MMIConfig cfg -> MMI.getDistanceMatrix entityId cfg req\n  NextBillionConfig _ -> throwNotProvidedError \"getDistances\" NextBillion\n\ngetRoutesProvided :: MapsService -> Bool\ngetRoutesProvided = \\case\n  Google -> True\n  OSRM -> False\n  MMI -> False\n  NextBillion -> True\n  SelfTuned -> False\n\ngetRoutes ::\n  ( EncFlow m r,\n    CoreMetrics m,\n    Log m,\n    HasKafkaProducer r\n  ) =>\n  Maybe Text ->\n  Bool ->\n  MapsServiceConfig ->\n  GetRoutesReq ->\n  m GetRoutesResp\ngetRoutes entityId isAvoidToll serviceConfig req = case serviceConfig of\n  GoogleConfig cfg -> Google.getRoutes entityId isAvoidToll cfg req\n  OSRMConfig osrmCfg -> OSRM.getRoutes entityId osrmCfg req\n  MMIConfig cfg -> MMI.getRoutes entityId cfg req\n  NextBillionConfig cfg -> NextBillion.getRoutes entityId cfg req\n\nsnapToRoadProvided :: MapsService -> Bool\nsnapToRoadProvided = \\case\n  Google -> True\n  OSRM -> True\n  MMI -> True\n  NextBillion -> False\n  SelfTuned -> True\n\nrunPreCheck ::\n  ( EncFlow m r,\n    CoreMetrics m,\n    HasFlowEnv m r '[\"droppedPointsThreshold\" ::: HighPrecMeters]\n  ) =>\n  MapsService ->\n  SnapToRoadReq ->\n  m Bool\nrunPreCheck mapsService req = do\n  droppedPointsThreshold <- asks (.droppedPointsThreshold)\n  case mapsService of\n    Google -> return (everySnippetIs (< droppedPointsThreshold) req.points)\n    MMI -> return (everySnippetIs (< droppedPointsThreshold) req.points)\n    OSRM -> return True\n    _ -> return True\n\nrunPostCheck ::\n  ( EncFlow m r,\n    CoreMetrics m,\n    HasFlowEnv m r '[\"snapToRoadSnippetThreshold\" ::: HighPrecMeters],\n    HasFlowEnv m r '[\"osrmMatchThreshold\" ::: HighPrecMeters]\n  ) =>\n  MapsService ->\n  SnapToRoadReq ->\n  SnapToRoadResp ->\n  m Bool\nrunPostCheck mapsService req res = do\n  snippetThreshold <- asks (.snapToRoadSnippetThreshold)\n  osrmThreshold <- asks (.osrmMatchThreshold)\n  case mapsService of\n    Google -> return (everySnippetIs (< snippetThreshold) res.snappedPoints)\n    MMI -> return (everySnippetIs (< snippetThreshold) res.snappedPoints)\n    OSRM -> return $ (< osrmThreshold) $ distanceBetweenInMeters (last req.points) (last res.snappedPoints)\n    _ -> return True\n\nsnapToRoadWithFallback ::\n  ( EncFlow m r,\n    EsqDBFlow m r,\n    CoreMetrics m,\n    HasFlowEnv m r '[\"snapToRoadSnippetThreshold\" ::: HighPrecMeters],\n    HasFlowEnv m r '[\"droppedPointsThreshold\" ::: HighPrecMeters],\n    HasFlowEnv m r '[\"maxStraightLineRectificationThreshold\" ::: HighPrecMeters],\n    HasFlowEnv m r '[\"osrmMatchThreshold\" ::: HighPrecMeters],\n    HasKafkaProducer r\n  ) =>\n  Maybe Text ->\n  Maybe MapsServiceConfig ->\n  SnapToRoadHandler m ->\n  SnapToRoadReq ->\n  m ([MapsService], Either String SnapToRoadResp)\nsnapToRoadWithFallback entityId mbMapServiceToRectifyDistantPointsFailure SnapToRoadHandler {..} req = do\n  providersList <- getProvidersList\n  when (null providersList) $ throwError $ InternalError \"No maps service provider configured\"\n  (servicesUsed, snapResponse) <- callSnapToRoadWithFallback providersList\n  case (snapResponse, mbMapServiceToRectifyDistantPointsFailure) of\n    (Right resp, _) -> return (servicesUsed, Right resp)\n    (Left err, Nothing) -> return (servicesUsed, Left err)\n    (Left _, Just mapServiceCfg) -> do\n      (rectificationServicesUsed, snapToRoadResponse) <- callSnapToRoadWithRectification mapServiceCfg providersList\n      return (servicesUsed ++ rectificationServicesUsed, snapToRoadResponse)\n  where\n    callSnapToRoadWithFallback [] = do\n      logError $ \"Snap to road failed with all the configured providers\"\n      return ([], Left \"Snap to road failed with all the configured providers\")\n    callSnapToRoadWithFallback (preferredProvider : restProviders) = do\n      mapsConfig <- getProviderConfig preferredProvider\n      preCheckPassed <- runPreCheck preferredProvider req\n      if preCheckPassed\n        then do\n          result <- try @_ @SomeException $ snapToRoad entityId mapsConfig req\n          case result of\n            Left err -> do\n              logError $ \"Snap to road Pre Check failed with error : \" <> show err <> \" - Provider : \" <> show preferredProvider\n              (servicesUsed, snapResponse) <- callSnapToRoadWithFallback restProviders\n              return (servicesUsed ++ [preferredProvider], snapResponse)\n            Right res -> do\n              confidencethreshold <- getConfidenceThreshold\n              postCheckPassed <- runPostCheck preferredProvider req res\n              when (not postCheckPassed) $ logError $ \"Snap to road Post Check failed - Povider : \" <> show preferredProvider\n              let confidenceOutOfRange = res.confidence < confidencethreshold || res.confidence > 1.0\n              when (confidenceOutOfRange) $ logError $ \"Snap to road Post Check failed due to Confidence : \" <> show res.confidence <> \" - Provider : \" <> show preferredProvider\n              if confidenceOutOfRange || not postCheckPassed\n                then do\n                  (servicesUsed, snapResponse) <- callSnapToRoadWithFallback restProviders\n                  return (servicesUsed ++ [preferredProvider], snapResponse)\n                else return ([preferredProvider], Right res)\n        else do\n          (servicesUsed, snapResponse) <- callSnapToRoadWithFallback restProviders\n          return (servicesUsed ++ [preferredProvider], snapResponse)\n\n    callSnapToRoadWithRectification _ [] = do\n      logError $ \"Snap to road rectification failed with all the configured providers\"\n      return ([], Left \"Snap to road rectification failed with all the configured providers\")\n    callSnapToRoadWithRectification mapServiceCfg (preferredProvider : restProviders) = do\n      mapsConfig <- getProviderConfig preferredProvider\n      droppedPointsThreshold <- asks (.droppedPointsThreshold)\n      maxStraightLineRectificationThreshold <- asks (.maxStraightLineRectificationThreshold)\n      let straightDistancePoints = getEverySnippetWhichIsNot (< droppedPointsThreshold) req.points\n      distanceRectified <-\n        mapM\n          ( \\(x1, x2, dist) -> do\n              if dist < maxStraightLineRectificationThreshold\n                then pure (x1, dist)\n                else do\n                  distanceRes <- getDistance entityId mapServiceCfg (GetDistanceReq {origin = x1, destination = x2, travelMode = Just CAR, distanceUnit = req.distanceUnit, sourceDestinationMapping = Nothing} :: GetDistanceReq LatLong LatLong)\n                  pure (x1, metersToHighPrecMeters distanceRes.distance)\n          )\n          straightDistancePoints\n      logDebug $ \"Rectified distances: \" <> show distanceRectified\n      let (pointsOutOfThreshold, distance) = foldl' (\\(accPoints, accDis) (x1, dis) -> (accPoints <> [x1], accDis + dis)) ([], 0) distanceRectified\n      let splitSnapToRoadCalls = filter (not . (<= 1) . length) $ splitWith pointsOutOfThreshold req.points\n      logDebug $ \"Split snap-to-road calls: \" <> show splitSnapToRoadCalls\n      pointsRes <- try @_ @SomeException $ mapM (\\section -> snapToRoad entityId mapsConfig (req {points = section})) splitSnapToRoadCalls\n      logDebug $ \"Snap-to-road results: \" <> show pointsRes\n      case pointsRes of\n        Right result -> do\n          let (totalSectorsDistance, snappedPoints) = foldl' (\\(accDis, snappedPoints') res -> (res.distance + accDis, snappedPoints' <> res.snappedPoints)) (0, []) result\n          let snapToRoadResp =\n                SnapToRoadResp\n                  { distance = totalSectorsDistance + distance,\n                    distanceWithUnit = convertHighPrecMetersToDistance req.distanceUnit $ totalSectorsDistance + distance,\n                    confidence = 1,\n                    snappedPoints = snappedPoints\n                  }\n          return ([preferredProvider, SelfTuned], Right snapToRoadResp)\n        Left err -> do\n          logError $ \"Snap to road rectification failed with error : \" <> show err <> \" - Provider : \" <> show preferredProvider\n          (servicesUsed, snapResponse) <- callSnapToRoadWithRectification mapServiceCfg restProviders\n          return (servicesUsed ++ [preferredProvider, SelfTuned], snapResponse)\n\nsnapToRoad ::\n  ( EncFlow m r,\n    CoreMetrics m,\n    HasKafkaProducer r\n  ) =>\n  Maybe Text ->\n  MapsServiceConfig ->\n  SnapToRoadReq ->\n  m SnapToRoadResp\nsnapToRoad entityId serviceConfig req =\n  case serviceConfig of\n    GoogleConfig cfg -> Google.snapToRoad entityId cfg req\n    OSRMConfig osrmCfg -> OSRM.callOsrmMatch entityId osrmCfg req\n    MMIConfig mmiCfg -> MMI.snapToRoad entityId mmiCfg req\n    NextBillionConfig _ -> throwNotProvidedError \"snapToRoad\" NextBillion\n\nautoCompleteProvided :: MapsService -> Bool\nautoCompleteProvided = \\case\n  Google -> True\n  OSRM -> False\n  MMI -> True\n  NextBillion -> False\n  SelfTuned -> False\n\nautoComplete ::\n  ( EncFlow m r,\n    Redis.HedisFlow m r,\n    CoreMetrics m,\n    HasShortDurationRetryCfg r c,\n    HasKafkaProducer r\n  ) =>\n  Maybe Text ->\n  MapsServiceConfig ->\n  AutoCompleteReq ->\n  m AutoCompleteResp\nautoComplete entityId serviceConfig req = case serviceConfig of\n  GoogleConfig cfg -> Google.autoComplete entityId cfg req\n  OSRMConfig _ -> throwNotProvidedError \"autoComplete\" OSRM\n  MMIConfig cfg -> MMI.autoSuggest entityId cfg req\n  NextBillionConfig _ -> throwNotProvidedError \"autoComplete\" NextBillion\n\ngetPlaceDetailsProvided :: MapsService -> Bool\ngetPlaceDetailsProvided = \\case\n  Google -> True\n  OSRM -> False\n  MMI -> True\n  NextBillion -> False\n  SelfTuned -> False\n\ngetPlaceDetails ::\n  ( EncFlow m r,\n    CoreMetrics m,\n    HasKafkaProducer r\n  ) =>\n  Maybe Text ->\n  MapsServiceConfig ->\n  GetPlaceDetailsReq ->\n  m GetPlaceDetailsResp\ngetPlaceDetails entityId serviceConfig req = case serviceConfig of\n  GoogleConfig cfg -> Google.getPlaceDetails entityId cfg req\n  OSRMConfig _ -> throwNotProvidedError \"getPlaceDetails\" OSRM\n  MMIConfig cfg -> MMI.getPlaceDetails entityId cfg req\n  NextBillionConfig _ -> throwNotProvidedError \"getPlaceDetails\" NextBillion\n\ngetPlaceNameProvided :: MapsService -> Bool\ngetPlaceNameProvided = \\case\n  Google -> True\n  OSRM -> False\n  MMI -> True\n  NextBillion -> False\n  SelfTuned -> False\n\ngetPlaceName ::\n  ( EncFlow m r,\n    CoreMetrics m,\n    Redis.HedisFlow m r,\n    HasKafkaProducer r\n  ) =>\n  Maybe Text ->\n  MapsServiceConfig ->\n  GetPlaceNameReq ->\n  m GetPlaceNameResp\ngetPlaceName entityId serviceConfig req = case serviceConfig of\n  GoogleConfig cfg -> Google.getPlaceName entityId cfg req\n  OSRMConfig _ -> throwNotProvidedError \"getPlaceName\" OSRM\n  MMIConfig cfg -> MMI.geocode entityId cfg req\n  NextBillionConfig _ -> throwNotProvidedError \"getPlaceName\" NextBillion\n",
      "hash": "a90db7b1298af83fe1c967e48e636e4fa7bf6435e4360e4e50c2479285fb498d",
      "size": 14212
    },
    "/lib/mobility-core/src/Kernel/External/Maps/Interface/Google.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n\nmodule Kernel.External.Maps.Interface.Google\n  ( module Reexport,\n    getDistances,\n    getRoutes,\n    snapToRoad,\n    autoComplete,\n    getPlaceDetails,\n    getPlaceName,\n    autoCompleteNew,\n  )\nwhere\n\nimport Control.Applicative ((<|>))\nimport Control.Monad.Extra (concatForM)\nimport qualified Data.List.Extra as List\nimport qualified Data.List.NonEmpty as NE\nimport qualified Data.Text as T\nimport GHC.Float (double2Int)\nimport Kernel.External.Encryption\nimport Kernel.External.Maps.Google.Config as Reexport\nimport qualified Kernel.External.Maps.Google.MapsClient as GoogleMaps\nimport Kernel.External.Maps.Google.PolyLinePoints\nimport qualified Kernel.External.Maps.Google.RoadsClient as GoogleRoads\nimport Kernel.External.Maps.HasCoordinates as Reexport (HasCoordinates (..))\nimport Kernel.External.Maps.Interface.Types as Types\nimport Kernel.External.Maps.Types as Reexport\nimport Kernel.Prelude\nimport Kernel.Streaming.Kafka.Producer.Types (HasKafkaProducer)\nimport Kernel.Tools.Metrics.CoreMetrics (CoreMetrics)\nimport Kernel.Types.Common hiding (id)\nimport Kernel.Types.Error\nimport Kernel.Utils.CalculateDistance (getRouteLinearLength)\nimport Kernel.Utils.Common hiding (id)\n\ngetDistancesWrapper ::\n  ( EncFlow m r,\n    CoreMetrics m,\n    HasCoordinates a,\n    HasCoordinates b,\n    ToJSON a,\n    ToJSON b,\n    MonadReader r m,\n    HasKafkaProducer r\n  ) =>\n  Maybe Text ->\n  GetDistancesReq a b ->\n  [[a]] ->\n  [[b]] ->\n  BaseUrl ->\n  Text ->\n  Maybe GoogleMaps.Mode ->\n  Bool ->\n  m [GetDistanceResp a b]\ngetDistancesWrapper entityId req limitedOriginObjectsList limitedDestinationObjectsList googleMapsUrl key mode isAvoidTolls = concatForM limitedOriginObjectsList $ \\limitedOriginObjects ->\n  concatForM limitedDestinationObjectsList $ \\limitedDestinationObjects ->\n    do\n      let limitedOriginPlaces = map (latLongToPlace . getCoordinates) limitedOriginObjects\n          limitedDestinationPlaces = map (latLongToPlace . getCoordinates) limitedDestinationObjects\n      GoogleMaps.distanceMatrix entityId req googleMapsUrl key limitedOriginPlaces limitedDestinationPlaces mode isAvoidTolls\n      >>= parseDistanceMatrixResp req.distanceUnit limitedOriginObjects limitedDestinationObjects\n\ngetDistances ::\n  ( EncFlow m r,\n    CoreMetrics m,\n    HasCoordinates a,\n    HasCoordinates b,\n    ToJSON a,\n    ToJSON b,\n    MonadReader r m,\n    HasKafkaProducer r\n  ) =>\n  Maybe Text ->\n  GoogleCfg ->\n  GetDistancesReq a b ->\n  m (NonEmpty (GetDistanceResp a b))\ngetDistances entityId cfg GetDistancesReq {..} = do\n  let googleMapsUrl = cfg.googleMapsUrl\n  key <- decrypt cfg.googleKey\n  let limitedOriginObjectsList = splitListByAPICap origins\n      limitedDestinationObjectsList = splitListByAPICap destinations\n  res <- getDistancesWrapper entityId GetDistancesReq {..} limitedOriginObjectsList limitedDestinationObjectsList googleMapsUrl key mode True\n  case res of\n    [] -> do\n      logInfo \"Falling back to avoid tolls\"\n      resp <- getDistancesWrapper entityId GetDistancesReq {..} limitedOriginObjectsList limitedDestinationObjectsList googleMapsUrl key mode False\n      case resp of\n        [] -> throwError (InternalError \"Empty GoogleMaps.getDistances result.\")\n        (a : xs) -> return $ a :| xs\n    (a : xs) -> return $ a :| xs\n  where\n    mode = mapToMode <$> travelMode\n\n    -- Constraints on Distance matrix API: https://developers.google.com/maps/documentation/distance-matrix/usage-and-billing#other-usage-limits\n    splitListByAPICap inputList = do\n      List.chunksOf 25 $ toList inputList\n\noriginAndDestinationRemover :: [a] -> [a]\noriginAndDestinationRemover waypoints = if length waypoints > 2 then init $ tail waypoints else []\n\nrouteToRouteProxyConverter :: GetRoutesReq -> GetRoutesReqProxy\nrouteToRouteProxyConverter req =\n  GetRoutesReqProxy\n    { origin = NE.head req.waypoints,\n      destination = NE.last req.waypoints,\n      mode = req.mode,\n      calcPoints = req.calcPoints,\n      waypoints = originAndDestinationRemover $ NE.toList req.waypoints\n    }\n\nlatLngToWaypointV2Converter :: LatLong -> GoogleMaps.WayPointV2\nlatLngToWaypointV2Converter LatLong {..} =\n  GoogleMaps.WayPointV2\n    { location =\n        GoogleMaps.LocationV2\n          { latLng =\n              GoogleMaps.LatLngV2\n                { latitude = lat,\n                  longitude = lon\n                }\n          }\n    }\n\ngetRoutes ::\n  ( EncFlow m r,\n    CoreMetrics m,\n    Log m,\n    MonadReader r m,\n    HasKafkaProducer r\n  ) =>\n  Maybe Text ->\n  Bool ->\n  GoogleCfg ->\n  GetRoutesReq ->\n  m GetRoutesResp\ngetRoutes entityId isAvoidToll cfg req = do\n  let routeProxyReq = routeToRouteProxyConverter req\n      useAdvancedDirections = cfg.useAdvancedDirections\n  key <- decrypt cfg.googleKey\n  if useAdvancedDirections && (routeProxyReq.origin /= routeProxyReq.destination)\n    then do\n      let googleMapsUrl = cfg.googleRouteConfig.url\n          computeAlternativeRoutes = cfg.googleRouteConfig.computeAlternativeRoutes\n          routePreference = cfg.googleRouteConfig.routePreference\n          waypointsV2 = NE.map latLngToWaypointV2Converter req.waypoints\n          origin = NE.head waypointsV2\n          destination = NE.last waypointsV2\n          intermediates = if length waypointsV2 > 2 then Just $ init $ NE.tail waypointsV2 else Nothing\n          mode = getModeV2 <$> req.mode\n      result <- try @_ @SomeException $ GoogleMaps.advancedDirectionsAPI entityId googleMapsUrl key origin destination mode intermediates isAvoidToll computeAlternativeRoutes routePreference\n      case result of\n        Right gRes -> do\n          if null gRes.routes && isAvoidToll\n            then do\n              gResp <- GoogleMaps.advancedDirectionsAPI entityId googleMapsUrl key origin destination mode intermediates False computeAlternativeRoutes routePreference\n              traverse (mkRoute' routeProxyReq) gResp.routes\n            else traverse (mkRoute' routeProxyReq) gRes.routes\n        Left err -> do\n          logTagWarning \"GoogleMapsDirections\" (\"Advanced Directions API failed, falling back to basic directions API, \" <> show req <> \" error is: \" <> show err)\n          let cfg' = cfg {useAdvancedDirections = False}\n          getRoutes entityId isAvoidToll cfg' req\n    else do\n      let googleMapsUrl = cfg.googleMapsUrl\n      let origin = latLongToPlace routeProxyReq.origin\n          destination = latLongToPlace routeProxyReq.destination\n          waypoints = getWayPoints routeProxyReq.waypoints\n          mode = mapToMode <$> routeProxyReq.mode\n      gRes <- GoogleMaps.directions entityId req googleMapsUrl key origin destination mode waypoints isAvoidToll\n      if null gRes.routes && isAvoidToll\n        then do\n          gResp <- GoogleMaps.directions entityId req googleMapsUrl key origin destination mode waypoints False\n          traverse (mkRoute routeProxyReq) gResp.routes\n        else traverse (mkRoute routeProxyReq) gRes.routes\n  where\n    getWayPoints waypoints =\n      case waypoints of\n        [] -> Nothing\n        _ -> Just (map latLongToPlace waypoints)\n    getModeV2 :: TravelMode -> GoogleMaps.ModeV2\n    getModeV2 mode =\n      case mode of\n        CAR -> GoogleMaps.DRIVE\n        FOOT -> GoogleMaps.WALK\n        BICYCLE -> GoogleMaps.BICYCLE\n        MOTORCYCLE -> GoogleMaps.TWO_WHEELER\n\nmkRoute' ::\n  (MonadFlow m) =>\n  GetRoutesReqProxy ->\n  GoogleMaps.RouteV2 ->\n  m RouteInfo\nmkRoute' req route = do\n  let bound = Just $ mkBounds route.viewport\n  if null route.legs\n    then do\n      logTagWarning \"GoogleMapsDirections\" (\"Empty route.legs, \" <> show req)\n      return $ RouteInfo Nothing Nothing Nothing Nothing bound [] []\n    else do\n      when (length route.legs > 1) $\n        logTagWarning \"GoogleMapsDirections\" (\"More than one element in route.legs, \" <> show req)\n\n      let totalDistance = Meters route.distanceMeters\n          distanceWithUnit = Distance (toHighPrecDistance totalDistance) Meter\n          allSteps = foldl (\\acc leg -> acc ++ leg.steps) [] route.legs\n          polylinePoints = concatMap (\\step -> decode step.polyline.encodedPolyline) allSteps\n          totalStaticDuration = durationInS =<< route.staticDuration\n      totalDuration <- durationInS route.duration & fromMaybeM (InternalError \"No duration value provided in advanced directions API response\")\n      return $ RouteInfo (Just totalDuration) totalStaticDuration (Just totalDistance) (Just distanceWithUnit) bound [] polylinePoints\n  where\n    mkBounds :: GoogleMaps.ViewPort -> BoundingBoxWithoutCRS\n    mkBounds viewport =\n      let ne = PointXY viewport.high.latitude viewport.high.longitude\n          sw = PointXY viewport.low.latitude viewport.low.longitude\n       in BoundingBoxWithoutCRSXY ne sw\n    durationInS :: Text -> (Maybe Seconds)\n    durationInS dur = do\n      let durationText = T.replace \"s\" \"\" dur\n          maybeDuration = fmap (round :: Double -> Int) (readMaybe $ T.unpack durationText) -- Convert Maybe Double to Maybe Int\n      Just . Seconds =<< maybeDuration\n\nmkRoute ::\n  (MonadFlow m) =>\n  GetRoutesReqProxy ->\n  GoogleMaps.Route ->\n  m RouteInfo\nmkRoute req route = do\n  let bound = Just $ mkBounds route.bounds\n  if null route.legs\n    then do\n      logTagWarning \"GoogleMapsDirections\" (\"Empty route.legs, \" <> show req)\n      return $ RouteInfo Nothing Nothing Nothing Nothing bound [] []\n    else do\n      when (length route.legs > 1) $\n        logTagWarning \"GoogleMapsDirections\" (\"More than one element in route.legs, \" <> show req)\n\n      let totalDistance = foldl (\\acc leg -> acc + fromIntegral leg.distance.value) 0 route.legs\n          distanceWithUnit = Distance (toHighPrecDistance totalDistance) Meter\n          totalDuration = foldl (\\acc leg -> acc + fromIntegral leg.duration.value) 0 route.legs\n          allSteps = foldl (\\acc leg -> acc ++ leg.steps) [] route.legs\n          polylinePoints = concatMap (\\step -> decode step.polyline.points) allSteps\n      -- TODO: Fix snappedWayPoints: the waypoint passed in request which are snapped to road\n      -- snappedWayPoints = (\\step -> (LatLong step.start_location.lat step.start_location.lng, LatLong step.end_location.lat step.end_location.lng)) <$> steps\n\n      return $ RouteInfo (Just totalDuration) Nothing (Just totalDistance) (Just distanceWithUnit) bound [] polylinePoints\n  where\n    mkBounds :: GoogleMaps.Bounds -> BoundingBoxWithoutCRS\n    mkBounds gBound =\n      let ne = PointXY gBound.northeast.lat gBound.northeast.lng\n          sw = PointXY gBound.southwest.lat gBound.southwest.lng\n       in BoundingBoxWithoutCRSXY ne sw\n\nparseDistanceMatrixResp ::\n  (MonadThrow m, MonadIO m, Log m) =>\n  DistanceUnit ->\n  [a] ->\n  [b] ->\n  GoogleMaps.DistanceMatrixResp ->\n  m [GetDistanceResp a b]\nparseDistanceMatrixResp distanceUnit origins destinations distanceMatrixResp = do\n  mapM buildGetDistanceResult origDestAndElemList\n  where\n    origDestAndElemList = do\n      (orig, row) <- zip origins distanceMatrixResp.rows\n      (dest, element) <- zip destinations row.elements\n      return (orig, dest, element)\n\n    buildGetDistanceResult (orig, dest, element) = do\n      distance <- parseDistances element\n      duration <- parseDuration element\n      pure $\n        GetDistanceResp\n          { origin = orig,\n            destination = dest,\n            distance = distance,\n            distanceWithUnit = convertMetersToDistance distanceUnit distance,\n            duration = Seconds . double2Int . realToFrac $ duration,\n            status = element.status\n          }\n\nlatLongToPlace :: LatLong -> GoogleMaps.Place\nlatLongToPlace LatLong {..} =\n  GoogleMaps.Location $ GoogleMaps.LocationS {lat = lat, lng = lon}\n\nmapToMode :: TravelMode -> GoogleMaps.Mode\nmapToMode CAR = GoogleMaps.DRIVING\nmapToMode MOTORCYCLE = GoogleMaps.DRIVING\nmapToMode BICYCLE = GoogleMaps.BICYCLING\nmapToMode FOOT = GoogleMaps.WALKING\n\nparseDistances :: (MonadThrow m, Log m) => GoogleMaps.DistanceMatrixElement -> m Meters\nparseDistances distanceMatrixElement = do\n  distance <-\n    distanceMatrixElement.distance\n      & fromMaybeM (InternalError \"No distance value provided in distance matrix API response\")\n  pure $ Meters $ distance.value\n\nparseDuration :: (MonadThrow m, Log m) => GoogleMaps.DistanceMatrixElement -> m NominalDiffTime\nparseDuration distanceMatrixElement = do\n  durationInTraffic <-\n    distanceMatrixElement.duration\n      & fromMaybeM (InternalError \"No duration value provided in distance matrix API response\")\n  pure $ intToNominalDiffTime durationInTraffic.value\n\nsnapToRoad ::\n  ( HasCallStack,\n    EncFlow m r,\n    CoreMetrics m,\n    MonadReader r m,\n    HasKafkaProducer r\n  ) =>\n  Maybe Text ->\n  GoogleCfg ->\n  SnapToRoadReq ->\n  m SnapToRoadResp\nsnapToRoad entityId cfg req@SnapToRoadReq {..} = do\n  let roadsUrl = cfg.googleRoadsUrl\n  key <- decrypt cfg.googleKey\n  res <- GoogleRoads.snapToRoad entityId req roadsUrl key points\n  let pts = map (.location) res.snappedPoints\n  let dist = getRouteLinearLength pts calculateDistanceFrom\n  pure\n    SnapToRoadResp\n      { distance = dist,\n        distanceWithUnit = convertHighPrecMetersToDistance distanceUnit dist,\n        confidence = 1.0, -- Considering Google's default confidence as 1.0\n        snappedPoints = pts\n      }\n\nautoComplete ::\n  ( EncFlow m r,\n    CoreMetrics m,\n    HasShortDurationRetryCfg r c,\n    MonadReader r m,\n    HasKafkaProducer r\n  ) =>\n  Maybe Text ->\n  GoogleCfg ->\n  AutoCompleteReq ->\n  m AutoCompleteResp\nautoComplete entityId cfg req@AutoCompleteReq {..} = do\n  if cfg.useNewPlaces\n    then do\n      result <- try @_ @SomeException $ autoCompleteNew entityId cfg AutoCompleteReq {..}\n      case result of\n        Right res -> return res\n        Left err -> do\n          logTagError \"GoogleMapsAutoComplete\" (\"New Places API failed, falling back to old places API, \" <> show AutoCompleteReq {..} <> \" error is: \" <> show err)\n          autoCompleteOld\n    else autoCompleteOld\n  where\n    autoCompleteOld = do\n      let mapsUrl = cfg.googleMapsUrl\n      key <- decrypt cfg.googleKey\n      let components =\n            case country of\n              India -> \"country:in\"\n              France -> \"country:fr\"\n              USA -> \"country:us|country:pr|country:vi|country:gu|country:mp\"\n      res <- withShortRetry $ GoogleMaps.autoComplete entityId req mapsUrl key input sessionToken location (maybe radius (toInteger . distanceToMeters) radiusWithUnit) components language strictbounds origin types_\n      let distanceUnit = fromMaybe Meter $ radiusWithUnit <&> (.unit)\n      let predictions = map (\\prediction -> Prediction {placeId = prediction.place_id, distance = prediction.distance_meters, distanceWithUnit = convertMetersToDistance distanceUnit . Meters <$> prediction.distance_meters, types = prediction.types, description = prediction.description}) res.predictions\n      return $ AutoCompleteResp predictions\n\nautoCompleteNew ::\n  ( EncFlow m r,\n    CoreMetrics m,\n    MonadReader r m,\n    HasKafkaProducer r\n  ) =>\n  Maybe Text ->\n  GoogleCfg ->\n  AutoCompleteReq ->\n  m AutoCompleteResp\nautoCompleteNew entityId cfg AutoCompleteReq {..} = do\n  let mapsUrl = cfg.googlePlaceNewUrl\n  key <- decrypt cfg.googleKey\n  let includedRegionCodes =\n        case cfg.googleAutocompleteParams of\n          Just params -> params\n          Nothing ->\n            case country of\n              India -> [\"in\"]\n              France -> [\"fr\", \"nl\"]\n              USA -> [\"us\", \"pr\", \"vi\", \"gu\", \"mp\"]\n      includedPrimaryTypes = types_\n      origin' = mkLatLngV2 <$> origin\n  center <- buildLatLng location\n  let radiusInM = (maybe radius (toInteger . distanceToMeters) radiusWithUnit)\n      circle = GoogleMaps.Circle {center = center, radius = fromIntegral radiusInM}\n      (locationBias, locationRestriction) = getLocationBiasAndLocationRestriction radiusInM circle\n  let req = GoogleMaps.AutoCompleteReqV2 {input, sessionToken, origin = origin', locationBias, locationRestriction, includedPrimaryTypes, includedRegionCodes}\n  res <- GoogleMaps.autoCompleteV2 entityId mapsUrl key language req\n  let distanceUnit = fromMaybe Meter $ radiusWithUnit <&> (.unit)\n  let predictions = map (\\suggestion -> Prediction {placeId = suggestion.placePrediction.placeId, distance = suggestion.placePrediction.distanceMeters, distanceWithUnit = convertMetersToDistance distanceUnit . Meters <$> suggestion.placePrediction.distanceMeters, types = suggestion.placePrediction.types, description = suggestion.placePrediction.text.text}) res.suggestions\n  return $ AutoCompleteResp predictions\n  where\n    mkLatLngV2 :: LatLong -> GoogleMaps.LatLngV2\n    mkLatLngV2 LatLong {..} = GoogleMaps.LatLngV2 {latitude = lat, longitude = lon}\n\n    buildLatLng :: (EncFlow m r, CoreMetrics m) => Text -> m GoogleMaps.LatLngV2\n    buildLatLng loc = do\n      case T.splitOn \",\" loc of\n        [lat, lon] -> do\n          let lat' = readMaybe $ T.unpack lat\n              lon' = readMaybe $ T.unpack lon\n          case (lat', lon') of\n            (Just latitude, Just longitude) -> return $ GoogleMaps.LatLngV2 {latitude = latitude, longitude = longitude}\n            _ -> throwError (InvalidRequest \"Invalid location\")\n        _ -> throwError (InvalidRequest \"Invalid location\")\n\n    getLocationBiasAndLocationRestriction radiusInM circle\n      | radiusInM > 50000 = (Nothing, Nothing) -- when radius in metres is > 50000 api will give bad request\n      | strictbounds == Just True = (Nothing, Just $ GoogleMaps.LocationRestriction circle)\n      | strictbounds == Just False = (Just $ GoogleMaps.LocationBias circle, Nothing)\n      | otherwise = (Just $ GoogleMaps.LocationBias circle, Nothing)\n\ngetPlaceDetails ::\n  ( EncFlow m r,\n    CoreMetrics m,\n    MonadReader r m,\n    HasKafkaProducer r\n  ) =>\n  Maybe Text ->\n  GoogleCfg ->\n  GetPlaceDetailsReq ->\n  m GetPlaceDetailsResp\ngetPlaceDetails entityId cfg req@GetPlaceDetailsReq {..} = do\n  let mapsUrl = cfg.googleMapsUrl\n  key <- decrypt cfg.googleKey\n  let fields = \"geometry\"\n  res <- GoogleMaps.getPlaceDetails entityId req mapsUrl key sessionToken placeId fields\n  let location = let loc = res.result.geometry.location in LatLong loc.lat loc.lng\n  return $ GetPlaceDetailsResp location\n\ngetPlaceName ::\n  ( EncFlow m r,\n    CoreMetrics m,\n    MonadReader r m,\n    HasKafkaProducer r\n  ) =>\n  Maybe Text ->\n  GoogleCfg ->\n  GetPlaceNameReq ->\n  m GetPlaceNameResp\ngetPlaceName entityId cfg req@GetPlaceNameReq {..} = do\n  let mapsUrl = cfg.googleMapsUrl\n  key <- decrypt cfg.googleKey\n  res <- GoogleMaps.getPlaceName entityId req mapsUrl key sessionToken mbByPlaceId mbByLatLong language\n  return $ map reformatePlaceName res.results\n  where\n    reformatePlaceName (placeName :: GoogleMaps.ResultsResp) =\n      PlaceName\n        { formattedAddress = placeName.formatted_address,\n          addressComponents = map reformateAddressResp placeName.address_components,\n          plusCode = (placeName.plus_code >>= (.compound_code)) <|> (placeName.plus_code >>= (.global_code)),\n          location = let loc = placeName.geometry.location in LatLong loc.lat loc.lng,\n          placeId = placeName.place_id,\n          source = Nothing\n        }\n    reformateAddressResp aResp =\n      AddressResp\n        { longName = aResp.long_name,\n          shortName = aResp.short_name,\n          types = aResp.types\n        }\n    (mbByPlaceId, mbByLatLong) = case getBy of\n      ByPlaceId id -> (Just id, Nothing)\n      ByLatLong latLong -> (Nothing, Just latLong)\n",
      "hash": "5a3b4e043e55861db80e65a5515d38d71e88b67e83df1bf03a692f9b4439764a",
      "size": 20017
    },
    "/lib/mobility-core/src/Kernel/External/Maps/Interface/MMI.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n\nmodule Kernel.External.Maps.Interface.MMI\n  ( autoSuggest,\n    getDistanceMatrix,\n    getRoutes,\n    snapToRoad,\n    reverseGeocode,\n    getPlaceDetails,\n    geocode,\n  )\nwhere\n\nimport Data.List.Extra ((!!))\nimport qualified Data.List.Extra as List\nimport qualified Data.List.NonEmpty as NE\nimport Data.Maybe\nimport qualified Data.Text as T\nimport EulerHS.Prelude\nimport GHC.Float (double2Int)\nimport Kernel.External.Encryption\nimport qualified Kernel.External.Maps.Google.PolyLinePoints as PP\nimport Kernel.External.Maps.HasCoordinates (HasCoordinates (..))\nimport Kernel.External.Maps.Interface.Types as IT\nimport Kernel.External.Maps.MMI.AutoSuggest as MMI\nimport Kernel.External.Maps.MMI.Config\nimport Kernel.External.Maps.MMI.DistanceMatrix as MMI\nimport Kernel.External.Maps.MMI.Geocode as MMI\nimport Kernel.External.Maps.MMI.MMIAuthToken as MMIAuthToken\nimport qualified Kernel.External.Maps.MMI.PlaceDetails as MMI\nimport Kernel.External.Maps.MMI.ReverseGeocoding as MMI\nimport Kernel.External.Maps.MMI.Routes as MMI\nimport Kernel.External.Maps.MMI.SnapToRoad as MMI\nimport qualified Kernel.External.Maps.MMI.Types as MMI\nimport qualified Kernel.External.Maps.MMI.Types as MMITypes\nimport Kernel.External.Maps.Types\nimport Kernel.Storage.Hedis as Redis\nimport Kernel.Streaming.Kafka.Producer.Types (HasKafkaProducer)\nimport Kernel.Tools.Metrics.CoreMetrics (CoreMetrics)\nimport Kernel.Types.Common\nimport Kernel.Types.Error\nimport Kernel.Utils.CalculateDistance (getRouteLinearLength)\nimport Kernel.Utils.Common hiding (id)\n\nautoSuggest ::\n  ( EncFlow m r,\n    CoreMetrics m,\n    Redis.HedisFlow m r,\n    MonadFlow m,\n    MonadReader r m,\n    HasKafkaProducer r\n  ) =>\n  Maybe Text ->\n  MMICfg ->\n  IT.AutoCompleteReq ->\n  m IT.AutoCompleteResp\nautoSuggest entityId mmiCfg req@AutoCompleteReq {..} = do\n  let query = input\n      loc = location\n      region =\n        case mmiCfg.mmiAutocompleteParams of\n          Just params -> params\n          Nothing ->\n            case country of\n              India -> \"ind\"\n              France -> \"fr\"\n              USA -> \"us\"\n      lang = language\n      mapsUrl = mmiCfg.mmiNonKeyUrl\n  token <- MMIAuthToken.getTokenText entityId mmiCfg\n  res <- MMI.mmiAutoSuggest entityId req mapsUrl (Just $ MMITypes.MMIAuthToken token) query loc region lang\n  let predictions = map (\\MMITypes.SuggestedLocations {..} -> Prediction {placeId = Just eLoc, description = placeName <> \" \" <> placeAddress, distance = Nothing, distanceWithUnit = Nothing, types = Nothing}) res.suggestedLocations\n  return $ AutoCompleteResp predictions\n\ngetDistanceMatrix ::\n  ( EncFlow m r,\n    CoreMetrics m,\n    MonadFlow m,\n    HasCoordinates a,\n    HasCoordinates b,\n    ToJSON a,\n    ToJSON b,\n    MonadReader r m,\n    HasKafkaProducer r\n  ) =>\n  Maybe Text ->\n  MMICfg ->\n  IT.GetDistancesReq a b ->\n  m (NonEmpty (IT.GetDistanceResp a b))\ngetDistanceMatrix entityId mmiCfg req@GetDistancesReq {..} = do\n  key <- decrypt mmiCfg.mmiApiKey\n  let limitedOriginObjectsList = splitListByAPICap origins\n      limitedDestinationObjectsList = splitListByAPICap destinations\n      mapsUrl = mmiCfg.mmiKeyUrl\n  res <- concatForM limitedOriginObjectsList $ \\limitedOriginObjects ->\n    concatForM limitedDestinationObjectsList $ \\limitedDestinationObjects -> do\n      let limitedOriginPlaces = map getCoordinates limitedOriginObjects\n          limitedDestinationPlaces = map getCoordinates limitedDestinationObjects\n          lOrigin = length limitedOriginObjects\n          lDest = length limitedDestinationObjects\n          strOrig = map show [0 .. lOrigin - 1]\n          strDest = map show [lOrigin .. (lOrigin + lDest - 1)]\n          origParam = T.intercalate \";\" strOrig\n          origDest = T.intercalate \";\" strDest\n          placesList = (++) limitedOriginPlaces limitedDestinationPlaces\n          coordinatesList = map latLongToText placesList\n          coordinates = T.intercalate \";\" coordinatesList\n      MMI.mmiDistanceMatrix entityId req mapsUrl key coordinates (Just origParam) (Just origDest)\n        >>= parseDistanceMatrixResp distanceUnit lOrigin lDest limitedOriginObjects limitedDestinationObjects\n  case res of\n    [] -> throwError (InternalError \"Empty MMI.getDistances result.\")\n    (a : xs) -> return $ a :| xs\n  where\n    splitListByAPICap inputList = do\n      List.chunksOf 50 $ toList inputList\n\nlatLongToText :: LatLong -> Text\nlatLongToText LatLong {..} = show lon <> \",\" <> show lat\n\ncartProd :: [a] -> [b] -> [(a, b)]\ncartProd xs ys = [(x, y) | x <- xs, y <- ys]\n\n-- orig, dest, distance, duration, status\nparseDistanceMatrixResp ::\n  (MonadThrow m, MonadIO m, Log m) =>\n  DistanceUnit ->\n  Int ->\n  Int ->\n  [a] ->\n  [b] ->\n  MMITypes.DistanceMatrixResp ->\n  m [IT.GetDistanceResp a b]\nparseDistanceMatrixResp distanceUnit lOrigin lDest listSrc listDest distanceMatrixResp = do\n  let lst = cartProd [0 .. (lOrigin - 1)] [0 .. (lDest - 1)]\n  return $ map (buildResp distanceUnit listSrc listDest distanceMatrixResp) lst\n\nbuildResp ::\n  DistanceUnit ->\n  [a] ->\n  [b] ->\n  MMITypes.DistanceMatrixResp ->\n  (Int, Int) ->\n  IT.GetDistanceResp a b\nbuildResp distanceUnit listSrc listDest distanceMatrixResp pair = do\n  let distance = floor $ (distanceMatrixResp.results.distances !! fst pair) !! snd pair\n  GetDistanceResp\n    { origin = listSrc !! fst pair,\n      destination = listDest !! snd pair,\n      distance,\n      distanceWithUnit = convertMetersToDistance distanceUnit distance,\n      duration = floor $ (distanceMatrixResp.results.durations !! fst pair) !! snd pair,\n      status = distanceMatrixResp.results.code\n    }\n\ngetRoutes ::\n  ( EncFlow m r,\n    CoreMetrics m,\n    Log m,\n    MonadReader r m,\n    HasKafkaProducer r\n  ) =>\n  Maybe Text ->\n  MMICfg ->\n  IT.GetRoutesReq ->\n  m IT.GetRoutesResp\ngetRoutes entityId mmiCfg req = do\n  key <- decrypt mmiCfg.mmiApiKey\n  let origin = latLongToText (NE.head req.waypoints)\n      destination = latLongToText (NE.last req.waypoints)\n      points = origin <> \";\" <> destination\n      mapsUrl = mmiCfg.mmiKeyUrl\n  resp <- MMI.mmiRoute entityId req mapsUrl key points\n  traverse (mkRoute req resp) resp.routes\n\ngetPlaceDetails ::\n  ( EncFlow m r,\n    CoreMetrics m,\n    Log m,\n    MonadReader r m,\n    HasKafkaProducer r\n  ) =>\n  Maybe Text ->\n  MMICfg ->\n  IT.GetPlaceDetailsReq ->\n  m IT.GetPlaceDetailsResp\ngetPlaceDetails entityId mmiCfg req@GetPlaceDetailsReq {..} = do\n  key <- decrypt mmiCfg.mmiApiKey\n  resp <- MMI.mmiPlaceDetails entityId req mmiCfg.mmiKeyUrl key placeId\n  let MMITypes.PlaceDetail {..} = NE.head resp.results\n  pure $ GetPlaceDetailsResp (LatLong {lat = latitude, lon = longitude})\n\nmkRoute ::\n  (MonadFlow m) =>\n  IT.GetRoutesReq ->\n  MMI.RouteResponse ->\n  MMI.Routes ->\n  m IT.RouteInfo\nmkRoute req resp route = do\n  let bound = Nothing\n  if null route.legs\n    then do\n      logTagWarning \"MMIRoutes\" (\"Empty route.legs, \" <> show req)\n      return $ RouteInfo Nothing Nothing Nothing Nothing bound [] []\n    else do\n      when (length route.legs > 1) $\n        logTagWarning \"MMIRoutes\" (\"More than one element in route.legs, \" <> show req)\n      let points = PP.decode route.geometry\n          bounds = boundingBoxCal points\n          boundBox = Just $ BoundingBoxWithoutCRSXY (PointXY bounds.minLat bounds.minLon) (PointXY bounds.minLat bounds.minLon)\n          snappedWayPoints = (\\waypoint -> waypoint.location.getLatLong) <$> resp.waypoints\n          distanceInM = Just $ Meters $ double2Int route.distance\n          distanceWithUnit = Just $ Distance (toHighPrecDistance route.distance) Meter\n          durationInS = Just $ Seconds $ double2Int route.duration\n      return $ RouteInfo durationInS Nothing distanceInM distanceWithUnit boundBox snappedWayPoints points\n  where\n    createAcc = Acc {minLat = 91.0, maxLat = -91.0, minLon = 180.0, maxLon = -180.0}\n    boundingBoxCal points = foldl' compareLatLong createAcc points\n    compareLatLong :: Acc -> LatLong -> Acc\n    compareLatLong acc loc =\n      let max_lat = max loc.lat acc.maxLat\n          max_lng = max loc.lon acc.maxLon\n          min_lat = min loc.lat acc.minLat\n          min_lng = min loc.lon acc.minLon\n       in Acc {minLat = min_lat, maxLat = max_lat, minLon = min_lng, maxLon = max_lng}\n\ndata Acc = Acc {minLat :: Double, maxLat :: Double, minLon :: Double, maxLon :: Double}\n  deriving (Generic, ToJSON, FromJSON)\n\nsnapToRoad ::\n  ( EncFlow m r,\n    CoreMetrics m,\n    Log m,\n    MonadReader r m,\n    HasKafkaProducer r\n  ) =>\n  Maybe Text ->\n  MMICfg ->\n  IT.SnapToRoadReq ->\n  m IT.SnapToRoadResp\nsnapToRoad entityId mmiCfg req = do\n  key <- decrypt mmiCfg.mmiApiKey\n  let points = T.intercalate \";\" $ latLongToMmiText <$> req.points\n      mapsUrl = mmiCfg.mmiKeyUrl\n  resp <- MMI.mmiSnapToRoad entityId req mapsUrl key points\n\n  let listOfSnappedPoints = sortOn (.waypoint_index) $ catMaybes $ resp.results.snappedPoints\n  let listOfPoints = getPoints listOfSnappedPoints\n  let dist = getRouteLinearLength listOfPoints req.calculateDistanceFrom\n  pure\n    SnapToRoadResp\n      { distance = dist,\n        distanceWithUnit = convertHighPrecMetersToDistance req.distanceUnit dist,\n        confidence = 1.0, -- Considering MMI's default confidence as 1.0\n        snappedPoints = listOfPoints\n      }\n  where\n    getPoints :: [MMITypes.SnappedPoint] -> [LatLong]\n    getPoints = fmap (\\x -> x.location.getLatLong)\n    latLongToMmiText :: LatLong -> Text\n    latLongToMmiText LatLong {..} = show lon <> \",\" <> show lat\n\nreverseGeocode ::\n  ( EncFlow m r,\n    CoreMetrics m,\n    Log m,\n    MonadReader r m,\n    HasKafkaProducer r\n  ) =>\n  Maybe Text ->\n  MMICfg ->\n  MMITypes.ReverseGeocodeReq ->\n  m MMITypes.ReverseGeocodeResp\nreverseGeocode entityId mmiCfg req@MMITypes.ReverseGeocodeReq {..} = do\n  key <- decrypt mmiCfg.mmiApiKey\n  let mapsUrl = mmiCfg.mmiKeyUrl\n  MMI.mmiReverseGeocode entityId req mapsUrl key location region lang\n\ngeocode ::\n  ( EncFlow m r,\n    CoreMetrics m,\n    Redis.HedisFlow m r,\n    MonadFlow m,\n    MonadReader r m,\n    HasKafkaProducer r\n  ) =>\n  Maybe Text ->\n  MMICfg ->\n  IT.GetPlaceNameReq ->\n  m IT.GetPlaceNameResp\ngeocode entityId mmiCfg req@GetPlaceNameReq {..} = do\n  let mapsUrl = mmiCfg.mmiNonKeyUrl\n  token <- MMIAuthToken.getTokenText entityId mmiCfg\n  res <- MMI.mmiGeoCode entityId req mapsUrl (Just $ MMI.MMIAuthToken token) mbByPlaceId\n  return [reformatePlaceName res.copResults]\n  where\n    reformatePlaceName (res :: MMI.GeocodeResult) =\n      PlaceName\n        { formattedAddress = Just res.formattedAddress,\n          addressComponents = [reformateAddressResp res],\n          plusCode = Just res.eLoc,\n          location = LatLong {lat = 0.00, lon = 0.00},\n          placeId = Nothing,\n          source = Nothing\n        }\n    reformateAddressResp aResp =\n      AddressResp\n        { longName = aResp.district,\n          shortName = aResp.locality,\n          types = [aResp.geocodeLevel]\n        }\n    mbByPlaceId = case getBy of\n      ByPlaceId placeId -> placeId -- Do we need to add a ByAddress?\n      ByLatLong _ -> \"BAD_REQUEST\" --TO be fixed post discussion with MMI to add lat-long in response as per our product requirement\n",
      "hash": "928ca97bab7b59d7a3d9bb140450d6ef7eaf3ab4888dd8c0b6c1269c51ea3745",
      "size": 11784
    },
    "/lib/mobility-core/src/Kernel/External/Maps/Interface/NextBillion.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n\nmodule Kernel.External.Maps.Interface.NextBillion\n  ( module Reexport,\n    getRoutes,\n    getRoutesWithExtraParameters,\n  )\nwhere\n\nimport qualified Data.List.NonEmpty as NE\nimport GHC.Float (double2Int)\nimport Kernel.External.Encryption\nimport Kernel.External.Maps.Google.Config as Reexport\nimport qualified Kernel.External.Maps.Google.MapsClient as GoogleMaps\nimport qualified Kernel.External.Maps.Google.PolyLinePoints as PP\nimport Kernel.External.Maps.HasCoordinates as Reexport (HasCoordinates (..))\nimport Kernel.External.Maps.Interface.Types\nimport Kernel.External.Maps.NextBillion.Config\nimport Kernel.External.Maps.NextBillion.Route as NB\nimport Kernel.External.Maps.NextBillion.Types as NextBillion\nimport Kernel.External.Maps.Types as Reexport\nimport Kernel.Prelude\nimport Kernel.Streaming.Kafka.Producer.Types (HasKafkaProducer)\nimport Kernel.Tools.Metrics.CoreMetrics (CoreMetrics)\nimport Kernel.Types.Common\n\noriginAndDestinationRemover :: [a] -> [a]\noriginAndDestinationRemover waypoints = if length waypoints > 2 then init $ tail waypoints else []\n\nrouteToRouteProxyConverter :: GetRoutesReq -> GetRoutesReqProxy\nrouteToRouteProxyConverter req =\n  GetRoutesReqProxy\n    { origin = NE.head req.waypoints,\n      destination = NE.last req.waypoints,\n      mode = req.mode,\n      calcPoints = req.calcPoints,\n      waypoints = originAndDestinationRemover $ NE.toList req.waypoints\n    }\n\nconvertToRoute :: NextBillion.Route -> RouteInfo\nconvertToRoute route =\n  RouteInfo\n    { duration = Just (Seconds $ double2Int route.duration),\n      distance = Just (Meters $ double2Int route.distance),\n      staticDuration = Nothing,\n      distanceWithUnit = Just $ Distance (toHighPrecDistance route.distance) Meter,\n      boundingBox = Nothing,\n      snappedWaypoints = [],\n      points = PP.decode $ route.geometry\n    }\n\nlatLongToPlace :: LatLong -> GoogleMaps.Place\nlatLongToPlace LatLong {..} =\n  GoogleMaps.Location $ GoogleMaps.LocationS {lat = lat, lng = lon}\n\ngetWayPoints :: [LatLong] -> Maybe [GoogleMaps.Place]\ngetWayPoints [] = Nothing\ngetWayPoints waypoints = Just (map latLongToPlace waypoints)\n\ngetRoutes ::\n  ( EncFlow m r,\n    CoreMetrics m,\n    Log m,\n    MonadReader r m,\n    HasKafkaProducer r\n  ) =>\n  Maybe Text ->\n  NextBillionCfg ->\n  GetRoutesReq ->\n  m GetRoutesResp\ngetRoutes entityId cfg req = do\n  let routeProxyReq = routeToRouteProxyConverter req\n  let url = cfg.nextBillionDirectionsUrl\n  let origin = latLongToPlace routeProxyReq.origin\n      destination = latLongToPlace routeProxyReq.destination\n      waypoints = getWayPoints routeProxyReq.waypoints\n  key <- decrypt cfg.nextBillionKey\n  res <- NB.directions entityId req url key origin destination waypoints Nothing Nothing Nothing Nothing\n  let allRoutes = map convertToRoute res.routes\n  return $ allRoutes\n\ngetRoutesWithExtraParameters ::\n  ( EncFlow m r,\n    CoreMetrics m,\n    Log m,\n    MonadReader r m,\n    HasKafkaProducer r\n  ) =>\n  Maybe Text ->\n  NextBillionCfg ->\n  NextBillion.GetRoutesRequest ->\n  m GetRoutesResp\ngetRoutesWithExtraParameters entityId cfg req = do\n  let url = cfg.nextBillionDirectionsUrl\n      origin = latLongToPlace $ NE.head req.waypoints\n      destination = latLongToPlace $ NE.last req.waypoints\n      waypoints = getWayPoints $ originAndDestinationRemover $ NE.toList req.waypoints\n  key <- decrypt cfg.nextBillionKey\n  res <- NB.directions entityId req url key origin destination waypoints req.alternatives req.altcount req.routeType req.option\n  let allRoutes = map convertToRoute res.routes\n  return $ allRoutes\n",
      "hash": "76647e105aca2665936c246a9b1fd18061399775fea0e00ed8aff236f9278850",
      "size": 4238
    },
    "/lib/mobility-core/src/Kernel/External/Maps/Interface/OSRM.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n\nmodule Kernel.External.Maps.Interface.OSRM\n  ( module Reexport,\n    callOsrmMatch,\n    getDistances,\n    getOSRMTable,\n    getRoutes,\n  )\nwhere\n\nimport qualified Data.List.NonEmpty as NE\nimport GHC.Float (double2Int)\nimport Kernel.External.Maps.Google.Config as Reexport\nimport Kernel.External.Maps.Google.PolyLinePoints\nimport Kernel.External.Maps.HasCoordinates as Reexport (HasCoordinates (..))\nimport Kernel.External.Maps.Interface.Types\nimport Kernel.External.Maps.OSRM.Config\nimport Kernel.External.Maps.OSRM.RoadsClient\nimport qualified Kernel.External.Maps.OSRM.RoadsClient as OSRM\nimport Kernel.External.Maps.Types as Reexport\nimport Kernel.Prelude\nimport Kernel.Streaming.Kafka.Producer.Types (HasKafkaProducer)\nimport qualified Kernel.Tools.Metrics.CoreMetrics as Metrics\nimport Kernel.Types.Error\nimport Kernel.Utils.CalculateDistance (getRouteLinearLength)\nimport Kernel.Utils.Common\n\ncallOsrmMatch ::\n  ( HasCallStack,\n    Metrics.CoreMetrics m,\n    MonadFlow m,\n    MonadReader r m,\n    HasKafkaProducer r\n  ) =>\n  Maybe Text ->\n  OSRMCfg ->\n  SnapToRoadReq ->\n  m SnapToRoadResp\ncallOsrmMatch entityId osrmCfg req@(SnapToRoadReq wps distanceUnit calculateDistanceFrom) = do\n  let mbRadius = fmap (.getMeters) osrmCfg.radiusDeviation\n  res <- OSRM.callOsrmMatchAPI entityId req osrmCfg.osrmUrl mbRadius CAR (OSRM.PointsList wps)\n  (dist, conf, interpolatedPts) <- OSRM.getResultOneRouteExpected res\n  pure $ case calculateDistanceFrom of\n    Just _ -> do\n      let dist' = getRouteLinearLength interpolatedPts calculateDistanceFrom\n      SnapToRoadResp dist' (convertHighPrecMetersToDistance distanceUnit dist') conf interpolatedPts\n    Nothing -> SnapToRoadResp dist (convertHighPrecMetersToDistance distanceUnit dist) conf interpolatedPts\n\ngetDistances ::\n  ( HasCallStack,\n    Metrics.CoreMetrics m,\n    MonadFlow m,\n    HasCoordinates a,\n    HasCoordinates b,\n    ToJSON a,\n    ToJSON b,\n    MonadReader r m,\n    HasKafkaProducer r\n  ) =>\n  Maybe Text ->\n  OSRMCfg ->\n  GetDistancesReq a b ->\n  m (GetDistancesResp a b)\ngetDistances entityId osrmCfg request = do\n  let pointsList = OSRM.PointsList $ map getCoordinates (toList request.origins) ++ map getCoordinates (toList request.destinations)\n  let sourcesList = OSRM.SourcesList [0 .. (length request.origins - 1)]\n  let destinationsList = OSRM.DestinationsList [(length request.origins) .. (length request.origins + length request.destinations - 1)]\n  response <- OSRM.callOsrmGetDistancesAPI entityId request osrmCfg.osrmUrl (fromMaybe CAR request.travelMode) pointsList sourcesList destinationsList request.sourceDestinationMapping\n  case request.sourceDestinationMapping of\n    Just OneToOne -> getOSRMTableOneToOne response request\n    _ -> getOSRMTable response request\n\ngetOSRMTable ::\n  ( Metrics.CoreMetrics m,\n    MonadFlow m,\n    HasCoordinates a,\n    HasCoordinates b\n  ) =>\n  OSRM.OSRMTableResponse ->\n  GetDistancesReq a b ->\n  m (GetDistancesResp a b)\ngetOSRMTable tableResponse request = do\n  let pairOfIndexSource = zip [0 .. (length request.origins - 1)] (NE.toList request.origins)\n  let pairOfIndexDestinations = zip [0 .. (length request.destinations - 1)] (NE.toList $ request.destinations)\n\n  pure $\n    NE.fromList $\n      foldl\n        ( \\mainList sourcePair ->\n            do\n              let subList =\n                    map\n                      ( \\destinationPair -> do\n                          let distance = Meters {getMeters = round $ tableResponse.distances !! fst sourcePair !! fst destinationPair}\n                          GetDistanceResp\n                            { origin = snd sourcePair,\n                              destination = snd destinationPair,\n                              distance,\n                              distanceWithUnit = convertMetersToDistance request.distanceUnit distance,\n                              duration = Seconds {getSeconds = round $ tableResponse.durations !! fst sourcePair !! fst destinationPair},\n                              status = \"ok\"\n                            }\n                      )\n                      pairOfIndexDestinations\n              mainList ++ subList\n        )\n        []\n        pairOfIndexSource\n\ngetOSRMTableOneToOne ::\n  ( Metrics.CoreMetrics m,\n    MonadFlow m,\n    HasCoordinates a,\n    HasCoordinates b\n  ) =>\n  OSRM.OSRMTableResponse ->\n  GetDistancesReq a b ->\n  m (GetDistancesResp a b)\ngetOSRMTableOneToOne tableResponse request = do\n  let pairOfIndexSourceDest = zip3 [0 .. (length request.origins - 1)] (NE.toList request.origins) (NE.toList $ request.destinations)\n  pure $\n    NE.fromList $\n      foldl\n        ( \\mainList (indx, source, dest) -> do\n            let distance = Meters {getMeters = round $ tableResponse.distances !! 0 !! indx}\n            let resp =\n                  GetDistanceResp\n                    { origin = source,\n                      destination = dest,\n                      distance,\n                      distanceWithUnit = convertMetersToDistance request.distanceUnit distance,\n                      duration = Seconds {getSeconds = round $ tableResponse.durations !! 0 !! indx},\n                      status = \"ok\"\n                    }\n            let subList = [resp]\n            mainList ++ subList\n        )\n        []\n        pairOfIndexSourceDest\n\ngetRoutes ::\n  ( HasCallStack,\n    Metrics.CoreMetrics m,\n    MonadFlow m,\n    MonadReader r m,\n    HasKafkaProducer r\n  ) =>\n  Maybe Text ->\n  OSRMCfg ->\n  GetRoutesReq ->\n  m GetRoutesResp\ngetRoutes entityId osrmCfg request = do\n  response <- OSRM.callOsrmRouteAPI entityId request osrmCfg.osrmUrl (fromMaybe CAR request.mode) $ OSRM.PointsList {getPointsList = NE.toList request.waypoints}\n  getOSRMRoute response\n\nconvertRouteToRouteInfo :: (Log m, MonadThrow m) => OSRM.OSRMRouteRoutes -> m RouteInfo\nconvertRouteToRouteInfo osrmRouteRoutes =\n  if length osrmRouteRoutes.legs < 1\n    then do\n      throwError $ InternalError \"OSRM snapped waypoints has no routes\"\n    else\n      return\n        RouteInfo\n          { distance = Just $ Meters $ double2Int $ osrmRouteRoutes.distance,\n            distanceWithUnit = Just $ Distance (toHighPrecDistance osrmRouteRoutes.distance) Meter,\n            duration = Just $ Seconds $ double2Int $ osrmRouteRoutes.duration,\n            staticDuration = Nothing,\n            points = map (.getLatLong) osrmRouteRoutes.geometry.coordinates,\n            snappedWaypoints = map (\\steps -> getLatLong $ head steps.geometry.coordinates) $ OSRM.steps $ head osrmRouteRoutes.legs,\n            boundingBox = Nothing\n          }\n\ngetOSRMRoute ::\n  ( HasCallStack,\n    Metrics.CoreMetrics m,\n    MonadFlow m\n  ) =>\n  OSRM.OSRMRouteResponse ->\n  m GetRoutesResp\ngetOSRMRoute osrmRouteResponse = sequence $ map convertRouteToRouteInfo osrmRouteResponse.routes\n",
      "hash": "19165eca0c673a695ddeb8320ab5b6217923cd3b927d9f347851736c692dd38a",
      "size": 7464
    },
    "/lib/mobility-core/src/Kernel/External/Maps/Interface/Types.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n{-# LANGUAGE DerivingVia #-}\n{-# LANGUAGE StandaloneDeriving #-}\n{-# OPTIONS_GHC -Wno-orphans #-}\n\nmodule Kernel.External.Maps.Interface.Types\n  ( module Kernel.External.Maps.Interface.Types,\n    module Data.Geospatial,\n    module Data.LineString,\n  )\nwhere\n\nimport Control.Lens.Operators\nimport qualified Data.Aeson as A\nimport Data.ByteString.Lazy as BL\nimport Data.ByteString.Lazy.Char8 as BLC\nimport Data.Geospatial\nimport Data.LineString\nimport Data.OpenApi hiding (components, description)\nimport qualified Data.OpenApi as OpenApi\nimport Data.Text\nimport qualified Data.Text.Encoding as TE\nimport qualified Database.Beam as B\nimport Database.Beam.Backend\nimport Database.Beam.Postgres\nimport Database.PostgreSQL.Simple.FromField (FromField (fromField))\nimport qualified Database.PostgreSQL.Simple.FromField as DPSF\nimport qualified Debug.Trace as T\nimport Deriving.Aeson\nimport EulerHS.Prelude\nimport qualified Kernel.External.Maps.Google.Config as Google\nimport qualified Kernel.External.Maps.MMI.Config as MMI\nimport qualified Kernel.External.Maps.NextBillion.Config as NextBillion\nimport qualified Kernel.External.Maps.OSRM.Config as OSRM\nimport Kernel.External.Maps.Types\nimport Kernel.External.Types (Language)\nimport Kernel.Types.Common\nimport Kernel.Utils.GenericPretty (PrettyShow)\n\ndata SnapToRoadHandler m = SnapToRoadHandler\n  { getProvidersList :: m [MapsService],\n    getConfidenceThreshold :: m Double,\n    getProviderConfig :: MapsService -> m MapsServiceConfig\n  }\n\ndata MapsServiceConfig = GoogleConfig Google.GoogleCfg | OSRMConfig OSRM.OSRMCfg | MMIConfig MMI.MMICfg | NextBillionConfig NextBillion.NextBillionCfg\n  deriving stock (Show, Eq, Generic)\n  deriving (FromJSON, ToJSON) via CustomJSON '[SumTaggedObject \"tag\" \"content\"] MapsServiceConfig\n\ndata TravelMode = CAR | MOTORCYCLE | BICYCLE | FOOT\n  deriving (Show, Eq, Generic, ToJSON, FromJSON, ToSchema)\n\ndata GetDistanceReq a b = GetDistanceReq\n  { origin :: a,\n    destination :: b,\n    distanceUnit :: DistanceUnit,\n    sourceDestinationMapping :: Maybe SourceDestinationMapping,\n    travelMode :: Maybe TravelMode\n  }\n  deriving (Generic, Show, ToJSON)\n\ndata GetDistancesReq a b = GetDistancesReq\n  { origins :: NonEmpty a,\n    destinations :: NonEmpty b,\n    distanceUnit :: DistanceUnit,\n    sourceDestinationMapping :: Maybe SourceDestinationMapping,\n    travelMode :: Maybe TravelMode\n  }\n  deriving (Generic, Show, ToJSON)\n\ndata GetDistanceResp a b = GetDistanceResp\n  { origin :: a,\n    destination :: b,\n    distance :: Meters,\n    distanceWithUnit :: Distance,\n    duration :: Seconds,\n    status :: Text\n  }\n  deriving (Generic, Show, PrettyShow, FromJSON, ToJSON)\n\ntype GetDistancesResp a b = NonEmpty (GetDistanceResp a b)\n\ndata GetRoutesReq = GetRoutesReq\n  { waypoints :: NonEmpty LatLong,\n    mode :: Maybe TravelMode, -- Defaults to CAR\n    calcPoints :: Bool -- True (default) if points needs to be calculated\n  }\n  deriving (Generic, ToJSON, FromJSON, Show, ToSchema)\n\ndata GetRoutesReqProxy = GetRoutesReqProxy\n  { waypoints :: [LatLong],\n    origin :: LatLong,\n    destination :: LatLong,\n    mode :: Maybe TravelMode, -- Defaults to CAR\n    calcPoints :: Bool -- True (default) if points needs to be calculated\n  }\n  deriving (Generic, ToJSON, FromJSON, Show, ToSchema)\n\ntype GetRoutesResp = [RouteInfo]\n\ndata RouteInfo = RouteInfo\n  { duration :: Maybe Seconds,\n    staticDuration :: Maybe Seconds,\n    distance :: Maybe Meters,\n    distanceWithUnit :: Maybe Distance,\n    boundingBox :: Maybe BoundingBoxWithoutCRS,\n    snappedWaypoints :: [LatLong],\n    points :: [LatLong]\n  }\n  deriving (Generic, ToJSON, FromJSON, ToSchema, Show, Eq, Ord)\n\ninstance FromField RouteInfo where\n  fromField f mbValue = case mbValue of\n    Nothing -> DPSF.returnError UnexpectedNull f mempty\n    Just value' ->\n      case T.trace (\"text val\" <> show value') $ A.eitherDecode $ BL.fromStrict value' of\n        Right jsonVal -> case T.trace (\"text val\" <> show value') $ A.eitherDecode (BL.fromStrict $ TE.encodeUtf8 jsonVal) of\n          Right val -> pure val\n          _ -> DPSF.returnError ConversionFailed f (\"Could not 'read'\" <> show value')\n        _ -> DPSF.returnError ConversionFailed f (\"Could not 'read'\" <> show value')\n\ninstance FromBackendRow Postgres RouteInfo\n\ninstance HasSqlValueSyntax be Text => HasSqlValueSyntax be RouteInfo where\n  sqlValueSyntax = sqlValueSyntax . (stringify . A.String . stringify . A.toJSON)\n    where\n      stringify = TE.decodeUtf8 . BLC.toStrict . A.encode\n\ninstance BeamSqlBackend be => B.HasSqlEqualityCheck be RouteInfo\n\nderiving stock instance Ord BoundingBoxWithoutCRS\n\nderiving stock instance Ord PointXY\n\nderiving stock instance Ord PointXYZ\n\nderiving stock instance Ord PointXYZM\n\nderiving stock instance Read BoundingBoxWithoutCRS\n\nderiving stock instance Read PointXY\n\nderiving stock instance Read PointXYZ\n\nderiving stock instance Read PointXYZM\n\ninstance ToSchema BoundingBoxWithoutCRS where\n  declareNamedSchema _ = do\n    aSchema <- declareSchema (Proxy :: Proxy Value)\n    return $\n      NamedSchema (Just \"BoundingBoxWithoutCRS\") $\n        aSchema\n          & OpenApi.description\n            ?~ \"https://datatracker.ietf.org/doc/html/rfc7946#section-5\"\n\ninstance ToSchema GeospatialGeometry where\n  declareNamedSchema _ = do\n    aSchema <- declareSchema (Proxy :: Proxy Value)\n    return $\n      NamedSchema (Just \"GeospatialGeometry\") $\n        aSchema\n          & OpenApi.description\n            ?~ \"https://datatracker.ietf.org/doc/html/rfc7946#section-2\"\n\ndata SnapToRoadReq = SnapToRoadReq\n  { points :: [LatLong],\n    distanceUnit :: DistanceUnit,\n    calculateDistanceFrom :: Maybe LatLong\n  }\n  deriving stock (Generic)\n  deriving (Show, ToJSON)\n\n-- deriving anyclass (FromJSON, ToJSON, ToSchema)\n\ndata SnapToRoadResp = SnapToRoadResp\n  { distance :: HighPrecMeters,\n    distanceWithUnit :: Distance,\n    confidence :: Double,\n    snappedPoints :: [LatLong]\n  }\n  deriving stock (Generic)\n  deriving (Show)\n  deriving anyclass (FromJSON, ToJSON, ToSchema)\n\ndata Country = India | France | USA\n  deriving stock (Generic)\n  deriving (Show)\n  deriving anyclass (FromJSON, ToJSON, ToSchema)\n\ndata AutoCompleteReq = AutoCompleteReq\n  { input :: Text,\n    sessionToken :: Maybe Text,\n    location :: Text,\n    radius :: Integer,\n    radiusWithUnit :: Maybe Distance,\n    language :: Language,\n    strictbounds :: Maybe Bool,\n    origin :: Maybe LatLong,\n    types_ :: Maybe Text,\n    country :: Country\n  }\n  deriving stock (Generic)\n  deriving (Show)\n  deriving anyclass (FromJSON, ToJSON, ToSchema)\n\nnewtype AutoCompleteResp = AutoCompleteResp\n  { predictions :: [Prediction]\n  }\n  deriving (Generic, ToJSON, FromJSON, ToSchema)\n\ndata Prediction = Prediction\n  { description :: Text,\n    placeId :: Maybe Text,\n    distance :: Maybe Int,\n    distanceWithUnit :: Maybe Distance,\n    types :: Maybe [Text]\n  }\n  deriving (Generic, ToJSON, FromJSON, ToSchema)\n\ndata GetPlaceDetailsReq = GetPlaceDetailsReq\n  { placeId :: Text,\n    sessionToken :: Maybe Text\n  }\n  deriving stock (Generic)\n  deriving anyclass (FromJSON, ToJSON, ToSchema)\n\nnewtype GetPlaceDetailsResp = GetPlaceDetailsResp\n  { location :: LatLong\n  }\n  deriving (Generic, ToJSON, FromJSON, ToSchema)\n\ndata GetPlaceNameBy = ByLatLong LatLong | ByPlaceId Text\n  deriving stock (Generic)\n  deriving anyclass (FromJSON, ToJSON, ToSchema)\n\ndata GetPlaceNameReq = GetPlaceNameReq\n  { getBy :: GetPlaceNameBy,\n    sessionToken :: Maybe Text,\n    language :: Maybe Language\n  }\n  deriving stock (Generic)\n  deriving anyclass (FromJSON, ToJSON, ToSchema)\n\ntype GetPlaceNameResp = [PlaceName]\n\ndata PlaceName = PlaceName\n  { formattedAddress :: Maybe Text,\n    addressComponents :: [AddressResp],\n    plusCode :: Maybe Text,\n    location :: LatLong,\n    placeId :: Maybe Text,\n    source :: Maybe Text\n  }\n  deriving stock (Generic)\n  deriving anyclass (ToJSON, FromJSON, ToSchema)\n\ndata AddressResp = AddressResp\n  { longName :: Text,\n    shortName :: Text,\n    types :: [Text]\n  }\n  deriving stock (Generic)\n  deriving anyclass (ToJSON, FromJSON, ToSchema)\n",
      "hash": "120778b4ce66db41ec2c0b043549601515e634214be2ad3bb720c09a897947d7",
      "size": 8760
    },
    "/lib/mobility-core/src/Kernel/External/Maps/MMI/AutoSuggest.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n{-# LANGUAGE TypeApplications #-}\n\nmodule Kernel.External.Maps.MMI.AutoSuggest where\n\nimport Data.Maybe\nimport EulerHS.Prelude\nimport EulerHS.Types as ET\nimport Kernel.External.Maps.Interface.Types as IT\nimport qualified Kernel.External.Maps.MMI.Types as MMI\nimport Kernel.External.Types (Language)\nimport Kernel.Storage.Hedis as Redis\nimport Kernel.Streaming.Kafka.Producer.Types (HasKafkaProducer)\nimport Kernel.Tools.Metrics.CoreMetrics (CoreMetrics)\nimport Kernel.Types.Common\nimport Kernel.Types.Error\nimport Kernel.Utils.Common\nimport qualified Kernel.Utils.ExternalAPICallLogging as ApiCallLogger\nimport qualified Kernel.Utils.Text as KUT\nimport Servant\n\ntype MMIAutoSuggestAPI =\n  \"api\" :> \"places\" :> \"search\" :> \"json\"\n    :> Header \"Authorization\" MMI.MMIAuthToken\n    :> MandatoryQueryParam \"query\" Text\n    :> MandatoryQueryParam \"location\" Text\n    :> MandatoryQueryParam \"region\" Text\n    :> MandatoryQueryParam \"responseLang\" Language\n    :> Get '[JSON] MMI.AutoSuggestResp\n\nmmiAutoSuggestAPI :: Proxy MMIAutoSuggestAPI\nmmiAutoSuggestAPI = Proxy\n\nmmiAutoSuggestClient :: Maybe MMI.MMIAuthToken -> Text -> Text -> Text -> Language -> ET.EulerClient MMI.AutoSuggestResp\nmmiAutoSuggestClient = ET.client mmiAutoSuggestAPI\n\nmmiAutoSuggest ::\n  ( CoreMetrics m,\n    Redis.HedisFlow m r,\n    MonadFlow m,\n    HasKafkaProducer r\n  ) =>\n  Maybe Text ->\n  IT.AutoCompleteReq ->\n  BaseUrl ->\n  Maybe MMI.MMIAuthToken ->\n  Text ->\n  Text ->\n  Text ->\n  Language ->\n  m MMI.AutoSuggestResp\nmmiAutoSuggest entityId req url authToken query location region lang = do\n  rsp <-\n    callMMIAutoSuggestAPI\n      url\n      (mmiAutoSuggestClient authToken query location region lang)\n      \"mmi-auto-suggest\"\n      mmiAutoSuggestAPI\n  fork (\"Logging external API Call of autoSuggest MMI \") $\n    ApiCallLogger.pushExternalApiCallDataToKafkaWithTextEncodedResp \"autoSuggest\" \"MMI\" entityId (Just req) $ KUT.encodeToText rsp\n  return rsp\n\ncallMMIAutoSuggestAPI :: CallAPI env api a\ncallMMIAutoSuggestAPI =\n  callApiUnwrappingApiError\n    (identity @MMIError)\n    Nothing\n    (Just \"MMI_AUTO_SUGGEST_ERROR\")\n    Nothing\n",
      "hash": "09f34758aed65bcdd046a0e1482496c2cfd619338309c71b1f63828192972bc0",
      "size": 2805
    },
    "/lib/mobility-core/src/Kernel/External/Maps/MMI/Config.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n\nmodule Kernel.External.Maps.MMI.Config where\n\nimport Kernel.External.Encryption\nimport Kernel.Prelude\n\n-- | MMI Service config\ndata MMICfg = MMICfg\n  { mmiAuthUrl :: BaseUrl,\n    mmiAuthId :: Text,\n    mmiAuthSecret :: EncryptedField 'AsEncrypted Text,\n    mmiApiKey :: EncryptedField 'AsEncrypted Text,\n    mmiKeyUrl :: BaseUrl,\n    mmiNonKeyUrl :: BaseUrl,\n    mmiAutocompleteParams :: Maybe Text\n  }\n  deriving (Show, Eq, Generic, FromJSON, ToJSON)\n",
      "hash": "57d24e17ae5cdb55d3bc691367d24d661fbda074327004149d907b5d96d56b04",
      "size": 1146
    },
    "/lib/mobility-core/src/Kernel/External/Maps/MMI/DistanceMatrix.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n\nmodule Kernel.External.Maps.MMI.DistanceMatrix where\n\nimport Data.Maybe\nimport EulerHS.Prelude\nimport qualified EulerHS.Types as ET\nimport Kernel.External.Encryption\nimport Kernel.External.Maps.Interface.Types as IT\nimport qualified Kernel.External.Maps.MMI.Types as MMI\nimport Kernel.Streaming.Kafka.Producer.Types (HasKafkaProducer)\nimport Kernel.Tools.Metrics.CoreMetrics (CoreMetrics)\nimport Kernel.Types.Common\nimport Kernel.Types.Error\nimport Kernel.Utils.Common\nimport qualified Kernel.Utils.ExternalAPICallLogging as ApiCallLogger\nimport qualified Kernel.Utils.Text as KUT\nimport Servant hiding (throwError)\n\ntype MMIDistanceMatrixAPI =\n  \"advancedmaps\" :> \"v1\"\n    :> Capture \"Authorization\" Text\n    :> \"distance_matrix\"\n    :> \"driving\"\n    :> Capture \"coordinates\" Text\n    :> QueryParam \"rtype\" Integer\n    :> QueryParam \"region\" Text\n    :> QueryParam \"sources\" Text\n    :> QueryParam \"destinations\" Text\n    :> Get '[JSON] MMI.DistanceMatrixResp\n\nmmiDistanceMatrixAPI :: Proxy MMIDistanceMatrixAPI\nmmiDistanceMatrixAPI = Proxy\n\ngetDistanceMatrixClient :: Text -> Text -> Maybe Integer -> Maybe Text -> Maybe Text -> Maybe Text -> ET.EulerClient MMI.DistanceMatrixResp\ngetDistanceMatrixClient = ET.client mmiDistanceMatrixAPI\n\nmmiDistanceMatrix ::\n  ( EncFlow m r,\n    CoreMetrics m,\n    MonadFlow m,\n    ToJSON a,\n    ToJSON b,\n    HasKafkaProducer r\n  ) =>\n  Maybe Text ->\n  IT.GetDistancesReq a b ->\n  BaseUrl ->\n  Text ->\n  Text ->\n  Maybe Text ->\n  Maybe Text ->\n  m MMI.DistanceMatrixResp\nmmiDistanceMatrix entityId req url apiKey points srcList destList = do\n  rsp <-\n    callMMIAPI\n      url\n      (getDistanceMatrixClient apiKey points (Just 0) (Just \"ind\") srcList destList)\n      \"mmi-distance-matrix\"\n      mmiDistanceMatrixAPI\n  fork (\"Logging external API Call of mmiDistanceMatrix MMI \") $\n    ApiCallLogger.pushExternalApiCallDataToKafkaWithTextEncodedResp \"mmiDistanceMatrix\" \"MMI\" entityId (Just req) $ KUT.encodeToText rsp\n  return rsp\n\ncallMMIAPI :: CallAPI env api a\ncallMMIAPI =\n  callApiUnwrappingApiError\n    (identity @MMIError)\n    Nothing\n    (Just \"MMI_NOT_AVAILABLE\")\n    Nothing\n",
      "hash": "8b5d995556fd40ee89523308ac7ad0e9382d4d1ec1eb229d09634227d32768bf",
      "size": 2817
    },
    "/lib/mobility-core/src/Kernel/External/Maps/MMI/Geocode.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n{-# LANGUAGE TypeApplications #-}\n\nmodule Kernel.External.Maps.MMI.Geocode where\n\nimport Data.Maybe\nimport EulerHS.Prelude\nimport EulerHS.Types as ET\nimport Kernel.External.Maps.Interface.Types as IT\nimport qualified Kernel.External.Maps.MMI.Types as MMI\nimport Kernel.Storage.Hedis as Redis\nimport Kernel.Streaming.Kafka.Producer.Types (HasKafkaProducer)\nimport Kernel.Tools.Metrics.CoreMetrics (CoreMetrics)\nimport Kernel.Types.Common\nimport Kernel.Types.Error\nimport Kernel.Utils.Common\nimport qualified Kernel.Utils.ExternalAPICallLogging as ApiCallLogger\nimport qualified Kernel.Utils.Text as KUT\nimport Servant\n\ntype MMIGeocodeAPI =\n  \"api\" :> \"places\" :> \"geocode\"\n    :> Header \"Authorization\" MMI.MMIAuthToken\n    :> MandatoryQueryParam \"address\" Text\n    -- :> QueryParam \"itemCount\" Int     -- Uncomment if array of response is expected in copResults of geocode response\n    :> QueryParam \"region\" Text\n    :> Get '[JSON] MMI.GeocodeResp\n\nmmiGeocodeAPI :: Proxy MMIGeocodeAPI\nmmiGeocodeAPI = Proxy\n\nmmiGeocodeClient :: Maybe MMI.MMIAuthToken -> Text -> Maybe Text -> ET.EulerClient MMI.GeocodeResp\nmmiGeocodeClient = ET.client mmiGeocodeAPI\n\nmmiGeoCode ::\n  ( CoreMetrics m,\n    Redis.HedisFlow m r,\n    MonadFlow m,\n    HasKafkaProducer r\n  ) =>\n  Maybe Text ->\n  IT.GetPlaceNameReq ->\n  BaseUrl ->\n  Maybe MMI.MMIAuthToken ->\n  Text ->\n  m MMI.GeocodeResp\nmmiGeoCode entityId req url authToken address = do\n  rsp <-\n    callMMIGeocodeAPI\n      url\n      (mmiGeocodeClient authToken address (Just \"ind\"))\n      \"mmi-auto-suggest\"\n      mmiGeocodeAPI\n  fork (\"Logging external API Call of mmiGeoCode MMI \") $\n    ApiCallLogger.pushExternalApiCallDataToKafkaWithTextEncodedResp \"mmiGeoCode\" \"MMI\" entityId (Just req) $ KUT.encodeToText rsp\n  return rsp\n\ncallMMIGeocodeAPI :: CallAPI env api a\ncallMMIGeocodeAPI =\n  callApiUnwrappingApiError\n    (identity @MMIError)\n    Nothing\n    (Just \"MMI_GEOCODE_ERROR\")\n    Nothing\n",
      "hash": "2d9b48a9f6a6beff72d97a7266f46e5cdc9bc169660611c7499c0caa68147e34",
      "size": 2624
    },
    "/lib/mobility-core/src/Kernel/External/Maps/MMI/MMIAuthToken.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n{-# LANGUAGE OverloadedStrings #-}\n{-# LANGUAGE ScopedTypeVariables #-}\n{-# LANGUAGE TypeApplications #-}\n\nmodule Kernel.External.Maps.MMI.MMIAuthToken where\n\nimport Data.Maybe\nimport EulerHS.Prelude\nimport qualified EulerHS.Types as ET\nimport Kernel.External.Encryption\nimport Kernel.External.Maps.MMI.Config\nimport qualified Kernel.External.Maps.MMI.Types as MMI\nimport Kernel.Storage.Hedis as Redis\nimport Kernel.Streaming.Kafka.Producer.Types (HasKafkaProducer)\nimport Kernel.Tools.Metrics.CoreMetrics (CoreMetrics)\nimport Kernel.Types.Common\nimport Kernel.Types.Error as ER\nimport Kernel.Utils.Common\nimport qualified Kernel.Utils.ExternalAPICallLogging as ApiCallLogger\nimport qualified Kernel.Utils.Text as KUT\nimport Servant hiding (throwError)\n\ntype MMIAuthAPI =\n  ReqBody '[FormUrlEncoded] MMI.AuthRequest\n    :> Post '[JSON] MMI.AuthResp\n\ndata AccessToken = AccessToken\n  { mmiAccessToken :: !Text,\n    mmiTokenType :: !Text\n  }\n  deriving (Show, Generic, FromJSON, ToJSON)\n\nmmiAuthAPI :: Proxy MMIAuthAPI\nmmiAuthAPI = Proxy\n\nmmiAuthToken ::\n  ( EncFlow m r,\n    CoreMetrics m,\n    Redis.HedisFlow m r,\n    MonadFlow m,\n    HasKafkaProducer r\n  ) =>\n  Maybe Text ->\n  MMICfg ->\n  m MMI.AuthResp\nmmiAuthToken entityId mmiCfg = do\n  secretKey <- decrypt mmiCfg.mmiAuthSecret\n  let url = mmiCfg.mmiAuthUrl\n      clientId = mmiCfg.mmiAuthId\n      grantType = \"client_credentials\"\n      authReq = MMI.AuthRequest grantType clientId secretKey\n  rsp <-\n    callMMIAPI\n      url\n      (callMMIAuth authReq)\n      \"mmi-auto-suggest\"\n      mmiAuthAPI\n  fork (\"Logging external API Call of mmiAuthToken MMI \") $\n    ApiCallLogger.pushExternalApiCallDataToKafkaWithTextEncodedResp \"mmiAuthToken\" \"MMI\" entityId (Nothing @(Maybe Value)) $ KUT.encodeToText rsp\n  return rsp\n  where\n    callMMIAuth authReq = ET.client mmiAuthAPI authReq\n\ncallMMIAPI :: CallAPI env api a\ncallMMIAPI =\n  callApiUnwrappingApiError\n    (identity @MMIError)\n    Nothing\n    (Just \"MMI_AUTH_ERROR\")\n    Nothing\n\nredisMMIKey :: Text\nredisMMIKey = \"Core:mmi_token\"\n\n-- | Get MMI token\ngetMMIToken ::\n  ( EncFlow m r,\n    CoreMetrics m,\n    Redis.HedisFlow m r,\n    MonadFlow m,\n    HasKafkaProducer r\n  ) =>\n  Maybe Text ->\n  MMICfg ->\n  m AccessToken\ngetMMIToken entityId config = do\n  tokenStatus :: Maybe AccessToken <- Redis.get (config.mmiAuthId <> \":\" <> redisMMIKey)\n  case tokenStatus of\n    Nothing -> refreshToken entityId config\n    Just token -> pure token\n\ngetTokenText ::\n  ( EncFlow m r,\n    CoreMetrics m,\n    Redis.HedisFlow m r,\n    MonadFlow m,\n    HasKafkaProducer r\n  ) =>\n  Maybe Text ->\n  MMICfg ->\n  m Text\ngetTokenText entityId mfg = do\n  token <- getMMIToken entityId mfg\n  pure $ mmiTokenType token <> \" \" <> mmiAccessToken token\n\nrefreshToken ::\n  ( EncFlow m r,\n    CoreMetrics m,\n    Redis.HedisFlow m r,\n    MonadFlow m,\n    HasKafkaProducer r\n  ) =>\n  Maybe Text ->\n  MMICfg ->\n  m AccessToken\nrefreshToken entityId config = do\n  res <- mmiAuthToken entityId config\n  let accessToken =\n        AccessToken\n          { mmiAccessToken = res.accessToken,\n            mmiTokenType = res.tokenType\n          }\n  Redis.set (config.mmiAuthId <> \":\" <> redisMMIKey) accessToken\n  pure accessToken\n",
      "hash": "5d907fb23b6f12e5f1bb0eb70f6f13f916cbf7ce405642e4aa05c1be03dd0f6d",
      "size": 3886
    },
    "/lib/mobility-core/src/Kernel/External/Maps/MMI/PlaceDetails.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n\nmodule Kernel.External.Maps.MMI.PlaceDetails where\n\nimport Data.Maybe\nimport EulerHS.Prelude\nimport qualified EulerHS.Types as ET\nimport Kernel.External.Encryption\nimport Kernel.External.Maps.Interface.Types as IT\nimport qualified Kernel.External.Maps.MMI.Types as MMI\nimport Kernel.Streaming.Kafka.Producer.Types (HasKafkaProducer)\nimport Kernel.Tools.Metrics.CoreMetrics (CoreMetrics)\nimport Kernel.Types.Common\nimport Kernel.Types.Error\nimport Kernel.Utils.Common\nimport qualified Kernel.Utils.ExternalAPICallLogging as ApiCallLogger\nimport qualified Kernel.Utils.Text as KUT\nimport Servant hiding (throwError)\n\ntype MMIPlaceDetails =\n  \"advancedmaps\" :> \"v1\"\n    :> Capture \"Authorization\" Text\n    :> \"place_detail\"\n    :> MandatoryQueryParam \"place_id\" Text\n    :> Get '[JSON] MMI.PlaceDetailResponse\n\nmmiPlaceDetailsAPI :: Proxy MMIPlaceDetails\nmmiPlaceDetailsAPI = Proxy\n\ngetPlaceDetailsClient :: Text -> Text -> ET.EulerClient MMI.PlaceDetailResponse\ngetPlaceDetailsClient = ET.client mmiPlaceDetailsAPI\n\nmmiPlaceDetails ::\n  ( EncFlow m r,\n    CoreMetrics m,\n    MonadFlow m,\n    HasKafkaProducer r\n  ) =>\n  Maybe Text ->\n  IT.GetPlaceDetailsReq ->\n  BaseUrl ->\n  Text ->\n  Text ->\n  m MMI.PlaceDetailResponse\nmmiPlaceDetails entityId req url apiKey placeId = do\n  rsp <-\n    callMMIAPI\n      url\n      (getPlaceDetailsClient apiKey placeId)\n      \"mmi-get-place-details\"\n      mmiPlaceDetailsAPI\n  fork (\"Logging external API Call of mmiPlaceDetails MMI \") $\n    ApiCallLogger.pushExternalApiCallDataToKafkaWithTextEncodedResp \"mmiPlaceDetails\" \"MMI\" entityId (Just req) $ KUT.encodeToText rsp\n  return rsp\n\ncallMMIAPI :: CallAPI env api a\ncallMMIAPI =\n  callApiUnwrappingApiError\n    (identity @MMIError)\n    Nothing\n    (Just \"MMI_NOT_AVAILABLE\")\n    Nothing\n",
      "hash": "a2545fe1df433e532616b9437a1d64a8560afdba57e6fd34b433a61b29d04f34",
      "size": 2466
    },
    "/lib/mobility-core/src/Kernel/External/Maps/MMI/ReverseGeocoding.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n\nmodule Kernel.External.Maps.MMI.ReverseGeocoding where\n\nimport EulerHS.Prelude\nimport qualified EulerHS.Types as ET\nimport Kernel.External.Encryption\nimport qualified Kernel.External.Maps.MMI.Types as MMI\nimport Kernel.External.Maps.Types\nimport Kernel.External.Types\nimport Kernel.Streaming.Kafka.Producer.Types (HasKafkaProducer)\nimport Kernel.Tools.Metrics.CoreMetrics (CoreMetrics)\nimport Kernel.Types.Common\nimport Kernel.Types.Error\nimport Kernel.Utils.Common\nimport qualified Kernel.Utils.ExternalAPICallLogging as ApiCallLogger\nimport qualified Kernel.Utils.Text as KUT\nimport Servant\n\ntype MMIReverseGeocodeAPI =\n  \"advancedmaps\" :> \"v1\"\n    :> Capture \"Authorization\" Text\n    :> \"rev_geocode\"\n    :> MandatoryQueryParam \"lat\" Double\n    :> MandatoryQueryParam \"lng\" Double\n    :> QueryParam \"region\" Text\n    :> QueryParam \"lang\" Language\n    :> Get '[JSON] MMI.ReverseGeocodeResp\n\nmmiReverseGeocodeAPI :: Proxy MMIReverseGeocodeAPI\nmmiReverseGeocodeAPI = Proxy\n\ngetReverseGeocodeClient :: Text -> Double -> Double -> Maybe Text -> Maybe Language -> ET.EulerClient MMI.ReverseGeocodeResp\ngetReverseGeocodeClient = ET.client mmiReverseGeocodeAPI\n\nmmiReverseGeocode ::\n  ( EncFlow m r,\n    CoreMetrics m,\n    MonadFlow m,\n    HasKafkaProducer r\n  ) =>\n  Maybe Text ->\n  MMI.ReverseGeocodeReq ->\n  BaseUrl ->\n  Text ->\n  LatLong ->\n  Maybe Text ->\n  Maybe Language ->\n  m MMI.ReverseGeocodeResp\nmmiReverseGeocode entityId req url apiKey LatLong {..} region lang = do\n  rsp <-\n    callMMIAPI\n      url\n      (getReverseGeocodeClient apiKey lat lon region lang)\n      \"mmi-reverse-geocode\"\n      mmiReverseGeocodeAPI\n  fork (\"Logging external API Call of mmiReverseGeocode MMI \") $\n    ApiCallLogger.pushExternalApiCallDataToKafkaWithTextEncodedResp \"mmiReverseGeocode\" \"MMI\" entityId (Just req) $ KUT.encodeToText rsp\n  return rsp\n\ncallMMIAPI :: CallAPI env api a\ncallMMIAPI =\n  callApiUnwrappingApiError\n    (identity @MMIError)\n    Nothing\n    (Just \"MMI_NOT_AVAILABLE\")\n    Nothing\n",
      "hash": "061424f60dcda1265b7fe5e7fd3956378773eaa13c9c180b218a3c2a8aa13929",
      "size": 2686
    },
    "/lib/mobility-core/src/Kernel/External/Maps/MMI/Routes.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n\nmodule Kernel.External.Maps.MMI.Routes where\n\nimport Data.Maybe\nimport EulerHS.Prelude\nimport qualified EulerHS.Types as ET\nimport Kernel.External.Encryption\nimport Kernel.External.Maps.Interface.Types as IT\nimport qualified Kernel.External.Maps.MMI.Types as MMI\nimport Kernel.Streaming.Kafka.Producer.Types (HasKafkaProducer)\nimport Kernel.Tools.Metrics.CoreMetrics (CoreMetrics)\nimport Kernel.Types.Common\nimport Kernel.Types.Error\nimport Kernel.Utils.Common\nimport qualified Kernel.Utils.ExternalAPICallLogging as ApiCallLogger\nimport qualified Kernel.Utils.Text as KUT\nimport Servant hiding (throwError)\n\ntype MMIRouteAPI =\n  \"advancedmaps\" :> \"v1\"\n    :> Capture \"Authorization\" Text\n    :> \"route_traffic\"\n    :> \"driving\"\n    :> Capture \"cordinates\" Text\n    :> QueryParam \"steps\" Bool\n    :> QueryParam \"region\" Text\n    :> QueryParam \"overview\" Text\n    :> QueryParam \"alternatives\" Int\n    :> Get '[JSON] MMI.RouteResponse\n\nmmiRouteAPI :: Proxy MMIRouteAPI\nmmiRouteAPI = Proxy\n\ngetRouteClient :: Text -> Text -> Maybe Bool -> Maybe Text -> Maybe Text -> Maybe Int -> ET.EulerClient MMI.RouteResponse\ngetRouteClient = ET.client mmiRouteAPI\n\nmmiRoute ::\n  ( EncFlow m r,\n    CoreMetrics m,\n    MonadFlow m,\n    HasKafkaProducer r\n  ) =>\n  Maybe Text ->\n  IT.GetRoutesReq ->\n  BaseUrl ->\n  Text ->\n  Text ->\n  m MMI.RouteResponse\nmmiRoute entityId req url apiKey points = do\n  rsp <-\n    callMMIAPI\n      url\n      (getRouteClient apiKey points (Just True) (Just \"ind\") (Just \"full\") (Just 3))\n      \"mmi-route\"\n      mmiRouteAPI\n  fork (\"Logging external API Call of mmiRoute MMI \") $\n    ApiCallLogger.pushExternalApiCallDataToKafkaWithTextEncodedResp \"mmiRoute\" \"MMI\" entityId (Just req) $ KUT.encodeToText rsp\n  return rsp\n\ncallMMIAPI :: CallAPI env api a\ncallMMIAPI =\n  callApiUnwrappingApiError\n    (identity @MMIError)\n    Nothing\n    (Just \"MMI_NOT_AVAILABLE\")\n    Nothing\n",
      "hash": "7f2fb0054e98ab0e0de73e75824ae1f0afd46f70146d95de2d122eeafeb2d6df",
      "size": 2582
    },
    "/lib/mobility-core/src/Kernel/External/Maps/MMI/SnapToRoad.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n\nmodule Kernel.External.Maps.MMI.SnapToRoad where\n\nimport Data.Maybe\nimport EulerHS.Prelude\nimport qualified EulerHS.Types as ET\nimport Kernel.External.Encryption\nimport Kernel.External.Maps.Interface.Types as IT\nimport qualified Kernel.External.Maps.MMI.Types as MMI\nimport Kernel.Streaming.Kafka.Producer.Types (HasKafkaProducer)\nimport Kernel.Tools.Metrics.CoreMetrics (CoreMetrics)\nimport Kernel.Types.Common\nimport Kernel.Types.Error\nimport Kernel.Utils.Common\nimport qualified Kernel.Utils.ExternalAPICallLogging as ApiCallLogger\nimport qualified Kernel.Utils.Text as KUT\nimport Servant hiding (throwError)\n\ntype MMISnapToRoadAPI =\n  \"advancedmaps\" :> \"v1\"\n    :> Capture \"Authorization\" Text\n    :> \"snapToRoad\"\n    :> MandatoryQueryParam \"pts\" Text\n    :> QueryParam \"timestamps\" Text\n    :> QueryParam \"geometries\" Text\n    :> QueryParam \"radiuses\" Text\n    :> QueryParam \"region\" Text\n    :> Get '[JSON] MMI.SnapToRoadResp\n\nmmiSnapToRoadAPI :: Proxy MMISnapToRoadAPI\nmmiSnapToRoadAPI = Proxy\n\ngetSnapToRoadClient :: Text -> Text -> Maybe Text -> Maybe Text -> Maybe Text -> Maybe Text -> ET.EulerClient MMI.SnapToRoadResp\ngetSnapToRoadClient = ET.client mmiSnapToRoadAPI\n\ncallMMIAPI :: CallAPI env api a\ncallMMIAPI =\n  callApiUnwrappingApiError\n    (identity @MMIError)\n    Nothing\n    (Just \"MMI_NOT_AVAILABLE\")\n    Nothing\n\nmmiSnapToRoad ::\n  ( EncFlow m r,\n    CoreMetrics m,\n    MonadFlow m,\n    HasKafkaProducer r\n  ) =>\n  Maybe Text ->\n  IT.SnapToRoadReq ->\n  BaseUrl ->\n  Text ->\n  Text ->\n  m MMI.SnapToRoadResp\nmmiSnapToRoad entityId req url apiKey points = do\n  rsp <-\n    callMMIAPI\n      url\n      (getSnapToRoadClient apiKey points Nothing Nothing Nothing (Just \"ind\"))\n      \"mmi-snap-to-road\"\n      mmiSnapToRoadAPI\n  fork (\"Logging external API Call of mmiSnapToRoad MMI \") $\n    ApiCallLogger.pushExternalApiCallDataToKafkaWithTextEncodedResp \"mmiSnapToRoad\" \"MMI\" entityId (Just req) $ KUT.encodeToText rsp\n  return rsp\n",
      "hash": "aae2893a97f3e1f83ca2ce07d56f9ffe4b0672e95b58991ea63b0f37df55527c",
      "size": 2641
    },
    "/lib/mobility-core/src/Kernel/External/Maps/MMI/Types.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n{-# LANGUAGE DeriveDataTypeable #-}\n{-# LANGUAGE DeriveGeneric #-}\n{-# LANGUAGE DerivingVia #-}\n{-# LANGUAGE GeneralizedNewtypeDeriving #-}\n{-# LANGUAGE OverloadedLists #-}\n{-# LANGUAGE OverloadedStrings #-}\n{-# LANGUAGE ScopedTypeVariables #-}\n{-# LANGUAGE StandaloneDeriving #-}\n{-# LANGUAGE TemplateHaskell #-}\n{-# LANGUAGE UndecidableInstances #-}\n\nmodule Kernel.External.Maps.MMI.Types where\n\nimport Data.Aeson\nimport qualified Data.Text as T\nimport qualified Data.Vector as V\nimport EulerHS.Prelude ((...))\nimport qualified Kernel.External.Maps.Google.PolyLinePoints as PP\nimport qualified Kernel.External.Maps.Types as Maps\nimport Kernel.External.Types\nimport Kernel.Prelude\nimport Kernel.Types.Common (HighPrecMeters)\nimport Kernel.Utils.GenericPretty\nimport Kernel.Utils.JSON (constructorsWithSnakeCase, stripPrefixUnderscoreIfAny)\nimport Kernel.Utils.TH\nimport Web.FormUrlEncoded (ToForm, toForm)\nimport Web.Internal.HttpApiData\n\ndata AuthRequest = AuthRequest\n  { grant_type :: Text,\n    client_id :: Text,\n    client_secret :: Text\n  }\n  deriving (Generic, Eq, Show)\n\ninstance ToForm AuthRequest where\n  toForm AuthRequest {..} =\n    [ (\"grant_type\", toQueryParam grant_type),\n      (\"client_id\", toQueryParam client_id),\n      (\"client_secret\", toQueryParam client_secret)\n    ]\n\ndata AuthResp = AuthResp\n  { accessToken :: Text,\n    tokenType :: Text,\n    expiresIn :: Int,\n    scope :: Text,\n    projectCode :: Text,\n    clientId :: Text\n  }\n  deriving (Generic)\n\ninstance FromJSON AuthResp where\n  parseJSON = genericParseJSON constructorsWithSnakeCase\n\ninstance ToJSON AuthResp where\n  toJSON = genericToJSON constructorsWithSnakeCase\n\nnewtype MMIAuthToken = MMIAuthToken\n  { getMMIAuthToken :: Text\n  }\n  deriving (Show)\n  deriving newtype (PrettyShow)\n\nderiveIdentifierInstances ''MMIAuthToken\n\ndata AutoSuggestResp = AutoSuggestResp\n  { suggestedLocations :: [SuggestedLocations],\n    userAddedLocations :: [UserAddedLocation],\n    suggestedSearches :: [SuggestedSearches]\n  }\n  deriving (Generic, FromJSON, ToJSON)\n\ndata SuggestedLocations = SuggestedLocations\n  { eLoc :: Text, -- place id in MMI\n    placeName :: Text,\n    placeAddress :: Text\n  }\n  deriving (Generic, FromJSON, ToJSON)\n\ndata UserAddedLocation = UserAddedLocation\n  { eLoc :: Text,\n    orderIndex :: Int,\n    placeAddress :: Text,\n    placeName :: Text\n  }\n  deriving (Generic, FromJSON, ToJSON)\n\ndata SuggestedSearches = SuggestedSearches\n  { keyword :: Text,\n    identifier :: Text,\n    location :: Text,\n    hyperlink :: Text,\n    orderIndex :: Int,\n    eLoc :: Text\n  }\n  deriving (Generic, FromJSON, ToJSON)\n\nnewtype LatLongList = LatLongList {getLatLongList :: [Maps.LatLong]}\n\ninstance ToHttpApiData LatLongList where\n  toUrlPiece (LatLongList lst) = T.intercalate \";\" $ map convertPoint lst\n\nconvertPoint :: Maps.LatLong -> Text\nconvertPoint (Maps.LatLong lat lon) = show lon <> \",\" <> show lat\n\ndata DistanceMatrixResp = DistanceMatrixResp\n  { version :: Text,\n    results :: DistanceMatrixResult,\n    responseCode :: Int\n  }\n  deriving (Generic, FromJSON, ToJSON)\n\ndata DistanceMatrixResult = DistanceMatrixResult\n  { code :: Text,\n    distances :: [[Double]],\n    durations :: [[Double]]\n  }\n  deriving (Generic, FromJSON, ToJSON)\n\ndata DistanceMatrixElement = DistanceMatrixElement\n  { distance :: Maybe TextValue,\n    duration :: Maybe TextValue,\n    status :: Text\n  }\n  deriving (Generic, ToJSON, FromJSON)\n\ndata TextValue = TextValue\n  { text :: Text,\n    value :: Int\n  }\n  deriving (Generic, ToJSON, FromJSON, ToSchema)\n\ndata RouteResponse = RouteResponse\n  { code :: Text,\n    routes :: [Routes],\n    waypoints :: [WayPoints]\n  }\n  deriving (Generic, FromJSON, ToJSON)\n\ndata PlaceDetailResponse = PlaceDetailResponse\n  { responseCode :: Int,\n    version :: Text,\n    results :: NonEmpty PlaceDetail\n  }\n  deriving (Generic, FromJSON, ToJSON)\n\ndata PlaceDetail = PlaceDetail\n  { longitude :: Double,\n    latitude :: Double\n  }\n  deriving (Generic, FromJSON, ToJSON)\n\ndata Routes = Routes\n  { legs :: [Legs],\n    weight_name :: Text,\n    geometry :: PP.PolyLinePoints,\n    weight :: Double,\n    distance :: Double,\n    duration :: Double\n  }\n  deriving (Generic, FromJSON, ToJSON)\n\ndata Legs = Legs\n  { steps :: [Steps],\n    weight :: Double,\n    distance :: Double,\n    summary :: Text,\n    duration :: Double\n  }\n  deriving (Generic, FromJSON, ToJSON)\n\ndata Steps = Steps\n  { intersections :: [Intersections],\n    driving_side :: Text,\n    mode :: Text,\n    maneuver :: Maneuver,\n    distance :: Double,\n    duration :: Double,\n    geometry :: PP.PolyLinePoints,\n    name :: Text\n  }\n  deriving (Generic)\n\ninstance FromJSON Steps where\n  parseJSON = genericParseJSON stripPrefixUnderscoreIfAny\n\ninstance ToJSON Steps where\n  toJSON = genericToJSON stripPrefixUnderscoreIfAny\n\ndata Maneuver = Maneuver\n  { location :: LngLat,\n    bearing_before :: Int,\n    bearing_after :: Int,\n    modifier :: Text,\n    _type :: Text\n  }\n  deriving (Generic)\n\ninstance FromJSON Maneuver where\n  parseJSON = genericParseJSON stripPrefixUnderscoreIfAny\n\ninstance ToJSON Maneuver where\n  toJSON = genericToJSON stripPrefixUnderscoreIfAny\n\ndata WayPoints = WayPoints\n  { hint :: Text,\n    location :: LngLat,\n    name :: Text\n  }\n  deriving (Generic, FromJSON, ToJSON)\n\ndata Intersections = Intersections\n  { location :: LngLat,\n    bearings :: [Int],\n    entry :: [Bool]\n  }\n  deriving (Generic)\n\ninstance FromJSON Intersections where\n  parseJSON = genericParseJSON stripPrefixUnderscoreIfAny\n\ninstance ToJSON Intersections where\n  toJSON = genericToJSON stripPrefixUnderscoreIfAny\n\nnewtype LngLat = LngLat {getLatLong :: Maps.LatLong}\n  deriving stock (Generic, Show, Eq)\n  deriving (PrettyShow) via (Showable LngLat)\n\ninstance FromJSON LngLat where\n  parseJSON = withArray \"array [lon, lat]\" $ \\arr_ -> case toList arr_ of\n    [lon, lat] -> LngLat ... Maps.LatLong <$> parseJSON lat <*> parseJSON lon\n    _ -> fail \"expected array [lon, lat]\"\n\ninstance ToJSON LngLat where\n  toJSON (LngLat Maps.LatLong {..}) = Array $ V.fromList $ map toJSON [lon, lat]\n\ndata SnapToRoadResp = SnapToRoadResp\n  { responseCode :: Int,\n    version :: Text,\n    results :: SnapToRoadResult\n  }\n  deriving (Generic, FromJSON, ToJSON, Show)\n\ndata SnapToRoadResult = SnapToRoadResult\n  { snappedPoints :: [Maybe SnappedPoint],\n    matchings :: Maybe [Matching]\n  }\n  deriving (Generic, FromJSON, ToJSON, Show)\n\ndata SnappedPoint = SnappedPoint\n  { location :: LngLat,\n    distance :: HighPrecMeters,\n    waypoint_index :: Int\n  }\n  deriving (Generic, FromJSON, ToJSON, Show)\n\nnewtype Matching = Matching\n  { geometry :: String\n  }\n  deriving (Generic, Show)\n  deriving anyclass (FromJSON, ToJSON)\n\ndata ReverseGeocodeResp = ReverseGeocodeResp\n  { responseCode :: Int,\n    version :: Text,\n    results :: [PlaceInfo]\n  }\n  deriving (Generic, ToJSON, FromJSON, ToSchema)\n\ndata PlaceInfo = PlaceInfo\n  { houseNumber :: Maybe Text,\n    houseName :: Maybe Text,\n    poi :: Maybe Text,\n    poi_dist :: Maybe Text,\n    street :: Maybe Text,\n    street_dist :: Maybe Text,\n    subSubLocality :: Maybe Text,\n    subLocality :: Maybe Text,\n    locality :: Maybe Text,\n    village :: Maybe Text,\n    district :: Maybe Text,\n    subDistrict :: Maybe Text,\n    city :: Maybe Text,\n    state :: Maybe Text,\n    pincode :: Maybe Text,\n    lat :: Maybe Text,\n    lng :: Maybe Text,\n    area :: Maybe Text,\n    formatted_address :: Maybe Text\n  }\n  deriving (Generic, ToJSON, FromJSON, ToSchema)\n\ndata ReverseGeocodeReq = ReverseGeocodeReq\n  { location :: Maps.LatLong,\n    region :: Maybe Text,\n    lang :: Maybe Language\n  }\n  deriving (Generic, ToJSON, FromJSON, ToSchema)\n\nnewtype GeocodeResp = GeocodeResp\n  { copResults :: GeocodeResult\n  }\n  deriving (Show, Generic)\n  deriving anyclass (FromJSON, ToJSON)\n\ndata GeocodeResult = GeocodeResult\n  { locality :: Text,\n    district :: Text,\n    formattedAddress :: Text,\n    eLoc :: Text,\n    geocodeLevel :: Text\n    {-\n\n    doc link: https://github.com/MapmyIndia/mapmyindia-rest-api/tree/master/mapmyindia-maps-geocoding-rest-api-example\n\n    other fields that can be used\n    houseNumber :: Text,\n    houseName :: Text,\n    poi :: Text,\n    street :: Text,\n    subSubLocality :: Text,\n    subLocality :: Text,\n    confidenceScore :: Int,\n    village :: Text,\n    subDistrict :: Text,\n    city :: Text,\n    state :: Text,\n    pincode :: Text\n     -}\n  }\n  deriving (Show, Generic, FromJSON, ToJSON)\n",
      "hash": "ca1f2a9c24c274d7c94bcef7183d77dee7aa05b0e639dc745192fe74a9c94709",
      "size": 9099
    },
    "/lib/mobility-core/src/Kernel/External/Maps/NextBillion/Config.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n\nmodule Kernel.External.Maps.NextBillion.Config (NextBillionCfg) where\n\nimport Kernel.External.Encryption\nimport Kernel.Prelude\n\ndata NextBillionCfg = NextBillionCfg\n  { nextBillionDirectionsUrl :: BaseUrl,\n    nextBillionKey :: EncryptedField 'AsEncrypted Text\n  }\n  deriving (Show, Eq, Generic, FromJSON, ToJSON)\n",
      "hash": "898065715cb53c3098c07cd546e10eaea718b059eb47f8f987a6018fd22d579e",
      "size": 1008
    },
    "/lib/mobility-core/src/Kernel/External/Maps/NextBillion/Route.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n\nmodule Kernel.External.Maps.NextBillion.Route\n  ( DirectionsAPI,\n    directions,\n  )\nwhere\n\nimport Data.Text as T\nimport EulerHS.Types (EulerClient, client)\nimport Kernel.External.Maps.Google.MapsClient.Types\nimport Kernel.External.Maps.NextBillion.Types as NextBillion\nimport Kernel.Prelude\nimport Kernel.Streaming.Kafka.Producer.Types (HasKafkaProducer)\nimport Kernel.Tools.Metrics.CoreMetrics.Types (CoreMetrics)\nimport Kernel.Types.Common\nimport Kernel.Types.Error\nimport Kernel.Utils.Common\nimport qualified Kernel.Utils.ExternalAPICallLogging as ApiCallLogger\nimport Servant hiding (throwError)\n\ntype DirectionsAPI =\n  \"directions\" :> \"json\"\n    :> MandatoryQueryParam \"origin\" Place\n    :> MandatoryQueryParam \"destination\" Place\n    :> MandatoryQueryParam \"key\" Text\n    :> QueryParam \"waypoints\" [Place]\n    :> QueryParam \"alternatives\" Bool\n    :> QueryParam \"altcount\" Int\n    :> QueryParam \"route_type\" Text\n    :> QueryParam \"option\" Text\n    :> QueryParam \"mode\" Text\n    :> Get '[JSON] NextBillion.DirectionsResp\n\ndirectionsClient ::\n  Place ->\n  Place ->\n  Text ->\n  Maybe [Place] ->\n  Maybe Bool ->\n  Maybe Int ->\n  Maybe Text ->\n  Maybe Text ->\n  Maybe Text ->\n  EulerClient NextBillion.DirectionsResp\ndirectionsClient = client (Proxy :: Proxy DirectionsAPI)\n\ndirections ::\n  ( HasCallStack,\n    CoreMetrics m,\n    MonadFlow m,\n    ToJSON a,\n    MonadReader r m,\n    HasKafkaProducer r\n  ) =>\n  Maybe Text ->\n  a ->\n  BaseUrl ->\n  Text ->\n  Place ->\n  Place ->\n  Maybe [Place] ->\n  Maybe Bool ->\n  Maybe Int ->\n  Maybe Text ->\n  Maybe Text ->\n  m NextBillion.DirectionsResp\ndirections entityId req url key origin destination waypoints alternatives altcount routeType option = do\n  rsp <- callAPI url (directionsClient origin destination key waypoints alternatives altcount routeType option (Just \"4w\")) \"next-billion-route\" (Proxy @DirectionsAPI)\n  fork (\"Logging external API Call of directions NextBillion \") $\n    ApiCallLogger.pushExternalApiCallDataToKafka \"directions\" \"NextBillion\" entityId (Just req) rsp\n  fromEitherM (FailedToCallNextBillionRouteAPI . show) rsp\n",
      "hash": "d34fc14d7abd2b77d4fa16d08cb46101910e8cec1e4714bc498cc606d6064d19",
      "size": 2784
    },
    "/lib/mobility-core/src/Kernel/External/Maps/NextBillion/Types.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n{-# LANGUAGE DerivingVia #-}\n\nmodule Kernel.External.Maps.NextBillion.Types\n  ( module Kernel.External.Maps.NextBillion.Types,\n  )\nwhere\n\nimport Kernel.External.Maps.Types (LatLong)\nimport Kernel.Prelude\n\ndata DirectionsResp = DirectionsResp\n  { routes :: [Route],\n    status :: Text\n  }\n  deriving (Generic, ToJSON, FromJSON, Show, Eq)\n\ndata Route = Route\n  { geometry :: Text,\n    distance :: Double, -- meters\n    duration :: Double -- seconds\n  }\n  deriving (Generic, ToJSON, FromJSON, Show, Eq)\n\ndata GetRoutesRequest = GetRoutesRequest\n  { waypoints :: NonEmpty LatLong,\n    alternatives :: Maybe Bool,\n    altcount :: Maybe Int,\n    routeType :: Maybe Text,\n    option :: Maybe Text\n  }\n  deriving (Generic, ToJSON, FromJSON, Show, Eq)\n",
      "hash": "bb0793eeb99f98c358b706d0d71e24c381315ec03e33a35b7b0d53c98330b77e",
      "size": 1436
    },
    "/lib/mobility-core/src/Kernel/External/Maps/OSRM/Config.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n\nmodule Kernel.External.Maps.OSRM.Config where\n\nimport Kernel.Prelude\nimport Kernel.Types.Common\n\ndata OSRMCfg = OSRMCfg\n  { osrmUrl :: BaseUrl,\n    radiusDeviation :: Maybe Meters\n  }\n  deriving (Show, Eq, Generic, FromJSON, ToJSON)\n",
      "hash": "6e05cac56736a5b69bf5af90f485096075dbd13e9fe2bcb325f9048c764f508e",
      "size": 927
    },
    "/lib/mobility-core/src/Kernel/External/Maps/OSRM/RoadsClient.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n{-# LANGUAGE DerivingVia #-}\n\nmodule Kernel.External.Maps.OSRM.RoadsClient where\n\nimport Data.Aeson\nimport qualified Data.List.NonEmpty as NE\nimport qualified Data.Text as T\nimport qualified Data.Vector as V\nimport EulerHS.Prelude ((...))\nimport qualified EulerHS.Types as Euler\nimport qualified Kernel.External.Maps.Interface.Types as Maps\nimport qualified Kernel.External.Maps.Interface.Types as MapsInterfaceTypes\nimport qualified Kernel.External.Maps.Types as Maps\nimport Kernel.Prelude hiding (unlines)\nimport Kernel.Streaming.Kafka.Producer.Types (HasKafkaProducer)\nimport qualified Kernel.Tools.Metrics.CoreMetrics as Metrics\nimport Kernel.Types.App\nimport Kernel.Types.Error\nimport Kernel.Utils.Common\nimport qualified Kernel.Utils.ExternalAPICallLogging as ApiCallLogger\nimport Kernel.Utils.GenericPretty\nimport Servant hiding (throwError)\n\n-- types\n\ndata OSRMProfile = Driving | Walking | Bicycling\n  deriving (Show, Eq)\n\ninstance ToHttpApiData OSRMProfile where\n  toUrlPiece Driving = \"driving\"\n  toUrlPiece Walking = \"foot\"\n  toUrlPiece Bicycling = \"bicycle\"\n\n-- Convert from Maps.TravelMode to OSRMProfile\ntoOSRMProfile :: Maps.TravelMode -> OSRMProfile\ntoOSRMProfile = \\case\n  Maps.CAR -> Driving\n  Maps.MOTORCYCLE -> Driving\n  Maps.BICYCLE -> Bicycling\n  Maps.FOOT -> Walking\n\ntype MatchAPI =\n  \"match\"\n    :> \"v1\"\n    :> Capture \"profile\" OSRMProfile\n    :> Capture \"coordinates\" PointsList\n    :> MandatoryQueryParam \"overview\" Text\n    :> MandatoryQueryParam \"steps\" AlwaysTrue\n    :> QueryParam \"radiuses\" RadiusesList\n    :> MandatoryQueryParam \"geometries\" GeometryRespType\n    :> Get '[JSON] MatchResp\n\ntype TableAPI =\n  \"table\"\n    :> \"v1\"\n    :> Capture \"profile\" OSRMProfile\n    :> Capture \"coordinates\" PointsList\n    :> MandatoryQueryParam \"annotations\" String\n    :> MandatoryQueryParam \"sources\" SourcesList\n    :> MandatoryQueryParam \"destinations\" DestinationsList\n    :> QueryParam \"source_destination_mapping\" Maps.SourceDestinationMapping\n    :> Get '[JSON] OSRMTableResponse\n\ntype RouteAPI =\n  \"route\"\n    :> \"v1\"\n    :> Capture \"profile\" OSRMProfile\n    :> Capture \"coordinates\" PointsList\n    :> MandatoryQueryParam \"geometries\" GeometryRespType\n    :> MandatoryQueryParam \"alternatives\" Bool\n    :> MandatoryQueryParam \"steps\" Bool\n    :> Get '[JSON] OSRMRouteResponse\n\nnewtype PointsList = PointsList {getPointsList :: [Maps.LatLong]}\n\nnewtype SourcesList = SourcesList {getSourcesList :: [Int]}\n\nnewtype DestinationsList = DestinationsList {getDestinationsList :: [Int]}\n\ninstance ToHttpApiData PointsList where\n  toUrlPiece (PointsList lst) = T.intercalate \";\" $ map convertPoint lst\n\nconvertPoint :: Maps.LatLong -> Text\nconvertPoint (Maps.LatLong lat lon) = show lon <> \",\" <> show lat\n\ndata AlwaysTrue = AlwaysTrue\n\ninstance ToHttpApiData AlwaysTrue where\n  toUrlPiece _ = \"true\"\n\nnewtype RadiusesList = RadiusesList {getRadiusesList :: [Int]}\n\ninstance ToHttpApiData RadiusesList where\n  toUrlPiece (RadiusesList lst) = T.intercalate \";\" $ map show lst\n\ninstance ToHttpApiData DestinationsList where\n  toUrlPiece (DestinationsList lst) = T.intercalate \";\" $ map show lst\n\ninstance ToHttpApiData SourcesList where\n  toUrlPiece (SourcesList lst) = T.intercalate \";\" $ map show lst\n\ndata GeometryRespType = GeoJson\n\ninstance ToHttpApiData GeometryRespType where\n  toUrlPiece GeoJson = \"geojson\"\n\ndata OSRMTableResponse = OSRMTableResponse\n  { distances :: [[Double]],\n    code :: String,\n    durations :: [[Double]]\n  }\n  deriving stock (Generic, Show, Eq)\n  deriving anyclass (FromJSON, ToJSON)\n\ndata MatchResp = MatchResp\n  { matchings :: NonEmpty Route,\n    tracepoints :: [Maybe Waypoint]\n  }\n  deriving stock (Generic, Show, Eq)\n  deriving anyclass (FromJSON, ToJSON, PrettyShow)\n\ndata Route = Route\n  { distance :: Double, -- meters\n    duration :: Double, -- seconds\n    legs :: [RouteLeg],\n    confidence :: Double, -- from 0 to 1, 1 is very confident\n    geometry :: RouteGeometry\n  }\n  deriving (Generic, Show, Eq, FromJSON, ToJSON, PrettyShow)\n\nnewtype RouteGeometry = RouteGeometry\n  { coordinates :: [Location]\n  }\n  deriving stock (Generic, Show, Eq)\n  deriving anyclass (FromJSON, ToJSON, PrettyShow)\n\ndata RouteLeg = RouteLeg\n  { distance :: Double, -- meters\n    duration :: Double -- seconds\n  }\n  deriving (Generic, Show, Eq, FromJSON, ToJSON, PrettyShow)\n\ndata Waypoint = Waypoint\n  { alternatives_count :: Int,\n    waypoint_index :: Int,\n    matchings_index :: Int,\n    location :: Location\n  }\n  deriving (Generic, Show, Eq, FromJSON, ToJSON, PrettyShow)\n\nnewtype Location = Location {getLatLong :: Maps.LatLong}\n  deriving stock (Generic, Show, Eq)\n  deriving (PrettyShow) via (Showable Location)\n\ndata OSRMRouteResponse = OSRMRouteResponse\n  { routes :: [OSRMRouteRoutes],\n    waypoints :: [OSRMRouteWaypoint]\n  }\n  deriving stock (Generic, Show, Eq)\n  deriving anyclass (FromJSON, ToJSON)\n\ndata OSRMRouteRoutes = OSRMRouteRoutes\n  { geometry :: RouteGeometry,\n    legs :: [RouteResponseLeg],\n    distance :: Double, -- meters\n    duration :: Double, -- seconds\n    weight :: Double\n  }\n  deriving stock (Generic, Show, Eq)\n  deriving anyclass (FromJSON, ToJSON)\n\ndata RouteResponseLeg = RouteResponseLeg\n  { steps :: [Steps],\n    distance :: Double,\n    duration :: Double,\n    weight :: Double\n  }\n  deriving stock (Generic, Show, Eq)\n  deriving anyclass (FromJSON, ToJSON)\n\ndata Steps = Steps\n  { geometry :: RouteGeometry,\n    maneuver :: Maneuver\n  }\n  deriving stock (Generic, Show, Eq)\n  deriving anyclass (FromJSON, ToJSON)\n\nnewtype Maneuver = Maneuver\n  { location :: Location\n  }\n  deriving stock (Generic, Show, Eq)\n  deriving anyclass (FromJSON, ToJSON)\n\ndata OSRMRouteWaypoint = OSRMRouteWaypoint\n  { distance :: Double,\n    location :: Location\n  }\n  deriving stock (Generic, Show, Eq)\n  deriving anyclass (FromJSON, ToJSON)\n\ninstance FromJSON Location where\n  parseJSON = withArray \"array [lon, lat]\" $ \\arr_ -> case toList arr_ of\n    [lonVal, latVal] -> Location ... Maps.LatLong <$> parseJSON latVal <*> parseJSON lonVal\n    _ -> fail \"expected array [lon, lat]\"\n\ninstance ToJSON Location where\n  toJSON (Location Maps.LatLong {..}) = Array $ V.fromList $ map toJSON [lon, lat]\n\n-- call\ncallOsrmMatchAPI ::\n  ( HasCallStack,\n    Metrics.CoreMetrics m,\n    MonadFlow m,\n    MonadReader r m,\n    HasKafkaProducer r\n  ) =>\n  Maybe Text ->\n  MapsInterfaceTypes.SnapToRoadReq ->\n  BaseUrl ->\n  Maybe Int ->\n  Maps.TravelMode -> -- Changed from Text to TravelMode\n  PointsList ->\n  m MatchResp\ncallOsrmMatchAPI entityId req osrmUrl mbRadius travelMode pointsList = do\n  let pointsNum = length pointsList.getPointsList\n      radiuses = flip fmap mbRadius $ \\r -> RadiusesList $ replicate pointsNum r\n      profile = toOSRMProfile travelMode\n  let eulerClient = Euler.client (Proxy @MatchAPI)\n  rsp <- callAPI osrmUrl (eulerClient profile pointsList \"full\" AlwaysTrue radiuses GeoJson) \"osrm-match\" (Proxy @MatchAPI)\n  fork (\"Logging external API Call of OsrmMatchAPI OSRM \") $\n    ApiCallLogger.pushExternalApiCallDataToKafka \"OsrmMatchAPI\" \"OSRM\" entityId (Just req) rsp\n  fromEitherM (FailedToCallOsrmMatchAPI . show) rsp\n\ngetResultOneRouteExpected :: (Log m, MonadThrow m) => MatchResp -> m (HighPrecMeters, Double, [Maps.LatLong])\ngetResultOneRouteExpected resp = do\n  logDebug $ T.pack $ defaultPretty resp\n  route_ <- case NE.tail resp.matchings of\n    [] -> pure $ NE.head resp.matchings\n    (_ : _) -> throwError $ InternalError \"OSRM failed to consider waypoints as part of one route, th result contains splitted routes\"\n  let points = map (.getLatLong) $ route_.geometry.coordinates\n  pure (realToFrac route_.distance, route_.confidence, points)\n\ncallOsrmGetDistancesAPI ::\n  ( HasCallStack,\n    Metrics.CoreMetrics m,\n    MonadFlow m,\n    MonadReader r m,\n    HasKafkaProducer r,\n    ToJSON a,\n    ToJSON b\n  ) =>\n  Maybe Text ->\n  MapsInterfaceTypes.GetDistancesReq a b ->\n  BaseUrl ->\n  Maps.TravelMode -> -- Changed from Text to TravelMode\n  PointsList ->\n  SourcesList ->\n  DestinationsList ->\n  Maybe Maps.SourceDestinationMapping ->\n  m OSRMTableResponse\ncallOsrmGetDistancesAPI entityId req osrmUrl travelMode pointsList sourcesList destinationsList mbSourceDestinationMapping =\n  do\n    let eulerClient = Euler.client (Proxy @TableAPI)\n        profile = toOSRMProfile travelMode\n    rsp <- callAPI osrmUrl (eulerClient profile pointsList \"distance,duration\" sourcesList destinationsList mbSourceDestinationMapping) \"osrm-table\" (Proxy @TableAPI)\n    fork (\"Logging external API Call of OsrmGetDistancesAPI OSRM \") $\n      ApiCallLogger.pushExternalApiCallDataToKafka \"OsrmGetDistancesAPI\" \"OSRM\" entityId (Just req) rsp\n    fromEitherM (FailedToCallOsrmTableAPI . show) rsp\n\ncallOsrmRouteAPI ::\n  ( HasCallStack,\n    Metrics.CoreMetrics m,\n    MonadFlow m,\n    MonadReader r m,\n    HasKafkaProducer r\n  ) =>\n  Maybe Text ->\n  MapsInterfaceTypes.GetRoutesReq ->\n  BaseUrl ->\n  Maps.TravelMode -> -- Changed from Text to TravelMode\n  PointsList ->\n  m OSRMRouteResponse\ncallOsrmRouteAPI entityId req osrmUrl travelMode pointsList = do\n  let eulerClient = Euler.client (Proxy @RouteAPI)\n      profile = toOSRMProfile travelMode\n  rsp <- callAPI osrmUrl (eulerClient profile pointsList GeoJson True True) \"osrm-route\" (Proxy @RouteAPI)\n  fork (\"Logging external API Call of OsrmRouteAPI OSRM \") $\n    ApiCallLogger.pushExternalApiCallDataToKafka \"OsrmRouteAPI\" \"OSRM\" entityId (Just req) rsp\n  fromEitherM (FailedToCallOsrmRouteAPI . show) rsp\n",
      "hash": "6c0360a5decb946103ddaece3e308d54e0852e1332a5a5638256093e3bd36477",
      "size": 10129
    },
    "/lib/mobility-core/src/Kernel/External/Maps/Types.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n{-# LANGUAGE InstanceSigs #-}\n{-# LANGUAGE TemplateHaskell #-}\n\nmodule Kernel.External.Maps.Types\n  ( module Kernel.External.Maps.Types,\n    module Data.Geospatial,\n    module Data.LineString,\n  )\nwhere\n\nimport Control.Lens.Operators\nimport Data.Geospatial\nimport Data.LineString\nimport Data.OpenApi\nimport Data.Text\nimport Database.Beam.Backend\nimport qualified Database.Beam.Backend.SQL.AST as B\nimport EulerHS.Prelude\nimport Kernel.Beam.Lib.UtilsTH (mkBeamInstancesForEnumAndList, mkBeamInstancesForList)\nimport Kernel.Storage.Esqueleto (derivePersistField)\nimport Kernel.Utils.GenericPretty (PrettyShow)\nimport Servant.API (FromHttpApiData (..), ToHttpApiData (..))\n\ndata MapsService = Google | OSRM | MMI | NextBillion | SelfTuned\n  deriving (Show, Read, Eq, Ord, Generic, ToJSON, FromJSON, ToSchema)\n\n$(mkBeamInstancesForEnumAndList ''MapsService)\n\navailableMapsServices :: [MapsService]\navailableMapsServices = [Google, OSRM, MMI, NextBillion]\n\nderivePersistField \"MapsService\"\n\ndata LatLong = LatLong\n  { lat :: Double,\n    lon :: Double\n  }\n  deriving (Show, Eq, Generic, FromJSON, ToJSON, ToSchema, PrettyShow, Ord, Read)\n\ninstance HasSqlValueSyntax B.Value LatLong where\n  sqlValueSyntax = autoSqlValueSyntax\n\n$(mkBeamInstancesForList ''LatLong)\n\ninstance ToParamSchema LatLong where\n  toParamSchema _ =\n    mempty\n      & title ?~ \"LatLong\"\n      & type_ ?~ OpenApiString\n      & format ?~ \"<latitude>,<longitude>\"\n\ninstance FromHttpApiData LatLong where\n  parseUrlPiece a = do\n    (lat, long) <- case splitOn \",\" a of\n      [lat, long] -> Right (lat, long)\n      _ -> Left \"Unable to parse LatLong,\"\n    LatLong <$> readEither lat <*> readEither long\n\ninstance ToHttpApiData LatLong where\n  toQueryParam :: LatLong -> Text\n  toQueryParam LatLong {..} = show lat <> \",\" <> show lon\n\ndata SourceDestinationMapping = OneToOne | ManyToMany\n  deriving (Show, Eq, Generic, FromJSON, ToJSON, ToSchema, Ord, Read)\n\ninstance ToHttpApiData SourceDestinationMapping where\n  toUrlPiece OneToOne = \"one-to-one\"\n  toUrlPiece ManyToMany = \"many-to-many\"\n",
      "hash": "5a2a0e4935ca3f637572259da520944b0733f07d51c0cfad62b4f86e2e905be3",
      "size": 2745
    },
    "/lib/mobility-core/src/Kernel/External/Maps/Utils.hs": {
      "type": "content",
      "content": "{-\n Copyright 2022-23, Juspay India Pvt Ltd\n\n This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program\n\n is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n\n or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of\n\n the GNU Affero General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n\nmodule Kernel.External.Maps.Utils\n  ( module Reexport,\n    module Kernel.External.Maps.Utils,\n  )\nwhere\n\nimport qualified Data.List as DL\nimport EulerHS.Prelude (comparing)\nimport Kernel.External.Maps as Reexport\nimport qualified Kernel.External.Maps as Maps\nimport Kernel.Prelude\nimport Kernel.Types.Common\n\nfindMaxWeightedInfoIdx :: Float -> Float -> [(Maybe Float, Maybe Float)] -> Int\nfindMaxWeightedInfoIdx distanceWeight durationWeight infoArr =\n  fst $ DL.maximumBy (comparing snd) indexedScores\n  where\n    indexedScores = zip [0 ..] (map (\\(dis, dur) -> calculateWeightedScore distanceWeight durationWeight (dis, dur)) infoArr)\n\nminDistance :: [Maps.RouteInfo] -> Meters\nminDistance = DL.minimum . mapMaybe (.distance)\n\nminDuration :: [Maps.RouteInfo] -> Seconds\nminDuration = DL.minimum . mapMaybe (.duration)\n\nnormalizeArr :: Maybe Meters -> Maybe Seconds -> [Maps.RouteInfo] -> [(Maybe Float, Maybe Float)]\nnormalizeArr minD minDur infoArr =\n  [normalizeInfo minD minDur info | info <- infoArr]\n\nnormalizeInfo :: Maybe Meters -> Maybe Seconds -> Maps.RouteInfo -> (Maybe Float, Maybe Float)\nnormalizeInfo minD minDur info =\n  (normalizeDisValue info.distance minD, normalizeDurValue info.duration minDur)\n\nnormalizeDisValue :: Maybe Meters -> Maybe Meters -> Maybe Float\nnormalizeDisValue (Just x) (Just minVal)\n  | x /= 0 = Just (fromIntegral minVal / fromIntegral x)\nnormalizeDisValue _ _ = Nothing\n\nnormalizeDurValue :: Maybe Seconds -> Maybe Seconds -> Maybe Float\nnormalizeDurValue (Just x) (Just minVal)\n  | x /= 0 = Just (fromIntegral minVal / fromIntegral x)\nnormalizeDurValue _ _ = Nothing\n\ncalculateWeightedScore :: Float -> Float -> (Maybe Float, Maybe Float) -> Float\ncalculateWeightedScore distanceWeight durationWeight (dis, dur) =\n  case (dis, dur) of\n    (Just normDist, Just normDur) -> normDist * distanceWeight + normDur * durationWeight\n    _ -> 0\n\ngetLongestRouteDistance :: [Maps.RouteInfo] -> Maybe Maps.RouteInfo\ngetLongestRouteDistance [] = Nothing\ngetLongestRouteDistance (routeInfo : routeInfoArray) =\n  if null routeInfoArray\n    then Just routeInfo\n    else do\n      restRouteresult <- getLongestRouteDistance routeInfoArray\n      Just $ comparator' routeInfo restRouteresult\n  where\n    comparator' route1 route2 =\n      if route1.distance > route2.distance\n        then route1\n        else route2\n\ngetEfficientRouteInfo :: [Maps.RouteInfo] -> Int -> Int -> (Maybe Maps.RouteInfo, Int)\ngetEfficientRouteInfo [] _ _ = (Nothing, 0)\ngetEfficientRouteInfo routeInfos distanceWeight durationWeight = do\n  let minD = minDistance routeInfos\n      minDur = minDuration routeInfos\n      normalizedInfos = normalizeArr (Just minD) (Just minDur) routeInfos\n      resultInfoIdx = findMaxWeightedInfoIdx (fromIntegral distanceWeight) (fromIntegral durationWeight) normalizedInfos\n  if resultInfoIdx < length routeInfos\n    then (Just (routeInfos !! resultInfoIdx), resultInfoIdx)\n    else (Nothing, 0)\n\nupdateEfficientRoutePosition :: [Maps.RouteInfo] -> Int -> [Maps.RouteInfo]\nupdateEfficientRoutePosition routeInfos idx = do\n  let (x, y) = splitAt idx routeInfos\n  y ++ x\n",
      "hash": "e1f0494f09a7522769f8798794c9dd946bf03e592868d0216a3347cac3aac93d",
      "size": 3792
    },
    "/lib/mobility-core/src/Kernel/External/MultiModal.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n\nmodule Kernel.External.MultiModal (module Reexport) where\n\nimport Kernel.External.MultiModal.Interface as Reexport\n",
      "hash": "5047c8c32154566b0de045d183d2da495d8b700fd81f9c1265ccdedf3ced51c8",
      "size": 809
    },
    "/lib/mobility-core/src/Kernel/External/MultiModal/Interface.hs": {
      "type": "content",
      "content": "module Kernel.External.MultiModal.Interface\n  ( module Reexport,\n    getTransitRoutesProvided,\n    getTransitRoutes,\n  )\nwhere\n\nimport Kernel.External.Maps.Google.Config as Reexport\nimport qualified Kernel.External.MultiModal.Interface.Google as Google\nimport qualified Kernel.External.MultiModal.Interface.OpenTripPlanner as OTP\nimport Kernel.External.MultiModal.Interface.Types as Reexport\nimport Kernel.External.MultiModal.OpenTripPlanner.Config as Reexport\nimport Kernel.External.MultiModal.Types\nimport Kernel.External.MultiModal.Utils as Reexport\nimport Kernel.Prelude\nimport Kernel.Streaming.Kafka.Producer.Types (HasKafkaProducer)\nimport Kernel.Tools.Metrics.CoreMetrics (CoreMetrics)\nimport Kernel.Types.Common hiding (id)\n\n-- To be used in future when we add another provider\n-- mkNotProvidedError :: Text -> MultiModalService -> Text\n-- mkNotProvidedError functionName serviceName = \"Function \" <> functionName <> \" is not provided by service \" <> show serviceName\n--\n-- throwNotProvidedError :: (MonadFlow m) => Text ->  MultiModalService -> m a\n-- throwNotProvidedError =\n--   (throwError . InternalError) ... mkNotProvidedError\n\ngetTransitRoutesProvided :: MultiModalService -> Bool\ngetTransitRoutesProvided = \\case\n  GoogleTransit -> True\n  OTPTransit -> True\n\ngetTransitRoutes ::\n  ( EncFlow m r,\n    CoreMetrics m,\n    Log m,\n    HasKafkaProducer r\n  ) =>\n  Maybe Text ->\n  MultiModalServiceConfig ->\n  GetTransitRoutesReq ->\n  m (Maybe MultiModalResponse)\ngetTransitRoutes entityId serviceConfig req = case serviceConfig of\n  GoogleTransitConfig cfg -> Google.getTransitRoutes entityId cfg req\n  OTPTransitConfig cfg -> OTP.getTransitRoutes cfg req\n",
      "hash": "fea9379892002d32d5255e0fe604e502c2c295b7803575c98084ed0dd7381313",
      "size": 1667
    },
    "/lib/mobility-core/src/Kernel/External/MultiModal/Interface/Google.hs": {
      "type": "content",
      "content": "module Kernel.External.MultiModal.Interface.Google (getTransitRoutes) where\n\nimport Data.Time\nimport Kernel.External.Encryption\nimport Kernel.External.Maps.Google.Config\nimport qualified Kernel.External.Maps.Google.MapsClient as GoogleMaps\nimport Kernel.External.MultiModal.Interface.Types as MultiModalTypes\nimport Kernel.External.MultiModal.Utils\nimport Kernel.Prelude\nimport Kernel.Streaming.Kafka.Producer.Types (HasKafkaProducer)\nimport Kernel.Tools.Metrics.CoreMetrics (CoreMetrics)\nimport Kernel.Types.Common hiding (id)\n\nformatUtcTime :: Maybe UTCTime -> Maybe String\nformatUtcTime Nothing = Nothing\nformatUtcTime (Just utcTime) = Just $ formatTime defaultTimeLocale \"%Y-%m-%dT%H:%M:%SZ\" utcTime\n\ngetTransitRoutes ::\n  ( EncFlow m r,\n    CoreMetrics m,\n    Log m,\n    HasKafkaProducer r\n  ) =>\n  Maybe Text ->\n  GoogleCfg ->\n  MultiModalTypes.GetTransitRoutesReq ->\n  m (Maybe MultiModalTypes.MultiModalResponse)\ngetTransitRoutes entityId cfg req = do\n  key <- decrypt cfg.googleKey\n  let googleMapsUrl = cfg.googleRouteConfig.url\n      computeAlternativeRoutes = cfg.googleRouteConfig.computeAlternativeRoutes\n      routePreference = cfg.googleRouteConfig.routePreference\n      origin = req.origin\n      destination = req.destination\n      travelMode = req.mode\n      arrivalTime = formatUtcTime req.arrivalTime\n      departureTime = formatUtcTime req.departureTime\n      transitPreferences = req.transitPreferences\n  result <- try @_ @SomeException $ GoogleMaps.transitDirectionsAPI entityId googleMapsUrl key origin destination travelMode computeAlternativeRoutes routePreference transitPreferences arrivalTime departureTime\n  case result of\n    Right gRes -> do\n      pure $ Just $ convertGoogleToGeneric gRes\n    Left _ -> do\n      pure Nothing\n",
      "hash": "7b0d0fbb3d73ade947b192c80d900ce2ae1d506ef397533e90bb1b5e503df539",
      "size": 1758
    },
    "/lib/mobility-core/src/Kernel/External/MultiModal/Interface/OpenTripPlanner.hs": {
      "type": "content",
      "content": "module Kernel.External.MultiModal.Interface.OpenTripPlanner (getTransitRoutes) where\n\nimport Data.Morpheus.Client\n  ( request,\n    single,\n  )\nimport Data.Time.Format (defaultTimeLocale, formatTime)\nimport EulerHS.Prelude hiding (id, product)\nimport qualified Kernel.External.MultiModal.Interface.Types as TP\nimport Kernel.External.MultiModal.OpenTripPlanner.Config\nimport Kernel.External.MultiModal.OpenTripPlanner.Types\nimport Kernel.External.MultiModal.Utils\nimport Kernel.Tools.Metrics.CoreMetrics (CoreMetrics)\nimport Kernel.Utils.Common hiding (id)\nimport Servant.Client.Core (showBaseUrl)\n\nformatUtcDateTime :: UTCTime -> (String, String)\nformatUtcDateTime utcTime = (dateString, timeString)\n  where\n    dateString = formatTime defaultTimeLocale \"%Y-%m-%d\" utcTime\n    timeString = formatTime defaultTimeLocale \"%H:%M\" utcTime\n\ngetTransitRoutes ::\n  ( EncFlow m r,\n    CoreMetrics m,\n    Log m\n  ) =>\n  OTPCfg ->\n  TP.GetTransitRoutesReq ->\n  m (Maybe TP.MultiModalResponse)\ngetTransitRoutes cfg req = do\n  let origin =\n        InputCoordinates\n          { lat = req.origin.location.latLng.latitude,\n            lon = req.origin.location.latLng.longitude\n          }\n  let destination =\n        InputCoordinates\n          { lat = req.destination.location.latLng.latitude,\n            lon = req.destination.location.latLng.longitude\n          }\n  let dateTime' = req.departureTime <&> formatUtcDateTime\n  dateTime <-\n    case cfg.nightMode of\n      Just True -> Just . formatUtcDateTime . addUTCTime 43200 <$> getCurrentTime\n      _ -> pure dateTime'\n  let planClient = fromString (showBaseUrl cfg.baseUrl)\n  let transportModes' = req.transportModes\n  let numItineraries' = Just $ fromMaybe 50 cfg.numItineraries\n  let minimumWalkDistance = req.minimumWalkDistance\n  let permissibleModes = req.permissibleModes\n  let maxAllowedPublicTransportLegs = req.maxAllowedPublicTransportLegs\n  let sortingType = req.sortingType\n  let queryType = fromMaybe NORMAL cfg.queryType\n  case queryType of\n    NORMAL -> do\n      let otpReq =\n            OTPPlanArgs\n              { from = origin,\n                to = destination,\n                date = fst <$> dateTime,\n                time = snd <$> dateTime,\n                transportModes = transportModes',\n                numItineraries = numItineraries'\n              }\n      resp <-\n        liftIO $\n          planClient\n            `request` otpReq\n              >>= single\n      case resp of\n        Left err -> do\n          logError $ \"Error in getTransitRoutes: \" <> show err\n          pure Nothing\n        Right plan' -> do\n          logInfo $ \"OTP plan log by gentleman and piyush: \" <> show plan' <> \" \" <> show req <> \" , GQLReq => \" <> show otpReq\n          pure $ Just $ convertOTPToGeneric plan' minimumWalkDistance permissibleModes maxAllowedPublicTransportLegs sortingType cfg.weightedSortCfg\n    MULTI_SEARCH -> withLogTag \"MULTI_SEARCH\" $ do\n      let otpReq =\n            MultiModePlanArgs\n              { from = origin,\n                to = destination,\n                date = fst <$> dateTime,\n                time = snd <$> dateTime,\n                metroTransportModes = map (Just . modeToTransportMode) $ catMaybes [Just ModeRAIL, Just ModeWALK],\n                metroItineraries = 5,\n                subwayTransportModes = map (Just . modeToTransportMode) $ catMaybes [Just ModeSUBWAY, Just ModeWALK],\n                subwayItineraries = 5,\n                busTransportModes = map (Just . modeToTransportMode) $ catMaybes [Just ModeBUS, Just ModeWALK],\n                busItineraries = 10,\n                bestTransportModes = map (Just . modeToTransportMode) $ catMaybes [Just ModeTRANSIT, Just ModeWALK],\n                bestItineraries = 10\n              }\n      resp <-\n        liftIO $\n          planClient\n            `request` otpReq\n              >>= single\n      case resp of\n        Left err -> do\n          logError $ \"Error in getTransitRoutes: \" <> show err\n          pure Nothing\n        Right plan -> do\n          logInfo $ \"OTP plan log: \" <> show plan <> \" \" <> show req <> \" , GQLReq => \" <> show otpReq\n          let allPlans = combinePlans plan\n          pure $ Just $ convertOTPToGeneric allPlans minimumWalkDistance permissibleModes maxAllowedPublicTransportLegs sortingType cfg.weightedSortCfg\n\nmodeToTransportMode :: Mode -> TransportMode\nmodeToTransportMode = TransportMode . show\n\ncombinePlans :: MultiModePlan -> OTPPlan\ncombinePlans res = do\n  let itineraries = res.metro.itineraries <> res.subway.itineraries <> res.bus.itineraries <> res.best.itineraries\n  OTPPlan {plan = OTPPlanPlan {..}}\n",
      "hash": "2c251cf408297a7d8ca69ac7baa7a2f916bcb18787fb782822483055e5db61a7",
      "size": 4590
    },
    "/lib/mobility-core/src/Kernel/External/MultiModal/Interface/Types.hs": {
      "type": "content",
      "content": "{-# LANGUAGE DeriveGeneric #-}\n{-# LANGUAGE DerivingVia #-}\n{-# LANGUAGE DuplicateRecordFields #-}\n{-# LANGUAGE GeneralizedNewtypeDeriving #-}\n{-# LANGUAGE StandaloneDeriving #-}\n{-# LANGUAGE TemplateHaskell #-}\n{-# OPTIONS_GHC -Wno-orphans #-}\n\nmodule Kernel.External.MultiModal.Interface.Types where\n\nimport Data.Aeson\nimport Data.OpenApi hiding (name)\nimport Data.Time (UTCTime)\nimport Deriving.Aeson\nimport EulerHS.Prelude\nimport Kernel.Beam.Lib.UtilsTH (mkBeamInstancesForEnumAndList)\nimport qualified Kernel.External.Maps.Google.Config as Google\nimport qualified Kernel.External.Maps.Google.MapsClient.Types as GT\nimport qualified Kernel.External.MultiModal.OpenTripPlanner.Config as OTP\nimport qualified Kernel.External.MultiModal.OpenTripPlanner.Types as OTPTypes\nimport qualified Kernel.Types.Distance as Distance\nimport qualified Kernel.Types.Time as Time\nimport Kernel.Utils.TH (mkHttpInstancesForEnum)\n\nnewtype MultiModalResponse = MultiModalResponse {routes :: [MultiModalRoute]}\n  deriving (Show, Generic)\n  deriving newtype (FromJSON, ToJSON, ToSchema)\n\ndata MultiModalRoute = MultiModalRoute\n  { distance :: Distance.Distance,\n    duration :: Time.Seconds,\n    startTime :: Maybe UTCTime,\n    endTime :: Maybe UTCTime,\n    legs :: [MultiModalLeg],\n    relevanceScore :: Maybe Double\n  }\n  deriving (Show, Generic)\n  deriving anyclass (FromJSON, ToJSON, ToSchema)\n\ndata NormalizerData = NormalizerData\n  { minArrivalTime :: Maybe UTCTime,\n    maxArrivalTime :: Maybe UTCTime,\n    minDuration :: Maybe Time.Seconds,\n    maxDuration :: Maybe Time.Seconds,\n    minTransfers :: Maybe Int,\n    maxTransfers :: Maybe Int\n  }\n  deriving (Show, Generic)\n\ndata MultiModalStopDetails = MultiModalStopDetails\n  { stopCode :: Maybe Text,\n    platformCode :: Maybe Text,\n    name :: Maybe Text,\n    gtfsId :: Maybe Text\n  }\n  deriving (Show, Generic, ToJSON, FromJSON, ToSchema)\n\ndata MultiModalAgency = MultiModalAgency\n  { gtfsId :: Maybe Text,\n    name :: Text\n  }\n  deriving (Eq, Show, Generic, ToJSON, FromJSON, ToSchema)\n\ndata MultiModalRouteDetails = MultiModalRouteDetails\n  { gtfsId :: Maybe Text,\n    longName :: Maybe Text,\n    shortName :: Maybe Text,\n    alternateShortNames :: [Text],\n    color :: Maybe Text,\n    fromStopDetails :: Maybe MultiModalStopDetails,\n    toStopDetails :: Maybe MultiModalStopDetails,\n    startLocation :: GT.LocationV2,\n    endLocation :: GT.LocationV2,\n    subLegOrder :: Int,\n    fromArrivalTime :: Maybe UTCTime,\n    fromDepartureTime :: Maybe UTCTime,\n    toArrivalTime :: Maybe UTCTime,\n    toDepartureTime :: Maybe UTCTime\n  }\n  deriving (Show, Generic, ToJSON, FromJSON, ToSchema)\n\ndata MultiModalLeg = MultiModalLeg\n  { distance :: Distance.Distance,\n    duration :: Time.Seconds,\n    polyline :: GT.Polyline,\n    mode :: GeneralVehicleType,\n    startLocation :: GT.LocationV2,\n    endLocation :: GT.LocationV2,\n    fromStopDetails :: Maybe MultiModalStopDetails,\n    toStopDetails :: Maybe MultiModalStopDetails,\n    routeDetails :: [MultiModalRouteDetails],\n    liveVehicleAvailableServiceTypes :: [Text],\n    agency :: Maybe MultiModalAgency,\n    fromArrivalTime :: Maybe UTCTime,\n    fromDepartureTime :: Maybe UTCTime,\n    toArrivalTime :: Maybe UTCTime,\n    toDepartureTime :: Maybe UTCTime,\n    entrance :: Maybe MultiModalLegGate,\n    exit :: Maybe MultiModalLegGate\n  }\n  deriving (Show, Generic, ToJSON, FromJSON, ToSchema)\n\ndata MultiModalLegGate = MultiModalLegGate\n  { distance :: Maybe Double,\n    lon :: Maybe Double,\n    lat :: Maybe Double,\n    isEntrance :: Maybe Bool,\n    absoluteDirection :: Maybe OTPTypes.AbsoluteDirection,\n    streetName :: Maybe Text,\n    exit :: Maybe Text,\n    stayOn :: Maybe Bool,\n    area :: Maybe Bool,\n    bogusName :: Maybe Bool,\n    walkingBike :: Maybe Bool\n  }\n  deriving (Generic, Show, Eq, ToSchema, FromJSON, ToJSON)\n\ndata MultiModalServiceConfig = GoogleTransitConfig Google.GoogleCfg | OTPTransitConfig OTP.OTPCfg\n  deriving stock (Show, Eq, Generic)\n  deriving (FromJSON, ToJSON) via CustomJSON '[SumTaggedObject \"tag\" \"content\"] MultiModalServiceConfig\n\ndata GeneralVehicleType\n  = Bus\n  | MetroRail\n  | Walk\n  | Subway\n  | Unspecified\n  deriving (Show, Eq, Ord, Generic, ToJSON, FromJSON, Read, ToSchema, ToParamSchema)\n\n$(mkHttpInstancesForEnum ''GeneralVehicleType)\n\n$(mkBeamInstancesForEnumAndList ''GeneralVehicleType)\n\ndata SortingType\n  = Fastest\n  | MinimumTransits\n  | MostRelevant\n  deriving (Show, Eq, Ord, Generic, ToJSON, FromJSON, Read, ToSchema, ToParamSchema)\n\n$(mkHttpInstancesForEnum ''SortingType)\n\n$(mkBeamInstancesForEnumAndList ''SortingType)\n\ndata GetTransitRoutesReq = GetTransitRoutesReq\n  { origin :: GT.WayPointV2,\n    destination :: GT.WayPointV2,\n    arrivalTime :: Maybe UTCTime,\n    departureTime :: Maybe UTCTime,\n    mode :: Maybe GT.ModeV2,\n    transitPreferences :: Maybe GT.TransitPreferencesV2,\n    transportModes :: Maybe [Maybe OTPTypes.TransportMode],\n    minimumWalkDistance :: Distance.Meters,\n    permissibleModes :: [GeneralVehicleType],\n    maxAllowedPublicTransportLegs :: Int,\n    sortingType :: SortingType\n  }\n  deriving (Generic, ToJSON, FromJSON, Show, ToSchema)\n",
      "hash": "94368993eb739e28933fdae01a74a6d67d32fdc9dd34e1e5e589bcbe67728ffc",
      "size": 5106
    },
    "/lib/mobility-core/src/Kernel/External/MultiModal/OpenTripPlanner/Config.hs": {
      "type": "content",
      "content": "module Kernel.External.MultiModal.OpenTripPlanner.Config where\n\nimport Kernel.Prelude\n\ndata MultiModalWeightedSortCfg = MultiModalWeightedSortCfg\n  { arrivalTime :: Double,\n    duration :: Double,\n    transfers :: Double\n  }\n  deriving (Show, Eq, Generic, ToJSON, FromJSON)\n\nvalidateWeightedSortCfg :: MultiModalWeightedSortCfg -> Bool\nvalidateWeightedSortCfg MultiModalWeightedSortCfg {..} =\n  let totalWeight =\n        arrivalTime\n          + duration\n          + transfers\n   in totalWeight == 1\n\ndata OTPQuery = NORMAL | MULTI_SEARCH\n  deriving (Show, Eq, Generic, ToJSON, FromJSON)\n\ndata OTPCfg = OTPCfg\n  { baseUrl :: BaseUrl,\n    queryType :: Maybe OTPQuery,\n    nightMode :: Maybe Bool,\n    numItineraries :: Maybe Int,\n    weightedSortCfg :: MultiModalWeightedSortCfg\n  }\n  deriving (Show, Eq, Generic, ToJSON, FromJSON)\n",
      "hash": "0d2dc8867ef161094abc29d2cf4c87ebfdfb9315359946b5583455a4c838f5ae",
      "size": 830
    },
    "/lib/mobility-core/src/Kernel/External/MultiModal/Types.hs": {
      "type": "content",
      "content": "{-# LANGUAGE DeriveGeneric #-}\n{-# LANGUAGE DuplicateRecordFields #-}\n{-# LANGUAGE InstanceSigs #-}\n{-# LANGUAGE TemplateHaskell #-}\n\nmodule Kernel.External.MultiModal.Types\n  ( module Kernel.External.MultiModal.Types,\n  )\nwhere\n\nimport Data.OpenApi hiding (name)\nimport EulerHS.Prelude\nimport Kernel.Beam.Lib.UtilsTH (mkBeamInstancesForEnumAndList)\nimport Kernel.Storage.Esqueleto (derivePersistField)\n\ndata MultiModalService = GoogleTransit | OTPTransit\n  deriving (Show, Read, Eq, Ord, Generic, ToJSON, FromJSON, ToSchema)\n\n$(mkBeamInstancesForEnumAndList ''MultiModalService)\n\navailableMultiModalService :: [MultiModalService]\navailableMultiModalService = [GoogleTransit, OTPTransit]\n\nderivePersistField \"MultiModalService\"\n",
      "hash": "af73fc4f4740a870327045c07d4503cf308d5c419ca7400435871dc152136583",
      "size": 728
    },
    "/lib/mobility-core/src/Kernel/External/MultiModal/Utils.hs": {
      "type": "content",
      "content": "{-# LANGUAGE BangPatterns #-}\n\nmodule Kernel.External.MultiModal.Utils\n  ( convertGoogleToGeneric,\n    convertOTPToGeneric,\n    decode,\n    encode,\n  )\nwhere\n\nimport qualified Data.Char as Char\nimport qualified Data.HashMap.Strict as HM\nimport Data.List (nub, partition, sortBy)\nimport Data.List.Split (splitOn)\nimport qualified Data.Map as Map\nimport Data.Maybe\nimport qualified Data.Text as T\nimport qualified Data.Text.Encoding as TE\nimport qualified Debug.Trace as DT\nimport EulerHS.Prelude (liftA2, liftA3, safeHead)\nimport Kernel.External.Maps.Google.MapsClient.Types as GT\nimport Kernel.External.Maps.Google.PolyLinePoints (oneCoordEnc, stringToCoords)\nimport Kernel.External.MultiModal.Interface.Types\nimport Kernel.External.MultiModal.OpenTripPlanner.Config (MultiModalWeightedSortCfg (..), validateWeightedSortCfg)\nimport qualified Kernel.External.MultiModal.OpenTripPlanner.Types as OTP\nimport Kernel.Prelude\nimport qualified Kernel.Types.Distance as Distance\nimport qualified Kernel.Types.Time as Time\nimport Kernel.Utils.Time (millisecondsToUTC, parseISO8601UTC, utcToEpochSeconds)\n\nextractDuration :: T.Text -> Int\nextractDuration t = read (filter Char.isDigit (T.unpack t)) :: Int\n\nmakePairs :: [Double] -> [GT.LatLngV2]\nmakePairs (d1 : d2 : ds) = GT.LatLngV2 d1 d2 : makePairs ds\nmakePairs [] = []\nmakePairs _ = []\n\ncatPairs :: [GT.LatLngV2] -> [Double]\ncatPairs [] = []\ncatPairs (GT.LatLngV2 a b : xs) = a : b : catPairs xs\n\naddPair :: GT.LatLngV2 -> GT.LatLngV2 -> GT.LatLngV2\naddPair (GT.LatLngV2 x1 y1) (GT.LatLngV2 x2 y2) = GT.LatLngV2 (x1 + x2) (y1 + y2)\n\nsubPair :: GT.LatLngV2 -> GT.LatLngV2 -> GT.LatLngV2\nsubPair (GT.LatLngV2 x1 y1) (GT.LatLngV2 x2 y2) = GT.LatLngV2 (x1 - x2) (y1 - y2)\n\nadjDiff :: [GT.LatLngV2] -> [GT.LatLngV2]\nadjDiff p = zipWith subPair p (GT.LatLngV2 0 0 : p)\n\ndecode :: T.Text -> [GT.LatLngV2]\ndecode = scanl1 addPair . makePairs . stringToCoords . TE.encodeUtf8\n\nencode :: [GT.LatLngV2] -> T.Text\nencode = T.concat . fmap oneCoordEnc . catPairs . adjDiff\n\nconvertModeToGeneral :: OTP.Mode -> GeneralVehicleType\nconvertModeToGeneral OTP.ModeBUS = Bus\nconvertModeToGeneral OTP.ModeRAIL = MetroRail\nconvertModeToGeneral OTP.ModeMONORAIL = MetroRail\nconvertModeToGeneral OTP.ModeSUBWAY = Subway\nconvertModeToGeneral OTP.ModeWALK = Walk\nconvertModeToGeneral _ = Unspecified\n\nconvertTransitVehicleToGeneral :: GT.TransitVehicleTypeV2 -> GeneralVehicleType\nconvertTransitVehicleToGeneral GT.VEHICLE_TYPE_BUS = Bus\nconvertTransitVehicleToGeneral GT.VEHICLE_TYPE_HEAVY_RAIL = MetroRail\nconvertTransitVehicleToGeneral GT.VEHICLE_TYPE_HIGH_SPEED_TRAIN = MetroRail\nconvertTransitVehicleToGeneral GT.VEHICLE_TYPE_LONG_DISTANCE_TRAIN = MetroRail\nconvertTransitVehicleToGeneral GT.VEHICLE_TYPE_METRO_RAIL = MetroRail\nconvertTransitVehicleToGeneral GT.VEHICLE_TYPE_MONORAIL = MetroRail\nconvertTransitVehicleToGeneral GT.VEHICLE_TYPE_RAIL = MetroRail\nconvertTransitVehicleToGeneral GT.VEHICLE_TYPE_SUBWAY = Subway\nconvertTransitVehicleToGeneral _ = Unspecified\n\nconvertGoogleToGeneric :: GT.AdvancedDirectionsResp -> MultiModalResponse\nconvertGoogleToGeneric gResponse =\n  let gRoutes = gResponse.routes\n      genericRoutes = foldr accumulateRoutes [] gRoutes\n   in MultiModalResponse\n        { routes = genericRoutes\n        }\n  where\n    accumulateRoutes :: GT.RouteV2 -> [MultiModalRoute] -> [MultiModalRoute]\n    accumulateRoutes gRoute genericRoutes =\n      let routeDuration = extractDuration gRoute.duration\n          routeDistance =\n            Distance.Distance\n              { value =\n                  Distance.HighPrecDistance\n                    { getHighPrecDistance = toRational gRoute.distanceMeters\n                    },\n                unit = Distance.Meter\n              }\n          gLegs = gRoute.legs\n          routeLegs = adjustWalkingLegs $ mergeWalkingLegs $ foldr accumulateLegs [] gLegs\n       in MultiModalRoute\n            { distance = routeDistance,\n              duration = Time.Seconds routeDuration,\n              legs = routeLegs,\n              startTime = Nothing,\n              endTime = Nothing,\n              relevanceScore = Nothing\n            } :\n          genericRoutes\n    accumulateLegs :: GT.LegV2 -> [MultiModalLeg] -> [MultiModalLeg]\n    accumulateLegs gLeg genericLegs =\n      let gSteps = gLeg.steps\n       in genericLegs ++ foldr accumulateSteps [] gSteps\n    accumulateSteps :: GT.StepV2 -> [MultiModalLeg] -> [MultiModalLeg]\n    accumulateSteps gStep genericLegs =\n      let stepDuration = extractDuration gStep.staticDuration\n          stepDistance =\n            Distance.Distance\n              { value =\n                  Distance.HighPrecDistance\n                    { getHighPrecDistance = toRational gStep.distanceMeters\n                    },\n                unit = Distance.Meter\n              }\n          stepPolyline = GT.encodedPolyline gStep.polyline\n          (stepTravelMode, genericAgency, fromStopDetails', toStopDetails', fromArrivalTime', fromDepartureTime', toArrivalTime', toDepartureTime') = case gStep.travelMode of\n            GT.TRANSIT ->\n              case gStep.transitDetails of\n                Just details ->\n                  let travelM = convertTransitVehicleToGeneral details.transitLine.vehicle._type\n                      gAgency = safeHead details.transitLine.agencies\n                      eName = details.stopDetails.arrivalStop.name\n                      sName = details.stopDetails.departureStop.name\n                      fDepartureTime = parseISO8601UTC $ T.unpack details.stopDetails.departureTime\n                      tArrivalTime = parseISO8601UTC $ T.unpack details.stopDetails.arrivalTime\n                      fromDetails =\n                        MultiModalStopDetails\n                          { stopCode = Nothing,\n                            name = Just sName,\n                            gtfsId = Nothing,\n                            platformCode = Nothing\n                          }\n                      toDetails =\n                        MultiModalStopDetails\n                          { stopCode = Nothing,\n                            name = Just eName,\n                            gtfsId = Nothing,\n                            platformCode = Nothing\n                          }\n                      generAgency = case gAgency of\n                        Just x ->\n                          Just\n                            MultiModalAgency\n                              { gtfsId = Nothing,\n                                name = x.name\n                              }\n                        Nothing -> Nothing\n                   in (travelM, generAgency, Just fromDetails, Just toDetails, Nothing, fDepartureTime, tArrivalTime, Nothing)\n                Nothing -> (Unspecified, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing)\n            _ -> (Walk, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing)\n          (startLocationLat, startLocationLng) = (gStep.startLocation.latLng.latitude, gStep.startLocation.latLng.longitude)\n          (endLocationLat, endLocationLng) = (gStep.endLocation.latLng.latitude, gStep.endLocation.latLng.longitude)\n       in MultiModalLeg\n            { distance = stepDistance,\n              duration = Time.Seconds stepDuration,\n              polyline =\n                GT.Polyline\n                  { encodedPolyline = stepPolyline\n                  },\n              mode = stepTravelMode,\n              fromStopDetails = fromStopDetails',\n              toStopDetails = toStopDetails',\n              startLocation =\n                GT.LocationV2\n                  { latLng =\n                      GT.LatLngV2\n                        { latitude = startLocationLat,\n                          longitude = startLocationLng\n                        }\n                  },\n              endLocation =\n                GT.LocationV2\n                  { latLng =\n                      GT.LatLngV2\n                        { latitude = endLocationLat,\n                          longitude = endLocationLng\n                        }\n                  },\n              agency = genericAgency,\n              liveVehicleAvailableServiceTypes = [],\n              fromArrivalTime = fromArrivalTime',\n              fromDepartureTime = fromDepartureTime',\n              toArrivalTime = toArrivalTime',\n              toDepartureTime = toDepartureTime',\n              routeDetails = [],\n              entrance = Nothing,\n              exit = Nothing\n            } :\n          genericLegs\n    mergeWalkingLegs :: [MultiModalLeg] -> [MultiModalLeg]\n    mergeWalkingLegs [] = []\n    mergeWalkingLegs (leg : legs) = mergeLeg leg legs\n      where\n        mergeLeg currentLeg [] = [currentLeg]\n        mergeLeg currentLeg (nextLeg : restLegs)\n          | currentLeg.mode == Walk && nextLeg.mode == Walk =\n            mergeLeg (mergeTwoLegs currentLeg nextLeg) restLegs\n          | otherwise = currentLeg : mergeLeg nextLeg restLegs\n\n    mergeTwoLegs :: MultiModalLeg -> MultiModalLeg -> MultiModalLeg\n    mergeTwoLegs leg1 leg2 =\n      let leg1Start = leg1.startLocation\n          leg2Start = leg2.startLocation\n          leg2End = leg2.endLocation\n          encodedPolylineText = encode [leg1Start.latLng, leg2Start.latLng, leg2End.latLng]\n       in MultiModalLeg\n            { distance =\n                Distance.Distance\n                  { value =\n                      Distance.HighPrecDistance\n                        { getHighPrecDistance = fromRational leg1.distance.value.getHighPrecDistance + fromRational leg2.distance.value.getHighPrecDistance\n                        },\n                    unit = leg1.distance.unit\n                  },\n              duration = Time.Seconds $ leg1.duration.getSeconds + leg2.duration.getSeconds,\n              polyline = GT.Polyline {encodedPolyline = encodedPolylineText},\n              mode = Walk,\n              startLocation = leg1Start,\n              endLocation = leg2End,\n              fromStopDetails = leg1.fromStopDetails,\n              toStopDetails = leg2.toStopDetails,\n              agency = Nothing,\n              liveVehicleAvailableServiceTypes = [],\n              fromArrivalTime = leg1.fromArrivalTime,\n              fromDepartureTime = leg1.fromDepartureTime,\n              toArrivalTime = leg2.toArrivalTime,\n              toDepartureTime = leg2.toDepartureTime,\n              routeDetails = leg1.routeDetails,\n              entrance = leg1.entrance,\n              exit = leg2.exit\n            }\n    adjustWalkingLegs :: [MultiModalLeg] -> [MultiModalLeg]\n    adjustWalkingLegs [] = []\n    adjustWalkingLegs [leg] = [leg]\n    adjustWalkingLegs (leg1 : leg2 : rest) =\n      let adjustedLeg1 =\n            if leg1.mode == Walk && leg2.mode /= Walk\n              then leg1{toStopDetails = leg2.fromStopDetails, toDepartureTime = leg2.fromDepartureTime, toArrivalTime = leg2.fromArrivalTime}\n              else leg1\n          adjustedLeg2 =\n            if leg2.mode == Walk && leg1.mode /= Walk\n              then leg2{fromStopDetails = leg1.toStopDetails, fromDepartureTime = leg1.toDepartureTime, fromArrivalTime = leg1.toArrivalTime}\n              else leg2\n       in adjustedLeg1 : adjustWalkingLegs (adjustedLeg2 : rest)\n\nconvertOTPToGeneric :: OTP.OTPPlan -> Distance.Meters -> [GeneralVehicleType] -> Int -> SortingType -> MultiModalWeightedSortCfg -> MultiModalResponse\nconvertOTPToGeneric otpResponse minimumWalkDistance permissibleModes maxAllowedPublicTransportLegs sortingType relevanceSortCfg =\n  let itineraries = otpResponse.plan.itineraries\n      (genericRoutes, frequencyMap) = foldr accumulateItineraries ([], HM.empty) itineraries\n      mergedRoutes = map mergeConsecutiveMetroLegs genericRoutes\n      orderedRoutes = map assignSubLegOrderToRoute mergedRoutes -- Assign subLegOrder here\n      updatedRoutes = map (updateRouteAlternateShortNames frequencyMap) orderedRoutes\n      filteredRoutes = map (removeShortWalkLegs minimumWalkDistance) updatedRoutes\n      filteredByPermissibleModes = filter (hasOnlyPermissibleModes permissibleModes) filteredRoutes\n      filteredByMaxPublicTransport = filter (withinMaxAllowedPublicTransportModes maxAllowedPublicTransportLegs) filteredByPermissibleModes\n      !_string = DT.trace $ \"Filtered by max public transport: \" <> show filteredByMaxPublicTransport <> \" \" <> show maxAllowedPublicTransportLegs <> \" \" <> show permissibleModes <> \" \" <> show sortingType <> \" \" <> show otpResponse <> \" \" <> show itineraries <> \" \" <> show genericRoutes <> \" \" <> show frequencyMap <> \" \" <> show mergedRoutes <> \" \" <> show orderedRoutes <> \" \" <> show updatedRoutes <> \" \" <> show filteredRoutes <> \" \" <> show filteredByPermissibleModes\n      sortedRoutes = case sortingType of\n        Fastest -> sortRoutesByDuration filteredByMaxPublicTransport\n        MinimumTransits -> sortRoutesByNumberOfLegs filteredByMaxPublicTransport\n        MostRelevant ->\n          if validateWeightedSortCfg relevanceSortCfg\n            then\n              let (onlyWalkItineraries, otherItineraries) = partition (\\r -> all (\\leg -> leg.mode == Walk) r.legs) filteredByMaxPublicTransport\n                  sortedItineraries = sortByRelevance $ addRelevanceScore relevanceSortCfg otherItineraries\n               in sortedItineraries <> onlyWalkItineraries\n            else filteredByMaxPublicTransport\n      finalRoutes = uniqueRoutes sortedRoutes\n   in MultiModalResponse\n        { routes = finalRoutes\n        }\n  where\n    sortRoutesByDuration :: [MultiModalRoute] -> [MultiModalRoute]\n    sortRoutesByDuration = sortBy (\\r1 r2 -> compare (r1.duration.getSeconds) (r2.duration.getSeconds))\n\n    sortRoutesByNumberOfLegs :: [MultiModalRoute] -> [MultiModalRoute]\n    sortRoutesByNumberOfLegs = sortBy (\\r1 r2 -> compare (length r1.legs) (length r2.legs))\n\n    sortByRelevance :: [MultiModalRoute] -> [MultiModalRoute]\n    sortByRelevance = sortBy relevanceComparator\n\n    relevanceComparator :: MultiModalRoute -> MultiModalRoute -> Ordering\n    relevanceComparator r1 r2 =\n      case (r1.relevanceScore, r2.relevanceScore) of\n        (Just score1, Just score2) -> compare score1 score2\n        (Nothing, Nothing) -> EQ\n        (Just _, Nothing) -> LT\n        (Nothing, Just _) -> GT\n\n    calculateRouteDuration :: MultiModalRoute -> Maybe Time.Seconds\n    calculateRouteDuration route = Just route.duration\n\n    getArrivalTime :: MultiModalRoute -> Maybe UTCTime\n    getArrivalTime route = route.endTime\n\n    getTransfers :: MultiModalRoute -> Maybe Int\n    getTransfers route = do\n      case filter (\\leg -> leg.mode /= Walk) route.legs of\n        [] -> Nothing\n        legs -> Just $ length legs\n\n    calculateNormalizerData :: [MultiModalRoute] -> Maybe NormalizerData\n    calculateNormalizerData [] = Nothing\n    calculateNormalizerData (firstRoute : routes) = do\n      let maxDuration = calculateRouteDuration firstRoute\n          minDuration = maxDuration\n          maxArrivalTime = getArrivalTime firstRoute\n          minArrivalTime = maxArrivalTime\n          maxTransfers = Just 5 -- hardcoded, to reduce skewness in score because of transfers\n          minTransfers = getTransfers firstRoute\n          normalizerDataInit = NormalizerData {..}\n      Just $ getData normalizerDataInit\n      where\n        getData normalizerDataInit =\n          foldr\n            ( \\route normalizerData -> do\n                let routeDur = calculateRouteDuration route\n                    routeAT = getArrivalTime route\n                    routeTf = getTransfers route\n                    maxDuration = liftA2 max routeDur normalizerData.maxDuration\n                    minDuration = liftA2 min routeDur normalizerData.minDuration\n                    maxArrivalTime = liftA2 max routeAT normalizerData.maxArrivalTime\n                    minArrivalTime = liftA2 min routeAT normalizerData.minArrivalTime\n                    maxTransfers = liftA2 max routeTf normalizerData.maxTransfers\n                    minTransfers = liftA2 min routeTf normalizerData.minTransfers\n                NormalizerData {..}\n            )\n            normalizerDataInit\n            routes\n\n    normalize :: (Num a, Ord a, Eq a, Integral a) => a -> a -> a -> Maybe Double\n    normalize x minVal maxVal = do\n      if maxVal < minVal || x < minVal || x > maxVal\n        then Nothing\n        else\n          if maxVal == minVal\n            then Just 0\n            else Just $ fromIntegral (x - minVal) / fromIntegral (maxVal - minVal)\n\n    normalizeSeconds :: Time.Seconds -> Time.Seconds -> Time.Seconds -> Maybe Double\n    normalizeSeconds x minVal maxVal = normalize x.getSeconds minVal.getSeconds maxVal.getSeconds\n\n    normalizeUTCTime :: UTCTime -> UTCTime -> UTCTime -> Maybe Double\n    normalizeUTCTime x minVal maxVal = do\n      let maxVal' = utcToEpochSeconds maxVal\n          minVal' = utcToEpochSeconds minVal\n          x' = utcToEpochSeconds x\n      normalizeSeconds x' minVal' maxVal'\n\n    maxDouble :: Double\n    maxDouble = 5\n\n    calculateRelevanceScore :: MultiModalWeightedSortCfg -> NormalizerData -> MultiModalRoute -> Double\n    calculateRelevanceScore weight NormalizerData {..} route =\n      let routeDur = calculateRouteDuration route\n          routeAT = getArrivalTime route\n          routeTf = getTransfers route\n          normDur :: Maybe Double = join $ liftA3 normalizeSeconds routeDur minDuration maxDuration\n          normAT :: Maybe Double = join $ liftA3 normalizeUTCTime routeAT minArrivalTime maxArrivalTime\n          normTf :: Maybe Double = join $ liftA3 normalize routeTf minTransfers maxTransfers\n          durScore = maybe maxDouble (* weight.duration) normDur\n          aTScore = maybe maxDouble (* weight.arrivalTime) normAT\n          tfScore = maybe maxDouble (* weight.transfers) normTf\n       in durScore + aTScore + tfScore\n\n    addRelevanceScore :: MultiModalWeightedSortCfg -> [MultiModalRoute] -> [MultiModalRoute]\n    addRelevanceScore weight routes = do\n      maybe\n        routes\n        ( \\normData -> do\n            map\n              ( \\route ->\n                  let relevanceScore = calculateRelevanceScore weight normData route\n                   in route {relevanceScore = Just relevanceScore}\n              )\n              routes\n        )\n        (calculateNormalizerData routes)\n\n    removeShortWalkLegs :: Distance.Meters -> MultiModalRoute -> MultiModalRoute\n    removeShortWalkLegs threshold route =\n      let thresholdValue = fromIntegral $ Distance.getMeters threshold -- Convert threshold to Double for comparison\n          legsWithIndices = zip [0 ..] route.legs -- Pair each leg with its index\n          totalLegs = length route.legs\n          filteredLegs =\n            [ leg\n              | (index, leg) <- legsWithIndices,\n                not (leg.mode == Walk && getLegDistance leg < thresholdValue && index /= 0 && index /= totalLegs - 1)\n            ]\n       in route {legs = filteredLegs}\n\n    getLegDistance :: MultiModalLeg -> Double\n    getLegDistance leg = fromRational $ leg.distance.value.getHighPrecDistance\n\n    -- Filter routes to include only those with permissible modes\n    hasOnlyPermissibleModes :: [GeneralVehicleType] -> MultiModalRoute -> Bool\n    hasOnlyPermissibleModes permissibleModesInRoute route =\n      all (\\leg -> leg.mode `elem` permissibleModesInRoute) route.legs\n\n    -- Filter routes with at most a specified number of legs of Public Transport Type: [Bus, MetroRail]\n    withinMaxAllowedPublicTransportModes :: Int -> MultiModalRoute -> Bool\n    withinMaxAllowedPublicTransportModes maxAllowed route =\n      let publicTransportLegs = filter (\\leg -> leg.mode `elem` [Bus, MetroRail, Subway]) route.legs\n       in length publicTransportLegs <= maxAllowed\n\n    -- Assign subLegOrder to each routeDetails within every leg\n    assignSubLegOrderToRoute :: MultiModalRoute -> MultiModalRoute\n    assignSubLegOrderToRoute route =\n      let updatedLegs = map assignSubLegOrderToLeg route.legs\n       in route {legs = updatedLegs}\n\n    assignSubLegOrderToLeg :: MultiModalLeg -> MultiModalLeg\n    assignSubLegOrderToLeg leg =\n      let updatedRouteDetails = zipWith (\\i rd -> rd {subLegOrder = i}) [1 ..] leg.routeDetails\n       in leg {routeDetails = updatedRouteDetails}\n\n    -- Merge consecutive MetroRail legs in a route\n    mergeConsecutiveMetroLegs :: MultiModalRoute -> MultiModalRoute\n    mergeConsecutiveMetroLegs route =\n      let mergedLegs = mergeMetroLegs route.legs\n       in route {legs = mergedLegs}\n\n    -- Recursive function to merge consecutive MetroRail legs\n    mergeMetroLegs :: [MultiModalLeg] -> [MultiModalLeg]\n    mergeMetroLegs [] = []\n    mergeMetroLegs [leg] = [leg] -- Single leg, no merging needed\n    mergeMetroLegs (leg1 : leg2 : rest)\n      | (leg1.mode == MetroRail && leg2.mode == MetroRail) && leg1.agency == leg2.agency =\n        let leg1Start = leg1.startLocation\n            leg2Start = leg2.startLocation\n            leg2End = leg2.endLocation\n            encodedPolylineText = encode [leg1Start.latLng, leg2Start.latLng, leg2End.latLng]\n            mergedLeg =\n              MultiModalLeg\n                { distance =\n                    Distance.Distance\n                      { value =\n                          Distance.HighPrecDistance\n                            { getHighPrecDistance = fromRational leg1.distance.value.getHighPrecDistance + fromRational leg2.distance.value.getHighPrecDistance\n                            },\n                        unit = leg1.distance.unit\n                      },\n                  duration = Time.Seconds $ leg1.duration.getSeconds + leg2.duration.getSeconds,\n                  polyline = GT.Polyline {encodedPolyline = encodedPolylineText},\n                  mode = leg1.mode,\n                  startLocation = leg1.startLocation,\n                  endLocation = leg2.endLocation,\n                  liveVehicleAvailableServiceTypes = nub (leg1.liveVehicleAvailableServiceTypes ++ leg2.liveVehicleAvailableServiceTypes),\n                  fromStopDetails = leg1.fromStopDetails,\n                  toStopDetails = leg2.toStopDetails,\n                  routeDetails = leg1.routeDetails ++ leg2.routeDetails,\n                  agency = leg1.agency,\n                  fromArrivalTime = min <$> leg1.fromArrivalTime <*> leg2.fromArrivalTime,\n                  fromDepartureTime = min <$> leg1.fromDepartureTime <*> leg2.fromDepartureTime,\n                  toArrivalTime = max <$> leg1.toArrivalTime <*> leg2.toArrivalTime,\n                  toDepartureTime = max <$> leg1.toDepartureTime <*> leg2.toDepartureTime,\n                  entrance = leg1.entrance,\n                  exit = leg2.exit\n                }\n         in mergeMetroLegs (mergedLeg : rest) -- Add merged leg and continue\n      | otherwise = leg1 : mergeMetroLegs (leg2 : rest) -- Keep leg1, process the rest\n    accumulateItineraries :: Maybe OTP.OTPPlanPlanItineraries -> ([MultiModalRoute], HM.HashMap T.Text [T.Text]) -> ([MultiModalRoute], HM.HashMap T.Text [T.Text])\n    accumulateItineraries itinerary (genericRoutes, freqMap) =\n      case itinerary of\n        Nothing -> (genericRoutes, freqMap)\n        Just itinerary' ->\n          let duration = fromMaybe 0.0 itinerary'.duration\n              (legs, distance, updatedFreqMap) = foldr accumulateLegs ([], 0.0, freqMap) itinerary'.legs\n              route =\n                MultiModalRoute\n                  { duration = Time.Seconds $ round duration,\n                    distance =\n                      Distance.Distance\n                        { value =\n                            Distance.HighPrecDistance\n                              { getHighPrecDistance = toRational distance\n                              },\n                          unit = Distance.Meter\n                        },\n                    legs = legs,\n                    startTime = (millisecondsToUTC . round) <$> itinerary'.startTime,\n                    endTime = (millisecondsToUTC . round) <$> itinerary'.endTime,\n                    relevanceScore = Nothing\n                  }\n           in (route : genericRoutes, updatedFreqMap)\n\n    accumulateLegs :: Maybe OTP.OTPPlanPlanItinerariesLegs -> ([MultiModalLeg], Double, HM.HashMap T.Text [T.Text]) -> ([MultiModalLeg], Double, HM.HashMap T.Text [T.Text])\n    accumulateLegs otpLeg (genericLegs, genericDistance, updatedFreqMap) =\n      case otpLeg of\n        Nothing -> (genericLegs, genericDistance, updatedFreqMap)\n        Just otpLeg' ->\n          let distance = fromMaybe 0.0 otpLeg'.distance\n              duration = fromMaybe 0.0 otpLeg'.duration\n              mode = convertModeToGeneral $ fromMaybe OTP.ModeTRANSIT otpLeg'.mode\n              startLocName = fmap T.pack $ if fromMaybe \"\" otpLeg'.from.name == \"Origin\" then Nothing else otpLeg'.from.name\n              endLocName = fmap T.pack $ if fromMaybe \"\" otpLeg'.to.name == \"Destination\" then Nothing else otpLeg'.to.name\n              encodedPolylineText = T.pack $ maybe \"\" (\\x -> fromMaybe \"\" x.points) otpLeg'.legGeometry\n              (startLat, startLng) = (otpLeg'.from.lat, otpLeg'.from.lon)\n              (endLat, endLng) = (otpLeg'.to.lat, otpLeg'.to.lon)\n              routeAgency = otpLeg'.route\n              liveVehicleAvailableServiceTypes = nub $ maybe [] (mapMaybe extractServiceType) (otpLeg'.route >>= \\r -> r.trips)\n                where\n                  extractServiceType (Just trip) =\n                    case splitOn \"-\" (T.unpack $ gtfsIdtoDomainCode $ T.pack trip.gtfsId) of\n                      [_prefix, middle, _suffix] -> Just $ T.pack middle\n                      _ -> Nothing\n                  extractServiceType Nothing = Nothing\n              fromArrivalTime' = Just $ millisecondsToUTC $ round otpLeg'.from.arrivalTime\n              fromDepartureTime' = Just $ millisecondsToUTC $ round otpLeg'.from.departureTime\n              toArrivalTime' = Just $ millisecondsToUTC $ round otpLeg'.to.arrivalTime\n              toDepartureTime' = Just $ millisecondsToUTC $ round otpLeg'.to.departureTime\n              (fromStopCode, fromStopGtfsId, fromStopPlatformCode) = case otpLeg'.from.stop of\n                Just x -> (x.code, Just x.gtfsId, x.platformCode)\n                Nothing -> (Nothing, Nothing, Nothing)\n              fromStopDetails' =\n                if mode == Walk\n                  then Nothing\n                  else\n                    Just\n                      MultiModalStopDetails\n                        { stopCode = fmap T.pack fromStopCode,\n                          name = startLocName,\n                          gtfsId = fmap T.pack fromStopGtfsId,\n                          platformCode = fmap T.pack fromStopPlatformCode\n                        }\n              (toStopCode, toStopGtfsId, toStopPlatformCode) = case otpLeg'.to.stop of\n                Just x -> (x.code, Just x.gtfsId, x.platformCode)\n                Nothing -> (Nothing, Nothing, Nothing)\n              toStopDetails' =\n                if mode == Walk\n                  then Nothing\n                  else\n                    Just\n                      MultiModalStopDetails\n                        { stopCode = fmap T.pack toStopCode,\n                          name = endLocName,\n                          gtfsId = fmap T.pack toStopGtfsId,\n                          platformCode = fmap T.pack toStopPlatformCode\n                        }\n              genericAgency = case routeAgency of\n                Nothing -> Nothing\n                Just ag ->\n                  Just $\n                    MultiModalAgency\n                      { gtfsId = (\\x -> Just $ T.pack x.gtfsId) =<< ag.agency,\n                        name = maybe \"\" (\\x -> T.pack x.name) ag.agency\n                      }\n\n              routeDetails = case otpLeg'.route of\n                Just route ->\n                  [ MultiModalRouteDetails\n                      { gtfsId = Just $ T.pack route.gtfsId,\n                        longName = fmap T.pack route.longName,\n                        shortName = fmap T.pack route.shortName,\n                        color = fmap T.pack route.color,\n                        alternateShortNames = [],\n                        fromStopDetails = fromStopDetails',\n                        toStopDetails = toStopDetails',\n                        startLocation =\n                          GT.LocationV2\n                            { latLng =\n                                GT.LatLngV2\n                                  { latitude = startLat,\n                                    longitude = startLng\n                                  }\n                            },\n                        endLocation =\n                          GT.LocationV2\n                            { latLng =\n                                GT.LatLngV2\n                                  { latitude = endLat,\n                                    longitude = endLng\n                                  }\n                            },\n                        subLegOrder = 1,\n                        fromArrivalTime = fromArrivalTime',\n                        fromDepartureTime = fromDepartureTime',\n                        toArrivalTime = toArrivalTime',\n                        toDepartureTime = toDepartureTime'\n                      }\n                  ]\n                Nothing -> []\n\n              -- Update the frequency map only if fromStopCode and toStopCode exists\n              newFreqMap = case (fromStopCode, toStopCode, otpLeg'.route >>= (.shortName)) of\n                (Just fromStopCode', Just toStopCode', Just shortName) ->\n                  let key = T.pack fromStopCode' <> \"-\" <> T.pack toStopCode'\n                   in HM.insertWith (\\new old -> nub (new ++ old)) key [T.pack shortName] updatedFreqMap\n                _ -> updatedFreqMap\n\n              leg =\n                MultiModalLeg\n                  { distance =\n                      Distance.Distance\n                        { value =\n                            Distance.HighPrecDistance\n                              { getHighPrecDistance = toRational distance\n                              },\n                          unit = Distance.Meter\n                        },\n                    duration = Time.Seconds $ round duration,\n                    polyline =\n                      GT.Polyline\n                        { encodedPolyline = encodedPolylineText\n                        },\n                    fromStopDetails = fromStopDetails',\n                    toStopDetails = toStopDetails',\n                    mode = mode,\n                    startLocation =\n                      GT.LocationV2\n                        { latLng =\n                            GT.LatLngV2\n                              { latitude = startLat,\n                                longitude = startLng\n                              }\n                        },\n                    routeDetails = routeDetails,\n                    liveVehicleAvailableServiceTypes = liveVehicleAvailableServiceTypes,\n                    endLocation =\n                      GT.LocationV2\n                        { latLng =\n                            GT.LatLngV2\n                              { latitude = endLat,\n                                longitude = endLng\n                              }\n                        },\n                    agency = genericAgency,\n                    fromArrivalTime = fromArrivalTime',\n                    fromDepartureTime = fromDepartureTime',\n                    toArrivalTime = toArrivalTime',\n                    toDepartureTime = toDepartureTime',\n                    entrance = (maybeEntranceToGate otpLeg'.entrance),\n                    exit = (maybeExitToGate otpLeg'.exit)\n                  }\n           in (leg : genericLegs, genericDistance + distance, newFreqMap)\n\n    -- Update frequency of each leg in a route using the frequencyMap\n    updateRouteAlternateShortNames :: HM.HashMap T.Text [T.Text] -> MultiModalRoute -> MultiModalRoute\n    updateRouteAlternateShortNames freqMap route =\n      let updatedLegs = map updateLegAlternateShortNames route.legs\n       in route {legs = updatedLegs}\n      where\n        updateLegAlternateShortNames :: MultiModalLeg -> MultiModalLeg\n        updateLegAlternateShortNames leg =\n          let updatedRouteDetails = updateDetailsAlternateShortNames freqMap <$> leg.routeDetails\n           in leg {routeDetails = updatedRouteDetails}\n\n        updateDetailsAlternateShortNames :: HM.HashMap T.Text [T.Text] -> MultiModalRouteDetails -> MultiModalRouteDetails\n        updateDetailsAlternateShortNames frequencyMap details =\n          case (details.fromStopDetails >>= (.stopCode), details.toStopDetails >>= (.stopCode)) of\n            (Just fromStopCode, Just toStopCode) ->\n              let key = fromStopCode <> \"-\" <> toStopCode\n                  shortNames = HM.lookupDefault [] key frequencyMap\n               in details {alternateShortNames = shortNames}\n            _ -> details\n\n    -- Function to get the sequence combination for a route\n    getSequenceCombination :: MultiModalRoute -> T.Text\n    getSequenceCombination route =\n      let sequenceCombination = concatMap (mapMaybe (\\r -> (\\f t -> f <> \"-\" <> t) <$> (r.fromStopDetails >>= (.stopCode)) <*> (r.toStopDetails >>= (.stopCode))) . (.routeDetails)) route.legs\n       in T.intercalate \"-\" sequenceCombination\n\n    -- Function to filter routes with unique sequence combinations\n    uniqueRoutes :: [MultiModalRoute] -> [MultiModalRoute]\n    uniqueRoutes routes =\n      let -- Create a map that tracks sequence combinations\n          seenCombinations = Map.empty\n          -- Filter routes based on unique sequence combinations\n          (newUniqueRoutes, _) =\n            foldl\n              ( \\(accRoutes, seen) route ->\n                  let seqComb = getSequenceCombination route\n                   in if Map.member seqComb seen\n                        then (accRoutes, seen)\n                        else (accRoutes ++ [route], Map.insert seqComb () seen)\n              )\n              ([], seenCombinations)\n              routes\n       in newUniqueRoutes\n\ngtfsIdtoDomainCode :: Text -> Text\ngtfsIdtoDomainCode gtfsId = case break (== ':') $ T.unpack gtfsId of\n  (_, ':' : code) -> T.pack code\n  _ -> gtfsId\n\nmaybeEntranceToGate :: Maybe OTP.OTPPlanPlanItinerariesLegsEntrance -> Maybe MultiModalLegGate\nmaybeEntranceToGate Nothing = Nothing\nmaybeEntranceToGate (Just entrance) =\n  Just $\n    MultiModalLegGate\n      { distance = entrance.distance,\n        lon = entrance.lon,\n        lat = entrance.lat,\n        isEntrance = Just True, -- Mark as entrance\n        absoluteDirection = entrance.absoluteDirection,\n        streetName = T.pack <$> entrance.streetName,\n        exit = T.pack <$> entrance.exit,\n        stayOn = entrance.stayOn,\n        area = entrance.area,\n        bogusName = entrance.bogusName,\n        walkingBike = entrance.walkingBike\n      }\n\nmaybeExitToGate :: Maybe OTP.OTPPlanPlanItinerariesLegsExit -> Maybe MultiModalLegGate\nmaybeExitToGate Nothing = Nothing\nmaybeExitToGate (Just exit) =\n  Just $\n    MultiModalLegGate\n      { distance = exit.distance,\n        lon = exit.lon,\n        lat = exit.lat,\n        isEntrance = Just False, -- Mark as exit\n        absoluteDirection = exit.absoluteDirection,\n        streetName = T.pack <$> exit.streetName,\n        exit = T.pack <$> exit.exit,\n        stayOn = exit.stayOn,\n        area = exit.area,\n        bogusName = exit.bogusName,\n        walkingBike = exit.walkingBike\n      }\n",
      "hash": "3edb0ca0ac76c21819ff7841aeaded77183dde03efedc496ce78229f0b6d6671",
      "size": 35132
    },
    "/lib/mobility-core/src/Kernel/External/Notification.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n\nmodule Kernel.External.Notification (module Reexport) where\n\nimport Kernel.External.Notification.Interface as Reexport\n",
      "hash": "225da939b7306bcb0121d0212c04b71ce59dfdbac659dc219546debd1d9a68ad",
      "size": 813
    },
    "/lib/mobility-core/src/Kernel/External/Notification/FCM/Error.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n\nmodule Kernel.External.Notification.FCM.Error where\n\nimport Kernel.Prelude hiding (error)\n\nnewtype FcmError = FcmError\n  { error :: Maybe ErrorRes\n  }\n  deriving (Show, Generic, FromJSON, ToJSON)\n\ndata ErrorRes = ErrorRes\n  { code :: Maybe Int,\n    message :: Maybe String,\n    status :: Maybe String,\n    details :: Maybe [ErrorDetail]\n  }\n  deriving (Show, Generic, FromJSON, ToJSON)\n\nnewtype ErrorDetail = ErrorDetail\n  { errorCode :: Maybe String\n  }\n  deriving (Show, Generic, FromJSON, ToJSON)\n",
      "hash": "4211e54b087b8dfe018d90232353d00c39a330a14ec9a511e198d2fa3a748acf",
      "size": 1194
    },
    "/lib/mobility-core/src/Kernel/External/Notification/FCM/Flow.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n{-# LANGUAGE OverloadedStrings #-}\n{-# LANGUAGE ScopedTypeVariables #-}\n\n-- |\n-- Module      : FCM.Flow\n-- Description : Firebase Cloud Messaging module\n--\n-- FCM description: https://firebase.google.com/docs/cloud-messaging\n-- Firebase Cloud Messaging (FCM) is a cross-platform messaging solution\n-- that lets you reliably send messages at no cost. Using FCM, you can notify\n-- a client app that new email or other data is available to sync. You can\n-- send notification messages to drive user re-engagement and retention.\n-- For use cases such as instant messaging, a message can transfer\n-- a payload of up to 4KB to a client app.\n--\n-- Protocol description : https://firebase.google.com/docs/reference/fcm/rest/v1/projects.messages\nmodule Kernel.External.Notification.FCM.Flow\n  ( createMessage,\n    createAndroidNotification,\n    notifyPerson,\n    notifyPersonWithPriority,\n    FCMSendMessageAPI,\n    fcmSendMessageAPI,\n    parseFCMAccount,\n    createAndroidNotificationWithIcon,\n    createAndroidOverlayNotification,\n    ApnsLiveActivityAPI,\n    apnsLiveActivityAPI,\n    updateLiveActivity,\n    createApnsLiveActivtyPayload,\n  )\nwhere\n\nimport qualified Data.Aeson as Aeson\nimport qualified Data.ByteString.Lazy as BL\nimport Data.Default.Class\nimport qualified Data.Text as T'\nimport qualified Data.Text.Encoding as T\nimport qualified Data.Text.Encoding.Base64 as B64\nimport Data.Time.Clock.POSIX (getPOSIXTime)\nimport EulerHS.Prelude hiding ((^.))\nimport qualified EulerHS.Types as ET\nimport Kernel.External.Notification.FCM.Error\nimport Kernel.External.Notification.FCM.Types\nimport qualified Kernel.Storage.Hedis as Redis\nimport Kernel.Tools.Metrics.CoreMetrics (CoreMetrics)\nimport Kernel.Types.Common\nimport Kernel.Utils.Common\nimport qualified Kernel.Utils.JWT as JWT\nimport Servant\nimport Servant.Client (ClientError (..), ResponseF (..))\n\n-- | Create FCM message\n-- Note that data should be formed as key-value pairs list\n-- recipientId::FCMToken is an app's registration token\ncreateMessage :: FCMData a -> FCMRecipientToken -> Maybe FCMAndroidMessagePriority -> (FCMData a -> FCMData b) -> FCMMessage a b\ncreateMessage msgData recipientId priority iosModifier =\n  def{fcmToken = Just recipientId,\n      fcmAndroid = Just androidCfg,\n      fcmApns = Just apnsCfg\n     }\n  where\n    androidCfg = createAndroidConfig msgData priority\n    apnsCfg = createApnsConfig msgData iosModifier\n\n-- | Android Notification details\ncreateAndroidConfig :: FCMData a -> Maybe FCMAndroidMessagePriority -> FCMAndroidConfig a\ncreateAndroidConfig cfgData priority =\n  def{fcmdData = Just cfgData,\n      fcmdPriority = priority\n     }\n\ncreateApnsConfig :: FCMData a -> (FCMData a -> FCMData b) -> FCMApnsConfig b\ncreateApnsConfig androidFcmData iosModifier =\n  def{fcmaPayload = Just apnsPayload,\n      fcmaHeaders =\n        Just\n          ( def{fcmApnsPriority = Just \"10\"\n               }\n          )\n     }\n  where\n    apnsPayload = createApnsPayload androidFcmData iosModifier\n\ncreateApnsPayload :: forall a b. FCMData a -> (FCMData a -> FCMData b) -> FCMApnPayload b\ncreateApnsPayload androidData iosModifier =\n  def {fcmAps = Just fcmAps}\n  where\n    fcmAlert :: FCMAlert\n    fcmAlert =\n      def{fcmBody = (.getFCMNotificationBody) <$> body,\n          fcmTitle = (.getFCMNotificationTitle) <$> title\n         }\n    fcmAps :: FCMaps b\n    fcmAps =\n      def{fcmAlert = if androidData.fcmShowNotification == SHOW then Just fcmAlert else Nothing,\n          fcmData = Just (iosModifier androidData),\n          fcmCategory = Just androidData.fcmNotificationType,\n          fcmMutableContent = 1,\n          fcmSound = Just $ fromMaybe \"\" androidData.fcmNotificationJSON.fcmdSound,\n          fcmContentAvailable = 1,\n          fcmBadge = if androidData.fcmShowNotification == DO_NOT_SHOW then Just 0 else Nothing\n         }\n    title :: Maybe FCMNotificationTitle\n    title = androidData.fcmNotificationJSON.fcmdTitle\n\n    body :: Maybe FCMNotificationBody\n    body = androidData.fcmNotificationJSON.fcmdBody\n\ncreateAndroidNotification :: FCMNotificationTitle -> FCMNotificationBody -> FCMNotificationType -> Maybe Text -> FCMAndroidNotification\ncreateAndroidNotification title body notificationType sound =\n  let notification = case notificationType of\n        ALLOCATION_REQUEST ->\n          def{fcmdChannelId = Just \"RINGING_ALERT\"\n             }\n        TRIP_STARTED ->\n          def{fcmdChannelId = Just \"TRIP_STARTED\"\n             }\n        _ -> def\n   in notification\n        { fcmdTitle = Just title,\n          fcmdBody = Just body,\n          fcmdIcon =\n            Just $\n              FCMNotificationIconUrl\n                \"http://localhost:8080/static/images/ride-success.png\",\n          fcmdTag = Just notificationType,\n          fcmdSound = sound\n        }\n\ncreateAndroidNotificationWithIcon :: FCMNotificationTitle -> FCMNotificationBody -> FCMNotificationType -> Maybe Text -> FCMAndroidNotification\ncreateAndroidNotificationWithIcon title body notificationType mIcon =\n  let notification = def\n   in notification\n        { fcmdTitle = Just title,\n          fcmdBody = Just body,\n          fcmdIcon = Just $ FCMNotificationIconUrl (fromMaybe \"http://localhost:8080/static/images/ride-success.png\" mIcon),\n          fcmdTag = Just notificationType\n        }\n\ncreateAndroidOverlayNotification ::\n  FCMOverlayReq ->\n  FCMOverlayNotificationJSON\ncreateAndroidOverlayNotification _req@FCMOverlayReq {..} =\n  FCMOverlayNotificationJSON\n    { titleVisibility = isJust title,\n      descriptionVisibility = isJust description,\n      buttonOkVisibility = isJust okButtonText,\n      buttonCancelVisibility = isJust cancelButtonText,\n      buttonLayoutVisibility = isJust okButtonText || isJust cancelButtonText,\n      imageVisibility = isJust imageUrl,\n      ..\n    }\n\n-- | Send FCM message to a person\nnotifyPerson ::\n  ( CoreMetrics m,\n    ToJSON a,\n    Redis.HedisFlow m r,\n    MonadFlow m\n  ) =>\n  FCMConfig ->\n  m () ->\n  FCMData a ->\n  FCMNotificationRecipient ->\n  m ()\nnotifyPerson config action msgData recipient = notifyPersonWithPriority config Nothing action msgData recipient EulerHS.Prelude.id\n\nnotifyPersonWithPriority ::\n  ( CoreMetrics m,\n    ToJSON a,\n    ToJSON b,\n    Redis.HedisFlow m r,\n    MonadFlow m\n  ) =>\n  FCMConfig ->\n  Maybe FCMAndroidMessagePriority ->\n  m () ->\n  FCMData a ->\n  FCMNotificationRecipient ->\n  (FCMData a -> FCMData b) ->\n  m ()\nnotifyPersonWithPriority config priority action msgData recipient iosModifier = do\n  let tokenNotFound = \"device token of a person \" <> recipient.id <> \" not found\"\n  case recipient.token of\n    Nothing -> do\n      logTagInfo \"FCM\" tokenNotFound\n      pure ()\n    Just token -> sendMessage config (FCMRequest (createMessage msgData token priority iosModifier)) action recipient.id\n\n-- | Google API interface\ntype FCMSendMessageAPI a b =\n  Header \"Authorization\" FCMAuthToken\n    :> ReqBody '[JSON] (FCMRequest a b)\n    :> Post '[JSON] FCMResponse\n\nfcmSendMessageAPI :: Proxy (FCMSendMessageAPI a b)\nfcmSendMessageAPI = Proxy\n\n-- | Send FCM message to a registered device\nsendMessage ::\n  ( CoreMetrics m,\n    ToJSON a,\n    ToJSON b,\n    Redis.HedisFlow m r,\n    MonadFlow m\n  ) =>\n  FCMConfig ->\n  FCMRequest a b ->\n  m () ->\n  Text ->\n  m ()\nsendMessage config fcmMsg action toWhom = fork desc $ do\n  logTagInfo fcm $ \"Message to be sent to the person: \" <> show (Aeson.encode fcmMsg)\n  authToken <- getTokenText config\n  case authToken of\n    Right token -> do\n      let fcmUrl = config.fcmUrl\n      res <- callAPI fcmUrl (callFCM (Just $ FCMAuthToken token) fcmMsg) \"sendMessage\" fcmSendMessageAPI\n      case res of\n        Right _ -> logTagInfo fcm $ \"Message sent successfully to a person with id \" <> toWhom\n        Left clientError -> do\n          case clientError of\n            FailureResponse _ (Response _ _ _ resbody) -> do\n              let eitherError = Aeson.eitherDecodeStrict (BL.toStrict resbody) :: Either String FcmError\n              case eitherError of\n                Right fcmError -> handleFcmError fcmError action\n                Left errorMsg -> logTagError fcm $ \"FCM decoding failed for person with id : \" <> toWhom <> \" Error Message : \" <> T'.pack errorMsg\n            _ -> return ()\n    Left err -> logTagError fcm $ \"AuthToken error while sending message to person with id \" <> toWhom <> \" : \" <> show err\n  where\n    callFCM token msg = void $ ET.client fcmSendMessageAPI token msg\n    desc = \"FCM send message forked flow\"\n    fcm = \"FCM\"\n\n    handleFcmError :: MonadFlow m => FcmError -> m () -> m ()\n    handleFcmError (FcmError (Just (ErrorRes _ _ _ (Just details)))) action' =\n      mapM_ (`handleDetail` action') details\n    handleFcmError _ _ = pure ()\n\n    handleDetail :: MonadFlow m => ErrorDetail -> m () -> m ()\n    handleDetail (ErrorDetail (Just errorCode)) action' =\n      case errorCode of\n        \"UNREGISTERED\" -> do\n          logTagError fcm $ \"Error while sending message to person with id \" <> toWhom <> \" : \" <> \"device token is unregistered and errorCode is : \" <> show errorCode\n          action'\n        _ -> logTagError fcm $ \"Error while sending message to person with id \" <> toWhom <> \" : \" <> \"unknown error code \" <> show errorCode\n    handleDetail _ _ = pure ()\n\n-- | try to get FCM text token\ngetTokenText ::\n  (Redis.HedisFlow m r, MonadFlow m) =>\n  FCMConfig ->\n  m (Either Text Text)\ngetTokenText config = do\n  token <- getToken config\n  pure $ case token of\n    Left err -> Left $ fromString err\n    Right t -> Right $ JWT.jwtTokenType t <> \" \" <> JWT.jwtAccessToken t\n\nredisFcmKey :: Text\nredisFcmKey = \"mobility:fcm_token\"\n\n-- | Get token (refresh token if expired / invalid)\ngetToken ::\n  (Redis.HedisFlow m r, MonadFlow m) =>\n  FCMConfig ->\n  m (Either String JWT.JWToken)\ngetToken config = do\n  tokenStatus <-\n    Redis.get (config.fcmTokenKeyPrefix <> \":\" <> redisFcmKey) >>= \\case\n      Nothing -> pure $ Left \"Token not found\"\n      Just jwt -> do\n        validityStatus <- liftIO $ JWT.isValid jwt\n        pure $ case validityStatus of\n          JWT.JWTValid _ -> Right jwt\n          JWT.JWTExpired _ -> Left \"Token expired\"\n          JWT.JWTInvalid -> Left \"Token is invalid\"\n  case tokenStatus of\n    Left err -> do\n      logTagWarning \"FCM\" $ \"Refreshing FCM token. Reason: \" <> fromString err\n      getNewToken config\n    jwt -> pure jwt\n\nparseFCMAccount ::\n  Text ->\n  Either String JWT.ServiceAccount\nparseFCMAccount fcmServiceAccount = do\n  case BL.fromStrict . T.encodeUtf8 <$> B64.decodeBase64 fcmServiceAccount of\n    Right bs -> Aeson.eitherDecode bs\n    _ -> Left \"FCM JSON file is not set in configs\"\n\ngetNewToken :: (Redis.HedisFlow m r, MonadFlow m) => FCMConfig -> m (Either String JWT.JWToken)\ngetNewToken config = either (pure . Left) (refreshToken config) $ parseFCMAccount config.fcmServiceAccount\n\nrefreshToken :: (Redis.HedisFlow m r, MonadFlow m) => FCMConfig -> JWT.ServiceAccount -> m (Either String JWT.JWToken)\nrefreshToken config fcmAcc = do\n  logTagInfo fcmTag \"Refreshing token\"\n  refreshRes <- liftIO $ JWT.doRefreshToken fcmAcc\n  case refreshRes of\n    Left err -> do\n      logTagInfo fcmTag $ fromString err\n      pure $ Left $ fromString err\n    Right token -> do\n      logTagInfo fcmTag $ fromString \"Success\"\n      Redis.set (config.fcmTokenKeyPrefix <> \":\" <> redisFcmKey) token\n      pure $ Right token\n  where\n    fcmTag = \"FCM\"\n\nupdateLiveActivity ::\n  ( CoreMetrics m,\n    Redis.HedisFlow m r,\n    MonadFlow m\n  ) =>\n  FCMConfig ->\n  FCMNotificationRecipient ->\n  LiveActivityReq ->\n  m ()\nupdateLiveActivity config recipient apnsReq = do\n  let tokenNotFound = \"device token of a person \" <> recipient.id <> \" not found\"\n  case recipient.token of\n    Nothing -> do\n      logTagInfo \"FCM\" tokenNotFound\n      pure ()\n    Just token -> do\n      currentTime <- liftIO getPOSIXTime\n      let currentTimeInt = floor currentTime :: Int\n          apnsReqTimeStamp = currentTimeInt\n      sendLiveActivityApns config (createApnsLiveActivtyPayload token apnsReq apnsReqTimeStamp) recipient.id\n\nsendLiveActivityApns ::\n  ( CoreMetrics m,\n    Redis.HedisFlow m r,\n    MonadFlow m\n  ) =>\n  FCMConfig ->\n  ApnsAPIRequest ->\n  Text ->\n  m ()\nsendLiveActivityApns config apnsApiRequest toWhom = do\n  authToken <- getTokenText config\n  case authToken of\n    Right token -> do\n      let fcmUrl = config.fcmUrl\n      res <- callAPI fcmUrl (callAPNS (Just $ FCMAuthToken token) apnsApiRequest) \"sendAPNSPayload\" apnsLiveActivityAPI\n      case res of\n        Right _ -> logTagInfo apns $ \"APNS sent successfully to a person with id \" <> toWhom\n        Left _ -> logTagInfo apns \"APNS WAS NOT SEND\"\n    Left err -> logTagError apns $ \"AuthToken error while sending apns to person with id \" <> toWhom <> \" : \" <> show err\n  where\n    callAPNS token req = void $ ET.client apnsLiveActivityAPI token req\n    apns = \"APNS\"\n\n-- | Google API interface\ntype ApnsLiveActivityAPI req =\n  Header \"Authorization\" FCMAuthToken\n    :> ReqBody '[JSON] req\n    :> Post '[JSON] ResponseType -- APNS Response\n\ndata ResponseType = ResponseType\n  { name :: Text\n  }\n  deriving (Show, Generic, ToJSON, FromJSON)\n\napnsLiveActivityAPI :: Proxy (ApnsLiveActivityAPI a)\napnsLiveActivityAPI = Proxy\n\ncreateApnsLiveActivtyPayload :: FCMRecipientToken -> LiveActivityReq -> Int -> ApnsAPIRequest\ncreateApnsLiveActivtyPayload receipentToken apnsReq apnsReqTimeStamp =\n  let apnsReqToken = apnsReq.liveActivityToken\n      apnsReqLiveActivity = apnsReq.liveActivityReqType\n      apnsContentState = apnsReq.liveActivityContentState\n      apnsReqDismissalDate = case apnsReq.liveActivityReqType of\n        \"end\" -> Just $ apnsReqTimeStamp + 600\n        _ -> Just $ apnsReqTimeStamp\n      liveActivityApnsPriority = apnsReq.liveActivityApnsPriority\n      apnsPayload' =\n        ApnsAPIRequest\n          { message =\n              Message\n                { token = receipentToken,\n                  apns =\n                    Apns\n                      { live_activity_token =\n                          apnsReqToken,\n                        headers =\n                          ApnsHeaders\n                            { apns_priority = liveActivityApnsPriority\n                            },\n                        payload =\n                          Payload\n                            { aps =\n                                Aps\n                                  { timestamp = apnsReqTimeStamp,\n                                    content_available = 1,\n                                    event = apnsReqLiveActivity,\n                                    content_state = apnsContentState,\n                                    alert =\n                                      Just $\n                                        Alert\n                                          { title = Just \"LIVE\"\n                                          },\n                                    dismissal_date = apnsReqDismissalDate\n                                  }\n                            }\n                      }\n                }\n          }\n   in apnsPayload'\n",
      "hash": "959ba81f0c78b37c2450844709d202818e96a16011758450be492a3a6bbca7eb",
      "size": 15680
    },
    "/lib/mobility-core/src/Kernel/External/Notification/FCM/Types.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n{-# LANGUAGE DeriveDataTypeable #-}\n{-# LANGUAGE DerivingVia #-}\n{-# LANGUAGE GeneralizedNewtypeDeriving #-}\n{-# LANGUAGE OverloadedStrings #-}\n{-# LANGUAGE ScopedTypeVariables #-}\n{-# LANGUAGE StandaloneDeriving #-}\n{-# LANGUAGE TemplateHaskell #-}\n\nmodule Kernel.External.Notification.FCM.Types where\n\nimport Control.Lens.TH\nimport Data.Aeson\nimport Data.Aeson.Casing\nimport Data.Aeson.TH\nimport Data.Aeson.Types\nimport Data.Default.Class\nimport Data.OpenApi (ToSchema)\nimport qualified Database.Beam as B\nimport Database.Beam.Backend\nimport Database.Beam.Postgres\nimport Database.PostgreSQL.Simple.FromField (FromField)\nimport EulerHS.Prelude hiding (id)\nimport Kernel.Beam.Lib.UtilsTH\nimport Kernel.Storage.Esqueleto (PersistField, PersistFieldSql)\nimport Kernel.Types.App\nimport qualified Kernel.Utils.Common as Common\nimport Kernel.Utils.GenericPretty\nimport Kernel.Utils.JSON\nimport Kernel.Utils.TH\nimport Kernel.Utils.Text (decodeFromText, encodeToText)\n\ndata FCMConfig = FCMConfig\n  { fcmUrl :: BaseUrl,\n    fcmServiceAccount :: Text,\n    fcmTokenKeyPrefix :: Text\n  }\n  deriving stock (Show, Eq, Generic)\n  deriving anyclass (PrettyShow, FromJSON, ToJSON)\n\ndata FCMNotificationRecipient = FCMNotificationRecipient\n  { id :: Text,\n    token :: Maybe FCMRecipientToken\n  }\n\n-- | Device token\nnewtype FCMRecipientToken = FCMRecipientToken\n  { getFCMRecipientToken :: Text\n  }\n  deriving newtype (PersistField, PersistFieldSql, Show, PrettyShow)\n\nderiving newtype instance FromField FCMRecipientToken\n\ninstance HasSqlValueSyntax be Text => HasSqlValueSyntax be FCMRecipientToken where\n  sqlValueSyntax = sqlValueSyntax . getFCMRecipientToken\n\ninstance BeamSqlBackend be => B.HasSqlEqualityCheck be FCMRecipientToken\n\ninstance FromBackendRow Postgres FCMRecipientToken\n\nderiving stock instance Read FCMRecipientToken\n\nderiveIdentifierInstances ''FCMRecipientToken\n\n-- | FCM authorization token\nnewtype FCMAuthToken = FCMAuthToken\n  { getFCMAuthToken :: Text\n  }\n  deriving (Show)\n  deriving newtype (PrettyShow)\n\nderiveIdentifierInstances ''FCMAuthToken\n\n-- | FCM notification title\nnewtype FCMNotificationTitle = FCMNotificationTitle\n  { getFCMNotificationTitle :: Text\n  }\n  deriving (Show)\n  deriving newtype (PrettyShow)\n\nderiveIdentifierInstances ''FCMNotificationTitle\n\n-- | FCM notification body\nnewtype FCMNotificationBody = FCMNotificationBody\n  { getFCMNotificationBody :: Text\n  }\n  deriving (Show)\n  deriving newtype (PrettyShow)\n\nderiveIdentifierInstances ''FCMNotificationBody\n\n-- | Notification image / icon path\nnewtype FCMNotificationIconUrl = FCMNotificationIconUrl\n  { getFCMNotificationIconUrl :: Text\n  }\n  deriving (Show)\n  deriving newtype (PrettyShow)\n\nderiveIdentifierInstances ''FCMNotificationIconUrl\n\n-- | Notification types\ndata FCMNotificationType\n  = REGISTRATION_APPROVED\n  | EXPIRED_CASE\n  | CANCELLED_PRODUCT\n  | CANCELLED_PRODUCT_DRIVER\n  | CANCELLED_PRODUCT_USER\n  | REALLOCATE_PRODUCT\n  | DRIVER_ASSIGNMENT\n  | TRIP_STARTED\n  | TRIP_FINISHED\n  | ALLOCATION_REQUEST\n  | ALLOCATION_REQUEST_UNASSIGNED\n  | ACCOUNT_DISABLED\n  | TRIGGER_SERVICE\n  | FARE_POLICY_CHANGED\n  | DISCOUNT_CHANGED\n  | QUOTE_RECEIVED\n  | NEW_RIDE_AVAILABLE\n  | DRIVER_QUOTE_INCOMING\n  | DRIVER_ON_THE_WAY\n  | DRIVER_HAS_REACHED\n  | DRIVER_REACHING\n  | CLEARED_FARE\n  | CANCELLED_SEARCH_REQUEST\n  | NEW_MESSAGE\n  | REFERRAL_ACTIVATED\n  | CHAT_MESSAGE\n  | PAYMENT_PENDING\n  | PAYMENT_OVERDUE\n  | PAYMENT_FAILED\n  | PAYMENT_SUCCESS\n  | PAYMENT_MODE_MANUAL\n  | PAYMENT_NUDGE\n  | DRIVER_NOTIFY\n  | DRIVER_NOTIFY_LOCATION_UPDATE\n  | SAFETY_ALERT_DEVIATION\n  | DRIVER_BIRTHDAY\n  | EDIT_LOCATION\n  | ADD_STOP\n  | EDIT_STOP\n  | STOP_REACHED\n  | COINS_SUCCESS\n  | FOLLOW_RIDE\n  | SHARE_RIDE\n  | SOS_TRIGGERED\n  | SOS_MOCK_DRILL\n  | SOS_RESOLVED\n  | EMERGENCY_CONTACT_ADDED\n  | SOS_MOCK_DRILL_NOTIFY\n  | DOCUMENT_INVALID\n  | SCHEDULED_RIDE_NOTIFICATION\n  | FIRST_RIDE_EVENT\n  | TOLL_CROSSED\n  | TRIP_UPDATED\n  | FCM_CHAT_MESSAGE\n  | PAYOUT_REWARD\n  | PAYOUT_VPA_REMINDER\n  | TRIGGER_FCM\n  | POST_RIDE_SOS_ALERT\n  | REFERRAL_FLOW\n  | FILE_UPLOADED\n  | SCHEDULED_RIDE_REMINDER\n  | DRIVER_HAS_REACHED_DESTINATION\n  | CANCELLATION_RATE_NUDGE_DAILY\n  | CANCELLATION_RATE_NUDGE_WEEKLY\n  | USER_FAVOURITE_DRIVER\n  | DRIVER_UNBLOCKED\n  | POST_RIDE_SAFETY_CHECK\n  | DRIVER_STOP_DETECTED\n  | TO_METRO_COINS\n  | FROM_METRO_COINS\n  | ISSUE_BREACH_EXTRA_FARE_MITIGATION\n  | MARKETING_EVENTS\n  | WMB_TRIP_ASSIGNED\n  | WMB_TRIP_STARTED\n  | WMB_TRIP_FINISHED\n  | FLEET_CONSENT\n  | OPERATOR_CONSENT\n  | DRIVER_UNLINK_FROM_FLEET\n  | DRIVER_UNLINK_FROM_OPERATOR\n  | FLEET_UNLINK_FROM_OPERATOR\n  | DRIVER_REQUEST_REJECTED\n  | SAFETY_ALERT_RIDE_STOPPAGE\n  | EKD_LIVE_CALL_FEEDBACK\n  | DRUNK_AND_DRIVE_VIOLATION_WARNING\n  | ACCOUNT_DELETED\n  deriving (Show, Eq, Read, Ord, Generic, ToJSON, FromJSON)\n  deriving (PrettyShow) via Showable FCMNotificationType\n\n$(mkBeamInstancesForEnum ''FCMNotificationType)\n\n-- | Entity types types\ndata FCMEntityType = SearchRequest | Product | Merchant | Person | PaymentOrder | EditLocation\n  deriving (Show, Eq, Read, Generic, ToJSON, FromJSON)\n  deriving (PrettyShow) via Showable FCMEntityType\n\n-- | Priority of a message to send to Android devices\ndata FCMAndroidMessagePriority = NORMAL | HIGH\n  deriving (Show, Eq, Read, Generic, ToJSON, FromJSON)\n  deriving (PrettyShow) via Showable FCMAndroidMessagePriority\n\n-- | Priority levels of a notification\ndata FCMNotificationPriority\n  = PRIORITY_UNSPECIFIED\n  | PRIORITY_MIN\n  | PRIORITY_LOW\n  | PRIORITY_DEFAULT\n  | PRIORITY_HIGH\n  | PRIORITY_MAX\n  deriving (Show, Eq, Read, Generic, ToJSON, FromJSON)\n  deriving (PrettyShow) via Showable FCMNotificationPriority\n\n-- | Different visibility levels of a notification\ndata FCMNotificationVisibility = VISIBILITY_UNSPECIFIED | PRIVATE | PUBLIC | SECRET\n  deriving (Show, Eq, Read, Generic, ToJSON, FromJSON)\n  deriving (PrettyShow) via Showable FCMNotificationVisibility\n\ndata FCMShowNotification = SHOW | DO_NOT_SHOW\n  deriving (Show, Eq, Read, Generic)\n  deriving (PrettyShow) via Showable FCMShowNotification\n\ninstance ToJSON FCMShowNotification where\n  toJSON SHOW = \"true\"\n  toJSON _ = \"false\"\n\ninstance FromJSON FCMShowNotification where\n  parseJSON = withText \"FCMShowNotification\" \\case\n    \"true\" -> pure SHOW\n    \"false\" -> pure DO_NOT_SHOW\n    str -> typeMismatch \"FCMShowNotification\" (String str)\n\n-- | HTTP request headers\ntype FCMHeaders = Map Text Text\n\n-- | Target to send a message to. Target can be only one of the following:\n-- data FCMTarget = FCMTopic Text | FCMToken Text | FCMCondition Text\n\n-- | Represents a color in the RGBA color space\ndata FCMColor = FCMColor\n  { fcmRed :: Int,\n    fcmGreen :: Int,\n    fcmBlue :: Int,\n    fcmAlpha :: Int\n  }\n  deriving (Eq, Show, Generic, PrettyShow)\n\n$(makeLenses ''FCMColor)\n\n$(deriveJSON (aesonPrefix snakeCase) {omitNothingFields = True} ''FCMColor)\n\n-- | Options for features provided by the FCM SDK for Android.\nnewtype FCMAndroidOptions = FCMAndroidOptions\n  { fcmdAnalyticsLabel :: Maybe Text\n  }\n  deriving (Eq, Show)\n  deriving newtype (PrettyShow)\n\n$(makeLenses ''FCMAndroidOptions)\n\n$(deriveJSON (aesonPrefix snakeCase) {omitNothingFields = True} ''FCMAndroidOptions)\n\ninstance Default FCMAndroidOptions where\n  def = FCMAndroidOptions Nothing\n\n-- | Options for features provided by the FCM SDK for iOS\ndata FCMApnsOptions = FCMApnsOptions\n  { fcmaAnalyticsLabel :: !(Maybe Text),\n    fcmaImage :: !(Maybe FCMNotificationIconUrl)\n  }\n  deriving (Eq, Show, Generic, PrettyShow)\n\n$(makeLenses ''FCMApnsOptions)\n\n$(deriveJSON (aesonPrefix snakeCase) {omitNothingFields = True} ''FCMApnsOptions)\n\ninstance Default FCMApnsOptions where\n  def = FCMApnsOptions Nothing Nothing\n\n-- | Options for features provided by the FCM SDK for iOS\ndata FCMWebpushOptions = FCMWebpushOptions\n  { fcmwAnalyticsLabel :: !(Maybe Text),\n    fcmwLink :: !(Maybe Text)\n  }\n  deriving (Eq, Show, Generic, PrettyShow)\n\n$(makeLenses ''FCMWebpushOptions)\n\n$(deriveJSON (aesonPrefix snakeCase) {omitNothingFields = True} ''FCMWebpushOptions)\n\ninstance Default FCMWebpushOptions where\n  def = FCMWebpushOptions Nothing Nothing\n\n-- | Settings to control notification LED\ndata FCMLightSettings = FCMLightSettings\n  { fcmLightOnDuration :: !(Maybe Text),\n    fcmLightOffDuration :: !(Maybe Text),\n    fcmColor :: !(Maybe FCMColor)\n  }\n  deriving (Eq, Show, Generic, PrettyShow)\n\n$(makeLenses ''FCMLightSettings)\n\n$(deriveJSON (aesonPrefix snakeCase) {omitNothingFields = True} ''FCMLightSettings)\n\ninstance Default FCMLightSettings where\n  def = FCMLightSettings Nothing Nothing Nothing\n\n-- | Basic notification template to use across all platforms\ndata FCMNotification = FCMNotification\n  { fcmTitle :: !(Maybe FCMNotificationTitle),\n    fcmBody :: !(Maybe FCMNotificationBody),\n    fcmImage :: !(Maybe FCMNotificationIconUrl)\n  }\n  deriving (Eq, Show, Generic, PrettyShow)\n\n$(makeLenses ''FCMNotification)\n\n$(deriveJSON (aesonPrefix snakeCase) {omitNothingFields = True} ''FCMNotification)\n\ninstance Default FCMNotification where\n  def = FCMNotification Nothing Nothing Nothing\n\ndata FCMOverlayReq = FCMOverlayReq\n  { title :: Maybe Text,\n    description :: Maybe Text,\n    imageUrl :: Maybe Text,\n    okButtonText :: Maybe Text,\n    cancelButtonText :: Maybe Text,\n    actions :: [Text],\n    actions2 :: [FCMActions],\n    secondaryActions2 :: Maybe [FCMActions],\n    link :: Maybe Text,\n    endPoint :: Maybe Text,\n    method :: Maybe Text,\n    reqBody :: Value,\n    delay :: Maybe Int,\n    contactSupportNumber :: Maybe Text,\n    toastMessage :: Maybe Text,\n    secondaryActions :: Maybe [Text],\n    socialMediaLinks :: Maybe [FCMMediaLink],\n    showPushNotification :: Maybe Bool\n  }\n  deriving (Eq, Show, Generic, ToSchema, FromJSON, PrettyShow)\n\ndata FCMActions = FCMActions\n  { primaryAction :: FCMOverlayAction,\n    dependentActions :: [FCMActions]\n  }\n  deriving (Eq, Show, Generic, ToSchema, FromJSON, PrettyShow, ToJSON)\n\ndata FCMOverlayAction = CALL_API CallAPIDetails | SET_DRIVER_ONLINE | OPEN_LINK OpenLinkDetails | CALL_SUPPORT CallSupportDetails | OPEN_SUBSCRIPTION | NAVIGATE NavigationDetails\n  deriving (Eq, Show, Generic, ToSchema, Read)\n  deriving (PrettyShow) via Showable FCMOverlayAction\n\ndata CallAPIDetails = CallAPIDetails\n  { endPoint :: Text,\n    method :: Text,\n    reqBody :: Value\n  }\n  deriving (Eq, Show, Generic, PrettyShow, ToSchema, FromJSON, ToJSON, Read)\n\ndata NavigationDetails = NavigationDetails\n  { lat :: Double,\n    long :: Double\n  }\n  deriving (Eq, Show, Generic, PrettyShow, ToSchema, FromJSON, ToJSON, Read)\n\nnewtype OpenLinkDetails = OpenLinkDetails\n  { link :: Text\n  }\n  deriving (Eq, Show, Generic)\n  deriving newtype (PrettyShow, ToSchema, FromJSON, ToJSON, Read)\n\nnewtype CallSupportDetails = CallSupportDetails\n  { contactSupportNumber :: Text\n  }\n  deriving (Eq, Show, Generic)\n  deriving newtype (PrettyShow, ToSchema, FromJSON, ToJSON, Read)\n\ninstance ToJSON FCMOverlayAction where\n  toJSON (CALL_API details) =\n    object\n      [ \"actionName\" .= String \"CALL_API\",\n        \"actionDetails\" .= toJSON details\n      ]\n  toJSON SET_DRIVER_ONLINE =\n    object\n      [ \"actionName\" .= String \"SET_DRIVER_ONLINE\",\n        \"actionDetails\" .= Null\n      ]\n  toJSON (OPEN_LINK details) =\n    object\n      [ \"actionName\" .= String \"OPEN_LINK\",\n        \"actionDetails\" .= toJSON details\n      ]\n  toJSON (CALL_SUPPORT details) =\n    object\n      [ \"actionName\" .= String \"CALL_SUPPORT\",\n        \"actionDetails\" .= toJSON details\n      ]\n  toJSON OPEN_SUBSCRIPTION =\n    object\n      [ \"actionName\" .= String \"OPEN_SUBSCRIPTION\",\n        \"actionDetails\" .= Null\n      ]\n  toJSON (NAVIGATE details) =\n    object\n      [ \"actionName\" .= String \"NAVIGATE\",\n        \"actionDetails\" .= toJSON details\n      ]\n\ninstance FromJSON FCMOverlayAction where\n  parseJSON = withObject \"FCMOverlayAction\" $ \\o -> do\n    actionName <- o .: \"actionName\" :: Parser Text\n    actionDetails <- o .:? \"actionDetails\" :: Parser (Maybe Value)\n    case (actionName, actionDetails) of\n      (\"CALL_API\", Just details) -> CALL_API <$> parseJSON details\n      (\"SET_DRIVER_ONLINE\", _) -> return SET_DRIVER_ONLINE\n      (\"OPEN_LINK\", Just details) -> OPEN_LINK <$> parseJSON details\n      (\"CALL_SUPPORT\", Just details) -> CALL_SUPPORT <$> parseJSON details\n      (\"OPEN_SUBSCRIPTION\", _) -> return OPEN_SUBSCRIPTION\n      (\"NAVIGATE\", Just details) -> NAVIGATE <$> parseJSON details\n      _ -> fail \"Invalid JSON format for FCMOverlayAction\"\n\ndata FCMMediaLink = FCMMediaLink\n  { prefixImage :: Maybe Text,\n    suffixImage :: Maybe Text,\n    link :: Text,\n    linkText :: Maybe Text,\n    height :: Maybe Text,\n    width :: Maybe Text\n  }\n  deriving (Eq, Show, Generic, PrettyShow, ToSchema, FromJSON)\n\n$(makeLenses ''FCMMediaLink)\n\ninstance ToJSON FCMMediaLink where\n  toJSON = genericToJSON removeNullFields\n\n-- | Notification to send to android devices for overlays\ndata FCMOverlayNotificationJSON = FCMOverlayNotificationJSON\n  { title :: !(Maybe Text),\n    description :: !(Maybe Text), -- need confirmation from UI if mandatory\n    imageUrl :: !(Maybe Text),\n    okButtonText :: !(Maybe Text),\n    cancelButtonText :: !(Maybe Text),\n    actions :: ![Text],\n    link :: !(Maybe Text),\n    method :: Maybe Text,\n    reqBody :: Value,\n    actions2 :: ![FCMActions],\n    secondaryActions2 :: !(Maybe [FCMActions]),\n    endPoint :: Maybe Text,\n    titleVisibility :: !Bool,\n    descriptionVisibility :: !Bool,\n    buttonOkVisibility :: !Bool,\n    buttonCancelVisibility :: !Bool,\n    buttonLayoutVisibility :: !Bool,\n    imageVisibility :: !Bool,\n    delay :: !(Maybe Int),\n    contactSupportNumber :: !(Maybe Text),\n    toastMessage :: !(Maybe Text),\n    secondaryActions :: !(Maybe [Text]),\n    socialMediaLinks :: !(Maybe [FCMMediaLink]),\n    showPushNotification :: !(Maybe Bool)\n  }\n  deriving (Eq, Show, Generic, PrettyShow)\n\n$(makeLenses ''FCMOverlayNotificationJSON)\n\ninstance ToJSON FCMOverlayNotificationJSON where\n  toJSON = genericToJSON removeNullFields\n\ninstance FromJSON FCMOverlayNotificationJSON where\n  parseJSON = genericParseJSON removeNullFields\n\n-- | Notification to send to android devices\ndata FCMAndroidNotification = FCMAndroidNotification\n  { fcmdTitle :: !(Maybe FCMNotificationTitle),\n    fcmdBody :: !(Maybe FCMNotificationBody),\n    fcmdIcon :: !(Maybe FCMNotificationIconUrl),\n    fcmdColor :: !(Maybe Text),\n    fcmdSound :: !(Maybe Text),\n    fcmdTag :: !(Maybe FCMNotificationType),\n    fcmdClickAction :: !(Maybe Text),\n    fcmdBodyLocKey :: !(Maybe Text),\n    fcmdBodyLockArgs :: !(Maybe [Text]),\n    fcmdTitleLocKey :: !(Maybe Text),\n    fcmdTitleLockArgs :: !(Maybe [Text]),\n    fcmdChannelId :: !(Maybe Text),\n    fcmdTicker :: !(Maybe Text),\n    fcmdSticky :: !(Maybe Bool),\n    fcmdEventTime :: !(Maybe Text),\n    fcmdLocalOnly :: !(Maybe Bool),\n    fcmdNotificationPriority :: !(Maybe FCMNotificationPriority),\n    fcmdDefaultSound :: !(Maybe Bool),\n    fcmdDefalutVibrateTimings :: !(Maybe Bool),\n    fcmdDefaultLightSettings :: !(Maybe Bool),\n    fcmdVibrateTimings :: !(Maybe [Text])\n  }\n  deriving (Eq, Show, Generic, PrettyShow)\n\n$(makeLenses ''FCMAndroidNotification)\n\n$(deriveJSON (aesonPrefix snakeCase) {omitNothingFields = True} ''FCMAndroidNotification)\n\ninstance Default FCMAndroidNotification where\n  def =\n    let sound = Just \"default\"\n        channelId = Just \"General\"\n     in FCMAndroidNotification\n          { fcmdTitle = Nothing,\n            fcmdBody = Nothing,\n            fcmdIcon = Nothing,\n            fcmdColor = Nothing,\n            fcmdSound = sound,\n            fcmdTag = Nothing,\n            fcmdClickAction = Nothing,\n            fcmdBodyLocKey = Nothing,\n            fcmdBodyLockArgs = Nothing,\n            fcmdTitleLocKey = Nothing,\n            fcmdTitleLockArgs = Nothing,\n            fcmdChannelId = channelId,\n            fcmdTicker = Nothing,\n            fcmdSticky = Nothing,\n            fcmdEventTime = Nothing,\n            fcmdLocalOnly = Nothing,\n            fcmdNotificationPriority = Nothing,\n            fcmdDefaultSound = Nothing,\n            fcmdDefalutVibrateTimings = Nothing,\n            fcmdDefaultLightSettings = Nothing,\n            fcmdVibrateTimings = Nothing\n          }\n\n-- | FCM payload\ndata FCMData a = FCMData\n  { fcmNotificationType :: FCMNotificationType,\n    fcmShowNotification :: FCMShowNotification,\n    fcmEntityType :: FCMEntityType,\n    fcmEntityIds :: Text,\n    fcmEntityData :: a,\n    fcmNotificationJSON :: FCMAndroidNotification,\n    fcmNotificationId :: Maybe Text,\n    fcmOverlayNotificationJSON :: Maybe FCMOverlayNotificationJSON\n  }\n  deriving (Eq, Show, Generic, PrettyShow)\n\n$(makeLenses ''FCMData)\n\ninstance (ToJSON a) => ToJSON (FCMData a) where\n  toJSON FCMData {..} =\n    object\n      [ \"notification_type\" .= fcmNotificationType,\n        \"show_notification\" .= fcmShowNotification,\n        \"entity_type\" .= fcmEntityType,\n        \"entity_ids\" .= fcmEntityIds,\n        \"entity_data\" .= encodeToText fcmEntityData,\n        \"notification_json\" .= encodeToText fcmNotificationJSON,\n        \"notification_id\" .= fcmNotificationId,\n        \"driver_notification_payload\" .= (encodeToText <$> fcmOverlayNotificationJSON)\n      ]\n\ninstance (FromJSON a) => FromJSON (FCMData a) where\n  parseJSON = withObject \"FCMData\" \\o ->\n    FCMData\n      <$> o .: \"notification_type\"\n      <*> o .: \"show_notification\"\n      <*> o .: \"entity_type\"\n      <*> o .: \"entity_ids\"\n      <*> (o .: \"entity_data\" >>= parseNotificationJson)\n      <*> (o .: \"notification_json\" >>= parseNotificationJson)\n      <*> o .:? \"notification_id\"\n      <*> (o .:? \"driver_notification_payload\" >>= maybe (pure Nothing) parseNotificationJson)\n    where\n      parseNotificationJson str =\n        maybe (typeMismatch \"Json string\" (String str)) pure $ decodeFromText str\n\n-- | Android specific options for messages sent through FCM connection server\ndata FCMAndroidConfig a = FCMAndroidConfig\n  { fcmdCollapseKey :: !(Maybe Text),\n    fcmdPriority :: !(Maybe FCMAndroidMessagePriority),\n    fcmdTtl :: !(Maybe Text),\n    fcmdRestrictedPackageName :: !(Maybe Text),\n    fcmdData :: !(Maybe (FCMData a)),\n    fcmdOptions :: !(Maybe FCMAndroidOptions),\n    fcmdDirectBootOk :: !(Maybe Bool)\n  }\n  deriving (Eq, Show, Generic, PrettyShow)\n\n$(makeLenses ''FCMAndroidConfig)\n\n$(deriveJSON (aesonPrefix snakeCase) {omitNothingFields = True} ''FCMAndroidConfig)\n\ninstance Default (FCMAndroidConfig a) where\n  def =\n    let z = Nothing\n     in FCMAndroidConfig z z z z z z z\n\n-- | Apple Push Notification Service specific options\ndata FCMAlert = FCMAlert\n  { fcmTitle :: !(Maybe Text),\n    fcmBody :: !(Maybe Text)\n  }\n  deriving (Eq, Show, Generic, PrettyShow)\n\n$(makeLenses ''FCMAlert)\n\ninstance ToJSON FCMAlert where\n  toJSON FCMAlert {..} =\n    object\n      [ \"title\" .= fcmTitle,\n        \"body\" .= fcmBody\n      ]\n\ninstance FromJSON FCMAlert where\n  parseJSON = withObject \"FCMAlert\" \\o ->\n    FCMAlert\n      <$> o .: \"title\"\n      <*> o .: \"body\"\n\ninstance Default FCMAlert where\n  def = FCMAlert Nothing Nothing\n\n-----------------------------------------\n\ndata FCMaps a = FCMaps\n  { fcmAlert :: !(Maybe FCMAlert),\n    fcmData :: !(Maybe (FCMData a)),\n    fcmCategory :: !(Maybe FCMNotificationType),\n    fcmMutableContent :: !Int,\n    fcmSound :: !(Maybe Text),\n    fcmContentAvailable :: !Int,\n    fcmBadge :: !(Maybe Int)\n  }\n  deriving (Eq, Show, Generic, PrettyShow)\n\n$(makeLenses ''FCMaps)\n\ninstance (ToJSON a) => ToJSON (FCMaps a) where\n  toJSON FCMaps {..} =\n    object $\n      catMaybes\n        [ (\"alert\" .=) <$> fcmAlert,\n          (\"data\" .=) <$> fcmData,\n          (\"category\" .=) <$> fcmCategory,\n          (\"sound\" .=) <$> fcmSound,\n          (\"badge\" .=) <$> fcmBadge\n        ]\n        ++ [ \"mutable-content\" .= fcmMutableContent,\n             \"content-available\" .= fcmContentAvailable\n           ]\n\ninstance (FromJSON a) => FromJSON (FCMaps a) where\n  parseJSON = withObject \"FCMaps\" \\o ->\n    FCMaps\n      <$> o .: \"alert\"\n      <*> o .: \"data\"\n      <*> o .: \"category\"\n      <*> o .: \"mutable-content\"\n      <*> o .: \"sound\"\n      <*> o .: \"content-available\"\n      <*> o .: \"badge\"\n\ninstance Default (FCMaps a) where\n  def = FCMaps Nothing Nothing Nothing 1 Nothing 1 Nothing\n\nnewtype FCMApnPayload a = FCMApnPayload\n  { fcmAps :: Maybe (FCMaps a)\n  }\n  deriving (Eq, Show)\n  deriving newtype (PrettyShow)\n\n$(makeLenses ''FCMApnPayload)\n\n$(deriveJSON (aesonPrefix snakeCase) {omitNothingFields = True} ''FCMApnPayload)\n\ninstance Default (FCMApnPayload a) where\n  def = FCMApnPayload Nothing\n\nnewtype FCMApnHeaders = FCMApnHeaders\n  { fcmApnsPriority :: Maybe Text\n  }\n  deriving (Eq, Show)\n  deriving newtype (PrettyShow)\n\n$(makeLenses ''FCMApnHeaders)\n\ninstance ToJSON FCMApnHeaders where\n  toJSON FCMApnHeaders {..} =\n    object\n      [ \"apns-priority\" .= fcmApnsPriority\n      ]\n\ninstance FromJSON FCMApnHeaders where\n  parseJSON = withObject \"FCMApnHeaders\" \\o ->\n    FCMApnHeaders\n      <$> o .: \"apns-priority\"\n\ninstance Default FCMApnHeaders where\n  def = FCMApnHeaders Nothing\n\ndata FCMApnsConfig a = FCMApnsConfig\n  { fcmaHeaders :: !(Maybe FCMApnHeaders),\n    fcmaPayload :: !(Maybe (FCMApnPayload a)),\n    fcmaOptions :: !(Maybe FCMApnsOptions)\n  }\n  deriving (Eq, Show, Generic, PrettyShow)\n\n$(makeLenses ''FCMApnsConfig)\n\n$(deriveJSON (aesonPrefix snakeCase) {omitNothingFields = True} ''FCMApnsConfig)\n\ninstance Default (FCMApnsConfig a) where\n  def = FCMApnsConfig Nothing Nothing Nothing\n\n-- | Webpush protocol specific options\ndata FCMWebpushConfig a = FCMWebpushConfig\n  { fcmwHeaders :: !(Maybe FCMHeaders),\n    fcmwData :: !(Maybe (FCMData a)),\n    fcmwNotification :: !(Maybe Value),\n    fcmwOptions :: !(Maybe FCMWebpushOptions)\n  }\n  deriving (Eq, Show, Generic)\n  deriving (PrettyShow) via Showable (FCMWebpushConfig a)\n\n$(makeLenses ''FCMWebpushConfig)\n\n$(deriveJSON (aesonPrefix snakeCase) {omitNothingFields = True} ''FCMWebpushConfig)\n\ninstance Default (FCMWebpushConfig a) where\n  def = FCMWebpushConfig Nothing Nothing Nothing Nothing\n\n-- | Message to send by Firebase Cloud Messaging Service\ndata FCMMessage a b = FCMMessage\n  { fcmToken :: !(Maybe FCMRecipientToken),\n    fcmTopic :: !(Maybe Text),\n    fcmCondition :: !(Maybe Text),\n    fcmNotification :: !(Maybe FCMNotification),\n    fcmAndroid :: !(Maybe (FCMAndroidConfig a)),\n    fcmWebpush :: !(Maybe (FCMWebpushConfig a)),\n    fcmApns :: !(Maybe (FCMApnsConfig b)),\n    fcmOptions :: !(Maybe FCMAndroidOptions)\n  }\n  deriving (Eq, Show, Generic, PrettyShow)\n\n$(makeLenses ''FCMMessage)\n\n$(deriveJSON (aesonPrefix snakeCase) {omitNothingFields = True} ''FCMMessage)\n\ninstance Default (FCMMessage a b) where\n  def =\n    let z = Nothing\n     in FCMMessage z z z z z z z z\n\nnewtype FCMRequest a b = FCMRequest\n  { fcmeMessage :: FCMMessage a b\n  }\n  deriving (Eq, Show, Generic)\n  deriving anyclass (PrettyShow)\n\n$(makeLenses ''FCMRequest)\n\n$(deriveJSON (aesonPrefix snakeCase) {omitNothingFields = True} ''FCMRequest)\n\n-- | Priority levels of a notification\ndata FCMErrorCode\n  = -- No more information is available about this error\n    UNSPECIFIED_ERROR\n  | -- (HTTP error code = 400) Request parameters were invalid.\n    -- An extension of type google.rpc.BadRequest is returned to specify\n    -- which field was invalid\n    INVALID_ARGUMENT\n  | -- (HTTP error code = 404) App instance was unregistered from FCM. This usually means that the token used is no longer valid and a new one must be used\n    UNREGISTERED\n  | -- (HTTP error code = 403) The authenticated sender Id is different from the sender Id for the registration token\n    SENDER_ID_MISMATCH\n  | -- (HTTP error code = 429) Sending limit exceeded for the message target. An extension of type google.rpc.QuotaFailure is returned to specify which quota got exceeded\n    QUOTA_EXCEEDED\n  | -- (HTTP error code = 401) APNs certificate or auth key was invalid or missing. Deprecated. Use THIRD_PARTY_AUTH_ERROR\n    APNS_AUTH_ERROR\n  | -- (HTTP error code = 503) The server is overloaded\n    UNAVAILABLE\n  | -- (HTTP error code = 500) An unknown internal error occurred\n    INTERNAL\n  | -- (HTTP error code = 401) APNs certificate or web push auth key was invalid or missing\n    THIRD_PARTY_AUTH_ERROR\n  | PERMISSION_DENIED\n  | UNAUTHENTICATED\n  deriving (Show, Eq, Read, Generic, ToJSON, FromJSON)\n  deriving (PrettyShow) via Showable FCMErrorCode\n\ndata FCMError = FCMError\n  { fcmerrCode :: Int,\n    fcmerrStatus :: FCMErrorCode,\n    fcmerrMessage :: !Text\n  }\n  deriving (Show, Eq, Read, Generic, PrettyShow)\n\n$(makeLenses ''FCMError)\n\n$(deriveJSON (aesonPrefix snakeCase) ''FCMError)\n\n-- | Message to send by Firebase Cloud Messaging Service\ndata FCMResponse = FCMResponse\n  { fcmName :: Maybe Text,\n    fcmerrError :: Maybe FCMError\n  }\n  deriving (Show, Eq, Read, Generic, PrettyShow)\n\n$(deriveJSON (aesonPrefix snakeCase) {omitNothingFields = True} ''FCMResponse)\n\n$(mkBeamInstancesForEnum ''FCMOverlayAction)\n\ndata LiveActivityReq = LiveActivityReq\n  { liveActivityToken :: Text, -- live activity token\n    liveActivityReqType :: Text, -- request to be update, end, start\n    liveActivityNotificationType :: Text, -- notification type , SEARCH_CANCELLED, RIDE_CANCELLED\n    liveActivityContentState :: LiveActivityContentState, -- live activity content state\n    liveActivityApnsPriority :: Text\n  }\n  deriving (Show, Eq, Generic, ToJSON, FromJSON)\n\ndata ApnsAPIRequest = ApnsAPIRequest\n  { message :: Message\n  }\n  deriving (Generic, Eq, Show)\n\ninstance ToJSON ApnsAPIRequest where\n  toJSON = genericToJSON $ defaultOptions {omitNothingFields = True}\n\ninstance FromJSON ApnsAPIRequest where\n  parseJSON = genericParseJSON defaultOptions {omitNothingFields = True}\n\ndata Message = Message\n  { token :: FCMRecipientToken,\n    apns :: Apns\n  }\n  deriving (Generic, Eq, Show)\n\ninstance ToJSON Message where\n  toJSON = genericToJSON $ defaultOptions {omitNothingFields = True}\n\ninstance FromJSON Message where\n  parseJSON = genericParseJSON defaultOptions {omitNothingFields = True}\n\ndata Apns = Apns\n  { live_activity_token :: Text,\n    headers :: ApnsHeaders,\n    payload :: Payload\n  }\n  deriving (Generic, Eq, Show)\n\ninstance ToJSON Apns where\n  toJSON = genericToJSON $ defaultOptions {omitNothingFields = True}\n\ninstance FromJSON Apns where\n  parseJSON = genericParseJSON defaultOptions {omitNothingFields = True}\n\ndata ApnsHeaders = ApnsHeaders\n  { apns_priority :: Text\n  }\n  deriving (Generic, Eq, Show)\n\njsonApnsHeadersData :: Options\njsonApnsHeadersData =\n  defaultOptions\n    { fieldLabelModifier = \\case\n        \"apns_priority\" -> \"apns-priority\"\n        other -> other\n    }\n\ninstance ToJSON ApnsHeaders where\n  toJSON = genericToJSON jsonApnsHeadersData\n\ninstance FromJSON ApnsHeaders where\n  parseJSON = genericParseJSON jsonApnsHeadersData\n\ndata Payload = Payload\n  { aps :: Aps\n  }\n  deriving (Generic, Eq, Show)\n\ninstance ToJSON Payload where\n  toJSON = genericToJSON $ defaultOptions {omitNothingFields = True}\n\ninstance FromJSON Payload where\n  parseJSON = genericParseJSON defaultOptions {omitNothingFields = True}\n\ndata Aps = Aps\n  { timestamp :: Int,\n    alert :: Maybe Alert,\n    dismissal_date :: Maybe Int,\n    content_available :: Int,\n    event :: Text,\n    content_state :: LiveActivityContentState\n  }\n  deriving (Generic, Eq, Show)\n\ninstance ToJSON Aps where\n  toJSON = genericToJSON jsonApsData\n\ninstance FromJSON Aps where\n  parseJSON = genericParseJSON jsonApsData\n\njsonApsData :: Options\njsonApsData =\n  defaultOptions\n    { fieldLabelModifier = \\case\n        \"content_available\" -> \"content-available\"\n        \"content_state\" -> \"content-state\"\n        \"dismissal_date\" -> \"dismissal-date\"\n        other -> other\n    }\n\ndata Alert = Alert\n  { title :: Maybe Text\n  }\n  deriving (Show, Eq, Generic)\n\ninstance ToJSON Alert where\n  toJSON = genericToJSON $ defaultOptions {omitNothingFields = True}\n\ninstance FromJSON Alert where\n  parseJSON = genericParseJSON defaultOptions {omitNothingFields = True}\n\ndata LiveActivityContentState = LiveActivityContentState\n  { driverInfo :: Maybe DriverInfo,\n    bookingInfo :: Maybe BookingInfo,\n    activityStatus :: Text, -- searching , arriving , waiting , onRide , rideCompleted , reallocated\n    timerDuration :: Maybe Common.BatchConfig,\n    customMessage :: Maybe Text\n  }\n  deriving (Eq, Show, Generic, ToJSON, FromJSON)\n\ndata DriverInfo = DriverInfo\n  { rideOtp :: Maybe Text,\n    driverName :: Maybe Text,\n    distanceLeft :: Maybe Text,\n    totalDistance :: Maybe Text,\n    driverNumber :: Maybe Text,\n    driverProfile :: Maybe Text\n  }\n  deriving (Eq, Show, Generic, ToJSON, FromJSON)\n\ndata BookingInfo = BookingInfo\n  { vehicleName :: Maybe Text,\n    vehicleNumber :: Maybe Text,\n    vehicleVariant :: Maybe Text,\n    vehicleColor :: Maybe Text,\n    source :: Maybe Text,\n    destination :: Maybe Text,\n    estimatedFare :: Maybe Text\n  }\n  deriving (Eq, Show, Generic, ToJSON, FromJSON)\n",
      "hash": "6c78a83d747be8af1f1b9ed1aaeb668e4d5985e323628a7591f5c0bee07f0e02",
      "size": 29498
    },
    "/lib/mobility-core/src/Kernel/External/Notification/GRPC/Flow.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n\nmodule Kernel.External.Notification.GRPC.Flow where\n\nimport Data.Maybe\nimport qualified Data.Text as T\nimport qualified Data.Text.Encoding as TE\nimport qualified Data.UUID as UU\nimport EulerHS.Prelude\nimport Kernel.External.Notification.GRPC.Types\nimport Kernel.Storage.Hedis as Redis\nimport qualified Kernel.Storage.Hedis.Queries as Hedis\nimport Kernel.Types.Common\nimport Kernel.Utils.Common hiding (Error)\n\nnotifyPerson ::\n  ( MonadFlow m,\n    Redis.HedisFlow m r,\n    ToJSON a,\n    HasFlowEnv m r '[\"maxNotificationShards\" ::: Int]\n  ) =>\n  GRPCConfig ->\n  GrpcNotificationData a ->\n  m ()\nnotifyPerson cfg notificationData = do\n  now <- getCurrentTime\n  maxShards <- asks (.maxNotificationShards)\n  let idToShardNumber uuidTxt = fromIntegral ((\\(a, b) -> a + b) (UU.toWords64 uuidTxt)) `mod` (fromIntegral maxShards :: Integer)\n      shardId :: Integer = idToShardNumber . fromJust $ UU.fromText notificationData.streamId\n  let notificationStreamId =\n        case T.splitOn \"-\" notificationData.streamId of\n          [startUuid, midOneUuid, _, _] -> T.intercalate \"-\" [startUuid, midOneUuid]\n          _ -> notificationData.streamId\n  let object = NotificationMessage notificationStreamId now\n  _ <- Hedis.withCrossAppRedis $ Hedis.publish \"active-notification\" object\n  void $ Hedis.withCrossAppRedis $ Hedis.xAddExp (\"N\" <> notificationStreamId <> \"{\" <> (show shardId) <> \"}\") \"*\" (buildFieldValue notificationData now) cfg.streamExpirationTime\n  where\n    buildFieldValue notifData createdAt =\n      [ (\"entity.id\", TE.encodeUtf8 notifData.entityId),\n        (\"entity.type\", TE.encodeUtf8 $ notifData.entityType),\n        (\"entity.data\", TE.encodeUtf8 $ encodeToText notifData.entityData),\n        (\"category\", TE.encodeUtf8 $ notifData.category),\n        (\"title\", TE.encodeUtf8 notifData.title.getGRPCNotificationTitle),\n        (\"body\", TE.encodeUtf8 notifData.body.getGRPCNotificationBody),\n        (\"show\", TE.encodeUtf8 $ notifData.showNotification),\n        (\"ttl\", TE.encodeUtf8 $ show notifData.ttl),\n        (\"created_at\", TE.encodeUtf8 $ show createdAt),\n        (\"id\", TE.encodeUtf8 $ notificationData.notificationId)\n      ]\n",
      "hash": "d1a5733fdbdfda5ab7c9599dc37440290a941b32c240ed781a30a78e882cb6aa",
      "size": 2841
    },
    "/lib/mobility-core/src/Kernel/External/Notification/GRPC/Types.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n{-# LANGUAGE DeriveDataTypeable #-}\n{-# LANGUAGE DerivingVia #-}\n{-# LANGUAGE GeneralizedNewtypeDeriving #-}\n{-# LANGUAGE OverloadedStrings #-}\n{-# LANGUAGE ScopedTypeVariables #-}\n{-# LANGUAGE StandaloneDeriving #-}\n{-# LANGUAGE TemplateHaskell #-}\n\nmodule Kernel.External.Notification.GRPC.Types where\n\nimport Data.Aeson.TH\nimport Data.Time (UTCTime)\nimport EulerHS.Prelude\nimport Kernel.Types.Time (Seconds)\nimport Kernel.Utils.GenericPretty (PrettyShow)\nimport Kernel.Utils.TH\n\ndata GRPCConfig = GRPCConfig\n  { defaultTtl :: Seconds, -- milliseconds ?\n    streamExpirationTime :: Int -- in seconds\n  }\n  deriving stock (Show, Eq, Generic)\n  deriving anyclass (PrettyShow, FromJSON, ToJSON)\n\nnewtype GRPCNotificationTitle = GRPCNotificationTitle\n  { getGRPCNotificationTitle :: Text\n  }\n  deriving (Show)\n  deriving newtype (PrettyShow)\n\nderiveIdentifierInstances ''GRPCNotificationTitle\n\nnewtype GRPCNotificationBody = GRPCNotificationBody\n  { getGRPCNotificationBody :: Text\n  }\n  deriving (Show)\n  deriving newtype (PrettyShow)\n\nderiveIdentifierInstances ''GRPCNotificationBody\n\ndata GrpcNotificationData a = GrpcNotificationData\n  { entityId :: Text,\n    entityType :: Text,\n    entityData :: a,\n    category :: Text,\n    title :: GRPCNotificationTitle,\n    body :: GRPCNotificationBody,\n    showNotification :: Text,\n    ttl :: UTCTime,\n    streamId :: Text,\n    notificationId :: Text\n  }\n  deriving stock (Show, Eq, Generic)\n  deriving anyclass (PrettyShow)\n\n$(deriveJSON defaultOptions {omitNothingFields = True} ''GrpcNotificationData)\n\ndata NotificationMessage = NotificationMessage\n  { streamId :: Text,\n    timestamp :: UTCTime\n  }\n  deriving (Show, Generic)\n\ninstance ToJSON NotificationMessage\n",
      "hash": "044c1ae31075f38604f2299856a2c0ed653ba273101d77992bb9d597d3adda1b",
      "size": 2404
    },
    "/lib/mobility-core/src/Kernel/External/Notification/Interface.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\nmodule Kernel.External.Notification.Interface\n  ( module Reexport,\n    module Kernel.External.Notification.Interface,\n  )\nwhere\n\nimport EulerHS.Prelude\nimport Kernel.External.Notification.FCM.Types (LiveActivityReq)\nimport qualified Kernel.External.Notification.Interface.FCM as FCM\nimport qualified Kernel.External.Notification.Interface.GRPC as GRPC\nimport qualified Kernel.External.Notification.Interface.PayTM as PayTM\nimport Kernel.External.Notification.Interface.Types as Reexport\nimport Kernel.External.Notification.Types as Reexport\nimport qualified Kernel.Storage.Hedis as Redis\nimport Kernel.Tools.Metrics.CoreMetrics (CoreMetrics)\nimport Kernel.Types.Common\nimport Kernel.Types.Error\nimport Kernel.Types.Field\nimport Kernel.Utils.Error.Throwing (throwError)\n\nnotifyPerson ::\n  ( MonadFlow m,\n    EncFlow m r,\n    CoreMetrics m,\n    Redis.HedisFlow m r,\n    ToJSON a,\n    ToJSON b\n  ) =>\n  NotificationServiceConfig ->\n  NotificationReq a b ->\n  Maybe LiveActivityReq ->\n  m () ->\n  m ()\nnotifyPerson serviceConfig req liveAcitvityRequest action = do\n  notificationId <- generateGUID\n\n  case serviceConfig of\n    FCMConfig cfg -> FCM.notifyPerson cfg req liveAcitvityRequest action (Just notificationId) EulerHS.Prelude.id\n    PayTMConfig cfg -> PayTM.notifyPerson cfg req\n    GRPCConfig _ -> throwError $ InternalError \"GRPC notification type not supported.\"\n\nnotifyPersonWithAllProviders ::\n  ( EsqDBFlow m r,\n    MonadFlow m,\n    EncFlow m r,\n    CoreMetrics m,\n    Redis.HedisFlow m r,\n    ToJSON a,\n    ToJSON b,\n    ToJSON c,\n    HasFlowEnv m r '[\"maxNotificationShards\" ::: Int]\n  ) =>\n  NotficationServiceHandler m a c ->\n  NotificationReq a b ->\n  Maybe LiveActivityReq ->\n  m () ->\n  m ()\nnotifyPersonWithAllProviders NotficationServiceHandler {..} req liveAcitvityRequest action = do\n  serviceList <- getNotificationServiceList\n  notificationId <- generateGUID\n  callNotifPerson serviceList notificationId\n  where\n    callNotifPerson [] _notificationId = return ()\n    callNotifPerson (serviceProvider : remaining) notificationId = do\n      fork (\"notifying person with following service \" <> show serviceProvider <> \"for following notification id : \" <> notificationId) $ do\n        serviceProviderConfig <- getServiceConfig serviceProvider\n        case serviceProviderConfig of\n          FCMConfig cfg -> FCM.notifyPerson cfg req liveAcitvityRequest action (Just notificationId) iosModifier\n          PayTMConfig cfg -> PayTM.notifyPerson cfg req\n          GRPCConfig cfg -> GRPC.notifyPerson cfg req notificationId\n      callNotifPerson remaining notificationId\n",
      "hash": "f2315ba1e90854529707d75ae134773f71d3717716867df47a3034281b0479f2",
      "size": 3279
    },
    "/lib/mobility-core/src/Kernel/External/Notification/Interface/FCM.hs": {
      "type": "content",
      "content": "module Kernel.External.Notification.Interface.FCM where\n\nimport qualified Kernel.External.Notification.FCM.Flow as FCM\nimport qualified Kernel.External.Notification.FCM.Types as FCM\nimport qualified Kernel.External.Notification.Interface.Types as Interface\nimport Kernel.Prelude\nimport qualified Kernel.Storage.Hedis as Redis\nimport Kernel.Tools.Metrics.CoreMetrics (CoreMetrics)\nimport Kernel.Types.Common\n\nnotifyPerson ::\n  ( CoreMetrics m,\n    MonadFlow m,\n    Redis.HedisFlow m r,\n    ToJSON a,\n    ToJSON b,\n    ToJSON c\n  ) =>\n  FCM.FCMConfig ->\n  Interface.NotificationReq a b ->\n  Maybe FCM.LiveActivityReq ->\n  m () ->\n  Maybe Text ->\n  (FCM.FCMData a -> FCM.FCMData c) ->\n  m ()\nnotifyPerson config req liveAcitvityRequest action mbNotificationId iosModifier = do\n  let title = FCM.FCMNotificationTitle req.title\n      body = FCM.FCMNotificationBody req.body\n      notificationType = interfaceCategoryToFCMNotificationType req.category\n      notificationData =\n        FCM.FCMData\n          { fcmNotificationType = notificationType,\n            fcmShowNotification = interfaceShowNotificationToFCMShowNotification req.showNotification,\n            fcmEntityType = interfaceEntityTypeToFCMEntityType req.entity.entityType,\n            fcmEntityIds = req.entity.entityIds,\n            fcmEntityData = req.entity.entityData,\n            fcmNotificationJSON = FCM.createAndroidNotification title body notificationType req.sound,\n            fcmOverlayNotificationJSON = Nothing,\n            fcmNotificationId = mbNotificationId\n          }\n      apnsData = liveAcitvityRequest\n  case apnsData of\n    (Just reqLive) -> do FCM.updateLiveActivity config (FCM.FCMNotificationRecipient req.auth.recipientId (FCM.FCMRecipientToken <$> req.auth.fcmToken)) reqLive\n    _ -> pure ()\n  FCM.notifyPersonWithPriority\n    config\n    (interfaceMessagePriorityToFCMMessagePriority <$> req.messagePriority)\n    action\n    notificationData\n    (FCM.FCMNotificationRecipient req.auth.recipientId (FCM.FCMRecipientToken <$> req.auth.fcmToken))\n    iosModifier\n\ninterfaceMessagePriorityToFCMMessagePriority :: Interface.MessagePriority -> FCM.FCMAndroidMessagePriority\ninterfaceMessagePriorityToFCMMessagePriority = \\case\n  Interface.NORMAL -> FCM.NORMAL\n  Interface.HIGH -> FCM.HIGH\n\ninterfaceEntityTypeToFCMEntityType :: Interface.EntityType -> FCM.FCMEntityType\ninterfaceEntityTypeToFCMEntityType = \\case\n  Interface.SearchRequest -> FCM.SearchRequest\n  Interface.Product -> FCM.Product\n  Interface.Merchant -> FCM.Merchant\n  Interface.Person -> FCM.Person\n  Interface.EditLocation -> FCM.EditLocation\n\ninterfaceCategoryToFCMNotificationType :: Interface.Category -> FCM.FCMNotificationType\ninterfaceCategoryToFCMNotificationType = \\case\n  Interface.REGISTRATION_APPROVED -> FCM.REGISTRATION_APPROVED\n  Interface.EXPIRED_CASE -> FCM.EXPIRED_CASE\n  Interface.CANCELLED_PRODUCT -> FCM.CANCELLED_PRODUCT\n  Interface.CANCELLED_PRODUCT_DRIVER -> FCM.CANCELLED_PRODUCT_DRIVER\n  Interface.CANCELLED_PRODUCT_USER -> FCM.CANCELLED_PRODUCT_USER\n  Interface.REALLOCATE_PRODUCT -> FCM.REALLOCATE_PRODUCT\n  Interface.DRIVER_ASSIGNMENT -> FCM.DRIVER_ASSIGNMENT\n  Interface.TRIP_STARTED -> FCM.TRIP_STARTED\n  Interface.TRIP_FINISHED -> FCM.TRIP_FINISHED\n  Interface.ALLOCATION_REQUEST -> FCM.ALLOCATION_REQUEST\n  Interface.ALLOCATION_REQUEST_UNASSIGNED -> FCM.ALLOCATION_REQUEST_UNASSIGNED\n  Interface.ACCOUNT_DISABLED -> FCM.ACCOUNT_DISABLED\n  Interface.TRIGGER_SERVICE -> FCM.TRIGGER_SERVICE\n  Interface.FARE_POLICY_CHANGED -> FCM.FARE_POLICY_CHANGED\n  Interface.DISCOUNT_CHANGED -> FCM.DISCOUNT_CHANGED\n  Interface.QUOTE_RECEIVED -> FCM.QUOTE_RECEIVED\n  Interface.NEW_RIDE_AVAILABLE -> FCM.NEW_RIDE_AVAILABLE\n  Interface.DRIVER_QUOTE_INCOMING -> FCM.DRIVER_QUOTE_INCOMING\n  Interface.DRIVER_ON_THE_WAY -> FCM.DRIVER_ON_THE_WAY\n  Interface.DRIVER_HAS_REACHED -> FCM.DRIVER_HAS_REACHED\n  Interface.DRIVER_REACHING -> FCM.DRIVER_REACHING\n  Interface.CLEARED_FARE -> FCM.CLEARED_FARE\n  Interface.CANCELLED_SEARCH_REQUEST -> FCM.CANCELLED_SEARCH_REQUEST\n  Interface.NEW_MESSAGE -> FCM.NEW_MESSAGE\n  Interface.REFERRAL_ACTIVATED -> FCM.REFERRAL_ACTIVATED\n  Interface.CHAT_MESSAGE -> FCM.CHAT_MESSAGE\n  Interface.PAYMENT_PENDING -> FCM.PAYMENT_PENDING\n  Interface.PAYMENT_OVERDUE -> FCM.PAYMENT_OVERDUE\n  Interface.PAYMENT_FAILED -> FCM.PAYMENT_FAILED\n  Interface.PAYMENT_SUCCESS -> FCM.PAYMENT_SUCCESS\n  Interface.PAYMENT_MODE_MANUAL -> FCM.PAYMENT_MODE_MANUAL\n  Interface.PAYMENT_NUDGE -> FCM.PAYMENT_NUDGE\n  Interface.DRIVER_NOTIFY -> FCM.DRIVER_NOTIFY\n  Interface.DRIVER_NOTIFY_LOCATION_UPDATE -> FCM.DRIVER_NOTIFY_LOCATION_UPDATE\n  Interface.SAFETY_ALERT_DEVIATION -> FCM.SAFETY_ALERT_DEVIATION\n  Interface.DRIVER_BIRTHDAY -> FCM.DRIVER_BIRTHDAY\n  Interface.EDIT_LOCATION -> FCM.EDIT_LOCATION\n  Interface.ADD_STOP -> FCM.ADD_STOP\n  Interface.EDIT_STOP -> FCM.EDIT_STOP\n  Interface.STOP_REACHED -> FCM.STOP_REACHED\n  Interface.COINS_SUCCESS -> FCM.COINS_SUCCESS\n  Interface.FOLLOW_RIDE -> FCM.FOLLOW_RIDE\n  Interface.SHARE_RIDE -> FCM.SHARE_RIDE\n  Interface.SOS_TRIGGERED -> FCM.SOS_TRIGGERED\n  Interface.SOS_MOCK_DRILL -> FCM.SOS_MOCK_DRILL\n  Interface.SOS_RESOLVED -> FCM.SOS_RESOLVED\n  Interface.EMERGENCY_CONTACT_ADDED -> FCM.EMERGENCY_CONTACT_ADDED\n  Interface.SOS_MOCK_DRILL_NOTIFY -> FCM.SOS_MOCK_DRILL_NOTIFY\n  Interface.DOCUMENT_INVALID -> FCM.DOCUMENT_INVALID\n  Interface.SCHEDULED_RIDE_NOTIFICATION -> FCM.SCHEDULED_RIDE_NOTIFICATION\n  Interface.FIRST_RIDE_EVENT -> FCM.FIRST_RIDE_EVENT\n  Interface.TOLL_CROSSED -> FCM.TOLL_CROSSED\n  Interface.TRIP_UPDATED -> FCM.TRIP_UPDATED\n  Interface.FCM_CHAT_MESSAGE -> FCM.FCM_CHAT_MESSAGE\n  Interface.PAYOUT_REWARD -> FCM.PAYOUT_REWARD\n  Interface.PAYOUT_VPA_REMINDER -> FCM.PAYOUT_VPA_REMINDER\n  Interface.TRIGGER_FCM -> FCM.TRIGGER_FCM\n  Interface.POST_RIDE_SOS_ALERT -> FCM.POST_RIDE_SOS_ALERT\n  Interface.REFERRAL_FLOW -> FCM.REFERRAL_FLOW\n  Interface.FILE_UPLOADED -> FCM.FILE_UPLOADED\n  Interface.SCHEDULED_RIDE_REMINDER -> FCM.SCHEDULED_RIDE_REMINDER\n  Interface.DRIVER_HAS_REACHED_DESTINATION -> FCM.DRIVER_HAS_REACHED_DESTINATION\n  Interface.CANCELLATION_RATE_NUDGE_DAILY -> FCM.CANCELLATION_RATE_NUDGE_DAILY\n  Interface.CANCELLATION_RATE_NUDGE_WEEKLY -> FCM.CANCELLATION_RATE_NUDGE_WEEKLY\n  Interface.USER_FAVOURITE_DRIVER -> FCM.USER_FAVOURITE_DRIVER\n  Interface.DRIVER_UNBLOCKED -> FCM.DRIVER_UNBLOCKED\n  Interface.POST_RIDE_SAFETY_CHECK -> FCM.POST_RIDE_SAFETY_CHECK\n  Interface.DRIVER_STOP_DETECTED -> FCM.DRIVER_STOP_DETECTED\n  Interface.TO_METRO_COINS -> FCM.TO_METRO_COINS\n  Interface.FROM_METRO_COINS -> FCM.FROM_METRO_COINS\n  Interface.ISSUE_BREACH_EXTRA_FARE_MITIGATION -> FCM.ISSUE_BREACH_EXTRA_FARE_MITIGATION\n  Interface.MARKETING_EVENTS -> FCM.MARKETING_EVENTS\n  Interface.DRIVER_REQUEST_REJECTED -> FCM.DRIVER_REQUEST_REJECTED\n  Interface.WMB_TRIP_ASSIGNED -> FCM.WMB_TRIP_ASSIGNED\n  Interface.WMB_TRIP_STARTED -> FCM.WMB_TRIP_STARTED\n  Interface.WMB_TRIP_FINISHED -> FCM.WMB_TRIP_FINISHED\n  Interface.FLEET_CONSENT -> FCM.FLEET_CONSENT\n  Interface.OPERATOR_CONSENT -> FCM.OPERATOR_CONSENT\n  Interface.DRIVER_UNLINK_FROM_FLEET -> FCM.DRIVER_UNLINK_FROM_FLEET\n  Interface.DRIVER_UNLINK_FROM_OPERATOR -> FCM.DRIVER_UNLINK_FROM_OPERATOR\n  Interface.FLEET_UNLINK_FROM_OPERATOR -> FCM.FLEET_UNLINK_FROM_OPERATOR\n  Interface.SAFETY_ALERT_RIDE_STOPPAGE -> FCM.SAFETY_ALERT_RIDE_STOPPAGE\n  Interface.EKD_LIVE_CALL_FEEDBACK -> FCM.EKD_LIVE_CALL_FEEDBACK\n  Interface.DRUNK_AND_DRIVE_VIOLATION_WARNING -> FCM.DRUNK_AND_DRIVE_VIOLATION_WARNING\n  Interface.ACCOUNT_DELETED -> FCM.ACCOUNT_DELETED\n\ninterfaceShowNotificationToFCMShowNotification :: Interface.ShowNotification -> FCM.FCMShowNotification\ninterfaceShowNotificationToFCMShowNotification = \\case\n  Interface.SHOW -> FCM.SHOW\n  Interface.DO_NOT_SHOW -> FCM.DO_NOT_SHOW\n",
      "hash": "a97134467900810c82fb9840d2695fc524ab8e27c60715c45a6ee1e314596b5c",
      "size": 7766
    },
    "/lib/mobility-core/src/Kernel/External/Notification/Interface/GRPC.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n\nmodule Kernel.External.Notification.Interface.GRPC where\n\nimport EulerHS.Prelude\nimport qualified Kernel.External.Notification.GRPC.Flow as GRPC\nimport qualified Kernel.External.Notification.GRPC.Types as GRPC\nimport qualified Kernel.External.Notification.Interface.Types as Interface\nimport Kernel.Storage.Hedis as Redis\nimport Kernel.Types.Common\nimport Kernel.Types.Field\nimport Kernel.Utils.Time\n\nnotifyPerson ::\n  ( MonadFlow m,\n    ToJSON a,\n    ToJSON b,\n    Redis.HedisFlow m r,\n    HasFlowEnv m r '[\"maxNotificationShards\" ::: Int]\n  ) =>\n  GRPC.GRPCConfig ->\n  Interface.NotificationReq a b ->\n  Text ->\n  m ()\nnotifyPerson config req notificationId = do\n  defaultTtlTime <- addUTCTime (secondsToNominalDiffTime config.defaultTtl) <$> getCurrentTime -- this time ? UTC or IST ?\n  let title = GRPC.GRPCNotificationTitle req.title\n      body = GRPC.GRPCNotificationBody req.body\n      notificationType = show req.category\n      notificationData =\n        GRPC.GrpcNotificationData\n          { entityId = req.entity.entityIds,\n            entityType = show req.entity.entityType,\n            entityData = req.entity.entityData,\n            category = notificationType,\n            showNotification = show req.showNotification,\n            ttl = fromMaybe defaultTtlTime req.ttl,\n            streamId = req.auth.recipientId,\n            ..\n          }\n  GRPC.notifyPerson config notificationData\n",
      "hash": "7acb89715f04b71076f9d05ec73e1bcac082beae0c3f2e3e1c6ecb6f4707ef3e",
      "size": 2096
    },
    "/lib/mobility-core/src/Kernel/External/Notification/Interface/PayTM.hs": {
      "type": "content",
      "content": "module Kernel.External.Notification.Interface.PayTM where\n\nimport Data.Aeson\nimport qualified Data.Aeson.KeyMap as AKM\nimport qualified Data.HashMap.Strict as HM\nimport qualified Data.Text as T hiding (map)\nimport qualified Kernel.External.Notification.Interface.Types as Interface\nimport qualified Kernel.External.Notification.PayTM.Client as PayTM\nimport qualified Kernel.External.Notification.PayTM.Types as PayTM\nimport Kernel.Prelude\nimport Kernel.Tools.Metrics.CoreMetrics (CoreMetrics)\nimport Kernel.Types.Common\nimport Kernel.Utils.Common\n\nnotifyPerson ::\n  ( CoreMetrics m,\n    MonadFlow m,\n    EncFlow m r,\n    ToJSON a,\n    ToJSON b\n  ) =>\n  PayTM.PayTMConfig ->\n  Interface.NotificationReq a b ->\n  m ()\nnotifyPerson config req = do\n  case req.auth.notificationToken of\n    Just notificationToken -> do\n      let templateName = \"PushNotification.\" <> show req.category <> maybe \"\" ((\".\" <>) . show) req.subCategory\n      let deeplinkUrl = \"paytmmp://mobility?provider=nammayatri&source=notification&type=\" <> show req.category <> maybe \"\" ((\"&subType=\" <>) . show) req.subCategory <> T.intercalate \"\" (map (\\(k, v) -> T.pack $ mconcat [\"&\", show k, \"=\", show v]) $ HM.toList $ toHashMap req.entity.entityData)\n      let notificationData =\n            PayTM.NotificationReq\n              { sendBroadcastPush = True,\n                notificationReceiver = PayTM.NotificationReciever \"CUSTOMERID\" [notificationToken],\n                deviceType = [PayTM.ANDROIDAPP, PayTM.IOSAPP],\n                templateName = templateName,\n                dynamicParams = req.dynamicParams,\n                extraCommonParams = PayTM.ExtraCommonParams \"external\" deeplinkUrl\n              }\n      PayTM.notifyPerson\n        config\n        notificationData\n    Nothing -> logTagInfo \"PayTM\" $ \"notificationToken of a person \" <> req.auth.recipientId <> \" not found\"\n  where\n    toHashMap :: (ToJSON a) => a -> HM.HashMap Text Value\n    toHashMap val = case toJSON val of\n      Object obj -> AKM.toHashMapText obj\n      _ -> HM.empty\n",
      "hash": "05535b1e0a951a482c8b4bf602a1e7c0c8989fd2f5ff9bbc043ad0b77d4e4f3c",
      "size": 2026
    },
    "/lib/mobility-core/src/Kernel/External/Notification/Interface/Types.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n{-# LANGUAGE DerivingStrategies #-}\n{-# LANGUAGE DerivingVia #-}\n{-# LANGUAGE TemplateHaskell #-}\n\nmodule Kernel.External.Notification.Interface.Types where\n\nimport Kernel.Beam.Lib.UtilsTH (mkBeamInstancesForEnum)\nimport Kernel.External.Notification.FCM.Types\nimport qualified Kernel.External.Notification.FCM.Types as FCM\nimport qualified Kernel.External.Notification.GRPC.Types as GRPC\nimport qualified Kernel.External.Notification.PayTM.Types as PayTM\nimport qualified Kernel.External.Notification.Types as Interface\nimport Kernel.Prelude\n\ndata NotificationServiceConfig = FCMConfig FCM.FCMConfig | PayTMConfig PayTM.PayTMConfig | GRPCConfig GRPC.GRPCConfig\n  deriving (Show, Eq, Generic, ToJSON, FromJSON)\n\ndata Category\n  = REGISTRATION_APPROVED\n  | EXPIRED_CASE\n  | CANCELLED_PRODUCT\n  | CANCELLED_PRODUCT_DRIVER\n  | CANCELLED_PRODUCT_USER\n  | REALLOCATE_PRODUCT\n  | DRIVER_ASSIGNMENT\n  | TRIP_STARTED\n  | TRIP_FINISHED\n  | ALLOCATION_REQUEST\n  | ALLOCATION_REQUEST_UNASSIGNED\n  | ACCOUNT_DISABLED\n  | TRIGGER_SERVICE\n  | FARE_POLICY_CHANGED\n  | DISCOUNT_CHANGED\n  | QUOTE_RECEIVED\n  | NEW_RIDE_AVAILABLE\n  | DRIVER_QUOTE_INCOMING\n  | DRIVER_ON_THE_WAY\n  | DRIVER_HAS_REACHED\n  | DRIVER_REACHING\n  | CLEARED_FARE\n  | CANCELLED_SEARCH_REQUEST\n  | NEW_MESSAGE\n  | REFERRAL_ACTIVATED\n  | CHAT_MESSAGE\n  | PAYMENT_PENDING\n  | PAYMENT_OVERDUE\n  | PAYMENT_FAILED\n  | PAYMENT_SUCCESS\n  | PAYMENT_MODE_MANUAL\n  | PAYMENT_NUDGE\n  | DRIVER_NOTIFY\n  | DRIVER_NOTIFY_LOCATION_UPDATE\n  | SAFETY_ALERT_DEVIATION\n  | DRIVER_BIRTHDAY\n  | EDIT_LOCATION\n  | ADD_STOP\n  | EDIT_STOP\n  | STOP_REACHED\n  | COINS_SUCCESS\n  | FOLLOW_RIDE\n  | SHARE_RIDE\n  | SOS_TRIGGERED\n  | SOS_MOCK_DRILL\n  | SOS_RESOLVED\n  | EMERGENCY_CONTACT_ADDED\n  | SOS_MOCK_DRILL_NOTIFY\n  | DOCUMENT_INVALID\n  | SCHEDULED_RIDE_NOTIFICATION\n  | FIRST_RIDE_EVENT\n  | TOLL_CROSSED\n  | TRIP_UPDATED\n  | FCM_CHAT_MESSAGE\n  | PAYOUT_REWARD\n  | PAYOUT_VPA_REMINDER\n  | TRIGGER_FCM\n  | POST_RIDE_SOS_ALERT\n  | REFERRAL_FLOW\n  | FILE_UPLOADED\n  | SCHEDULED_RIDE_REMINDER\n  | DRIVER_HAS_REACHED_DESTINATION\n  | CANCELLATION_RATE_NUDGE_DAILY\n  | CANCELLATION_RATE_NUDGE_WEEKLY\n  | USER_FAVOURITE_DRIVER\n  | DRIVER_UNBLOCKED\n  | POST_RIDE_SAFETY_CHECK\n  | DRIVER_STOP_DETECTED\n  | TO_METRO_COINS\n  | FROM_METRO_COINS\n  | ISSUE_BREACH_EXTRA_FARE_MITIGATION\n  | MARKETING_EVENTS\n  | DRIVER_REQUEST_REJECTED\n  | WMB_TRIP_ASSIGNED\n  | WMB_TRIP_STARTED\n  | WMB_TRIP_FINISHED\n  | FLEET_CONSENT\n  | OPERATOR_CONSENT\n  | DRIVER_UNLINK_FROM_FLEET\n  | DRIVER_UNLINK_FROM_OPERATOR\n  | FLEET_UNLINK_FROM_OPERATOR\n  | SAFETY_ALERT_RIDE_STOPPAGE\n  | EKD_LIVE_CALL_FEEDBACK\n  | DRUNK_AND_DRIVE_VIOLATION_WARNING\n  | ACCOUNT_DELETED\n  deriving (Show, Eq, Read, Generic, Ord, ToSchema, ToJSON, FromJSON)\n\n$(mkBeamInstancesForEnum ''Category)\n\ndata SubCategory\n  = ByUser\n  | ByMerchant\n  | ByDriver\n  | ByAllocator\n  | ByApplication\n  deriving (Show, Eq, Read, Generic, Ord, ToSchema, ToJSON, FromJSON)\n\n$(mkBeamInstancesForEnum ''SubCategory)\n\ndata ShowNotification = SHOW | DO_NOT_SHOW\n  deriving (Show, Eq, Read, Generic, ToJSON, FromJSON)\n\ndata EntityType = SearchRequest | Product | Merchant | Person | EditLocation\n  deriving (Show, Eq, Read, Generic, ToJSON, FromJSON)\n\ndata Auth = Auth\n  { recipientId :: Text,\n    fcmToken :: Maybe Text,\n    notificationToken :: Maybe Text\n  }\n  deriving (Show, Eq, Read, Generic, ToJSON, FromJSON)\n\ndata MessagePriority = NORMAL | HIGH\n  deriving (Show, Eq, Read, Generic, ToJSON, FromJSON)\n\ndata Entity a = Entity\n  { entityType :: EntityType,\n    entityIds :: Text,\n    entityData :: a\n  }\n  deriving (Show, Eq, Read, Generic, ToJSON, FromJSON)\n\ndata NotificationReq a b = NotificationReq\n  { auth :: Auth,\n    category :: Category,\n    subCategory :: Maybe SubCategory,\n    showNotification :: ShowNotification,\n    messagePriority :: Maybe MessagePriority,\n    entity :: Entity a,\n    dynamicParams :: b,\n    body :: Text,\n    title :: Text,\n    ttl :: Maybe UTCTime,\n    sound :: Maybe Text\n  }\n  deriving (Show, Eq, Read, Generic, ToJSON, FromJSON)\n\ndata NotficationServiceHandler m a b = NotficationServiceHandler\n  { getNotificationServiceList :: m [Interface.NotificationService],\n    getServiceConfig :: Interface.NotificationService -> m NotificationServiceConfig,\n    iosModifier :: FCMData a -> FCMData b\n  }\n",
      "hash": "8df3bf4e25db57df61c231811ffe4fb02e73320d6eba15b778130857a375a680",
      "size": 4986
    },
    "/lib/mobility-core/src/Kernel/External/Notification/PayTM/API.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n\nmodule Kernel.External.Notification.PayTM.API where\n\nimport EulerHS.Prelude\nimport EulerHS.Types (EulerClient, client)\nimport qualified Kernel.External.Notification.PayTM.Types as Notification\nimport Servant\n\ntype NotificationAPI a =\n  Header \"client_id\" Text\n    :> Header \"secret_key\" Text\n    :> ReqBody '[JSON] (Notification.NotificationReq a)\n    :> Post '[JSON] Notification.NotificationResp\n\nnotifyClient :: ToJSON a => Text -> Text -> Notification.NotificationReq a -> EulerClient Notification.NotificationResp\nnotifyClient clientId apiKey = client notificationAPI (Just clientId) (Just apiKey)\n\nnotificationAPI :: Proxy (NotificationAPI a)\nnotificationAPI = Proxy\n",
      "hash": "8069ab6304ba8f406e91a0bf14060f17404fd4825b1dc3c1f07e3932eb4dc74f",
      "size": 1367
    },
    "/lib/mobility-core/src/Kernel/External/Notification/PayTM/Client.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n\nmodule Kernel.External.Notification.PayTM.Client where\n\nimport EulerHS.Prelude\nimport Kernel.External.Encryption (decrypt)\nimport qualified Kernel.External.Notification.PayTM.API as API\nimport qualified Kernel.External.Notification.PayTM.Types as PayTM\nimport Kernel.Tools.Metrics.CoreMetrics (CoreMetrics)\nimport Kernel.Types.Common\nimport Kernel.Utils.Common\n\nnotifyPerson ::\n  ( CoreMetrics m,\n    EncFlow m r,\n    MonadFlow m,\n    ToJSON a\n  ) =>\n  PayTM.PayTMConfig ->\n  PayTM.NotificationReq a ->\n  m ()\nnotifyPerson config req = do\n  if (any (\\el -> el == req.templateName) config.whitelistedTemplates)\n    then do\n      logTagDebug tag $ \"request body : \" <> encodeToText req -- TODO :: To Be deleted\n      apiKey <- PayTM.getPaytmApiKey <$> decrypt config.apiKey\n      clientId <- PayTM.getPaytmClientId <$> decrypt config.clientId\n      eitherRes <- callAPI config.paytmUrl (API.notifyClient clientId apiKey req) \"notifyPerson\" API.notificationAPI\n      case eitherRes of\n        Right res ->\n          case res.code of\n            202 -> logTagInfo tag $ \"message sent successfully to : \" <> show req.notificationReceiver.notificationReceiverIdentifier\n            _ -> logTagError tag $ \"message failed to send to : \" <> show req.notificationReceiver.notificationReceiverIdentifier\n        Left _ -> logTagError tag $ \"message failed to send to : \" <> show req.notificationReceiver.notificationReceiverIdentifier\n    else logTagInfo tag $ \"message not sent as template \" <> req.templateName <> \" is not whitelisted\"\n  where\n    tag = \"PayTM\"\n",
      "hash": "8b0738269069474ba8a49adba928b53bdb87a539e9ba802f536d54a6a4bee134",
      "size": 2248
    },
    "/lib/mobility-core/src/Kernel/External/Notification/PayTM/Types.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n{-# LANGUAGE DerivingVia #-}\n{-# LANGUAGE GeneralizedNewtypeDeriving #-}\n{-# LANGUAGE TemplateHaskell #-}\n\nmodule Kernel.External.Notification.PayTM.Types where\n\nimport Data.Aeson.Casing\nimport Data.Aeson.TH\nimport Data.Aeson.Types\nimport Kernel.External.Encryption\nimport Kernel.Prelude\n\nnewtype PaytmApiKey = PaytmApiKey\n  { getPaytmApiKey :: Text\n  }\n  deriving newtype (Show, Eq, ToJSON, FromJSON, DbHashable)\n\nnewtype PaytmClientId = PaytmClientId\n  { getPaytmClientId :: Text\n  }\n  deriving newtype (Show, Eq, ToJSON, FromJSON, DbHashable)\n\ndata PayTMConfig = PayTMConfig\n  { paytmUrl :: BaseUrl,\n    clientId :: EncryptedField 'AsEncrypted PaytmClientId,\n    apiKey :: EncryptedField 'AsEncrypted PaytmApiKey,\n    whitelistedTemplates :: [Text]\n  }\n  deriving (Show, Eq, Generic, FromJSON, ToJSON)\n\ndata NotificationReciever = NotificationReciever\n  { notificationReceiverType :: Text,\n    notificationReceiverIdentifier :: [Text]\n  }\n  deriving (Generic, Show, ToJSON)\n\ndata DeviceType = ANDROIDAPP | IOSAPP deriving (Generic, Show, ToJSON)\n\ndata ExtraCommonParams = ExtraCommonParams\n  { urlType :: Text,\n    url :: Text\n  }\n  deriving (Generic, Show)\n\nderiveJSON (defaultOptions {fieldLabelModifier = snakeCase}) ''ExtraCommonParams\n\ndata NotificationReq a = NotificationReq\n  { sendBroadcastPush :: Bool,\n    notificationReceiver :: NotificationReciever,\n    deviceType :: [DeviceType],\n    templateName :: Text,\n    extraCommonParams :: ExtraCommonParams,\n    dynamicParams :: a\n  }\n  deriving (Generic, Show, ToJSON)\n\ndata Status = SUCCESS | FAILURE deriving (Generic, Show, FromJSON, ToJSON)\n\ndata NotificationResp = NotificationResp\n  { code :: Int,\n    message :: Text,\n    status :: Status\n  }\n  deriving (Generic, Show, FromJSON, ToJSON)\n",
      "hash": "921b4fa52bf9d11cb39976b6651421b155c799b718c249c6f086e105da8f9701",
      "size": 2449
    },
    "/lib/mobility-core/src/Kernel/External/Notification/Types.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n{-# LANGUAGE TemplateHaskell #-}\n\nmodule Kernel.External.Notification.Types where\n\nimport Data.OpenApi\nimport EulerHS.Prelude\nimport Kernel.Beam.Lib.UtilsTH (mkBeamInstancesForEnumAndList)\nimport Kernel.Storage.Esqueleto (derivePersistField)\n\ndata NotificationService = FCM | PayTM | GRPC\n  deriving (Show, Read, Eq, Ord, Generic, ToJSON, FromJSON, ToSchema)\n\n$(mkBeamInstancesForEnumAndList ''NotificationService)\n\nderivePersistField \"NotificationService\"\n",
      "hash": "63fe7964a1e6a66dfdb62be7ca0fe4f58625367cd09c7eb939c036effeeacd0c",
      "size": 1150
    },
    "/lib/mobility-core/src/Kernel/External/Payment/Interface.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\nmodule Kernel.External.Payment.Interface\n  ( module Reexport,\n    module Kernel.External.Payment.Interface,\n  )\nwhere\n\nimport qualified Kernel.External.Payment.Interface.Juspay as Juspay\nimport qualified Kernel.External.Payment.Interface.Stripe as Stripe\nimport Kernel.External.Payment.Interface.Types as Reexport\nimport qualified Kernel.External.Payment.Stripe.Types as Stripe\nimport Kernel.External.Payment.Types as Reexport\nimport Kernel.Prelude\nimport Kernel.Tools.Metrics.CoreMetrics (CoreMetrics)\nimport Kernel.Types.Error\nimport Kernel.Utils.Common\n\ncreateOrder ::\n  ( EncFlow m r,\n    CoreMetrics m\n  ) =>\n  PaymentServiceConfig ->\n  Maybe Text ->\n  CreateOrderReq ->\n  m CreateOrderResp\ncreateOrder serviceConfig mRoutingId req = case serviceConfig of\n  JuspayConfig cfg -> do\n    let req' = req {metadataGatewayReferenceId = cfg.gatewayReferenceId}\n    Juspay.createOrder cfg mRoutingId req'\n  StripeConfig _ -> throwError $ InternalError \"Stripe Create Order not supported.\"\n\norderStatus ::\n  ( EncFlow m r,\n    CoreMetrics m\n  ) =>\n  PaymentServiceConfig ->\n  Maybe Text ->\n  OrderStatusReq ->\n  m OrderStatusResp\norderStatus serviceConfig mRoutingId req = case serviceConfig of\n  JuspayConfig cfg -> Juspay.orderStatus cfg mRoutingId req\n  StripeConfig _ -> throwError $ InternalError \"Stripe Order Status not supported.\"\n\nupdateOrder ::\n  ( EncFlow m r,\n    CoreMetrics m\n  ) =>\n  PaymentServiceConfig ->\n  Maybe Text ->\n  OrderUpdateReq ->\n  m OrderUpdateResp\nupdateOrder serviceConfig mRoutingId req = case serviceConfig of\n  JuspayConfig cfg -> Juspay.updateOrder cfg mRoutingId req\n  StripeConfig _ -> throwError $ InternalError \"Stripe Update Order not supported.\"\n\nofferList ::\n  ( EncFlow m r,\n    CoreMetrics m\n  ) =>\n  PaymentServiceConfig ->\n  Maybe Text ->\n  OfferListReq ->\n  m OfferListResp\nofferList serviceConfig mRoutingId req = case serviceConfig of\n  JuspayConfig cfg -> Juspay.offerList cfg mRoutingId req\n  StripeConfig _ -> throwError $ InternalError \"Stripe Offer List not supported.\"\n\nofferApply ::\n  ( EncFlow m r,\n    CoreMetrics m\n  ) =>\n  PaymentServiceConfig ->\n  Maybe Text ->\n  OfferApplyReq ->\n  m OfferApplyResp\nofferApply serviceConfig mRoutingId req = case serviceConfig of\n  JuspayConfig cfg -> Juspay.offerApply cfg mRoutingId req\n  StripeConfig _ -> throwError $ InternalError \"Stripe Offer Apply not supported.\"\n\nofferNotify ::\n  ( EncFlow m r,\n    CoreMetrics m\n  ) =>\n  PaymentServiceConfig ->\n  Maybe Text ->\n  OfferNotifyReq ->\n  m OfferNotifyResp\nofferNotify serviceConfig mRoutingId req = case serviceConfig of\n  JuspayConfig cfg -> Juspay.offerNotify cfg mRoutingId req\n  StripeConfig _ -> throwError $ InternalError \"Stripe Offer Notify not supported.\"\n\nmandateRevoke ::\n  ( EncFlow m r,\n    CoreMetrics m\n  ) =>\n  PaymentServiceConfig ->\n  Maybe Text ->\n  MandateRevokeReq ->\n  m MandateRevokeRes\nmandateRevoke serviceConfig mRoutingId req = case serviceConfig of\n  JuspayConfig cfg -> Juspay.mandateRevoke cfg mRoutingId req\n  StripeConfig _ -> throwError $ InternalError \"Stripe Mandate Revoke not supported.\"\n\nmandateNotification ::\n  ( EncFlow m r,\n    CoreMetrics m\n  ) =>\n  PaymentServiceConfig ->\n  Maybe Text ->\n  MandateNotificationReq ->\n  m MandateNotificationRes\nmandateNotification serviceConfig mRoutingId req = case serviceConfig of\n  JuspayConfig cfg -> Juspay.mandateNotification cfg mRoutingId req\n  StripeConfig _ -> throwError $ InternalError \"Stripe Mandate Notification not supported.\"\n\nmandateNotificationStatus ::\n  ( EncFlow m r,\n    CoreMetrics m\n  ) =>\n  PaymentServiceConfig ->\n  Maybe Text ->\n  NotificationStatusReq ->\n  m NotificationStatusResp\nmandateNotificationStatus serviceConfig mRoutingId req = case serviceConfig of\n  JuspayConfig cfg -> Juspay.mandateNotificationStatus cfg mRoutingId req\n  StripeConfig _ -> throwError $ InternalError \"Stripe Mandate Notification Status not supported.\"\n\nmandateExecution ::\n  ( EncFlow m r,\n    CoreMetrics m\n  ) =>\n  PaymentServiceConfig ->\n  Maybe Text ->\n  MandateExecutionReq ->\n  m MandateExecutionRes\nmandateExecution serviceConfig mRoutingId req = case serviceConfig of\n  JuspayConfig cfg -> Juspay.mandateExecution cfg mRoutingId req\n  StripeConfig _ -> throwError $ InternalError \"Stripe Mandate Execution not supported.\"\n\nautoRefunds ::\n  ( EncFlow m r,\n    CoreMetrics m\n  ) =>\n  PaymentServiceConfig ->\n  Maybe Text ->\n  AutoRefundReq ->\n  m AutoRefundResp\nautoRefunds serviceConfig mRoutingId req = case serviceConfig of\n  JuspayConfig cfg -> Juspay.autoRefund cfg mRoutingId req\n  StripeConfig _ -> throwError $ InternalError \"Stripe Auto Refunds not supported.\"\n\ncreateIndividualConnectAccount ::\n  ( EncFlow m r,\n    CoreMetrics m\n  ) =>\n  PaymentServiceConfig ->\n  IndividualConnectAccountReq ->\n  m IndividualConnectAccountResp\ncreateIndividualConnectAccount serviceConfig req = case serviceConfig of\n  JuspayConfig _ -> throwError $ InternalError \"Juspay Create Individual Connect Account not supported.\"\n  StripeConfig cfg -> Stripe.createIndividualConnectAccount cfg req\n\nretryAccountLink ::\n  ( CoreMetrics m,\n    EncFlow m r\n  ) =>\n  PaymentServiceConfig ->\n  Stripe.AccountId ->\n  m RetryAccountLink\nretryAccountLink config accountId = case config of\n  JuspayConfig _ -> throwError $ InternalError \"Juspay Retry Account Link not supported.\"\n  StripeConfig cfg -> Stripe.retryAccountLink cfg accountId\n\ngetAccount ::\n  ( CoreMetrics m,\n    EncFlow m r\n  ) =>\n  PaymentServiceConfig ->\n  Stripe.AccountId ->\n  m ConnectAccountResp\ngetAccount config accountId = case config of\n  JuspayConfig _ -> throwError $ InternalError \"Juspay Get Account not supported.\"\n  StripeConfig cfg -> Stripe.getAccount cfg accountId\n\ncreateCustomer ::\n  ( CoreMetrics m,\n    EncFlow m r\n  ) =>\n  PaymentServiceConfig ->\n  CreateCustomerReq ->\n  m CreateCustomerResp\ncreateCustomer config req = case config of\n  JuspayConfig cfg -> Juspay.createCustomer cfg req\n  StripeConfig cfg -> Stripe.createCustomer cfg req\n\ngetCustomer ::\n  ( CoreMetrics m,\n    EncFlow m r\n  ) =>\n  PaymentServiceConfig ->\n  CustomerId ->\n  m CreateCustomerResp\ngetCustomer config customerId = case config of\n  JuspayConfig cfg -> Juspay.getCustomer cfg customerId\n  StripeConfig _ -> throwError $ InternalError \"Stripe Get Customer not supported.\"\n\ncreateEphemeralKeys ::\n  ( CoreMetrics m,\n    EncFlow m r\n  ) =>\n  PaymentServiceConfig ->\n  CustomerId ->\n  m Text\ncreateEphemeralKeys config customerId = case config of\n  JuspayConfig _ -> throwError $ InternalError \"Juspay Create Ephemeral Keys not supported.\"\n  StripeConfig cfg -> Stripe.createEphemeralKeys cfg customerId\n\ndeleteCard ::\n  ( CoreMetrics m,\n    EncFlow m r\n  ) =>\n  PaymentServiceConfig ->\n  PaymentMethodId ->\n  m ()\ndeleteCard config cardId = case config of\n  JuspayConfig _ -> throwError $ InternalError \"Juspay Delete Card not supported.\"\n  StripeConfig cfg -> Stripe.deleteCard cfg cardId\n\ngetCardList ::\n  ( CoreMetrics m,\n    EncFlow m r\n  ) =>\n  PaymentServiceConfig ->\n  CustomerId ->\n  m CustomerCardListResp\ngetCardList config customerId = case config of\n  JuspayConfig _ -> throwError $ InternalError \"Juspay Get Card List not supported.\"\n  StripeConfig cfg -> Stripe.getCardList cfg customerId\n\ncreatePaymentIntent ::\n  ( CoreMetrics m,\n    EncFlow m r\n  ) =>\n  PaymentServiceConfig ->\n  CreatePaymentIntentReq ->\n  m CreatePaymentIntentResp\ncreatePaymentIntent config req = case config of\n  JuspayConfig _ -> throwError $ InternalError \"Juspay Create Payment Intent not supported.\"\n  StripeConfig cfg -> Stripe.createPaymentIntent cfg req\n\nupdatePaymentMethodInIntent ::\n  ( CoreMetrics m,\n    EncFlow m r\n  ) =>\n  PaymentServiceConfig ->\n  PaymentIntentId ->\n  PaymentMethodId ->\n  m ()\nupdatePaymentMethodInIntent config paymentIntentId paymentMethodId = case config of\n  JuspayConfig _ -> throwError $ InternalError \"Juspay Update Payment Method In Intent not supported.\"\n  StripeConfig cfg -> Stripe.updatePaymentMethodInIntent cfg paymentIntentId paymentMethodId\n\ngetPaymentIntent ::\n  ( CoreMetrics m,\n    EncFlow m r\n  ) =>\n  PaymentServiceConfig ->\n  PaymentIntentId ->\n  m CreatePaymentIntentResp\ngetPaymentIntent config paymentIntentId = case config of\n  JuspayConfig _ -> throwError $ InternalError \"Juspay Get Payment Intent not supported.\"\n  StripeConfig cfg -> Stripe.getPaymentIntent cfg paymentIntentId\n\ncapturePaymentIntent ::\n  ( CoreMetrics m,\n    EncFlow m r\n  ) =>\n  PaymentServiceConfig ->\n  PaymentIntentId ->\n  HighPrecMoney ->\n  HighPrecMoney ->\n  m ()\ncapturePaymentIntent config paymentIntentId amount applicationFeeAmount = case config of\n  JuspayConfig _ -> throwError $ InternalError \"Juspay Capture Payment Intent not supported.\"\n  StripeConfig cfg -> Stripe.capturePaymentIntent cfg paymentIntentId amount applicationFeeAmount\n\nupdateAmountInPaymentIntent ::\n  ( CoreMetrics m,\n    EncFlow m r\n  ) =>\n  PaymentServiceConfig ->\n  PaymentIntentId ->\n  HighPrecMoney ->\n  HighPrecMoney ->\n  m ()\nupdateAmountInPaymentIntent config paymentIntentId amount applicationFeeAmount = case config of\n  JuspayConfig _ -> throwError $ InternalError \"Juspay Update Amount In Payment Intent not supported.\"\n  StripeConfig cfg -> Stripe.updateAmountInPaymentIntent cfg paymentIntentId amount applicationFeeAmount\n\ncreateSetupIntent ::\n  ( CoreMetrics m,\n    EncFlow m r\n  ) =>\n  PaymentServiceConfig ->\n  CustomerId ->\n  m CreateSetupIntentResp\ncreateSetupIntent config customerId = case config of\n  JuspayConfig _ -> throwError $ InternalError \"Juspay Create Setup Intent not supported.\"\n  StripeConfig cfg -> Stripe.createSetupIntent cfg customerId\n\ngetCard ::\n  ( CoreMetrics m,\n    EncFlow m r\n  ) =>\n  PaymentServiceConfig ->\n  PaymentMethodId ->\n  CustomerId ->\n  m CustomerCard\ngetCard config cardId customerId = case config of\n  JuspayConfig _ -> throwError $ InternalError \"Juspay Get Card not supported.\"\n  StripeConfig cfg -> Stripe.getCard cfg cardId customerId\n\ncancelPaymentIntent ::\n  ( CoreMetrics m,\n    EncFlow m r\n  ) =>\n  PaymentServiceConfig ->\n  PaymentIntentId ->\n  m CreatePaymentIntentResp\ncancelPaymentIntent config paymentIntentId = case config of\n  JuspayConfig _ -> throwError $ InternalError \"Juspay Cancel Payment Intent not supported.\"\n  StripeConfig cfg -> Stripe.cancelPaymentIntent cfg paymentIntentId\n\nverifyVPA ::\n  ( CoreMetrics m,\n    EncFlow m r\n  ) =>\n  PaymentServiceConfig ->\n  Maybe Text ->\n  VerifyVPAReq ->\n  m VerifyVPAResp\nverifyVPA config mRoutingId req = case config of\n  JuspayConfig cfg -> Juspay.verifyVPA cfg mRoutingId req\n  StripeConfig _ -> throwError $ InternalError \"Stripe Verify VPA not supported.\"\n\nisSplitEnabled :: PaymentServiceConfig -> Bool\nisSplitEnabled = \\case\n  JuspayConfig cfg -> fromMaybe False cfg.isSplitEnabled\n  StripeConfig _ -> False\n",
      "hash": "12a894d2991d0babdae8c1d98d746d41ed68fa2689f3f384231b1c4c9201e38a",
      "size": 11420
    },
    "/lib/mobility-core/src/Kernel/External/Payment/Interface/Juspay.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n\nmodule Kernel.External.Payment.Interface.Juspay\n  ( module Reexport,\n    createOrder,\n    createCustomer,\n    getCustomer,\n    orderStatus,\n    updateOrder,\n    orderStatusWebhook,\n    offerList,\n    offerApply,\n    offerNotify,\n    mandateNotification,\n    mandateExecution,\n    mandateRevoke,\n    mandatePause,\n    mandateResume,\n    autoRefund,\n    mandateNotificationStatus,\n    verifyVPA,\n  )\nwhere\n\nimport qualified Data.Aeson as A\nimport Data.Text (pack, replace, toUpper)\nimport qualified Data.Text as T\nimport Data.Time (UTCTime (utctDay), addDays)\nimport Data.Time.Clock.POSIX (posixSecondsToUTCTime, utcTimeToPOSIXSeconds)\nimport Data.Time.Format\nimport qualified EulerHS.Prelude as E\nimport GHC.Float (double2Int)\nimport Kernel.External.Encryption\nimport Kernel.External.Payment.Interface.Types\nimport Kernel.External.Payment.Juspay.Config as Reexport\nimport qualified Kernel.External.Payment.Juspay.Flow as Juspay\nimport qualified Kernel.External.Payment.Juspay.Types as Juspay\nimport qualified Kernel.External.Payment.Juspay.Types.CreateCustomer as Customer\nimport qualified Kernel.External.Payment.Juspay.Webhook as Juspay\nimport Kernel.Prelude\nimport qualified Kernel.Tools.Metrics.CoreMetrics as Metrics\nimport Kernel.Types.APISuccess\nimport Kernel.Types.Beckn.Ack\nimport Kernel.Types.Error\nimport Kernel.Utils.Common (HighPrecMoney, Log, MonadTime, fromMaybeM, getCurrentTime)\nimport Kernel.Utils.Logging (logDebug)\nimport Servant hiding (throwError)\n\ncreateOrder ::\n  ( Metrics.CoreMetrics m,\n    EncFlow m r\n  ) =>\n  JuspayCfg ->\n  Maybe Text ->\n  CreateOrderReq ->\n  m CreateOrderResp\ncreateOrder config mRoutingId req = do\n  let url = config.url\n      merchantId = config.merchantId\n      clientId = fromMaybe merchantId config.pseudoClientId\n  apiKey <- decrypt config.apiKey\n  orderReq <- mkCreateOrderReq config.returnUrl clientId merchantId req\n  Juspay.createOrder url apiKey merchantId mRoutingId orderReq\n\nupdateOrder ::\n  ( Metrics.CoreMetrics m,\n    EncFlow m r\n  ) =>\n  JuspayCfg ->\n  Maybe Text ->\n  OrderUpdateReq ->\n  m OrderUpdateResp\nupdateOrder config mRoutingId req = do\n  let url = config.url\n      merchantId = config.merchantId\n  logDebug $ \"updateOrder req: \" <> show req\n  apiKey <- decrypt config.apiKey\n  updateOrderReq <- mkUpdateOrderReq req\n  logDebug $ \"updateOrder mkUpdateOrderReq: \" <> show updateOrderReq\n  updateOrderRes <- Juspay.updateOrder url apiKey merchantId req.orderShortId mRoutingId updateOrderReq\n  logDebug $ \"updateOrder res: \" <> show updateOrderRes\n  return $ mkUpdateOrderRes updateOrderRes\n  where\n    mkUpdateOrderReq :: MonadTime m => OrderUpdateReq -> m Juspay.OrderUpdateReq\n    mkUpdateOrderReq OrderUpdateReq {..} =\n      do\n        return\n          Juspay.OrderUpdateReq\n            { amount = amount,\n              split_settlement_details = mkSplitSettlementDetails <$> splitSettlementDetails\n            }\n    mkUpdateOrderRes Juspay.OrderUpdateResp {..} =\n      OrderUpdateResp\n        { orderId = order_id,\n          amount\n        }\n\ncreateCustomer ::\n  ( Metrics.CoreMetrics m,\n    EncFlow m r\n  ) =>\n  JuspayCfg ->\n  CreateCustomerReq ->\n  m CreateCustomerResp\ncreateCustomer config req = do\n  let url = config.url\n      merchantId = config.merchantId\n      routingId = req.objectReferenceId\n  apiKey <- decrypt config.apiKey\n  createCustomerReq <- mkcreateCustomerReq req\n  creatCustomerRespo <- Juspay.createCustomer url apiKey merchantId routingId createCustomerReq\n  return $ mkCreateCustomerRes creatCustomerRespo\n  where\n    mkcreateCustomerReq :: MonadTime m => CreateCustomerReq -> m Juspay.CreateCustomerRequest\n    mkcreateCustomerReq CreateCustomerReq {..} =\n      do\n        return\n          Juspay.CreateCustomerRequest\n            { object_reference_id = fromMaybe \"\" objectReferenceId,\n              mobile_number = fromMaybe \"\" phone,\n              email_address = email,\n              first_name = name,\n              last_name = lastName,\n              mobile_country_code = mobileCountryCode,\n              options_get_client_auth_token = optionsGetClientAuthToken\n            }\n    mkCreateCustomerRes Juspay.CreateCustomerResp {..} =\n      CreateCustomerResp\n        { customerId = object_reference_id,\n          clientAuthToken = Customer.client_auth_token <$> juspay,\n          clientAuthTokenExpiry = Customer.client_auth_token_expiry <$> juspay\n        }\n\ngetCustomer ::\n  ( Metrics.CoreMetrics m,\n    EncFlow m r\n  ) =>\n  JuspayCfg ->\n  CustomerId ->\n  m CreateCustomerResp\ngetCustomer config customerId = do\n  let url = config.url\n      merchantId = config.merchantId\n  apiKey <- decrypt config.apiKey\n  creatCustomerRespo <- Juspay.getCustomer url apiKey merchantId (Just customerId) customerId mkGetCustomerReq\n  return $ mkCreateCustomerRes creatCustomerRespo\n  where\n    mkCreateCustomerRes Juspay.CreateCustomerResp {..} =\n      CreateCustomerResp\n        { customerId = object_reference_id,\n          clientAuthToken = Customer.client_auth_token <$> juspay,\n          clientAuthTokenExpiry = Customer.client_auth_token_expiry <$> juspay\n        }\n    mkGetCustomerReq =\n      Juspay.GetCustomerReq\n        { options_get_client_auth_token = True\n        }\n\nmandateNotification ::\n  ( Metrics.CoreMetrics m,\n    EncFlow m r\n  ) =>\n  JuspayCfg ->\n  Maybe Text ->\n  MandateNotificationReq ->\n  m MandateNotificationRes\nmandateNotification config mRoutingId req = do\n  let url = config.url\n      merchantId = config.merchantId\n  apiKey <- decrypt config.apiKey\n  notificationResponse <- Juspay.mandateNotification url apiKey req.mandateId merchantId mRoutingId (mkNotificationReq req)\n  return $ mkNotificationRes notificationResponse\n  where\n    mkNotificationRes Juspay.MandateNotificationRes {..} =\n      MandateNotificationRes\n        { juspayProvidedId = id,\n          sourceInfo = castSourceInfo source_info,\n          notificationId = object_reference_id,\n          providerName = provider_name,\n          notificationType = notification_type,\n          description,\n          status,\n          dateCreated = posixSecondsToUTCTime <$> (fromIntegral <$> (readMaybe (T.unpack date_created) :: Maybe Int)),\n          lastUpdated = posixSecondsToUTCTime <$> (fromIntegral <$> (readMaybe (T.unpack last_updated) :: Maybe Int))\n        }\n\nmandateNotificationStatus ::\n  ( Metrics.CoreMetrics m,\n    EncFlow m r\n  ) =>\n  JuspayCfg ->\n  Maybe Text ->\n  NotificationStatusReq ->\n  m NotificationStatusResp\nmandateNotificationStatus config mRoutingId req = do\n  let url = config.url\n      merchantId = config.merchantId\n  apiKey <- decrypt config.apiKey\n  notificationStatusResponse <- Juspay.mandateNotificationStatus url apiKey req.notificationId merchantId mRoutingId\n  return $ mkNotificationStatusRes notificationStatusResponse\n  where\n    mkNotificationStatusRes Juspay.NotificationStatusResp {..} =\n      NotificationStatusResp\n        { id,\n          sourceObject = source_object,\n          sourceObjectId = source_object_id,\n          sourceInfo = castSourceInfo source_info,\n          objectReferenceId = object_reference_id,\n          providerName = provider_name,\n          notificationType = notification_type,\n          providerResponse =\n            ( \\pR ->\n                Just $\n                  ProviderResponse\n                    { providerRefId = pR.provider_ref_id,\n                      notificationDate = (\\date -> posixSecondsToUTCTime <$> (fromIntegral <$> (readMaybe (T.unpack date) :: Maybe Int))) =<< pR.notification_date,\n                      responseCode = pR.provider_response_code,\n                      responseMessage = pR.provider_response_message\n                    }\n            )\n              =<< provider_response,\n          description,\n          status,\n          dateCreated = posixSecondsToUTCTime <$> (fromIntegral <$> (readMaybe (T.unpack date_created) :: Maybe Int)),\n          lastUpdated = posixSecondsToUTCTime <$> (fromIntegral <$> (readMaybe (T.unpack last_updated) :: Maybe Int))\n        }\n\nmandateExecution ::\n  ( Metrics.CoreMetrics m,\n    EncFlow m r\n  ) =>\n  JuspayCfg ->\n  Maybe Text ->\n  MandateExecutionReq ->\n  m MandateExecutionRes\nmandateExecution config mRoutingId req = do\n  let url = config.url\n      merchantId = config.merchantId\n  apiKey <- decrypt config.apiKey\n  executionResponse <- Juspay.mandateExecution url apiKey merchantId mRoutingId (mkExecutionReq req merchantId)\n  return $ mkExecutionResponse executionResponse\n  where\n    mkExecutionResponse Juspay.MandateExecutionRes {..} =\n      MandateExecutionRes\n        { orderId = order_id,\n          txnId = txn_id,\n          txnUUID = txn_uuid,\n          status\n        }\n\nmandateRevoke ::\n  ( Metrics.CoreMetrics m,\n    EncFlow m r\n  ) =>\n  JuspayCfg ->\n  Maybe Text ->\n  MandateRevokeReq ->\n  m MandateRevokeRes\nmandateRevoke config mRoutingId req = do\n  let url = config.url\n      merchantId = config.merchantId\n  apiKey <- decrypt config.apiKey\n  void $ Juspay.mandateRevoke url apiKey merchantId mRoutingId req.mandateId Juspay.MandateRevokeReq {command = \"revoke\"}\n  return Success\n\nmkCreateOrderReq :: MonadTime m => BaseUrl -> Text -> Text -> CreateOrderReq -> m Juspay.CreateOrderReq\nmkCreateOrderReq returnUrl clientId merchantId CreateOrderReq {..} =\n  do\n    return\n      Juspay.CreateOrderReq\n        { order_id = orderShortId,\n          amount = show amount,\n          customer_id = customerId,\n          customer_email = customerEmail,\n          customer_phone = customerPhone,\n          payment_page_client_id = clientId,\n          action = \"paymentPage\",\n          return_url = showBaseUrl returnUrl,\n          description = \"Complete your payment\",\n          first_name = customerFirstName,\n          last_name = customerLastName,\n          mandate_max_amount = show <$> mandateMaxAmount,\n          mandate_frequency = mandateFrequency,\n          create_mandate = createMandate,\n          metadata_mandate_name = if isJust createMandate then Just (toUpper merchantId) else Nothing,\n          metadata_remarks = (\"Amount to be paid now is Rs \" <>) . show . double2Int . realToFrac $ amount,\n          mandate_start_date = mandateStartDate,\n          mandate_end_date = mandateEndDate,\n          options_get_upi_deep_links = optionsGetUpiDeepLinks,\n          metadata_expiry_in_mins = metadataExpiryInMins,\n          metadata_gateway_reference_id = metadataGatewayReferenceId,\n          split_settlement_details = mkSplitSettlementDetails <$> splitSettlementDetails\n        }\n\nmkSplitSettlementDetails :: SplitSettlementDetails -> Juspay.SplitSettlementDetails\nmkSplitSettlementDetails splitDetails =\n  Juspay.SplitSettlementDetails\n    { marketplace = mkMarketplace splitDetails.marketplace,\n      mdr_borne_by = show splitDetails.mdrBorneBy,\n      vendor = mkVendor splitDetails.vendor\n    }\n  where\n    mkMarketplace Marketplace {..} = Juspay.Marketplace {..}\n    mkVendor vendor = Juspay.Vendor {split = mkSplit <$> vendor.split}\n    mkSplit split = Juspay.Split {amount = split.amount, merchant_commission = split.merchantCommission, sub_mid = split.subMid, unique_split_id = split.uniqueSplitId}\n\norderStatus ::\n  ( HasCallStack,\n    Metrics.CoreMetrics m,\n    EncFlow m r\n  ) =>\n  JuspayCfg ->\n  Maybe Text ->\n  OrderStatusReq ->\n  m OrderStatusResp\norderStatus config mRoutingId req = do\n  let url = config.url\n      merchantId = config.merchantId\n  apiKey <- decrypt config.apiKey\n  mkOrderStatusResp <$> Juspay.orderStatus url apiKey merchantId mRoutingId req.orderShortId\n\nmkOrderStatusResp :: Juspay.OrderStatusResp -> OrderStatusResp\nmkOrderStatusResp Juspay.OrderData {..} =\n  case mandate of\n    Just justMandate ->\n      MandateOrderStatusResp\n        { eventName = Nothing,\n          orderShortId = order_id,\n          transactionUUID = txn_uuid,\n          txnId = txn_id,\n          transactionStatusId = fromMaybe (-3001) status_id,\n          transactionStatus = status,\n          paymentMethodType = payment_method_type,\n          paymentMethod = payment_method,\n          respMessage = resp_message,\n          respCode = resp_code,\n          gatewayReferenceId = gateway_reference_id,\n          amount = realToFrac amount,\n          currency = currency,\n          dateCreated = date_created,\n          bankErrorMessage = if bank_error_message == Just \"\" then Nothing else bank_error_message,\n          bankErrorCode = if bank_error_code == Just \"\" then Nothing else bank_error_code,\n          mandateStartDate = posixSecondsToUTCTime <$> (fromIntegral <$> (readMaybe (T.unpack justMandate.start_date) :: Maybe Int)),\n          mandateEndDate = posixSecondsToUTCTime <$> (fromIntegral <$> (readMaybe (T.unpack justMandate.end_date) :: Maybe Int)),\n          mandateId = justMandate.mandate_id,\n          mandateStatus = justMandate.mandate_status,\n          mandateFrequency = justMandate.frequency,\n          mandateMaxAmount = justMandate.max_amount,\n          payerVpa = payer_vpa,\n          upi = castUpi <$> upi,\n          refunds = maybe [] mkRefundsData refunds,\n          amountRefunded = realToFrac <$> amount_refunded\n        }\n    Nothing -> do\n      let (isRetriedOrder, retargetPaymentLink, retargetPaymentLinkExpiry, isRetargetedOrder) = parseRetargetAndRetryData metadata links additional_info\n      OrderStatusResp\n        { eventName = Nothing,\n          orderShortId = order_id,\n          transactionUUID = txn_uuid,\n          txnId = txn_id,\n          transactionStatusId = fromMaybe (-3001) status_id,\n          transactionStatus = status,\n          paymentMethodType = payment_method_type,\n          paymentMethod = payment_method,\n          paymentGatewayResponse =\n            payment_gateway_response\n              <&> ( \\pgResp ->\n                      PaymentGatewayResponse\n                        { respCode = pgResp.resp_code,\n                          rrn = pgResp.rrn,\n                          created = pgResp.created,\n                          epgTxnId = pgResp.epg_txn_id,\n                          respMessage = pgResp.resp_message,\n                          authIdCode = pgResp.auth_id_code,\n                          txnId = pgResp.txn_id\n                        }\n                  ),\n          respMessage = resp_message,\n          respCode = resp_code,\n          gatewayReferenceId = gateway_reference_id,\n          amount = realToFrac amount,\n          currency = currency,\n          bankErrorMessage = if bank_error_message == Just \"\" then Nothing else bank_error_message,\n          bankErrorCode = if bank_error_code == Just \"\" then Nothing else bank_error_code,\n          dateCreated = date_created,\n          refunds = maybe [] mkRefundsData refunds,\n          amountRefunded = realToFrac <$> amount_refunded,\n          payerVpa = payer_vpa,\n          upi = castUpi <$> upi,\n          card = castCard <$> card,\n          splitSettlementResponse = mkSplitSettlementResponse <$> split_settlement_response,\n          ..\n        }\n\ncastUpi :: Juspay.Upi -> Upi\ncastUpi Juspay.Upi {..} = Upi {payerApp = payer_app, payerAppName = payer_app_name, txnFlowType = txn_flow_type, payerVpa = payer_vpa}\n\ncastCard :: Juspay.CardInfo -> CardInfo\ncastCard Juspay.CardInfo {..} = CardInfo {cardType = card_type, lastFourDigits = last_four_digits}\n\nmkNotificationReq :: MandateNotificationReq -> Juspay.MandateNotificationReq\nmkNotificationReq mandateNotificationReq =\n  Juspay.MandateNotificationReq\n    { command = \"pre_debit_notify\",\n      object_reference_id = mandateNotificationReq.notificationId,\n      source_info = Juspay.SourceInfo {amount = show mandateNotificationReq.amount, txn_date = show $ utcTimeToPOSIXSeconds mandateNotificationReq.txnDate},\n      description = mandateNotificationReq.description\n    }\n\nmkExecutionReq :: MandateExecutionReq -> Text -> Juspay.MandateExecutionReq\nmkExecutionReq MandateExecutionReq {..} merchantId =\n  Juspay.MandateExecutionReq\n    { merchantId,\n      mandateId = mandateId,\n      mandate = Juspay.MandateInfo {notificationId = notificationId, executionDate = show $ utcTimeToPOSIXSeconds executionDate},\n      order = Juspay.MandateOrder {orderId = orderId, orderAmount = show amount, orderCustomerId = customerId, splitSettlementDetails = mkSplitSettlementDetails <$> splitSettlementDetails},\n      format = \"json\"\n    }\n\nmandatePause ::\n  ( Metrics.CoreMetrics m,\n    EncFlow m r\n  ) =>\n  JuspayCfg ->\n  MandatePauseReq ->\n  m ()\nmandatePause config req = do\n  let url = config.url\n  apiKey <- decrypt config.apiKey\n  juspayReq <- mkPauseReq req\n  Juspay.mandatePause url apiKey req.mandateId juspayReq\n\nmkPauseReq ::\n  ( Metrics.CoreMetrics m,\n    EncFlow m r\n  ) =>\n  MandatePauseReq ->\n  m Juspay.MandatePauseReq\nmkPauseReq MandatePauseReq {..} = do\n  now <- liftIO getCurrentTime\n  return $\n    Juspay.MandatePauseReq\n      { command = \"pause\",\n        pause_start_date = show $ utcTimeToPOSIXSeconds pauseStartDate,\n        pause_end_date = show $ utcTimeToPOSIXSeconds $ fromMaybe (addDaysUtcTime now (365 * 20)) pauseEndDate\n      }\n\nmandateResume ::\n  ( Metrics.CoreMetrics m,\n    EncFlow m r\n  ) =>\n  JuspayCfg ->\n  MandateResumeReq ->\n  m ()\nmandateResume config req = do\n  let url = config.url\n  apiKey <- decrypt config.apiKey\n  Juspay.mandateResume url apiKey req.mandateId (mkResumeReq req)\n\nmkResumeReq :: MandateResumeReq -> Juspay.MandateResumeReq\nmkResumeReq req =\n  Juspay.MandateResumeReq\n    { command = \"resume\",\n      resume_date = show $ utcTimeToPOSIXSeconds req.resumeDate\n    }\n\naddDaysUtcTime :: UTCTime -> Integer -> UTCTime\naddDaysUtcTime t x = t {utctDay = addDays x (utctDay t)}\n\norderStatusWebhook ::\n  EncFlow m r =>\n  PaymentServiceConfig ->\n  (OrderStatusResp -> Text -> m AckResponse) ->\n  BasicAuthData ->\n  A.Value ->\n  m (Maybe OrderStatusResp)\norderStatusWebhook paymentConfig orderStatusHandler authData val = do\n  now <- getCurrentTime\n  response <- Juspay.orderStatusWebhook paymentConfig (orderStatusHandler . mkWebhookOrderStatusResp now . (\\resp -> (resp.event_name, resp.content))) authData val\n  return $ mkWebhookOrderStatusResp now <$> response\n\nmkWebhookOrderStatusResp :: UTCTime -> (Juspay.PaymentStatus, Juspay.OrderAndNotificationStatusContent) -> OrderStatusResp\nmkWebhookOrderStatusResp now (eventName, Juspay.OrderAndNotificationStatusContent {..}) =\n  case (order, mandate, notification, txn) of\n    (Just justOrder, Nothing, _, _) ->\n      case justOrder.mandate of\n        Just justMandate ->\n          MandateOrderStatusResp\n            { eventName = Just eventName,\n              orderShortId = justOrder.order_id,\n              txnId = justOrder.txn_id,\n              transactionUUID = justOrder.txn_uuid,\n              transactionStatusId = fromMaybe (-3001) justOrder.status_id,\n              transactionStatus = justOrder.status,\n              paymentMethodType = justOrder.payment_method_type,\n              paymentMethod = justOrder.payment_method,\n              respMessage = justOrder.resp_message,\n              respCode = justOrder.resp_code,\n              gatewayReferenceId = justOrder.gateway_reference_id,\n              amount = realToFrac justOrder.amount,\n              bankErrorMessage = if justOrder.bank_error_message == Just \"\" then Nothing else justOrder.bank_error_message,\n              bankErrorCode = if justOrder.bank_error_code == Just \"\" then Nothing else justOrder.bank_error_code,\n              currency = justOrder.currency,\n              dateCreated = justOrder.date_created,\n              mandateStartDate = posixSecondsToUTCTime <$> (fromIntegral <$> (readMaybe (T.unpack justMandate.start_date) :: Maybe Int)),\n              mandateEndDate = posixSecondsToUTCTime <$> (fromIntegral <$> (readMaybe (T.unpack justMandate.end_date) :: Maybe Int)),\n              mandateStatus = justMandate.mandate_status,\n              mandateId = justMandate.mandate_id,\n              mandateFrequency = justMandate.frequency,\n              mandateMaxAmount = justMandate.max_amount,\n              payerVpa = justOrder.payer_vpa,\n              upi = castUpi <$> justOrder.upi,\n              refunds = maybe [] mkRefundsData justOrder.refunds,\n              amountRefunded = realToFrac <$> justOrder.amount_refunded -- not adding split\n            }\n        Nothing -> do\n          let (isRetriedOrder, retargetPaymentLink, retargetPaymentLinkExpiry, isRetargetedOrder) = parseRetargetAndRetryData justOrder.metadata justOrder.links justOrder.additional_info\n          OrderStatusResp\n            { eventName = Just eventName,\n              orderShortId = justOrder.order_id,\n              transactionUUID = justOrder.txn_uuid,\n              txnId = justOrder.txn_id,\n              transactionStatusId = fromMaybe (-3001) justOrder.status_id,\n              transactionStatus = justOrder.status,\n              paymentMethodType = justOrder.payment_method_type,\n              paymentMethod = justOrder.payment_method,\n              paymentGatewayResponse =\n                justOrder.payment_gateway_response\n                  <&> ( \\pgResp ->\n                          PaymentGatewayResponse\n                            { respCode = pgResp.resp_code,\n                              rrn = pgResp.rrn,\n                              created = pgResp.created,\n                              epgTxnId = pgResp.epg_txn_id,\n                              respMessage = pgResp.resp_message,\n                              authIdCode = pgResp.auth_id_code,\n                              txnId = pgResp.txn_id\n                            }\n                      ),\n              respMessage = justOrder.resp_message,\n              respCode = justOrder.resp_code,\n              gatewayReferenceId = justOrder.gateway_reference_id,\n              bankErrorMessage = if justOrder.bank_error_message == Just \"\" then Nothing else justOrder.bank_error_message,\n              bankErrorCode = if justOrder.bank_error_code == Just \"\" then Nothing else justOrder.bank_error_code,\n              amount = realToFrac justOrder.amount,\n              currency = justOrder.currency,\n              dateCreated = justOrder.date_created,\n              refunds = maybe [] mkRefundsData justOrder.refunds,\n              amountRefunded = realToFrac <$> justOrder.amount_refunded,\n              payerVpa = justOrder.payer_vpa,\n              upi = castUpi <$> justOrder.upi,\n              card = castCard <$> justOrder.card,\n              splitSettlementResponse = mkSplitSettlementResponse <$> justOrder.split_settlement_response,\n              ..\n            }\n    (Nothing, Just justMandate, _, _) ->\n      MandateStatusResp\n        { eventName = Just eventName,\n          orderShortId = justMandate.order_id,\n          status = justMandate.status,\n          mandateStartDate = posixSecondsToUTCTime <$> (fromIntegral <$> (readMaybe (T.unpack justMandate.start_date) :: Maybe Int)),\n          mandateEndDate = posixSecondsToUTCTime <$> (fromIntegral <$> (readMaybe (T.unpack justMandate.end_date) :: Maybe Int)),\n          mandateId = justMandate.mandate_id,\n          mandateFrequency = justMandate.frequency,\n          mandateMaxAmount = justMandate.max_amount,\n          upi = castUpi <$> (justMandate.payment_info >>= (.upi))\n        }\n    (_, _, Just justNotification, _) ->\n      PDNNotificationStatusResp\n        { eventName = Just eventName,\n          notificationStatus = justNotification.status,\n          sourceObject = justNotification.source_object,\n          sourceInfo = maybe SourceInfo {txnDate = Just now, sourceAmount = Just 0} castSourceInfo (justNotification.source_info),\n          notificationType = justNotification.notification_type,\n          juspayProviedId = justNotification.id,\n          responseCode = listToMaybe $ catMaybes [justNotification.response_code, justNotification.provider_response >>= (.provider_response_code)],\n          responseMessage = listToMaybe $ catMaybes [justNotification.response_message, justNotification.provider_response >>= (.provider_response_message)],\n          notificationId = justNotification.object_reference_id\n        }\n    (_, _, _, Just justTransaction) -> do\n      let (isRetriedOrder, retargetPaymentLink, retargetPaymentLinkExpiry, isRetargetedOrder) = parseRetargetAndRetryData justTransaction.metadata justTransaction.links justTransaction.additional_info\n      OrderStatusResp\n        { eventName = Just eventName,\n          orderShortId = justTransaction.order_id,\n          transactionUUID = justTransaction.txn_uuid,\n          txnId = Just justTransaction.txn_id,\n          transactionStatusId = fromMaybe (-3001) justTransaction.status_id,\n          transactionStatus = justTransaction.status,\n          paymentMethodType = Nothing,\n          paymentMethod = Nothing,\n          paymentGatewayResponse = Nothing,\n          respMessage = Nothing,\n          respCode = Nothing,\n          gatewayReferenceId = Nothing,\n          bankErrorMessage = if justTransaction.error_message == Just \"\" then Nothing else justTransaction.error_message,\n          bankErrorCode = if justTransaction.error_code == Just \"\" then Nothing else justTransaction.error_code,\n          amount = realToFrac justTransaction.txn_amount,\n          currency = justTransaction.currency,\n          dateCreated = Nothing,\n          refunds = [],\n          amountRefunded = Nothing,\n          payerVpa = justTransaction.payer_vpa,\n          upi = castUpi <$> justTransaction.upi,\n          card = castCard <$> justTransaction.card,\n          splitSettlementResponse = Nothing,\n          ..\n        }\n    (_, _, Nothing, _) -> BadStatusResp\n\nmkSplitSettlementResponse :: Juspay.SplitSettlementResponse -> SplitSettlementResponse\nmkSplitSettlementResponse Juspay.SplitSettlementResponse {..} =\n  SplitSettlementResponse\n    { splitDetails = split_details >>= (Just . map mkSplitDetailsResponse),\n      splitApplied = split_applied\n    }\n  where\n    mkSplitDetailsResponse Juspay.SplitDetailsResponse {..} =\n      SplitDetailsResponse\n        { subVendorId = sub_vendor_id,\n          merchantCommission = merchant_commission,\n          amount = amount,\n          gatewaySubAccountId = gateway_sub_account_id,\n          epgTxnId = epg_txn_id\n        }\n\ncastSourceInfo :: Juspay.SourceInfo -> SourceInfo\ncastSourceInfo source_info =\n  SourceInfo\n    { txnDate = posixSecondsToUTCTime <$> (fromIntegral <$> (readMaybe (T.unpack source_info.txn_date) :: Maybe Int)),\n      sourceAmount = readMaybe (T.unpack source_info.amount) :: Maybe HighPrecMoney\n    }\n\nofferList ::\n  ( HasCallStack,\n    Metrics.CoreMetrics m,\n    EncFlow m r\n  ) =>\n  JuspayCfg ->\n  Maybe Text ->\n  OfferListReq ->\n  m OfferListResp\nofferList config mRoutingId req = do\n  let url = config.url\n      merchantId = config.merchantId\n  apiKey <- decrypt config.apiKey\n  let juspayReq = mkOfferListReq req\n  juspayResp <- Juspay.offerList url apiKey merchantId mRoutingId juspayReq\n  buildOfferListResp juspayResp\n\nmkOfferListReq :: OfferListReq -> Juspay.OfferListReq\nmkOfferListReq OfferListReq {..} =\n  Juspay.OfferListReq\n    { order = mkOfferOrder order planId registrationDate dutyDate paymentMode numOfRides offerListingMetric,\n      payment_method_info = [],\n      customer = mkOfferCustomer <$> customer,\n      offer_code = Nothing\n    }\n\nmkOfferOrder :: OfferOrder -> Text -> UTCTime -> UTCTime -> Text -> Int -> Maybe UDF6 -> Juspay.OfferOrder\n---- add duty day and payment mode respectively in holes ----\nmkOfferOrder OfferOrder {..} planId registrationDate dutyDate paymentMode numOfRides offerListingMetric =\n  Juspay.OfferOrder\n    { order_id = orderId,\n      amount = show amount,\n      currency,\n      udf1 = replace \"-\" \"_\" planId,\n      udf2 = pack $ formatTime defaultTimeLocale \"%d_%m_%y\" registrationDate,\n      udf3 = paymentMode,\n      udf4 = pack $ formatTime defaultTimeLocale \"%d_%m_%y\" dutyDate,\n      udf5 = do\n        let strNumRides = show numOfRides\n        if strNumRides == \"-1\" then \"DEFAULT\" else strNumRides,\n      udf6 = parseUDF6 <$> offerListingMetric\n    }\n  where\n    parseUDF6 offerListingMetric' = do\n      case offerListingMetric' of\n        LIST_BASED_ON_DATE listingDates -> pack $ formatTime defaultTimeLocale \"%d_%m_%y\" listingDates\n        _ -> show offerListingMetric'\n\nmkOfferCustomer :: OfferCustomer -> Juspay.OfferCustomer\nmkOfferCustomer OfferCustomer {..} = Juspay.OfferCustomer {id = customerId, email, mobile}\n\nbuildOfferListResp :: (MonadThrow m, Log m) => Juspay.OfferListResp -> m OfferListResp\nbuildOfferListResp resp = do\n  bestOfferCombination <- buildBestOfferCombination `mapM` (listToMaybe resp.best_offer_combinations)\n  let offerResp = filter (\\offer -> offer.status == ELIGIBLE) $ mkOfferResp <$> resp.offers\n  pure OfferListResp {..}\n\nmkOfferResp :: Juspay.OfferResp -> OfferResp\nmkOfferResp Juspay.OfferResp {..} = do\n  OfferResp\n    { offerId = offer_id,\n      status,\n      offerDescription = mkOfferDescription offer_description,\n      orderAmount = read $ T.unpack order_breakup.final_order_amount,\n      finalOrderAmount = read $ T.unpack order_breakup.final_order_amount,\n      discountAmount = read $ T.unpack order_breakup.discount_amount\n    }\n\nmkOfferDescription :: Juspay.OfferDescription -> OfferDescription\nmkOfferDescription Juspay.OfferDescription {..} = OfferDescription {sponsoredBy = sponsored_by, ..}\n\nbuildBestOfferCombination :: (MonadThrow m, Log m) => Juspay.BestOfferCombination -> m BestOfferCombination\nbuildBestOfferCombination combination = do\n  offers <- buildBestOfferCombinationOffer `mapM` combination.offers\n  orderBreakup <- buildOrderBreakup combination.order_breakup\n  pure BestOfferCombination {..}\n\nbuildBestOfferCombinationOffer :: (MonadThrow m, Log m) => Juspay.BestOfferCombinationOffer -> m BestOfferCombinationOffer\nbuildBestOfferCombinationOffer Juspay.BestOfferCombinationOffer {..} = do\n  cashbackAmount <- parseMoney cashback_amount \"cashback_amount\"\n  discountAmount <- parseMoney discount_amount \"discount_amount\"\n  merchantDiscountAmount <- parseMoney merchant_discount_amount \"merchant_discount_amount\"\n  totalOfferedAmount <- parseMoney total_offered_amount \"total_offered_amount\"\n  pure $ BestOfferCombinationOffer {offerId = offer_id, ..}\n\nbuildOrderBreakup :: (MonadThrow m, Log m) => Juspay.OrderBreakup -> m OrderBreakup\nbuildOrderBreakup Juspay.OrderBreakup {..} = do\n  orderAmount <- parseMoney order_amount \"order_amount\"\n  finalOrderAmount <- parseMoney final_order_amount \"final_order_amount\"\n  discountAmount <- parseMoney discount_amount \"discount_amount\"\n  merchantDiscountAmount <- parseMoney merchant_discount_amount \"merchant_discount_amount\"\n  cashbackAmount <- parseMoney cashback_amount \"cashback_amount\"\n  offerAmount <- parseMoney offer_amount \"offer_amount\"\n  pure $ OrderBreakup {..}\n\nparseMoney :: (MonadThrow m, Log m) => Text -> Text -> m HighPrecMoney\nparseMoney field desc = do\n  readMaybe (show field) & fromMaybeM (InternalError $ \"Couldn't parse \" <> desc)\n\nofferApply ::\n  ( HasCallStack,\n    Metrics.CoreMetrics m,\n    EncFlow m r\n  ) =>\n  JuspayCfg ->\n  Maybe Text ->\n  OfferApplyReq ->\n  m OfferApplyResp\nofferApply config mRoutingId req = do\n  let url = config.url\n      merchantId = config.merchantId\n  apiKey <- decrypt config.apiKey\n  let juspayReq = mkOfferApplyReq merchantId req\n  juspayResp <- Juspay.offerApply url apiKey merchantId mRoutingId juspayReq\n  buildOfferApplyResp juspayResp\n\nmkOfferApplyReq :: Text -> OfferApplyReq -> Juspay.OfferApplyReq\nmkOfferApplyReq merchantId OfferApplyReq {..} = do\n  let order =\n        Juspay.OfferApplyOrder\n          { amount = show amount,\n            currency,\n            merchant_id = Just merchantId,\n            order_type = Just \"ORDER_PAYMENT\",\n            udf1 = replace \"-\" \"_\" planId,\n            udf2 = pack $ formatTime defaultTimeLocale \"%d_%m_%y\" registrationDate,\n            udf3 = paymentMode,\n            udf4 = pack $ formatTime defaultTimeLocale \"%d_%m_%y\" dutyDate,\n            udf5 = show numOfRides,\n            payment_channel = Just \"WEB\"\n          }\n  Juspay.OfferApplyReq\n    { txn_id = txnId,\n      customer = Juspay.OfferApplyCustomer {id = customerId},\n      offers,\n      order,\n      payment_method_info = Just $ Juspay.OfferApplyPaymentMethodInfo Juspay.UPI Nothing Nothing Nothing Nothing Nothing Nothing\n    }\n\nbuildOfferApplyResp :: (MonadThrow m, Log m) => Juspay.OfferApplyResp -> m OfferApplyResp\nbuildOfferApplyResp resp = do\n  offers <- forM resp.offers $ \\offer -> do\n    finalOrderAmount <- parseMoney offer.order_breakup.final_order_amount \"final_order_amount\"\n    pure\n      OfferApplyRespItem\n        { finalOrderAmount,\n          offerId = offer.offer_id\n        }\n  pure OfferApplyResp {offers}\n\nofferNotify ::\n  ( HasCallStack,\n    Metrics.CoreMetrics m,\n    EncFlow m r\n  ) =>\n  JuspayCfg ->\n  Maybe Text ->\n  OfferNotifyReq ->\n  m OfferNotifyResp\nofferNotify config mRoutingId req = do\n  let url = config.url\n      merchantId = config.merchantId\n  apiKey <- decrypt config.apiKey\n  let juspayReq = mkOfferNotifyReq merchantId req\n  void $ Juspay.offerNotify url apiKey merchantId mRoutingId req.mandateId juspayReq\n  pure Success\n\nmkOfferNotifyReq :: Text -> OfferNotifyReq -> Juspay.OfferNotifyReq\nmkOfferNotifyReq merchantId OfferNotifyReq {..} = do\n  Juspay.OfferNotifyReq\n    { order_id = orderShortId,\n      txn_id = transactionUUID,\n      merchant_id = merchantId,\n      txn_status = transactionStatus,\n      offers = offers <&> (\\OfferNotifyOffer {offerId, status} -> Juspay.OfferNotifyOffer {offer_id = offerId, status})\n    }\n\nautoRefund ::\n  ( Metrics.CoreMetrics m,\n    EncFlow m r\n  ) =>\n  JuspayCfg ->\n  Maybe Text ->\n  AutoRefundReq ->\n  m AutoRefundResp\nautoRefund config mRoutingId req = do\n  let url = config.url\n      merchantId = config.merchantId\n  apiKey <- decrypt config.apiKey\n  mkRefundResp <$> Juspay.autoRefund url apiKey req.orderId merchantId mRoutingId (mkAutoPayRequest req)\n  where\n    mkAutoPayRequest request =\n      Juspay.AutoRefundReq\n        { unique_request_id = request.requestId,\n          amount = realToFrac request.amount\n        }\n\nmkRefundResp :: Juspay.AutoRefundResp -> AutoRefundResp\nmkRefundResp Juspay.AutoRefundResp {..} = do\n  AutoRefundResp\n    { orderId = order_id,\n      merchantId = merchant_id,\n      customerId = customer_id,\n      currency,\n      amountRefunded = amount_refunded,\n      refunds = maybe [] mkRefundsData refunds\n    }\n\nmkRefundsData :: [Juspay.RefundsData] -> [RefundsData]\nmkRefundsData =\n  map\n    ( \\Juspay.RefundsData {..} ->\n        RefundsData\n          { idAssignedByServiceProvider = id,\n            amount = realToFrac amount,\n            status = status,\n            errorMessage = error_message,\n            errorCode = error_code,\n            initiatedBy = initiated_by,\n            requestId = unique_request_id\n          }\n    )\n\nparseRetargetAndRetryData ::\n  Maybe Juspay.MetaData ->\n  Maybe Juspay.LinkData ->\n  Maybe Juspay.AdditionalInfo ->\n  (Maybe Bool, Maybe Text, Maybe UTCTime, Maybe Bool)\nparseRetargetAndRetryData metaData linkData additionalInfo = do\n  let retargetInfoFromMetaData = metaData >>= (.juspay_internal_retarget_configs)\n      retargetInfoFromAdditionalInfo = additionalInfo >>= (.retarget_payment_info)\n      retargetInfoFromLinkData = linkData >>= (.retarget_payment_links)\n      functionsToCalls = (Juspay.retarget_payment_link, Juspay.is_retargeted_order, Juspay.retarget_payment_link_expiry, Juspay.retarget_done_count, Juspay.max_retarget_limit)\n      (retargetLink, isRetargetedOrder, retargetPaymentLinkExpiry, _, _) = mapTuple5 (getFieldData retargetInfoFromMetaData retargetInfoFromLinkData retargetInfoFromAdditionalInfo) functionsToCalls\n      retargetPaymentLinkExpiryTime = (\\val -> readMaybe val :: Maybe UTCTime) . T.unpack =<< retargetPaymentLinkExpiry\n      isRetriedOrder = (metaData >>= (.is_retried_order)) E.<|> (additionalInfo >>= (.mandate_retry_info) >>= (.is_retried_order))\n  (getBoolValue =<< isRetriedOrder, retargetLink, retargetPaymentLinkExpiryTime, getBoolValue =<< isRetargetedOrder)\n  where\n    getFieldData retargetInfoFromMetaData retargetInfoFromLinkData retargetInfoFromAdditionalInfo func = do\n      listToMaybe $ mapMaybe (>>= func) [retargetInfoFromMetaData, retargetInfoFromLinkData, retargetInfoFromAdditionalInfo]\n    getBoolValue = (\\val -> readMaybe val :: Maybe Bool) . T.unpack\n\n    mapTuple5 :: (a -> b) -> (a, a, a, a, a) -> (b, b, b, b, b)\n    mapTuple5 f (a1, a2, a3, a4, a5) = (f a1, f a2, f a3, f a4, f a5)\n\nverifyVPA ::\n  ( Metrics.CoreMetrics m,\n    EncFlow m r\n  ) =>\n  JuspayCfg ->\n  Maybe Text ->\n  VerifyVPAReq ->\n  m VerifyVPAResp\nverifyVPA config mRoutingId req = do\n  let url = config.url\n      merchantId = config.merchantId\n  apiKey <- decrypt config.apiKey\n  mkVerifyVpaResp <$> Juspay.verifyVPA url apiKey merchantId mRoutingId (mkVerifyVpaRequest req merchantId)\n  where\n    mkVerifyVpaRequest request merchantId =\n      Juspay.VerifyVPAReq\n        { vpa = request.vpa,\n          order_id = request.orderId,\n          merchant_id = merchantId,\n          customer_id = request.customerId\n        }\n\nmkVerifyVpaResp :: Juspay.VerifyVPAResp -> VerifyVPAResp\nmkVerifyVpaResp Juspay.VerifyVPAResp {..} = do\n  VerifyVPAResp\n    { vpa,\n      status = show status,\n      customerName = customer_name\n    }\n",
      "hash": "76fb25b480860d11b9dee0eaeed8710ea9cf79afae54c6a4b83d00d0db36f19d",
      "size": 37753
    },
    "/lib/mobility-core/src/Kernel/External/Payment/Interface/Stripe.hs": {
      "type": "content",
      "content": "module Kernel.External.Payment.Interface.Stripe where\n\nimport Control.Applicative ((<|>))\nimport Data.Time\nimport Data.Time.Clock.POSIX (posixSecondsToUTCTime)\nimport Kernel.External.Encryption\nimport Kernel.External.Payment.Interface.Types\nimport Kernel.External.Payment.Stripe.Config as Reexport\nimport qualified Kernel.External.Payment.Stripe.Flow as Stripe\nimport qualified Kernel.External.Payment.Stripe.Types as Stripe\nimport Kernel.Prelude\nimport qualified Kernel.Tools.Metrics.CoreMetrics as Metrics\nimport qualified Kernel.Types.Beckn.Context as Context\nimport Kernel.Types.Common\n\ncreateIndividualConnectAccount ::\n  ( Metrics.CoreMetrics m,\n    EncFlow m r\n  ) =>\n  StripeCfg ->\n  IndividualConnectAccountReq ->\n  m IndividualConnectAccountResp\ncreateIndividualConnectAccount config req = do\n  let url = config.url\n  apiKey <- decrypt config.apiKey\n  let accountReq = mkAccountReq\n  accountResp <- Stripe.createAccount url apiKey accountReq\n  let accountId = accountResp.id\n  let chargesEnabled = accountResp.charges_enabled\n  let detailsSubmitted = accountResp.details_submitted\n  let accountLinkReq = mkAccountLinkReq config accountId\n  accountLinkResp <- Stripe.createAccountLink url apiKey accountLinkReq\n  let accountUrl = accountLinkResp.url\n  let accountUrlExpiry = posixSecondsToUTCTime accountLinkResp.expires_at\n  pure $ IndividualConnectAccountResp {..}\n  where\n    mkAccountReq :: Stripe.AccountsReq\n    mkAccountReq =\n      let _type = Nothing\n          country =\n            case req.country of\n              Context.India -> \"IN\"\n              Context.USA -> \"US\"\n              Context.France -> \"FR\"\n              Context.AnyCountry -> \"US\" -- fix later\n          email = req.email\n          controller =\n            Just $\n              Stripe.AccountController\n                { fees = Just $ Stripe.AccountFees {payer = Stripe.AccountFeePayerAccount},\n                  losses = Just $ Stripe.AccountLosses {payments = Stripe.AccountLossesPayerStripe},\n                  requirement_collection = Just Stripe.AccountRquirementCollectorStripe,\n                  stripe_dashboard = Just $ Stripe.AccountDashboard {_type = Stripe.AccountDashboardNone}\n                }\n          capabilities =\n            Just $\n              Stripe.AccountCapabilities\n                { card_payments = Stripe.CardPayments {requested = True},\n                  -- cashapp_payments = Stripe.CashAppPayments {requested = True}\n                  transfers = Stripe.Transfers {requested = True}\n                }\n          settings =\n            Just $\n              Stripe.AccountSettings\n                { payouts = Stripe.PayoutsSettings {debit_negative_balances = True, statement_descriptor = \"Bridge Rideshare\"}\n                }\n          business_type = Stripe.Individual\n          (year', month, day) = toGregorian req.dateOfBirth\n          individual =\n            Just $\n              Stripe.IndividualDetails\n                { first_name = req.firstName,\n                  last_name = req.lastName,\n                  dob = Just $ Stripe.DateOfBirth {year = fromInteger year', ..},\n                  address = req.address,\n                  email = req.email,\n                  id_number = req.idNumber,\n                  phone = req.mobileNumber,\n                  ssn_last_4 = req.ssnLast4\n                }\n          default_business_profile =\n            Just $\n              Stripe.BusinessProfile\n                { mcc = Just \"4121\",\n                  product_description = Just \"Rideshare driver\",\n                  support_phone = Just \"7605636815\", -- dummy number\n                  url = Just \"https://bridge.cab\",\n                  support_address =\n                    Just $\n                      Stripe.BusinessSupportAddress\n                        { city = Just \"St. Louis Park\",\n                          country = Just \"US\",\n                          line1 = Just \"Suite 100, 1650, West End Blvd\",\n                          line2 = Nothing,\n                          postal_code = Just \"55416\",\n                          state = Just \"MN\"\n                        }\n                }\n          business_profile = config.businessProfile <|> default_business_profile\n       in Stripe.AccountsReq {..}\n\nretryAccountLink ::\n  ( Metrics.CoreMetrics m,\n    EncFlow m r\n  ) =>\n  StripeCfg ->\n  Stripe.AccountId ->\n  m RetryAccountLink\nretryAccountLink config accountId = do\n  let url = config.url\n  apiKey <- decrypt config.apiKey\n  let accountLinkReq = mkAccountLinkReq config accountId\n  accountLinkResp <- Stripe.createAccountLink url apiKey accountLinkReq\n  let accountUrlExpiry = posixSecondsToUTCTime accountLinkResp.expires_at\n  let accountUrl = accountLinkResp.url\n  pure $ RetryAccountLink {..}\n\ngetAccount ::\n  ( Metrics.CoreMetrics m,\n    EncFlow m r\n  ) =>\n  StripeCfg ->\n  Stripe.AccountId ->\n  m ConnectAccountResp\ngetAccount config accountId = do\n  let url = config.url\n  apiKey <- decrypt config.apiKey\n  accountResp <- Stripe.getAccount url apiKey accountId\n  let chargesEnabled = accountResp.charges_enabled\n  let detailsSubmitted = accountResp.details_submitted\n  pure $ ConnectAccountResp {..}\n\ncreateCustomer ::\n  ( Metrics.CoreMetrics m,\n    EncFlow m r\n  ) =>\n  StripeCfg ->\n  CreateCustomerReq ->\n  m CreateCustomerResp\ncreateCustomer config req = do\n  let url = config.url\n  apiKey <- decrypt config.apiKey\n  let customerReq = mkCustomerReq req\n  customerResp <- Stripe.createCustomer url apiKey customerReq\n  let customerId = customerResp.id\n  let clientAuthToken = Nothing\n  let clientAuthTokenExpiry = Nothing\n  return $ CreateCustomerResp {..}\n  where\n    mkCustomerReq :: CreateCustomerReq -> Stripe.CustomerReq\n    mkCustomerReq CreateCustomerReq {..} = do\n      Stripe.CustomerReq\n        { email = fromMaybe \"User@gmail.com\" email,\n          name = fromMaybe \"User\" name,\n          payment_method = Nothing,\n          source = Nothing,\n          phone = phone\n        }\n\ncreateEphemeralKeys ::\n  ( Metrics.CoreMetrics m,\n    EncFlow m r\n  ) =>\n  StripeCfg ->\n  CustomerId ->\n  m Text\ncreateEphemeralKeys config customerId = do\n  let url = config.url\n  apiKey <- decrypt config.apiKey\n  let ephemeralKeysReq = Stripe.EphemeralKeysReq {customer = customerId}\n  ephemeralKeysResp <- Stripe.createEphemeralKeys url apiKey ephemeralKeysReq\n  return ephemeralKeysResp.secret\n\ngetCardList ::\n  ( Metrics.CoreMetrics m,\n    EncFlow m r\n  ) =>\n  StripeCfg ->\n  CustomerId ->\n  m CustomerCardListResp\ngetCardList config customerId = do\n  let url = config.url\n  apiKey <- decrypt config.apiKey\n  paymentMethodListResp <- Stripe.getPaymentMethodList url apiKey customerId\n  let cards = map mkCard paymentMethodListResp._data\n  return cards\n  where\n    mkCard :: Stripe.PaymentMethod -> CustomerCard\n    mkCard paymentMethod =\n      CustomerCard\n        { cardId = paymentMethod.id,\n          expMonth = paymentMethod.card.exp_month,\n          expYear = paymentMethod.card.exp_year,\n          last4 = paymentMethod.card.last4,\n          brand = paymentMethod.card.brand,\n          country = paymentMethod.card.country\n        }\n\ndeleteCard ::\n  ( Metrics.CoreMetrics m,\n    EncFlow m r\n  ) =>\n  StripeCfg ->\n  PaymentMethodId ->\n  m ()\ndeleteCard config paymentMethodId = do\n  let url = config.url\n  apiKey <- decrypt config.apiKey\n  void $ Stripe.detachPaymentMethod url apiKey paymentMethodId\n\ncreatePaymentIntent ::\n  ( Metrics.CoreMetrics m,\n    EncFlow m r\n  ) =>\n  StripeCfg ->\n  CreatePaymentIntentReq ->\n  m CreatePaymentIntentResp\ncreatePaymentIntent config req = do\n  let url = config.url\n  apiKey <- decrypt config.apiKey\n  -- Clone the payment method to the driver's connected account\n  let clonePaymentMethodReq = Stripe.ClonePaymentMethodReq {payment_method = req.paymentMethod, customer = req.customer}\n  clonedPMRes <- Stripe.clonePaymentMethod url apiKey req.driverAccountId clonePaymentMethodReq\n  -- use cloned paymentMethodId to create paymentIntent\n  let paymentIntentReq = mkPaymentIntentReq clonedPMRes.id req\n  paymentIntentResp <- Stripe.createPaymentIntent url apiKey paymentIntentReq\n  let paymentIntentId = paymentIntentResp.id\n  let clientSecret = paymentIntentResp.client_secret\n  let status = paymentIntentResp.status\n  return $ CreatePaymentIntentResp {..}\n  where\n    mkPaymentIntentReq :: PaymentMethodId -> CreatePaymentIntentReq -> Stripe.PaymentIntentReq\n    mkPaymentIntentReq clonedPaymentMethodId CreatePaymentIntentReq {amount = amonutInUsd, ..} = do\n      let application_fee_amount = usdToCents applicationFeeAmount\n      let amountInCents = usdToCents amonutInUsd\n      let payment_method = clonedPaymentMethodId\n      let receipt_email = receiptEmail\n      let on_behalf_of = driverAccountId\n      let transfer_data = Stripe.TransferData {destination = driverAccountId}\n      -- let automatic_payment_methods = Stripe.AutomaticPayementMethods {enabled = True, allow_redirects = Stripe.NeverRedirect}\n      let confirm = True\n      let description = Nothing\n      let setup_future_usage = Nothing\n      let capture_method = Stripe.ManualCaptureMethod\n      let confirmation_method = Stripe.AutomaticConfirmationMethod\n      let use_stripe_sdk = True\n      let return_url = showBaseUrl config.returnUrl\n      Stripe.PaymentIntentReq {amount = amountInCents, ..}\n\ncreateSetupIntent ::\n  ( Metrics.CoreMetrics m,\n    EncFlow m r\n  ) =>\n  StripeCfg ->\n  CustomerId ->\n  m CreateSetupIntentResp\ncreateSetupIntent config customerId = do\n  let url = config.url\n  apiKey <- decrypt config.apiKey\n  let setupIntentReq = mkSetupIntentReq\n  setupIntentResp <- Stripe.createSetupIntent url apiKey setupIntentReq\n  let setupIntentId = setupIntentResp.id\n  let clientSecret = setupIntentResp.client_secret\n  let status = setupIntentResp.status\n  return $ CreateSetupIntentResp {..}\n  where\n    mkSetupIntentReq :: Stripe.SetupIntentReq\n    mkSetupIntentReq = do\n      let automatic_payment_methods = Stripe.AutomaticPayementMethods {enabled = True, allow_redirects = Stripe.NeverRedirect}\n      let confirm = False\n      let customer = customerId\n      let description = Nothing\n      let usage = Nothing\n      let payment_method = Nothing\n      let use_stripe_sdk = True\n      Stripe.SetupIntentReq {..}\n\ncancelPaymentIntent ::\n  ( Metrics.CoreMetrics m,\n    EncFlow m r\n  ) =>\n  StripeCfg ->\n  PaymentIntentId ->\n  m CreatePaymentIntentResp\ncancelPaymentIntent config paymentIntentId = do\n  let url = config.url\n  apiKey <- decrypt config.apiKey\n  paymentIntentResp <- Stripe.cancelPaymentIntent url apiKey paymentIntentId\n  let clientSecret = paymentIntentResp.client_secret\n  let status = paymentIntentResp.status\n  return $ CreatePaymentIntentResp {..}\n\nupdatePaymentMethodInIntent ::\n  ( Metrics.CoreMetrics m,\n    EncFlow m r\n  ) =>\n  StripeCfg ->\n  PaymentIntentId ->\n  PaymentMethodId ->\n  m ()\nupdatePaymentMethodInIntent config paymentIntentId paymentMethodId = do\n  let url = config.url\n  apiKey <- decrypt config.apiKey\n  let confirmPaymentIntentReq = Stripe.ConfirmPaymentIntentReq {payment_method = paymentMethodId}\n  void $ Stripe.confirmPaymentIntent url apiKey paymentIntentId confirmPaymentIntentReq\n\ngetCard ::\n  ( Metrics.CoreMetrics m,\n    EncFlow m r\n  ) =>\n  StripeCfg ->\n  PaymentMethodId ->\n  CustomerId ->\n  m CustomerCard\ngetCard config paymentMethodId customerId = do\n  let url = config.url\n  apiKey <- decrypt config.apiKey\n  cardObjectResp <- Stripe.getCard url apiKey customerId paymentMethodId\n  let card = mkCard cardObjectResp\n  return card\n  where\n    mkCard :: Stripe.CardObject -> CustomerCard\n    mkCard cardObject =\n      CustomerCard\n        { cardId = cardObject.id,\n          expMonth = cardObject.exp_month,\n          expYear = cardObject.exp_year,\n          last4 = cardObject.last4,\n          brand = cardObject.brand,\n          country = cardObject.country\n        }\n\ngetPaymentIntent ::\n  ( Metrics.CoreMetrics m,\n    EncFlow m r\n  ) =>\n  StripeCfg ->\n  PaymentIntentId ->\n  m CreatePaymentIntentResp\ngetPaymentIntent config paymentIntentId = do\n  let url = config.url\n  apiKey <- decrypt config.apiKey\n  paymentIntentResp <- Stripe.getPaymentIntent url apiKey paymentIntentId\n  let clientSecret = paymentIntentResp.client_secret\n  let status = paymentIntentResp.status\n  return $ CreatePaymentIntentResp {..}\n\ncapturePaymentIntent ::\n  ( Metrics.CoreMetrics m,\n    EncFlow m r\n  ) =>\n  StripeCfg ->\n  PaymentIntentId ->\n  HighPrecMoney ->\n  HighPrecMoney ->\n  m ()\ncapturePaymentIntent config paymentIntentId amount applicationFeeAmount = do\n  let url = config.url\n  apiKey <- decrypt config.apiKey\n  let amount_to_capture = usdToCents amount\n  let application_fee_amount = usdToCents applicationFeeAmount\n  let req = Stripe.CapturePaymentIntentReq {..}\n  void $ Stripe.capturePaymentIntent url apiKey paymentIntentId req\n\nupdateAmountInPaymentIntent ::\n  ( Metrics.CoreMetrics m,\n    EncFlow m r\n  ) =>\n  StripeCfg ->\n  PaymentIntentId ->\n  HighPrecMoney ->\n  HighPrecMoney ->\n  m ()\nupdateAmountInPaymentIntent config paymentIntentId amount_ applicationFeeAmount = do\n  let url = config.url\n  apiKey <- decrypt config.apiKey\n  let amount = usdToCents amount_\n  let application_fee_amount = usdToCents applicationFeeAmount\n  let req = Stripe.IncrementAuthorizationReq {..}\n  void $ Stripe.incrementAuthorizationPaymentIntent url apiKey paymentIntentId req\n\nmkAccountLinkReq :: StripeCfg -> Stripe.AccountId -> Stripe.AccountLinkReq\nmkAccountLinkReq config accountId =\n  let account = accountId\n      refresh_url = showBaseUrl config.refreshUrl\n      return_url = showBaseUrl config.returnUrl\n      _type = Stripe.AccountOnboarding\n      collection_options =\n        Just $\n          Stripe.CollectionOptions\n            { fields = Stripe.CurrentlyDue,\n              future_requirements = Stripe.Omit\n            }\n   in Stripe.AccountLinkReq {..}\n\n-- TODO: Do it properly later for other currencies as well\n\n-- | Convert USD to cents\nusdToCents :: HighPrecMoney -> Int\nusdToCents (HighPrecMoney money) = round $ money * 100\n",
      "hash": "0d77bcc0cef92eaa7d77e1cdc5711903f101e008fcd1fa570c6a88f6aefc23bb",
      "size": 13952
    },
    "/lib/mobility-core/src/Kernel/External/Payment/Interface/Types.hs": {
      "type": "content",
      "content": "{-# LANGUAGE DerivingStrategies #-}\n{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n{-# LANGUAGE OverloadedLists #-}\n{-# OPTIONS_GHC -Wwarn=incomplete-record-updates #-}\n\nmodule Kernel.External.Payment.Interface.Types\n  ( module Kernel.External.Payment.Interface.Types,\n    module Reexport,\n  )\nwhere\n\nimport Data.Time\nimport qualified Kernel.External.Payment.Juspay.Config as Juspay\nimport Kernel.External.Payment.Juspay.Types as Reexport (CreateOrderResp (..), MandateFrequency (..), MandateStatus (..), MandateType (..), NotificationStatus (..), OfferListStatus (..), OfferStatus (..), PaymentLinks (..), PaymentStatus (..), RefundStatus (..), TransactionStatus (..))\nimport qualified Kernel.External.Payment.Stripe.Config as Stripe\nimport Kernel.External.Payment.Stripe.Types as Reexport\nimport Kernel.Prelude\nimport Kernel.Types.APISuccess (APISuccess)\nimport qualified Kernel.Types.Beckn.Context as Context\nimport Kernel.Types.Common\n\ncastToTransactionStatus :: PaymentIntentStatus -> TransactionStatus\ncastToTransactionStatus Succeeded = CHARGED\ncastToTransactionStatus Cancelled = CANCELLED\ncastToTransactionStatus Processing = AUTHORIZING\ncastToTransactionStatus RequiresAction = PENDING_VBV\ncastToTransactionStatus RequiresCapture = STARTED\ncastToTransactionStatus RequiresConfirmation = NEW\ncastToTransactionStatus RequiresPaymentMethod = NEW\n\ncaseToPaymentIntentStatus :: TransactionStatus -> PaymentIntentStatus\ncaseToPaymentIntentStatus CHARGED = Succeeded\ncaseToPaymentIntentStatus CANCELLED = Cancelled\ncaseToPaymentIntentStatus AUTHORIZING = Processing\ncaseToPaymentIntentStatus PENDING_VBV = RequiresAction\ncaseToPaymentIntentStatus STARTED = RequiresCapture\ncaseToPaymentIntentStatus NEW = RequiresConfirmation\ncaseToPaymentIntentStatus AUTHENTICATION_FAILED = Cancelled\ncaseToPaymentIntentStatus AUTHORIZATION_FAILED = Cancelled\ncaseToPaymentIntentStatus JUSPAY_DECLINED = Cancelled\ncaseToPaymentIntentStatus _ = RequiresPaymentMethod\n\ndata PaymentServiceConfig = JuspayConfig Juspay.JuspayCfg | StripeConfig Stripe.StripeCfg\n  deriving (Show, Eq, Generic, ToJSON, FromJSON)\n\ndata CreateOrderReq = CreateOrderReq\n  { orderId :: Text,\n    orderShortId :: Text, -- Should be Alphanumeric with character length less than 18.\n    amount :: HighPrecMoney,\n    customerId :: Text,\n    customerEmail :: Text,\n    customerPhone :: Text,\n    customerFirstName :: Maybe Text,\n    customerLastName :: Maybe Text,\n    createMandate :: Maybe MandateType,\n    mandateMaxAmount :: Maybe HighPrecMoney,\n    mandateFrequency :: Maybe MandateFrequency,\n    mandateStartDate :: Maybe Text,\n    mandateEndDate :: Maybe Text,\n    metadataGatewayReferenceId :: Maybe Text,\n    optionsGetUpiDeepLinks :: Maybe Bool,\n    metadataExpiryInMins :: Maybe Int,\n    splitSettlementDetails :: Maybe SplitSettlementDetails\n  }\n\ndata Split = Split\n  { amount :: HighPrecMoney,\n    merchantCommission :: HighPrecMoney,\n    subMid :: Text,\n    uniqueSplitId :: Maybe Text\n  }\n  deriving (Show, Eq, Generic, FromJSON, ToJSON, ToSchema)\n\nnewtype Vendor = Vendor\n  { split :: [Split]\n  }\n  deriving (Show, Eq, Generic, FromJSON, ToJSON, ToSchema)\n\ndata SplitSettlementDetails = SplitSettlementDetails\n  { marketplace :: Marketplace,\n    mdrBorneBy :: MBY,\n    vendor :: Vendor\n  }\n  deriving (Show, Eq, Generic, FromJSON, ToJSON, ToSchema)\n\ndata MBY = MARKETPLACE | VENDOR | ALL deriving (Show, Eq, Generic, FromJSON, ToJSON, ToSchema)\n\nnewtype Marketplace = Marketplace\n  { amount :: HighPrecMoney\n  }\n  deriving (Show, Eq, Generic, FromJSON, ToJSON, ToSchema)\n\nnewtype OrderStatusReq = OrderStatusReq\n  { orderShortId :: Text\n  }\n\ndata OrderStatusResp\n  = OrderStatusResp\n      { eventName :: Maybe PaymentStatus,\n        orderShortId :: Text,\n        transactionUUID :: Maybe Text,\n        txnId :: Maybe Text,\n        transactionStatusId :: Int,\n        transactionStatus :: TransactionStatus,\n        paymentMethodType :: Maybe Text,\n        paymentMethod :: Maybe Text,\n        paymentGatewayResponse :: Maybe PaymentGatewayResponse,\n        respMessage :: Maybe Text,\n        respCode :: Maybe Text,\n        gatewayReferenceId :: Maybe Text,\n        bankErrorMessage :: Maybe Text,\n        bankErrorCode :: Maybe Text,\n        amount :: HighPrecMoney,\n        currency :: Currency,\n        dateCreated :: Maybe UTCTime,\n        isRetriedOrder :: Maybe Bool,\n        isRetargetedOrder :: Maybe Bool,\n        retargetPaymentLink :: Maybe Text,\n        retargetPaymentLinkExpiry :: Maybe UTCTime,\n        amountRefunded :: Maybe HighPrecMoney,\n        refunds :: [RefundsData],\n        payerVpa :: Maybe Text,\n        upi :: Maybe Upi,\n        card :: Maybe CardInfo,\n        splitSettlementResponse :: Maybe SplitSettlementResponse\n      }\n  | MandateOrderStatusResp\n      { eventName :: Maybe PaymentStatus,\n        orderShortId :: Text,\n        transactionUUID :: Maybe Text,\n        txnId :: Maybe Text,\n        transactionStatusId :: Int,\n        transactionStatus :: TransactionStatus,\n        paymentMethodType :: Maybe Text,\n        paymentMethod :: Maybe Text,\n        respMessage :: Maybe Text,\n        respCode :: Maybe Text,\n        gatewayReferenceId :: Maybe Text,\n        amount :: HighPrecMoney,\n        currency :: Currency,\n        dateCreated :: Maybe UTCTime,\n        bankErrorMessage :: Maybe Text,\n        bankErrorCode :: Maybe Text,\n        mandateStartDate :: Maybe UTCTime,\n        mandateEndDate :: Maybe UTCTime,\n        mandateId :: Text,\n        mandateStatus :: MandateStatus,\n        mandateFrequency :: MandateFrequency,\n        mandateMaxAmount :: HighPrecMoney,\n        payerVpa :: Maybe Text,\n        upi :: Maybe Upi,\n        amountRefunded :: Maybe HighPrecMoney,\n        refunds :: [RefundsData]\n      }\n  | MandateStatusResp\n      { eventName :: Maybe PaymentStatus,\n        orderShortId :: Text,\n        status :: MandateStatus,\n        mandateStartDate :: Maybe UTCTime,\n        mandateEndDate :: Maybe UTCTime,\n        mandateId :: Text,\n        mandateFrequency :: MandateFrequency,\n        mandateMaxAmount :: HighPrecMoney,\n        upi :: Maybe Upi\n      }\n  | PDNNotificationStatusResp\n      { eventName :: Maybe PaymentStatus,\n        notificationStatus :: NotificationStatus,\n        sourceObject :: Maybe Text,\n        sourceInfo :: SourceInfo,\n        notificationType :: Maybe Text,\n        juspayProviedId :: Text,\n        notificationId :: Text,\n        responseCode :: Maybe Text,\n        responseMessage :: Maybe Text\n      }\n  | BadStatusResp\n  deriving stock (Show, Read, Eq, Generic)\n  deriving anyclass (FromJSON, ToJSON, ToSchema)\n\ndata SplitSettlementResponse = SplitSettlementResponse\n  { splitDetails :: Maybe [SplitDetailsResponse],\n    splitApplied :: Maybe Bool\n  }\n  deriving stock (Show, Read, Eq, Generic)\n  deriving anyclass (FromJSON, ToJSON, ToSchema)\n\ndata SplitDetailsResponse = SplitDetailsResponse\n  { subVendorId :: Maybe Text,\n    amount :: Maybe HighPrecMoney,\n    merchantCommission :: Maybe HighPrecMoney,\n    gatewaySubAccountId :: Maybe Text,\n    epgTxnId :: Maybe Text\n  }\n  deriving stock (Show, Read, Eq, Generic)\n  deriving anyclass (FromJSON, ToJSON, ToSchema)\n\ndata Upi = Upi\n  { payerApp :: Maybe Text,\n    payerVpa :: Maybe Text,\n    payerAppName :: Maybe Text,\n    txnFlowType :: Maybe Text\n  }\n  deriving stock (Show, Read, Eq, Generic)\n  deriving anyclass (FromJSON, ToJSON, ToSchema)\n\ndata CardInfo = CardInfo\n  { lastFourDigits :: Maybe Text,\n    cardType :: Maybe Text\n  }\n  deriving stock (Show, Read, Eq, Generic)\n  deriving anyclass (FromJSON, ToJSON, ToSchema)\n\n-- notification request --\ndata MandateNotificationReq = MandateNotificationReq\n  { amount :: HighPrecMoney,\n    txnDate :: UTCTime,\n    mandateId :: Text,\n    notificationId :: Text,\n    description :: Text\n  }\n  deriving (Eq, Show, Generic)\n\ndata MandateNotificationRes = MandateNotificationRes\n  { juspayProvidedId :: Text,\n    sourceInfo :: SourceInfo,\n    notificationId :: Text,\n    providerName :: Maybe Text,\n    notificationType :: Maybe Text,\n    description :: Text,\n    status :: NotificationStatus,\n    dateCreated :: Maybe UTCTime,\n    lastUpdated :: Maybe UTCTime\n  }\n\ndata SourceInfo = SourceInfo\n  { sourceAmount :: Maybe HighPrecMoney,\n    txnDate :: Maybe UTCTime\n  }\n  deriving (Eq, Show, Read, Generic, ToJSON, FromJSON, ToSchema)\n\ndata PaymentGatewayResponse = PaymentGatewayResponse\n  { txnId :: Maybe Text,\n    rrn :: Maybe Text,\n    respMessage :: Maybe Text,\n    respCode :: Maybe Text,\n    epgTxnId :: Maybe Text,\n    created :: Maybe UTCTime,\n    authIdCode :: Maybe Text\n  }\n  deriving (Eq, Show, Read, Generic, ToJSON, FromJSON, ToSchema)\n\n--- Notification status response and request --\nnewtype NotificationStatusReq = NotificationStatusReq\n  {notificationId :: Text}\n\ndata NotificationStatusResp = NotificationStatusResp\n  { id :: Text,\n    sourceObject :: Maybe Text,\n    sourceObjectId :: Maybe Text, -- mandate Id in this case --\n    objectReferenceId :: Text,\n    providerName :: Maybe Text,\n    notificationType :: Maybe Text,\n    sourceInfo :: SourceInfo,\n    providerResponse :: Maybe ProviderResponse,\n    description :: Text,\n    status :: NotificationStatus,\n    dateCreated :: Maybe UTCTime,\n    lastUpdated :: Maybe UTCTime\n  }\n  deriving stock (Show, Read, Eq, Generic)\n  deriving anyclass (FromJSON, ToJSON, ToSchema)\n\ndata ProviderResponse = ProviderResponse\n  { providerRefId :: Maybe Text,\n    notificationDate :: Maybe UTCTime,\n    responseCode :: Maybe Text,\n    responseMessage :: Maybe Text\n  }\n  deriving stock (Show, Read, Eq, Generic)\n  deriving anyclass (FromJSON, ToJSON, ToSchema)\n\n-- mandate pause | resume | revoke request --\n\ndata MandateCommandsReq = Pause MandatePauseReq | Resume MandateResumeReq | Revoke MandateRevokeReq\n\ndata MandatePauseReq = MandatePauseReq {mandateId :: Text, pauseStartDate :: UTCTime, pauseEndDate :: Maybe UTCTime}\n\ndata MandateResumeReq = MandateResumeReq {mandateId :: Text, resumeDate :: UTCTime}\n\nnewtype MandateRevokeReq = MandateRevokeReq {mandateId :: Text}\n\ntype MandateRevokeRes = APISuccess\n\n--- mandate Execution request and response ---\n\ndata MandateExecutionReq = MandateExecutionReq\n  { notificationId :: Text,\n    orderId :: Text,\n    amount :: HighPrecMoney,\n    customerId :: Text,\n    mandateId :: Text,\n    executionDate :: UTCTime,\n    splitSettlementDetails :: Maybe SplitSettlementDetails\n  }\n\ndata MandateExecutionRes = MandateExecutionRes\n  { orderId :: Text,\n    txnId :: Text,\n    txnUUID :: Text,\n    status :: TransactionStatus\n  }\n  deriving (Eq, Show, Generic, ToJSON, FromJSON, ToSchema)\n\n-- offer list request --\n\ndata OfferListReq = OfferListReq\n  { order :: OfferOrder,\n    customer :: Maybe OfferCustomer,\n    planId :: Text,\n    registrationDate :: UTCTime,\n    dutyDate :: UTCTime,\n    paymentMode :: Text,\n    numOfRides :: Int,\n    offerListingMetric :: Maybe UDF6\n  }\n\ndata UDF6 = IS_VISIBLE | IS_APPLICABLE | LIST_BASED_ON_DATE UTCTime\n  deriving stock (Show, Eq, Generic, Read)\n\ndata OfferOrder = OfferOrder\n  { orderId :: Maybe Text,\n    amount :: HighPrecMoney,\n    currency :: Currency\n  }\n\ndata OfferCustomer = OfferCustomer\n  { customerId :: Text,\n    email :: Maybe Text,\n    mobile :: Maybe Text\n  }\n\n-- offer list response --\n\ndata OfferListResp = OfferListResp\n  { bestOfferCombination :: Maybe BestOfferCombination,\n    offerResp :: [OfferResp]\n  }\n  deriving (Generic, Show, FromJSON, ToJSON)\n\ndata BestOfferCombination = BestOfferCombination\n  { offers :: [BestOfferCombinationOffer],\n    orderBreakup :: OrderBreakup\n  }\n  deriving (Generic, Show, FromJSON, ToJSON)\n\ndata BestOfferCombinationOffer = BestOfferCombinationOffer\n  { offerId :: Text,\n    cashbackAmount :: HighPrecMoney,\n    discountAmount :: HighPrecMoney,\n    merchantDiscountAmount :: HighPrecMoney,\n    totalOfferedAmount :: HighPrecMoney\n  }\n  deriving (Generic, Show, FromJSON, ToJSON)\n\ndata OrderBreakup = OrderBreakup\n  { orderAmount :: HighPrecMoney,\n    finalOrderAmount :: HighPrecMoney,\n    discountAmount :: HighPrecMoney,\n    merchantDiscountAmount :: HighPrecMoney,\n    cashbackAmount :: HighPrecMoney,\n    offerAmount :: HighPrecMoney\n  }\n  deriving (Generic, Show, FromJSON, ToJSON)\n\ndata OfferResp = OfferResp\n  { offerId :: Text,\n    status :: OfferListStatus,\n    offerDescription :: OfferDescription,\n    orderAmount :: HighPrecMoney,\n    finalOrderAmount :: HighPrecMoney,\n    discountAmount :: HighPrecMoney\n  }\n  deriving (Generic, Show, FromJSON, ToJSON)\n\ndata OfferDescription = OfferDescription\n  { sponsoredBy :: Maybe Text,\n    title :: Maybe Text,\n    description :: Maybe Text,\n    tnc :: Maybe Text\n  }\n  deriving (Generic, Show, FromJSON, ToJSON)\n\n-- offer apply --\n\ndata OfferApplyReq = OfferApplyReq\n  { txnId :: Text,\n    offers :: [Text],\n    customerId :: Text,\n    amount :: HighPrecMoney,\n    currency :: Currency,\n    planId :: Text,\n    registrationDate :: UTCTime,\n    dutyDate :: UTCTime,\n    paymentMode :: Text,\n    numOfRides :: Int\n  }\n\nnewtype OfferApplyResp = OfferApplyResp\n  { offers :: [OfferApplyRespItem]\n  }\n\ndata OfferApplyRespItem = OfferApplyRespItem\n  { offerId :: Text,\n    finalOrderAmount :: HighPrecMoney\n  }\n\n-- offer notify --\n\ndata OfferNotifyReq = OfferNotifyReq\n  { mandateId :: Text,\n    orderShortId :: Text,\n    transactionUUID :: Text,\n    transactionStatus :: TransactionStatus,\n    offers :: [OfferNotifyOffer]\n  }\n\ndata OfferNotifyOffer = OfferNotifyOffer\n  { offerId :: Text,\n    status :: OfferStatus\n  }\n\ntype OfferNotifyResp = APISuccess\n\n--- auto refund request ---\ndata AutoRefundReq = AutoRefundReq\n  { orderId :: Text,\n    requestId :: Text,\n    amount :: HighPrecMoney\n  }\n\ndata AutoRefundResp = AutoRefundResp\n  { orderId :: Text,\n    merchantId :: Text,\n    customerId :: Text,\n    currency :: Currency,\n    amountRefunded :: Double,\n    refunds :: [RefundsData]\n  }\n  deriving stock (Show, Generic, Read, Eq)\n  deriving anyclass (FromJSON, ToJSON, ToSchema)\n\ndata RefundsData = RefundsData\n  { idAssignedByServiceProvider :: Maybe Text,\n    amount :: HighPrecMoney,\n    status :: RefundStatus,\n    errorMessage :: Maybe Text,\n    errorCode :: Maybe Text,\n    initiatedBy :: Maybe Text,\n    requestId :: Text\n  }\n  deriving stock (Show, Generic, Read, Eq)\n  deriving anyclass (FromJSON, ToJSON, ToSchema)\n\n-- | Request to create a Connect Account\ndata IndividualConnectAccountReq = IndividualConnectAccountReq\n  { country :: Context.Country,\n    email :: Maybe Text,\n    mobileNumber :: Text,\n    dateOfBirth :: Day,\n    firstName :: Text,\n    lastName :: Maybe Text,\n    ssnLast4 :: Maybe Text,\n    idNumber :: Maybe Text,\n    address :: Maybe Address\n  }\n  deriving stock (Show, Eq, Generic)\n  deriving anyclass (FromJSON, ToJSON, ToSchema)\n\ndata IndividualConnectAccountResp = IndividualConnectAccountResp\n  { accountId :: AccountId,\n    accountUrl :: Text,\n    accountUrlExpiry :: UTCTime,\n    chargesEnabled :: Bool,\n    detailsSubmitted :: Bool\n  }\n  deriving stock (Show, Eq, Generic)\n  deriving anyclass (FromJSON, ToJSON, ToSchema)\n\ndata RetryAccountLink = RetryAccountLink\n  { accountId :: AccountId,\n    accountUrl :: Text,\n    accountUrlExpiry :: UTCTime\n  }\n  deriving stock (Show, Eq, Generic)\n  deriving anyclass (FromJSON, ToJSON, ToSchema)\n\ndata ConnectAccountResp = ConnectAccountResp\n  { accountId :: AccountId,\n    chargesEnabled :: Bool,\n    detailsSubmitted :: Bool\n  }\n  deriving stock (Show, Eq, Generic)\n  deriving anyclass (FromJSON, ToJSON, ToSchema)\n\ndata CreateCustomerReq = CreateCustomerReq\n  { email :: Maybe Text,\n    name :: Maybe Text,\n    lastName :: Maybe Text,\n    phone :: Maybe Text,\n    objectReferenceId :: Maybe Text,\n    mobileCountryCode :: Maybe Text,\n    optionsGetClientAuthToken :: Maybe Bool\n  }\n  deriving stock (Show, Eq, Generic)\n  deriving anyclass (FromJSON, ToJSON, ToSchema)\n\ndata CreateCustomerResp = CreateCustomerResp\n  { customerId :: CustomerId,\n    clientAuthToken :: Maybe Text,\n    clientAuthTokenExpiry :: Maybe UTCTime\n  }\n  deriving stock (Show, Eq, Generic)\n  deriving anyclass (FromJSON, ToJSON, ToSchema)\n\ndata OrderUpdateReq = OrderUpdateReq\n  { amount :: HighPrecMoney,\n    orderShortId :: Text,\n    splitSettlementDetails :: Maybe SplitSettlementDetails\n  }\n  deriving stock (Show, Eq, Generic)\n  deriving anyclass (FromJSON, ToJSON, ToSchema)\n\ndata OrderUpdateResp = OrderUpdateResp\n  { orderId :: Maybe Text,\n    amount :: Maybe HighPrecMoney\n  }\n  deriving stock (Show, Eq, Generic)\n  deriving anyclass (FromJSON, ToJSON, ToSchema)\n\ndata CreatePaymentIntentReq = CreatePaymentIntentReq\n  { amount :: HighPrecMoney,\n    applicationFeeAmount :: HighPrecMoney,\n    currency :: Currency,\n    customer :: CustomerId,\n    paymentMethod :: PaymentMethodId,\n    receiptEmail :: Maybe Text,\n    driverAccountId :: AccountId\n  }\n  deriving stock (Show, Eq, Generic)\n  deriving anyclass (FromJSON, ToJSON, ToSchema)\n\ndata CreatePaymentIntentResp = CreatePaymentIntentResp\n  { paymentIntentId :: PaymentIntentId,\n    clientSecret :: Text,\n    status :: PaymentIntentStatus\n  }\n  deriving stock (Show, Eq, Generic)\n  deriving anyclass (FromJSON, ToJSON, ToSchema)\n\ndata CreateSetupIntentResp = CreateSetupIntentResp\n  { setupIntentId :: SetupIntentId,\n    clientSecret :: Text,\n    status :: PaymentIntentStatus\n  }\n  deriving stock (Show, Eq, Generic)\n  deriving anyclass (FromJSON, ToJSON, ToSchema)\n\ndata CustomerCard = CustomerCard\n  { cardId :: PaymentMethodId,\n    brand :: Text,\n    last4 :: Text,\n    expMonth :: Int,\n    expYear :: Int,\n    country :: Maybe Text\n  }\n  deriving stock (Show, Eq, Generic)\n  deriving anyclass (FromJSON, ToJSON, ToSchema)\n\ntype CustomerCardListResp = [CustomerCard]\n\ndata VerifyVPAReq = VerifyVPAReq\n  { vpa :: Text,\n    customerId :: Maybe Text,\n    orderId :: Maybe Text\n  }\n  deriving stock (Show, Generic, Read, Eq)\n  deriving anyclass (FromJSON, ToJSON, ToSchema)\n\ndata VerifyVPAResp = VerifyVPAResp\n  { vpa :: Text,\n    status :: Text,\n    customerName :: Maybe Text\n  }\n  deriving stock (Show, Generic, Read, Eq)\n  deriving anyclass (FromJSON, ToJSON, ToSchema)\n",
      "hash": "1f7352a70927fa4881380f72cef59ef020c618f6f94302eea05f2901e7c61c21",
      "size": 18664
    },
    "/lib/mobility-core/src/Kernel/External/Payment/Juspay/Config.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n{-# LANGUAGE DerivingStrategies #-}\n\nmodule Kernel.External.Payment.Juspay.Config where\n\nimport Data.Aeson\nimport Kernel.External.Encryption\nimport Kernel.Prelude\n\ndata JuspayCfg = JuspayCfg\n  { apiKey :: EncryptedField 'AsEncrypted Text,\n    returnUrl :: BaseUrl,\n    url :: BaseUrl,\n    merchantId :: Text,\n    username :: Text,\n    password :: EncryptedField 'AsEncrypted Text,\n    serviceMode :: Maybe ServiceMode,\n    gatewayReferenceId :: Maybe Text,\n    pseudoClientId :: Maybe Text, --- it is passed in response to for handling multiple merchants in same payment page\n    isSplitEnabled :: Maybe Bool\n  }\n  deriving stock (Show, Eq, Generic)\n  deriving anyclass (FromJSON, ToJSON)\n\ndata ServiceMode = AA | NonAA\n  deriving stock (Show, Eq, Generic)\n  deriving anyclass (FromJSON, ToJSON)\n",
      "hash": "ea34742236eb50793df38f64fc6b7d1fbdc1caec1ac07d685b76fefc313a0323",
      "size": 1489
    },
    "/lib/mobility-core/src/Kernel/External/Payment/Juspay/Flow.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n\nmodule Kernel.External.Payment.Juspay.Flow where\n\nimport qualified Data.Text.Encoding as DT\nimport Data.Time.Format\nimport EulerHS.Types as Euler\nimport Kernel.External.Payment.Juspay.Types\nimport qualified Kernel.External.Payment.Juspay.Types.Offer as Offer\nimport Kernel.Prelude\nimport Kernel.Tools.Metrics.CoreMetrics as Metrics\nimport Kernel.Types.Common\nimport Kernel.Types.Error (GenericError (InternalError))\nimport Kernel.Utils.Common (CallAPI', callAPI, encodeToText, fromEitherM)\nimport Servant hiding (throwError)\n\n-- https://docs.juspay.in/payment-page/ios/base-sdk-integration/order-status-api\n\ntype CreateCustomerAPI =\n  \"customers\"\n    :> BasicAuth \"username-password\" BasicAuthData\n    :> Header \"x-merchantid\" Text\n    :> Header \"x-routing-id\" Text\n    :> ReqBody '[JSON] CreateCustomerRequest\n    :> Post '[JSON] CreateCustomerResp\n\ncreateCustomer ::\n  ( Metrics.CoreMetrics m,\n    MonadFlow m\n  ) =>\n  BaseUrl ->\n  Text ->\n  Text ->\n  Maybe Text ->\n  CreateCustomerRequest ->\n  m CreateCustomerResp\ncreateCustomer url apiKey merchantId mRoutingId req = do\n  let proxy = Proxy @CreateCustomerAPI\n      eulerClient = Euler.client proxy (mkBasicAuthData apiKey) (Just merchantId) mRoutingId req\n  callJuspayAPI url eulerClient \"create-customer\" proxy\n\ntype GetCustomerAPI =\n  \"v2\" :> \"customers\"\n    :> Capture \"id\" CustomerId\n    :> BasicAuth \"username-password\" BasicAuthData\n    :> Header \"x-merchantid\" Text\n    :> Header \"x-routing-id\" Text\n    :> ReqBody '[FormUrlEncoded] GetCustomerReq\n    :> Post '[JSON] CreateCustomerResp\n\ngetCustomer ::\n  ( Metrics.CoreMetrics m,\n    MonadFlow m\n  ) =>\n  BaseUrl ->\n  Text ->\n  Text ->\n  Maybe Text ->\n  CustomerId ->\n  GetCustomerReq ->\n  m CreateCustomerResp\ngetCustomer url apiKey merchantId mRoutingId customerId req = do\n  let proxy = Proxy @GetCustomerAPI\n      eulerClient = Euler.client proxy customerId (mkBasicAuthData apiKey) (Just merchantId) mRoutingId req\n  callJuspayAPI url eulerClient \"get-customer\" proxy\n\ntype CreateOrderAPI =\n  \"session\"\n    :> BasicAuth \"username-password\" BasicAuthData\n    :> Header \"x-merchantid\" Text\n    :> Header \"x-routing-id\" Text\n    :> ReqBody '[JSON] CreateOrderReq\n    :> Post '[JSON] CreateOrderResp\n\ncreateOrder ::\n  ( Metrics.CoreMetrics m,\n    MonadFlow m\n  ) =>\n  BaseUrl ->\n  Text ->\n  Text ->\n  Maybe Text ->\n  CreateOrderReq ->\n  m CreateOrderResp\ncreateOrder url apiKey merchantId mRoutingId req = do\n  let proxy = Proxy @CreateOrderAPI\n      eulerClient = Euler.client proxy (mkBasicAuthData apiKey) (Just merchantId) mRoutingId req\n  callJuspayAPI url eulerClient \"create-order\" proxy\n\ntype OrderStatusAPI =\n  \"orders\"\n    :> Capture \"orderId\" Text\n    :> BasicAuth \"username-password\" BasicAuthData\n    :> Header \"x-merchantid\" Text\n    :> Header \"x-routing-id\" Text\n    :> MandatoryQueryParam \"version\" Text\n    :> Get '[JSON] OrderStatusResp\n\norderStatus ::\n  ( Metrics.CoreMetrics m,\n    MonadFlow m\n  ) =>\n  BaseUrl ->\n  Text ->\n  Text ->\n  Maybe Text ->\n  Text ->\n  m OrderStatusResp\norderStatus url apiKey merchantId mRoutingId orderId = do\n  version <- getCurrentDate\n  let proxy = Proxy @OrderStatusAPI\n      eulerClient = Euler.client proxy orderId (mkBasicAuthData apiKey) (Just merchantId) mRoutingId version\n  callJuspayAPI url eulerClient \"order-status\" proxy\n\ngetCurrentDate :: MonadFlow m => m Text\ngetCurrentDate = do\n  currentTime <- getCurrentTime\n  let dateFormat = \"%Y-%m-%d\"\n      formattedDate = formatTime defaultTimeLocale dateFormat currentTime\n  return $ encodeToText formattedDate\n\ntype OrderUpdateAPI =\n  \"orders\"\n    :> Capture \"orderId\" Text\n    :> BasicAuth \"username-password\" BasicAuthData\n    :> Header \"x-merchantid\" Text\n    :> Header \"x-routing-id\" Text\n    :> ReqBody '[FormUrlEncoded] OrderUpdateReq\n    :> Post '[JSON] OrderUpdateResp\n\nupdateOrder ::\n  ( Metrics.CoreMetrics m,\n    MonadFlow m\n  ) =>\n  BaseUrl ->\n  Text ->\n  Text ->\n  Text ->\n  Maybe Text ->\n  OrderUpdateReq ->\n  m OrderUpdateResp\nupdateOrder url apiKey merchantId orderId mRoutingId req = do\n  let proxy = Proxy @OrderUpdateAPI\n      eulerClient = Euler.client proxy orderId (mkBasicAuthData apiKey) (Just merchantId) mRoutingId req\n  callJuspayAPI url eulerClient \"update-order\" proxy\n\ntype OfferListAPI =\n  \"offers\"\n    :> \"list\"\n    :> BasicAuth \"username-password\" BasicAuthData\n    :> Header \"x-merchantid\" Text\n    :> Header \"x-routing-id\" Text\n    :> ReqBody '[JSON] Offer.OfferListReq\n    :> Post '[JSON] Offer.OfferListResp\n\nofferList ::\n  ( Metrics.CoreMetrics m,\n    MonadFlow m\n  ) =>\n  BaseUrl ->\n  Text ->\n  Text ->\n  Maybe Text ->\n  Offer.OfferListReq ->\n  m Offer.OfferListResp\nofferList url apiKey merchantId mRoutingId req = do\n  let proxy = Proxy @OfferListAPI\n      eulerClient = Euler.client proxy (mkBasicAuthData apiKey) (Just merchantId) mRoutingId req\n  callJuspayAPI url eulerClient \"offer-list\" proxy\n\ntype OfferApplyAPI =\n  \"offers\"\n    :> \"apply\"\n    :> BasicAuth \"username-password\" BasicAuthData\n    :> Header \"x-merchantid\" Text\n    :> Header \"x-routing-id\" Text\n    :> ReqBody '[JSON] Offer.OfferApplyReq\n    :> Post '[JSON] Offer.OfferApplyResp\n\nofferApply ::\n  ( Metrics.CoreMetrics m,\n    MonadFlow m\n  ) =>\n  BaseUrl ->\n  Text ->\n  Text ->\n  Maybe Text ->\n  Offer.OfferApplyReq ->\n  m Offer.OfferApplyResp\nofferApply url apiKey merchantId mRoutingId req = do\n  let proxy = Proxy @OfferApplyAPI\n      eulerClient = Euler.client proxy (mkBasicAuthData apiKey) (Just merchantId) mRoutingId req\n  callJuspayAPI url eulerClient \"offer-apply\" proxy\n\ntype OfferNotifyAPI =\n  \"merchant\"\n    :> \"offers\"\n    :> Capture \"mandateId\" Text\n    :> BasicAuth \"username-password\" BasicAuthData\n    :> Header \"x-merchantid\" Text\n    :> Header \"x-routing-id\" Text\n    :> ReqBody '[JSON] Offer.OfferNotifyReq\n    :> Post '[JSON] Offer.OfferNotifyResp\n\nofferNotify ::\n  ( Metrics.CoreMetrics m,\n    MonadFlow m\n  ) =>\n  BaseUrl ->\n  Text ->\n  Text ->\n  Maybe Text ->\n  Text ->\n  Offer.OfferNotifyReq ->\n  m Offer.OfferNotifyResp\nofferNotify url apiKey merchantId mRoutingId mandateId req = do\n  let proxy = Proxy @OfferNotifyAPI\n      eulerClient = Euler.client proxy mandateId (mkBasicAuthData apiKey) (Just merchantId) mRoutingId req\n  callJuspayAPI url eulerClient \"offer-notify\" proxy\n\ncallJuspayAPI :: CallAPI' m api res res\ncallJuspayAPI url eulerClient description proxy = do\n  callAPI url eulerClient description proxy\n    >>= fromEitherM (\\err -> InternalError $ \"Failed to call \" <> description <> \" API: \" <> show err)\n\nmkBasicAuthData :: Text -> BasicAuthData\nmkBasicAuthData apiKey =\n  BasicAuthData\n    { basicAuthUsername = DT.encodeUtf8 apiKey,\n      basicAuthPassword = \"\"\n    }\n\ntype MandateNotificationAPI =\n  \"mandates\"\n    :> Capture \"mandateId\" Text\n    :> BasicAuth \"username-password\" BasicAuthData\n    :> Header \"x-merchantid\" Text\n    :> Header \"x-routing-id\" Text\n    :> ReqBody '[FormUrlEncoded] MandateNotificationReq\n    :> Post '[JSON] MandateNotificationRes\n\nmandateNotification ::\n  ( Metrics.CoreMetrics m,\n    MonadFlow m\n  ) =>\n  BaseUrl ->\n  Text ->\n  Text ->\n  Text ->\n  Maybe Text ->\n  MandateNotificationReq ->\n  m MandateNotificationRes\nmandateNotification url apiKey mandateId merchantId mRoutingId req = do\n  let eulerClient = Euler.client (Proxy @MandateNotificationAPI)\n  let basicAuthData =\n        BasicAuthData\n          { basicAuthUsername = DT.encodeUtf8 apiKey,\n            basicAuthPassword = \"\"\n          }\n  callAPI url (eulerClient mandateId basicAuthData (Just merchantId) mRoutingId req) \"mandate-notification\" (Proxy @MandateNotificationAPI)\n    >>= fromEitherM (\\err -> InternalError $ \"Failed to call mandate notification API: \" <> show err)\n\ntype NotificationStatusAPI =\n  \"notifications\"\n    :> Capture \"object_reference_id\" Text\n    :> BasicAuth \"username-password\" BasicAuthData\n    :> Header \"x-merchantid\" Text\n    :> Header \"x-routing-id\" Text\n    :> Get '[JSON] NotificationStatusResp\n\nmandateNotificationStatus ::\n  ( Metrics.CoreMetrics m,\n    MonadFlow m\n  ) =>\n  BaseUrl ->\n  Text ->\n  Text ->\n  Text ->\n  Maybe Text ->\n  m NotificationStatusResp\nmandateNotificationStatus url apiKey object_reference_id merchantId mRoutingId = do\n  let eulerClient = Euler.client (Proxy @NotificationStatusAPI)\n  let basicAuthData =\n        BasicAuthData\n          { basicAuthUsername = DT.encodeUtf8 apiKey,\n            basicAuthPassword = \"\"\n          }\n  callAPI url (eulerClient object_reference_id basicAuthData (Just merchantId) mRoutingId) \"mandate-notification-status\" (Proxy @NotificationStatusAPI)\n    >>= fromEitherM (\\err -> InternalError $ \"Failed to call mandate notification status API: \" <> show err)\n\ntype MandateExecutionAPI =\n  \"txns\"\n    :> BasicAuth \"username-password\" BasicAuthData\n    :> Header \"x-merchantid\" Text\n    :> Header \"x-routing-id\" Text\n    :> ReqBody '[FormUrlEncoded] MandateExecutionReq\n    :> Post '[JSON] MandateExecutionRes\n\nmandateExecution ::\n  ( Metrics.CoreMetrics m,\n    MonadFlow m\n  ) =>\n  BaseUrl ->\n  Text ->\n  Text ->\n  Maybe Text ->\n  MandateExecutionReq ->\n  m MandateExecutionRes\nmandateExecution url apiKey merchantId mRoutingId req = do\n  let eulerClient = Euler.client (Proxy @MandateExecutionAPI)\n  let basicAuthData =\n        BasicAuthData\n          { basicAuthUsername = DT.encodeUtf8 apiKey,\n            basicAuthPassword = \"\"\n          }\n  callAPI url (eulerClient basicAuthData (Just merchantId) mRoutingId req) \"mandate-execution\" (Proxy @MandateExecutionAPI)\n    >>= fromEitherM (\\err -> InternalError $ \"Failed to call mandate Execution API: \" <> show err)\n\ntype MandateRevokeAPI =\n  \"mandates\"\n    :> Header \"x-merchantid\" Text\n    :> Header \"x-routing-id\" Text\n    :> BasicAuth \"username-password\" BasicAuthData\n    :> Capture \"mandateId\" Text\n    :> ReqBody '[FormUrlEncoded] MandateRevokeReq\n    :> Post '[JSON] MandateRevokeRes\n\nmandateRevoke ::\n  ( Metrics.CoreMetrics m,\n    MonadFlow m\n  ) =>\n  BaseUrl ->\n  Text ->\n  Text ->\n  Maybe Text ->\n  Text ->\n  MandateRevokeReq ->\n  m MandateRevokeRes\nmandateRevoke url apiKey merchantId mRoutingId mandateId req = do\n  let eulerClient = Euler.client (Proxy @MandateRevokeAPI)\n  let basicAuthData =\n        BasicAuthData\n          { basicAuthUsername = DT.encodeUtf8 apiKey,\n            basicAuthPassword = \"\"\n          }\n  callAPI url (eulerClient (Just merchantId) mRoutingId basicAuthData mandateId req) \"mandate-Revoke\" (Proxy @MandateRevokeAPI)\n    >>= fromEitherM (\\err -> InternalError $ \"Failed to call mandate Revoke API: \" <> show err)\n\ntype MandatePauseAPI =\n  \"mandates\"\n    :> Capture \"mandateId\" Text\n    :> BasicAuth \"username-password\" BasicAuthData\n    :> ReqBody '[FormUrlEncoded] MandatePauseReq\n    :> Post '[JSON] ()\n\nmandatePause ::\n  ( Metrics.CoreMetrics m,\n    MonadFlow m\n  ) =>\n  BaseUrl ->\n  Text ->\n  Text ->\n  MandatePauseReq ->\n  m ()\nmandatePause url apiKey mandateId req = do\n  let eulerClient = Euler.client (Proxy @MandatePauseAPI)\n  let basicAuthData =\n        BasicAuthData\n          { basicAuthUsername = DT.encodeUtf8 apiKey,\n            basicAuthPassword = \"\"\n          }\n  callAPI url (eulerClient mandateId basicAuthData req) \"mandate-pause\" (Proxy @MandatePauseAPI)\n    >>= fromEitherM (\\err -> InternalError $ \"Failed to call mandate pause API: \" <> show err)\n\ntype MandateResumeAPI =\n  \"mandates\"\n    :> Capture \"mandateId\" Text\n    :> BasicAuth \"username-password\" BasicAuthData\n    :> ReqBody '[FormUrlEncoded] MandateResumeReq\n    :> Post '[JSON] ()\n\nmandateResume ::\n  ( Metrics.CoreMetrics m,\n    MonadFlow m\n  ) =>\n  BaseUrl ->\n  Text ->\n  Text ->\n  MandateResumeReq ->\n  m ()\nmandateResume url apiKey mandateId req = do\n  let eulerClient = Euler.client (Proxy @MandateResumeAPI)\n  let basicAuthData =\n        BasicAuthData\n          { basicAuthUsername = DT.encodeUtf8 apiKey,\n            basicAuthPassword = \"\"\n          }\n  callAPI url (eulerClient mandateId basicAuthData req) \"mandate-resume\" (Proxy @MandateResumeAPI)\n    >>= fromEitherM (\\err -> InternalError $ \"Failed to call mandate resume API: \" <> show err)\n\ntype AutoRefundAPI =\n  \"orders\"\n    :> Capture \"orderId\" Text\n    :> \"refunds\"\n    :> BasicAuth \"username-password\" BasicAuthData\n    :> Header \"x-merchantid\" Text\n    :> Header \"x-routing-id\" Text\n    :> ReqBody '[JSON] AutoRefundReq\n    :> Post '[JSON] AutoRefundResp\n\nautoRefund ::\n  ( Metrics.CoreMetrics m,\n    MonadFlow m\n  ) =>\n  BaseUrl ->\n  Text ->\n  Text ->\n  Text ->\n  Maybe Text ->\n  AutoRefundReq ->\n  m AutoRefundResp\nautoRefund url apiKey orderId merchantId mRoutingId req = do\n  let eulerClient = Euler.client (Proxy @AutoRefundAPI)\n  let basicAuthData =\n        BasicAuthData\n          { basicAuthUsername = DT.encodeUtf8 apiKey,\n            basicAuthPassword = \"\"\n          }\n  callAPI url (eulerClient orderId basicAuthData (Just merchantId) mRoutingId req) \"order-refund\" (Proxy @AutoRefundAPI)\n    >>= fromEitherM (\\err -> InternalError $ \"Failed to call order refund API: \" <> show err)\n\ntype VerifyVPAAPI =\n  \"v2\"\n    :> \"upi\"\n    :> \"verify-vpa\"\n    :> BasicAuth \"username-password\" BasicAuthData\n    :> Header \"x-merchantid\" Text\n    :> Header \"x-routing-id\" Text\n    :> ReqBody '[JSON] VerifyVPAReq\n    :> Post '[JSON] VerifyVPAResp\n\nverifyVPA ::\n  (Metrics.CoreMetrics m, MonadFlow m) =>\n  BaseUrl ->\n  Text ->\n  Text ->\n  Maybe Text ->\n  VerifyVPAReq ->\n  m VerifyVPAResp\nverifyVPA url apiKey merchantId mRoutingId req = do\n  let eulerClient = Euler.client (Proxy @VerifyVPAAPI) (mkBasicAuthData apiKey) (Just merchantId) mRoutingId req\n  callAPI url eulerClient \"verify-vpa\" (Proxy @VerifyVPAAPI)\n    >>= fromEitherM (\\err -> InternalError $ \"Failed to call verify VPA API: \" <> show err)\n",
      "hash": "bd570a2d77d9bfefc737a9c0e86bf02d3adcb4ccf72564132902bb00c43f1904",
      "size": 14309
    },
    "/lib/mobility-core/src/Kernel/External/Payment/Juspay/Types.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n\nmodule Kernel.External.Payment.Juspay.Types\n  ( module Reexport,\n  )\nwhere\n\nimport Kernel.External.Payment.Juspay.Types.Common as Reexport\nimport Kernel.External.Payment.Juspay.Types.CreateCustomer as Reexport\nimport Kernel.External.Payment.Juspay.Types.CreateOrder as Reexport\nimport Kernel.External.Payment.Juspay.Types.Mandate as Reexport\nimport Kernel.External.Payment.Juspay.Types.Offer as Reexport\nimport Kernel.External.Payment.Juspay.Types.UpdateOrder as Reexport\nimport Kernel.External.Payment.Juspay.Types.Webhook as Reexport\n  ( OrderAndNotificationStatusContent (..),\n    WebhookReq (..),\n  )\n",
      "hash": "f2c54632a39bdf20a88725300d06ba816b585d1b1ad6d0efe3d1eed9d39b37c3",
      "size": 1299
    },
    "/lib/mobility-core/src/Kernel/External/Payment/Juspay/Types/Common.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n{-# LANGUAGE DerivingStrategies #-}\n{-# LANGUAGE TemplateHaskell #-}\n\nmodule Kernel.External.Payment.Juspay.Types.Common where\n\nimport Data.Aeson.Types\nimport Kernel.Beam.Lib.UtilsTH (mkBeamInstancesForEnum)\nimport Kernel.Prelude\nimport Kernel.Storage.Esqueleto (derivePersistField)\nimport Kernel.Types.Common\n\ntype CustomerId = Text\n\ndata PaymentStatus\n  = ORDER_SUCCEEDED\n  | ORDER_REFUNDED\n  | ORDER_FAILED\n  | ORDER_REFUND_FAILED\n  | TXN_CREATED\n  | REFUND_MANUAL_REVIEW_NEEDED\n  | REFUND_INITIATED\n  | AUTO_REFUND_SUCCEEDED\n  | AUTO_REFUND_FAILED\n  | MANDATE_CREATED\n  | MANDATE_ACTIVATED\n  | MANDATE_FAILED\n  | MANDATE_REVOKED\n  | MANDATE_PAUSED\n  | MANDATE_EXPIRED\n  | NOTIFICATION_FAILED\n  | NOTIFICATION_SUCCEEDED\n  | ORDER_AUTHORIZED\n  | TXN_CHARGED\n  | TXN_FAILED\n  deriving stock (Show, Eq, Generic, Read)\n  deriving anyclass (FromJSON, ToJSON, ToSchema)\n\ndata MandateType = OPTIONAL | REQUIRED\n  deriving stock (Show, Read, Eq, Generic, Ord)\n  deriving anyclass (FromJSON, ToJSON, ToSchema)\n\nderivePersistField \"MandateType\"\n\n$(mkBeamInstancesForEnum ''MandateType)\n\ndata MandateFrequency = ONETIME | DAILY | WEEKLY | FORTNIGHTLY | MONTHLY | BIMONTHLY | QUARTERLY | HALFYEARLY | YEARLY | ASPRESENTED\n  deriving stock (Show, Read, Eq, Generic, Ord)\n  deriving anyclass (FromJSON, ToJSON, ToSchema)\n\n$(mkBeamInstancesForEnum ''MandateFrequency)\n\nderivePersistField \"MandateFrequency\"\n\ndata MandateStatus = CREATED | ACTIVE | FAILURE | PAUSED | EXPIRED | REVOKED\n  deriving stock (Show, Read, Eq, Generic, Ord)\n  deriving anyclass (FromJSON, ToJSON, ToSchema)\n\n$(mkBeamInstancesForEnum ''MandateStatus)\n\nderivePersistField \"MandateStatus\"\n\ndata NotificationStatus = NOTIFICATION_CREATED | NOTIFICATION_FAILURE | PENDING | SUCCESS\n  deriving stock (Show, Read, Eq, Generic)\n  deriving anyclass (ToSchema)\n\nderivePersistField \"NotificationStatus\"\n\ninstance FromJSON NotificationStatus where\n  parseJSON (String \"CREATED\") = pure NOTIFICATION_CREATED\n  parseJSON (String \"FAILURE\") = pure NOTIFICATION_FAILURE\n  parseJSON (String \"PENDING\") = pure PENDING\n  parseJSON (String \"SUCCESS\") = pure SUCCESS\n  parseJSON (String _) = parseFail \"Expected type\"\n  parseJSON e = typeMismatch \"String\" e\n\ninstance ToJSON NotificationStatus where\n  toJSON NOTIFICATION_CREATED = \"CREATED\"\n  toJSON NOTIFICATION_FAILURE = \"FAILURE\"\n  toJSON PENDING = \"PENDING\"\n  toJSON SUCCESS = \"SUCCESS\"\n\ndata RefundStatus = REFUND_PENDING | REFUND_FAILURE | REFUND_SUCCESS | MANUAL_REVIEW\n  deriving stock (Show, Eq, Read, Ord, Generic)\n  deriving anyclass (ToSchema)\n\nderivePersistField \"RefundStatus\"\n\n$(mkBeamInstancesForEnum ''RefundStatus)\n\ninstance FromJSON RefundStatus where\n  parseJSON (String \"FAILURE\") = pure REFUND_FAILURE\n  parseJSON (String \"PENDING\") = pure REFUND_PENDING\n  parseJSON (String \"SUCCESS\") = pure REFUND_SUCCESS\n  parseJSON (String \"MANUAL_REVIEW\") = pure MANUAL_REVIEW\n  parseJSON (String _) = parseFail \"Expected type\"\n  parseJSON e = typeMismatch \"String\" e\n\ninstance ToJSON RefundStatus where\n  toJSON REFUND_FAILURE = \"FAILURE\"\n  toJSON REFUND_PENDING = \"PENDING\"\n  toJSON REFUND_SUCCESS = \"SUCCESS\"\n  toJSON MANUAL_REVIEW = \"MANUAL_REVIEW\"\n\ndata TransactionStatus\n  = NEW\n  | PENDING_VBV\n  | CHARGED\n  | AUTHENTICATION_FAILED\n  | AUTHORIZATION_FAILED\n  | CANCELLED -- for stripe\n  | JUSPAY_DECLINED\n  | AUTHORIZING\n  | COD_INITIATED\n  | STARTED\n  | AUTO_REFUNDED\n  | CLIENT_AUTH_TOKEN_EXPIRED -- Domain status, not part of Juspay Euler status types\n  deriving stock (Show, Eq, Read, Ord, Generic)\n  deriving anyclass (FromJSON, ToJSON, ToSchema)\n\nderivePersistField \"TransactionStatus\"\n\n$(mkBeamInstancesForEnum ''TransactionStatus)\n\ntype OrderStatusResp = OrderData\n\ndata OrderData = OrderData\n  { order_id :: Text,\n    txn_uuid :: Maybe Text,\n    txn_id :: Maybe Text,\n    status_id :: Maybe Int,\n    event_name :: Maybe PaymentStatus, --- only webhook res contains this field ---\n    status :: TransactionStatus,\n    payment_method_type :: Maybe Text,\n    payment_method :: Maybe Text,\n    payment_gateway_response :: Maybe PaymentGatewayResponse,\n    resp_message :: Maybe Text,\n    resp_code :: Maybe Text,\n    gateway_reference_id :: Maybe Text,\n    amount :: Double,\n    currency :: Currency,\n    date_created :: Maybe UTCTime,\n    mandate :: Maybe MandateData,\n    payer_vpa :: Maybe Text,\n    bank_error_code :: Maybe Text,\n    bank_error_message :: Maybe Text,\n    upi :: Maybe Upi,\n    card :: Maybe CardInfo,\n    metadata :: Maybe MetaData,\n    additional_info :: Maybe AdditionalInfo,\n    links :: Maybe LinkData,\n    amount_refunded :: Maybe Double,\n    refunds :: Maybe [RefundsData],\n    split_settlement_response :: Maybe SplitSettlementResponse\n  }\n  deriving stock (Show, Generic)\n  deriving anyclass (FromJSON, ToJSON, ToSchema)\n\ndata SplitSettlementResponse = SplitSettlementResponse\n  { split_details :: Maybe [SplitDetailsResponse],\n    split_applied :: Maybe Bool\n  }\n  deriving stock (Show, Generic)\n  deriving anyclass (FromJSON, ToJSON, ToSchema)\n\ndata SplitDetailsResponse = SplitDetailsResponse\n  { sub_vendor_id :: Maybe Text,\n    amount :: Maybe HighPrecMoney,\n    merchant_commission :: Maybe HighPrecMoney,\n    gateway_sub_account_id :: Maybe Text,\n    epg_txn_id :: Maybe Text\n  }\n  deriving stock (Show, Generic)\n  deriving anyclass (FromJSON, ToJSON, ToSchema)\n\ndata PaymentGatewayResponse = PaymentGatewayResponse\n  { resp_code :: Maybe Text,\n    rrn :: Maybe Text,\n    created :: Maybe UTCTime,\n    epg_txn_id :: Maybe Text,\n    resp_message :: Maybe Text,\n    auth_id_code :: Maybe Text,\n    txn_id :: Maybe Text\n  }\n  deriving stock (Show, Generic)\n  deriving anyclass (FromJSON, ToJSON, ToSchema)\n\ndata MandateData = MandateData\n  { mandate_status :: MandateStatus,\n    start_date :: Text,\n    end_date :: Text,\n    mandate_id :: Text,\n    frequency :: MandateFrequency,\n    max_amount :: HighPrecMoney\n  }\n  deriving stock (Show, Generic)\n  deriving anyclass (FromJSON, ToJSON, ToSchema)\n\ndata Upi = Upi\n  { payer_app :: Maybe Text,\n    payer_app_name :: Maybe Text,\n    payer_vpa :: Maybe Text,\n    txn_flow_type :: Maybe Text\n  }\n  deriving stock (Show, Generic, Read, Eq)\n  deriving anyclass (FromJSON, ToJSON, ToSchema)\n\ndata CardInfo = CardInfo\n  { card_type :: Maybe Text,\n    last_four_digits :: Maybe Text\n  }\n  deriving stock (Show, Generic, Read, Eq)\n  deriving anyclass (FromJSON, ToJSON, ToSchema)\n\ndata MetaData = MetaData\n  { is_retried_order :: Maybe Text,\n    juspay_internal_retarget_configs :: Maybe RetargetConfigs\n  }\n  deriving stock (Show, Generic, Read, Eq)\n  deriving anyclass (FromJSON, ToJSON, ToSchema)\n\ndata RetargetConfigs = RetargetConfigs\n  { retarget_payment_link_expiry :: Maybe Text,\n    is_retargeted_order :: Maybe Text,\n    retarget_done_count :: Maybe Text,\n    max_retarget_limit :: Maybe Text,\n    retarget_payment_link :: Maybe Text\n  }\n  deriving stock (Show, Generic, Read, Eq)\n  deriving anyclass (FromJSON, ToJSON, ToSchema)\n\nnewtype LinkData = LinkData\n  { retarget_payment_links :: Maybe RetargetConfigs\n  }\n  deriving stock (Show, Generic, Read, Eq)\n  deriving anyclass (FromJSON, ToJSON, ToSchema)\n\ndata AdditionalInfo = AdditionalInfo\n  { retarget_payment_info :: Maybe RetargetConfigs,\n    mandate_retry_info :: Maybe MandateRetryInfo,\n    is_business_retried :: Maybe Text,\n    is_technical_retried :: Maybe Text\n  }\n  deriving stock (Show, Generic, Read, Eq)\n  deriving anyclass (FromJSON, ToJSON, ToSchema)\n\ndata MandateRetryInfo = MandateRetryInfo\n  { is_retried_order :: Maybe Text,\n    retries_done_count :: Maybe Text,\n    is_technical_retried :: Maybe Text,\n    allowed_retry :: Maybe Text,\n    is_business_retried :: Maybe Text\n  }\n  deriving stock (Show, Generic, Read, Eq)\n  deriving anyclass (FromJSON, ToJSON, ToSchema)\n\ndata RefundsData = RefundsData\n  { id :: Maybe Text,\n    amount :: Double,\n    status :: RefundStatus,\n    error_message :: Maybe Text,\n    error_code :: Maybe Text,\n    initiated_by :: Maybe Text,\n    unique_request_id :: Text\n  }\n  deriving stock (Show, Generic, Read, Eq)\n  deriving anyclass (FromJSON, ToJSON, ToSchema)\n\ndata VerifyVPAReq = VerifyVPAReq\n  { vpa :: Text,\n    merchant_id :: Text,\n    customer_id :: Maybe Text,\n    order_id :: Maybe Text\n  }\n  deriving stock (Show, Generic)\n  deriving anyclass (FromJSON, ToJSON, ToSchema)\n\nnewtype MandateDetails = MandateDetails\n  { is_handle_supported :: Bool\n  }\n  deriving stock (Show, Generic)\n  deriving anyclass (FromJSON, ToJSON)\n\ndata VPAStatus = VALID | INVALID\n  deriving (Eq, Show, Read, Generic, ToJSON, FromJSON, ToSchema)\n\nderivePersistField \"VPAStatus\"\n\n$(mkBeamInstancesForEnum ''VPAStatus)\n\ndata VerifyVPAResp = VerifyVPAResp\n  { vpa :: Text,\n    status :: VPAStatus,\n    mandate_details :: Maybe MandateDetails,\n    customer_name :: Maybe Text\n  }\n  deriving stock (Show, Generic)\n  deriving anyclass (FromJSON, ToJSON)\n",
      "hash": "ea7e581ee2bad4c52c052d3d463a1e2fdf96dc6b331a148d0c38a6fc8fbebc17",
      "size": 9531
    },
    "/lib/mobility-core/src/Kernel/External/Payment/Juspay/Types/CreateCustomer.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n{-# LANGUAGE DerivingStrategies #-}\n\nmodule Kernel.External.Payment.Juspay.Types.CreateCustomer where\n\nimport Data.Aeson\nimport qualified Data.HashMap.Strict as HM\nimport Kernel.Prelude\nimport Web.FormUrlEncoded\nimport Web.HttpApiData (ToHttpApiData (..))\n\ndata CreateCustomerRequest = CreateCustomerRequest\n  { object_reference_id :: Text,\n    mobile_number :: Text,\n    email_address :: Maybe Text,\n    first_name :: Maybe Text,\n    last_name :: Maybe Text,\n    mobile_country_code :: Maybe Text,\n    options_get_client_auth_token :: Maybe Bool\n  }\n  deriving (Show, Generic)\n  deriving anyclass (ToSchema)\n\njsonOptionsCCR :: Options\njsonOptionsCCR =\n  defaultOptions\n    { fieldLabelModifier = \\case\n        \"options_get_client_auth_token\" -> \"options.get_client_auth_token\"\n        other -> other\n    }\n\ninstance FromJSON CreateCustomerRequest where\n  parseJSON = genericParseJSON jsonOptionsCCR\n\ninstance ToJSON CreateCustomerRequest where\n  toJSON = genericToJSON jsonOptionsCCR\n\ndata GetCustomerReq = GetCustomerReq\n  { options_get_client_auth_token :: Bool\n  }\n  deriving (Show, Generic)\n  deriving anyclass (ToSchema)\n\njsonOptionsGCR :: Options\njsonOptionsGCR =\n  defaultOptions\n    { fieldLabelModifier = \\case\n        \"options_get_client_auth_token\" -> \"options.get_client_auth_token\"\n        other -> other\n    }\n\ninstance FromJSON GetCustomerReq where\n  parseJSON = genericParseJSON jsonOptionsGCR\n\ninstance ToJSON GetCustomerReq where\n  toJSON = genericToJSON jsonOptionsGCR\n\ninstance ToForm GetCustomerReq where\n  toForm GetCustomerReq {..} =\n    Form $\n      HM.fromList\n        [ (\"options.get_client_auth_token\", [toQueryParam (options_get_client_auth_token)])\n        ]\n\ndata CreateCustomerResp = CreateCustomerResp\n  { last_name :: Maybe Text,\n    mobile_number :: Maybe Text,\n    id :: Maybe Text,\n    last_updated :: Maybe Text,\n    mobile_country_code :: Maybe Text,\n    date_created :: Maybe Text,\n    email_address :: Maybe Text,\n    object_reference_id :: Text,\n    customer_object :: Maybe Text,\n    first_name :: Maybe Text,\n    juspay :: Maybe ClientAuthDetails\n  }\n  deriving stock (Show, Generic, Eq)\n\ndata ClientAuthDetails = ClientAuthDetails\n  { client_auth_token :: Text,\n    client_auth_token_expiry :: UTCTime\n  }\n  deriving stock (Show, Eq, Generic)\n  deriving anyclass (ToJSON, FromJSON)\n\njsonOptionsData :: Options\njsonOptionsData =\n  defaultOptions\n    { fieldLabelModifier = \\case\n        \"customer_object\" -> \"object\"\n        other -> other\n    }\n\ninstance FromJSON CreateCustomerResp where\n  parseJSON = genericParseJSON jsonOptionsData\n\ninstance ToJSON CreateCustomerResp where\n  toJSON = genericToJSON jsonOptionsData\n",
      "hash": "8a3e36a5e2dad0908108abb1385a79154666967388e7e0be847ace7f4a9c4fd6",
      "size": 3357
    },
    "/lib/mobility-core/src/Kernel/External/Payment/Juspay/Types/CreateOrder.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n{-# LANGUAGE DerivingStrategies #-}\n\nmodule Kernel.External.Payment.Juspay.Types.CreateOrder where\n\nimport Data.Aeson\nimport qualified Data.ByteString.Lazy as BSL\nimport qualified Data.Text as T\nimport qualified Data.Text.Encoding as DT\nimport Kernel.External.Payment.Juspay.Types.Common\nimport Kernel.Prelude\nimport Kernel.Types.Price\nimport Servant.API (FromHttpApiData (..), ToHttpApiData (..))\n\ndata CreateOrderReq = CreateOrderReq\n  { order_id :: Text,\n    amount :: Text,\n    customer_id :: Text,\n    customer_email :: Text,\n    customer_phone :: Text,\n    payment_page_client_id :: Text,\n    action :: Text,\n    return_url :: Text,\n    description :: Text,\n    first_name :: Maybe Text,\n    last_name :: Maybe Text,\n    create_mandate :: Maybe MandateType,\n    mandate_max_amount :: Maybe Text,\n    mandate_frequency :: Maybe MandateFrequency,\n    metadata_mandate_name :: Maybe Text,\n    metadata_remarks :: Text,\n    mandate_start_date :: Maybe Text,\n    mandate_end_date :: Maybe Text,\n    metadata_gateway_reference_id :: Maybe Text,\n    options_get_upi_deep_links :: Maybe Bool,\n    metadata_expiry_in_mins :: Maybe Int,\n    split_settlement_details :: Maybe SplitSettlementDetails\n  }\n  deriving stock (Show, Eq, Generic)\n\ndata Split = Split\n  { amount :: HighPrecMoney,\n    merchant_commission :: HighPrecMoney,\n    sub_mid :: Text,\n    unique_split_id :: Maybe Text\n  }\n  deriving stock (Show, Eq, Generic)\n  deriving anyclass (ToJSON, FromJSON)\n\nnewtype Vendor = Vendor\n  { split :: [Split]\n  }\n  deriving stock (Show, Eq, Generic)\n  deriving anyclass (ToJSON, FromJSON)\n\ndata SplitSettlementDetails = SplitSettlementDetails\n  { marketplace :: Marketplace,\n    mdr_borne_by :: Text,\n    vendor :: Vendor\n  }\n  deriving stock (Show, Eq, Generic)\n  deriving anyclass (ToJSON, FromJSON)\n\ninstance FromHttpApiData SplitSettlementDetails where\n  parseUrlPiece = parseHeader . DT.encodeUtf8\n  parseQueryParam = parseUrlPiece\n  parseHeader = left T.pack . eitherDecode . BSL.fromStrict\n\ninstance ToHttpApiData SplitSettlementDetails where\n  toUrlPiece = DT.decodeUtf8 . toHeader\n  toQueryParam = toUrlPiece\n  toHeader = BSL.toStrict . encode\n\ndata MBY = MARKETPLACE | VENDOR | ALL\n  deriving stock (Show, Eq, Generic)\n  deriving anyclass (ToJSON, FromJSON)\n\nnewtype Marketplace = Marketplace\n  { amount :: HighPrecMoney\n  }\n  deriving stock (Show, Eq, Generic)\n  deriving anyclass (ToJSON, FromJSON)\n\njsonReqOptions :: Options\njsonReqOptions =\n  defaultOptions\n    { fieldLabelModifier = \\case\n        \"create_mandate\" -> \"options.create_mandate\"\n        \"mandate_max_amount\" -> \"mandate.max_amount\"\n        \"mandate_frequency\" -> \"mandate.frequency\"\n        \"mandate_start_date\" -> \"mandate.start_date\"\n        \"mandate_end_date\" -> \"mandate.end_date\"\n        \"metadata_mandate_name\" -> \"metadata.AXIS_BIZ:mandate_name\"\n        \"metadata_remarks\" -> \"metadata.AXIS_BIZ:remarks\"\n        \"metadata_gateway_reference_id\" -> \"metadata.JUSPAY:gateway_reference_id\"\n        \"metadata_expiry_in_mins\" -> \"metadata.expiryInMins\"\n        \"split_settlement_details\" -> \"metadata.split_settlement_details\"\n        other -> other\n    }\n\ninstance FromJSON CreateOrderReq where\n  parseJSON = genericParseJSON jsonReqOptions {omitNothingFields = True}\n\ninstance ToJSON CreateOrderReq where\n  toJSON = genericToJSON jsonReqOptions {omitNothingFields = True}\n\ndata CreateOrderResp = CreateOrderResp\n  { status :: TransactionStatus,\n    id :: Text,\n    order_id :: Text,\n    payment_links :: Maybe PaymentLinks,\n    sdk_payload :: SDKPayload,\n    sdk_payload_json :: Maybe Value\n  }\n  deriving stock (Show, Generic)\n  deriving anyclass (ToJSON, ToSchema)\n\ninstance FromJSON CreateOrderResp where\n  parseJSON = withObject \"CreateOrderResp\" $ \\v -> do\n    status <- v .: \"status\"\n    order_id <- v .: \"order_id\"\n    id <- v .: \"id\"\n    payment_links <- v .: \"payment_links\"\n    sdk_payload <- v .: \"sdk_payload\"\n    sdk_payload_json <- v .: \"sdk_payload\"\n    return (CreateOrderResp status id order_id payment_links sdk_payload sdk_payload_json)\n\ndata PaymentLinks = PaymentLinks\n  { web :: Maybe BaseUrl,\n    iframe :: Maybe BaseUrl,\n    mobile :: Maybe BaseUrl,\n    deep_link :: Maybe Text\n  }\n  deriving stock (Show, Eq, Generic)\n  deriving anyclass (FromJSON, ToJSON, ToSchema)\n\ndata SDKPayload = SDKPayload\n  { requestId :: Maybe Text,\n    service :: Maybe Text,\n    payload :: SDKPayloadDetails\n  }\n  deriving stock (Show, Generic)\n  deriving anyclass (FromJSON, ToJSON, ToSchema)\n\ndata SDKPayloadDetails = SDKPayloadDetails\n  { clientId :: Maybe Text,\n    amount :: Text,\n    merchantId :: Maybe Text,\n    clientAuthToken :: Text,\n    clientAuthTokenExpiry :: UTCTime,\n    environment :: Maybe Text,\n    options_getUpiDeepLinks :: Maybe Bool,\n    lastName :: Maybe Text,\n    action :: Maybe Text,\n    customerId :: Maybe Text,\n    returnUrl :: Maybe Text,\n    currency :: Currency,\n    firstName :: Maybe Text,\n    customerPhone :: Maybe Text,\n    customerEmail :: Maybe Text,\n    orderId :: Maybe Text,\n    description :: Maybe Text,\n    createMandate :: Maybe MandateType,\n    mandateMaxAmount :: Maybe Text,\n    mandateStartDate :: Maybe Text,\n    mandateEndDate :: Maybe Text\n  }\n  deriving stock (Show, Generic)\n  deriving anyclass (ToSchema)\n\njsonOptions :: Options\njsonOptions =\n  defaultOptions\n    { fieldLabelModifier = \\case\n        \"createMandate\" -> \"options.createMandate\"\n        \"mandateMaxAmount\" -> \"mandate.maxAmount\"\n        \"mandateStartDate\" -> \"mandate.startDate\"\n        \"mandateEndDate\" -> \"mandate.endDate\"\n        \"options_getUpiDeepLinks\" -> \"options.getUpiDeepLinks\"\n        other -> other\n    }\n\ninstance FromJSON SDKPayloadDetails where\n  parseJSON = genericParseJSON jsonOptions\n\ninstance ToJSON SDKPayloadDetails where\n  toJSON = genericToJSON jsonOptions\n\ndata AutoRefundReq = AutoRefundReq\n  { amount :: Double,\n    unique_request_id :: Text\n  }\n  deriving stock (Show, Generic, Read, Eq)\n  deriving anyclass (FromJSON, ToJSON, ToSchema)\n\ndata AutoRefundResp = AutoRefundResp\n  { order_id :: Text,\n    merchant_id :: Text,\n    customer_id :: Text,\n    currency :: Currency,\n    amount_refunded :: Double,\n    refunds :: Maybe [RefundsData]\n  }\n  deriving stock (Show, Generic, Read, Eq)\n  deriving anyclass (FromJSON, ToJSON, ToSchema)\n",
      "hash": "c283e54832e312d817233737426614a5ba1ea93f16898045db2e58c909217e12",
      "size": 6961
    },
    "/lib/mobility-core/src/Kernel/External/Payment/Juspay/Types/Mandate.hs": {
      "type": "content",
      "content": "{-# LANGUAGE DerivingStrategies #-}\n{-# LANGUAGE OverloadedLists #-}\n\nmodule Kernel.External.Payment.Juspay.Types.Mandate where\n\nimport Kernel.External.Payment.Juspay.Types.Common (NotificationStatus, TransactionStatus)\nimport Kernel.External.Payment.Juspay.Types.CreateOrder (SplitSettlementDetails)\nimport Kernel.Prelude\nimport Servant (ToHttpApiData (..))\nimport Web.FormUrlEncoded\n\n--- For Mandate Notifications ---\ndata MandateNotificationReq = MandateNotificationReq\n  { command :: Text,\n    object_reference_id :: Text,\n    source_info :: SourceInfo,\n    description :: Text\n  }\n  deriving (Eq, Show, Generic)\n\ndata MandateNotificationRes = MandateNotificationRes\n  { id :: Text,\n    source_info :: SourceInfo,\n    object_reference_id :: Text,\n    provider_name :: Maybe Text,\n    notification_type :: Maybe Text,\n    description :: Text,\n    status :: NotificationStatus,\n    date_created :: Text,\n    last_updated :: Text\n  }\n  deriving (Eq, Show, Generic, ToJSON, FromJSON, ToSchema)\n\ndata SourceInfo = SourceInfo\n  { amount :: Text,\n    txn_date :: Text\n  }\n  deriving (Eq, Show, Generic, ToJSON, FromJSON, ToSchema)\n\ninstance ToForm MandateNotificationReq where\n  toForm MandateNotificationReq {..} =\n    [ (\"command\", toQueryParam command),\n      (\"object_reference_id\", toQueryParam object_reference_id),\n      (\"source_info\", toQueryParam (\"{\\\"amount\\\" : \\\"\" <> source_info.amount <> \"\\\",\" <> \" \\\"txn_date\\\" : \\\"\" <> source_info.txn_date <> \"\\\"}\")),\n      (\"description\", toQueryParam description)\n    ]\n\n---- Notification status response ------\n\ndata NotificationStatusResp = NotificationStatusResp\n  { id :: Text,\n    source_object :: Maybe Text,\n    source_object_id :: Maybe Text, -- mandate Id in this case --\n    object_reference_id :: Text,\n    provider_name :: Maybe Text,\n    notification_type :: Maybe Text,\n    source_info :: SourceInfo,\n    provider_response :: Maybe ProviderResponse,\n    description :: Text,\n    status :: NotificationStatus,\n    date_created :: Text,\n    last_updated :: Text\n  }\n  deriving (Eq, Show, Generic, ToJSON, FromJSON, ToSchema)\n\ndata ProviderResponse = ProviderResponse\n  { provider_ref_id :: Maybe Text,\n    notification_date :: Maybe Text,\n    provider_response_code :: Maybe Text,\n    provider_response_message :: Maybe Text\n  }\n  deriving (Eq, Show, Generic, ToJSON, FromJSON, ToSchema)\n\n--- For Mandate Execution ---\ndata MandateOrder = MandateOrder\n  { orderId :: Text,\n    orderAmount :: Text,\n    orderCustomerId :: Text,\n    splitSettlementDetails :: Maybe SplitSettlementDetails\n  }\n\ndata MandateInfo = MandateInfo\n  { notificationId :: Text,\n    executionDate :: Text\n  }\n\ndata MandateExecutionReq = MandateExecutionReq\n  { order :: MandateOrder,\n    merchantId :: Text,\n    mandateId :: Text,\n    mandate :: MandateInfo,\n    format :: Text\n  }\n\ninstance ToForm MandateExecutionReq where\n  toForm MandateExecutionReq {..} =\n    toForm (params ++ maybe [] splitSettleParam (splitSettlementDetails order))\n    where\n      params :: [(Text, Text)]\n      params =\n        [ (\"order.order_id\", toQueryParam (orderId order)),\n          (\"order.amount\", toQueryParam (orderAmount order)),\n          (\"order.customer_id\", toQueryParam (orderCustomerId order)),\n          (\"mandate_id\", toQueryParam mandateId),\n          (\"mandate.notification_id\", toQueryParam (notificationId mandate)),\n          (\"mandate.execution_date\", toQueryParam (executionDate mandate)),\n          (\"merchant_id\", toQueryParam merchantId),\n          (\"format\", toQueryParam format)\n        ]\n\n      splitSettleParam :: SplitSettlementDetails -> [(Text, Text)]\n      splitSettleParam details =\n        [(\"order.metadata.split_settlement_details\", toQueryParam details)]\n\ndata MandateExecutionRes = MandateExecutionRes\n  { order_id :: Text,\n    txn_id :: Text,\n    txn_uuid :: Text,\n    status :: TransactionStatus\n  }\n  deriving (Eq, Show, Generic, ToJSON, FromJSON, ToSchema)\n\n--- For Mandate Revoke --\nnewtype MandateRevokeReq = MandateRevokeReq\n  { command :: Text\n  }\n  deriving (Eq, Show, Generic, ToForm)\n\ndata MandateRevokeRes = MandateRevokeRes\n  { mandate_id :: Text,\n    mandate_status :: Text\n  }\n  deriving (Eq, Show, Generic, ToJSON, FromJSON, ToSchema)\n\n--- For Mandate Pause ---\n\ndata MandatePauseReq = MandatePauseReq\n  { command :: Text,\n    pause_start_date :: Text,\n    pause_end_date :: Text\n  }\n  deriving (Eq, Show, Generic, ToJSON, FromJSON, ToSchema, ToForm)\n\n--- For Mandate Resume ---\n\ndata MandateResumeReq = MandateResumeReq\n  { command :: Text,\n    resume_date :: Text\n  }\n  deriving (Eq, Show, Generic, ToJSON, FromJSON, ToSchema, ToForm)\n",
      "hash": "a32fa8a8542ad724d23b9d6fb1a34a6adc5a37df2bfef86c617eb3b090f85ab9",
      "size": 4606
    },
    "/lib/mobility-core/src/Kernel/External/Payment/Juspay/Types/Offer.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n{-# LANGUAGE DerivingStrategies #-}\n\nmodule Kernel.External.Payment.Juspay.Types.Offer where\n\nimport Data.Aeson\nimport Kernel.External.Payment.Juspay.Types.Common\nimport Kernel.Prelude\nimport Kernel.Types.Common\nimport Kernel.Utils.JSON (stripPrefixUnderscoreIfAny)\n\n-- offer list request --\n\ndata OfferListReq = OfferListReq\n  { order :: OfferOrder,\n    payment_method_info :: [OfferPaymentMethodInfo],\n    customer :: Maybe OfferCustomer,\n    offer_code :: Maybe Text\n  }\n  deriving stock (Show, Generic)\n  deriving anyclass (FromJSON, ToJSON)\n\ndata OfferOrder = OfferOrder\n  { order_id :: Maybe Text,\n    amount :: Text,\n    currency :: Currency,\n    udf1 :: Text,\n    udf2 :: Text,\n    --- need to be added after offers are configured accordingly on dashboard ----\n    udf3 :: Text,\n    udf4 :: Text,\n    udf5 :: Text,\n    udf6 :: Maybe Text\n  }\n  deriving stock (Show, Generic)\n  deriving anyclass (FromJSON, ToJSON)\n\ndata OfferPaymentMethodInfo = OfferPaymentMethodInfo\n  { payment_method_type :: PaymentMethodType,\n    payment_method_reference :: Maybe Text,\n    payment_method :: Maybe Text,\n    card_number :: Maybe Text,\n    card_token :: Maybe Text,\n    txn_type :: Maybe TxnType,\n    upi_app :: Maybe Text,\n    upi_vpa :: Maybe Text\n  }\n  deriving stock (Show, Generic)\n  deriving anyclass (FromJSON, ToJSON)\n\ndata PaymentMethodType = CARD | NB | UPI | WALLET | REWARD\n  deriving stock (Show, Generic)\n  deriving anyclass (FromJSON, ToJSON)\n\ndata TxnType = UPI_PAY | UPI_COLLECT\n  deriving stock (Show, Generic)\n  deriving anyclass (FromJSON, ToJSON)\n\ndata OfferCustomer = OfferCustomer\n  { id :: Text,\n    email :: Maybe Text,\n    mobile :: Maybe Text\n  }\n  deriving stock (Show, Generic)\n  deriving anyclass (FromJSON, ToJSON)\n\n-- offer list response --\n\ndata OfferListResp = OfferListResp\n  { best_offer_combinations :: [BestOfferCombination],\n    offers :: [OfferResp]\n  }\n  deriving stock (Show, Generic)\n  deriving anyclass (FromJSON, ToJSON)\n\ndata BestOfferCombination = BestOfferCombination\n  { payment_method_reference :: Maybe Text,\n    offers :: [BestOfferCombinationOffer],\n    order_breakup :: OrderBreakup\n  }\n  deriving stock (Show, Generic)\n  deriving anyclass (FromJSON, ToJSON)\n\ndata BestOfferCombinationOffer = BestOfferCombinationOffer\n  { offer_id :: Text,\n    cashback_amount :: Text,\n    discount_amount :: Text,\n    merchant_discount_amount :: Text,\n    total_offered_amount :: Text\n  }\n  deriving stock (Show, Generic)\n  deriving anyclass (FromJSON, ToJSON)\n\ndata OrderBreakup = OrderBreakup\n  { order_amount :: Text,\n    final_order_amount :: Text,\n    discount_amount :: Text,\n    merchant_discount_amount :: Text,\n    cashback_amount :: Text,\n    offer_amount :: Text,\n    benefits :: [BestOfferCombinationBenefit]\n  }\n  deriving stock (Show, Generic)\n  deriving anyclass (FromJSON, ToJSON)\n\ndata BestOfferCombinationBenefit = BestOfferCombinationBenefit\n  { _type :: Text,\n    calculation_rule :: Text,\n    value :: HighPrecMoney\n  }\n  deriving stock (Show, Generic)\n\ninstance FromJSON BestOfferCombinationBenefit where\n  parseJSON = genericParseJSON stripPrefixUnderscoreIfAny\n\ninstance ToJSON BestOfferCombinationBenefit where\n  toJSON = genericToJSON stripPrefixUnderscoreIfAny\n\ndata OfferResp = OfferResp\n  { offer_id :: Text,\n    status :: OfferListStatus,\n    offer_code :: Text,\n    offer_description :: OfferDescription,\n    offer_rules :: OfferRules,\n    order_breakup :: OrderBreakup\n  }\n  deriving stock (Show, Generic)\n  deriving anyclass (FromJSON, ToJSON)\n\ndata OfferDescription = OfferDescription\n  { sponsored_by :: Maybe Text,\n    title :: Maybe Text,\n    description :: Maybe Text,\n    tnc :: Maybe Text\n  }\n  deriving stock (Show, Generic)\n  deriving anyclass (FromJSON, ToJSON)\n\ndata OfferRules = OfferRules\n  { amount :: OfferRulesAmount,\n    payment_instrument :: [OfferRulesPaymentInstrument]\n  }\n  deriving stock (Show, Generic)\n  deriving anyclass (FromJSON, ToJSON)\n\ndata OfferRulesAmount = OfferRulesAmount\n  { currency :: Currency,\n    min_order_amount :: Text\n  }\n  deriving stock (Show, Generic)\n  deriving anyclass (FromJSON, ToJSON)\n\ndata OfferRulesPaymentInstrument = OfferRulesPaymentInstrument\n  { payment_method :: [Text],\n    payment_method_type :: PaymentMethodType\n  }\n  deriving stock (Show, Generic)\n  deriving anyclass (FromJSON, ToJSON)\n\n-- offer apply request --\n\ndata OfferApplyReq = OfferApplyReq\n  { txn_id :: Text,\n    customer :: OfferApplyCustomer,\n    offers :: [Text],\n    order :: OfferApplyOrder,\n    payment_method_info :: Maybe OfferApplyPaymentMethodInfo\n  }\n  deriving stock (Show, Generic)\n  deriving anyclass (FromJSON, ToJSON)\n\ndata OfferApplyOrder = OfferApplyOrder\n  { amount :: Text,\n    currency :: Currency,\n    merchant_id :: Maybe Text,\n    order_type :: Maybe Text,\n    udf1 :: Text,\n    udf2 :: Text,\n    udf3 :: Text,\n    udf4 :: Text,\n    udf5 :: Text,\n    payment_channel :: Maybe Text\n  }\n  deriving stock (Show, Generic)\n  deriving anyclass (FromJSON, ToJSON)\n\ndata OfferApplyPaymentMethodInfo = OfferApplyPaymentMethodInfo\n  { payment_method_type :: PaymentMethodType,\n    payment_method_reference :: Maybe Text,\n    payment_method :: Maybe Text,\n    card_type :: Maybe Text,\n    card_sub_type :: Maybe Text,\n    bank_code :: Maybe Text,\n    card_bin :: Maybe Text\n  }\n  deriving stock (Show, Generic)\n  deriving anyclass (FromJSON, ToJSON)\n\nnewtype OfferApplyCustomer = OfferApplyCustomer\n  { id :: Text\n  }\n  deriving stock (Show, Generic)\n  deriving anyclass (FromJSON, ToJSON)\n\n-- offer apply response (other fields omitted) --\n\nnewtype OfferApplyResp = OfferApplyResp\n  { offers :: [OfferApplyOffer]\n  }\n  deriving stock (Show, Generic)\n  deriving anyclass (FromJSON, ToJSON)\n\ndata OfferApplyOffer = OfferApplyOffer\n  { offer_id :: Text,\n    order_breakup :: OfferApplyOrderBreakup\n  }\n  deriving stock (Show, Generic)\n  deriving anyclass (FromJSON, ToJSON)\n\nnewtype OfferApplyOrderBreakup = OfferApplyOrderBreakup\n  { final_order_amount :: Text\n  }\n  deriving stock (Show, Generic)\n  deriving anyclass (FromJSON, ToJSON)\n\n-- offer notify request --\n\ndata OfferNotifyReq = OfferNotifyReq\n  { order_id :: Text,\n    txn_id :: Text,\n    merchant_id :: Text,\n    txn_status :: TransactionStatus,\n    offers :: [OfferNotifyOffer]\n  }\n  deriving stock (Show, Generic)\n  deriving anyclass (FromJSON, ToJSON)\n\ndata OfferNotifyOffer = OfferNotifyOffer\n  { offer_id :: Text,\n    status :: OfferStatus\n  }\n  deriving stock (Show, Generic)\n  deriving anyclass (FromJSON, ToJSON)\n\ndata OfferStatus = INITIATED | AVAILED | REFUNDED | FAILED\n  deriving stock (Show, Eq, Generic)\n  deriving anyclass (FromJSON, ToJSON)\n\ndata OfferListStatus = ELIGIBLE | INELIGIBLE\n  deriving stock (Show, Eq, Generic)\n  deriving anyclass (FromJSON, ToJSON)\n\n-- offer notify response --\n\ndata OfferNotifyResp = OfferNotifyResp\n  { code :: Text,\n    status :: Text,\n    response :: Text\n  }\n  deriving stock (Show, Generic)\n  deriving anyclass (FromJSON, ToJSON)\n",
      "hash": "230b79be67387a45a442cffc381dd643309245cce7c9a69942e8dcbf41e66a3e",
      "size": 7644
    },
    "/lib/mobility-core/src/Kernel/External/Payment/Juspay/Types/UpdateOrder.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n{-# LANGUAGE DerivingStrategies #-}\n\nmodule Kernel.External.Payment.Juspay.Types.UpdateOrder where\n\nimport Data.Aeson\nimport Kernel.External.Payment.Juspay.Types.CreateOrder (SplitSettlementDetails)\nimport Kernel.Prelude\nimport Kernel.Utils.Common\nimport Web.FormUrlEncoded\n\ndata OrderUpdateReq = OrderUpdateReq\n  { amount :: HighPrecMoney,\n    split_settlement_details :: Maybe SplitSettlementDetails\n  }\n  deriving (Show, Generic)\n  deriving anyclass (ToForm)\n\ndata OrderUpdateResp = OrderUpdateResp\n  { order_id :: Maybe Text,\n    amount :: Maybe HighPrecMoney\n  }\n  deriving (Show, Generic)\n  deriving anyclass (ToSchema, FromJSON, ToJSON)\n\njsonReqOptionsUpdateOrder :: Options\njsonReqOptionsUpdateOrder =\n  defaultOptions\n    { fieldLabelModifier = \\case\n        \"split_settlement_details\" -> \"metadata.split_settlement_details\"\n        other -> other\n    }\n\ninstance FromJSON OrderUpdateReq where\n  parseJSON = genericParseJSON jsonReqOptionsUpdateOrder {omitNothingFields = True}\n\ninstance ToJSON OrderUpdateReq where\n  toJSON = genericToJSON jsonReqOptionsUpdateOrder {omitNothingFields = True}\n",
      "hash": "495388ff6b5c86d2d8a2324ea9d0dafa051cd74ada0b91c007dbf9ec2124f72c",
      "size": 1796
    },
    "/lib/mobility-core/src/Kernel/External/Payment/Juspay/Types/Webhook.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n{-# LANGUAGE DerivingVia #-}\n{-# LANGUAGE ScopedTypeVariables #-}\n\nmodule Kernel.External.Payment.Juspay.Types.Webhook where\n\nimport Data.Aeson\nimport Kernel.External.Payment.Juspay.Types.Common\nimport Kernel.External.Payment.Juspay.Types.Mandate (ProviderResponse, SourceInfo)\nimport Kernel.Prelude\nimport Kernel.Utils.Common\n\ndata WebhookReq = WebhookReq\n  { id :: Text,\n    date_created :: UTCTime,\n    event_name :: PaymentStatus,\n    content :: OrderAndNotificationStatusContent\n  }\n  deriving stock (Show, Generic)\n  deriving anyclass (FromJSON, ToJSON, ToSchema)\n\ntype WebhookOrderData = OrderData\n\ndata OrderAndNotificationStatusContent = OrderAndNotificationStatusContent\n  { order :: Maybe WebhookOrderData,\n    mandate :: Maybe WebhookMandateData,\n    notification :: Maybe WebhookNotificationData,\n    txn :: Maybe WebhookTxnData\n  }\n  deriving stock (Show, Generic)\n  deriving anyclass (FromJSON, ToJSON, ToSchema)\n\ndata WebhookMandateData = WebhookMandateData\n  { status :: MandateStatus,\n    start_date :: Text,\n    end_date :: Text,\n    mandate_id :: Text,\n    frequency :: MandateFrequency,\n    max_amount :: HighPrecMoney,\n    order_id :: Text,\n    payment_info :: Maybe PaymentInfo\n  }\n  deriving stock (Show, Generic)\n  deriving anyclass (FromJSON, ToJSON, ToSchema)\n\ndata WebhookNotificationData = WebhookNotificationData\n  { status :: NotificationStatus,\n    source_object :: Maybe Text,\n    source_info :: Maybe SourceInfo,\n    notification_type :: Maybe Text,\n    object_reference_id :: Text,\n    response_code :: Maybe Text,\n    response_message :: Maybe Text,\n    provider_response :: Maybe ProviderResponse,\n    id :: Text\n  }\n  deriving stock (Show, Generic)\n  deriving anyclass (FromJSON, ToJSON, ToSchema)\n\nnewtype PaymentInfo = PaymentInfo {upi :: Maybe Upi}\n  deriving stock (Show, Generic)\n  deriving anyclass (FromJSON, ToJSON, ToSchema)\n\ndata WebhookTxnData = WebhookTxnData\n  { txn_id :: Text,\n    txn_uuid :: Maybe Text,\n    status :: TransactionStatus,\n    order_id :: Text,\n    error_code :: Maybe Text,\n    error_message :: Maybe Text,\n    txn_amount :: Double,\n    status_id :: Maybe Int,\n    currency :: Currency,\n    metadata :: Maybe MetaData,\n    additional_info :: Maybe AdditionalInfo,\n    links :: Maybe LinkData,\n    payer_vpa :: Maybe Text,\n    upi :: Maybe Upi,\n    card :: Maybe CardInfo\n  }\n  deriving stock (Show, Generic)\n  deriving anyclass (FromJSON, ToJSON, ToSchema)\n",
      "hash": "80851c0cd12bba0a853ce3111eeb772ad88fe8db653fb20306843301e3c0d7ec",
      "size": 3119
    },
    "/lib/mobility-core/src/Kernel/External/Payment/Juspay/Webhook.hs": {
      "type": "content",
      "content": "{-\n Copyright 2022-23, Juspay India Pvt Ltd\n\n This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program\n\n is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n\n or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of\n\n the GNU Affero General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n\nmodule Kernel.External.Payment.Juspay.Webhook where\n\nimport Data.Aeson.Types as DAT\nimport qualified Data.Text.Encoding as DT\nimport EulerHS.Prelude\nimport Kernel.External.Encryption\nimport Kernel.External.Payment.Interface.Types\nimport qualified Kernel.External.Payment.Juspay.Types as Juspay\nimport Kernel.Types.Error\nimport Kernel.Utils.Common\nimport Servant hiding (throwError)\n\ntype JuspayWebhookAPI =\n  \"service\" :> \"juspay\" :> \"payment\"\n    :> BasicAuth \"username-password\" BasicAuthData\n    :> ReqBody '[JSON] Value\n    :> Post '[JSON] AckResponse\n\norderStatusWebhook ::\n  EncFlow m r =>\n  PaymentServiceConfig ->\n  (Juspay.WebhookReq -> Text -> m AckResponse) ->\n  BasicAuthData ->\n  Value ->\n  m (Maybe (Juspay.PaymentStatus, Juspay.OrderAndNotificationStatusContent))\norderStatusWebhook paymentConfig orderStatusHandler authData val = do\n  withLogTag \"webhookPaymentOrderStatus\" $ do\n    let respDump = encodeToText val\n    let mResp = fromJSON val\n    case mResp of\n      DAT.Success (resp :: Juspay.WebhookReq) -> do\n        void $ verifyAuth paymentConfig authData\n        void $ orderStatusHandler resp respDump\n        pure (Just (resp.event_name, resp.content))\n      DAT.Error err -> do\n        logInfo $ \"OrderStatus Parsing failed :: \" <> show err\n        pure Nothing\n\nverifyAuth ::\n  EncFlow m r =>\n  PaymentServiceConfig ->\n  BasicAuthData ->\n  m ()\nverifyAuth config authData = do\n  (username, password) <- case config of\n    JuspayConfig cfg -> do\n      cfgPassword <- decrypt cfg.password\n      return (cfg.username, cfgPassword)\n    StripeConfig _ -> return (\"\", \"\")\n  unless (basicAuthUsername authData == DT.encodeUtf8 username && basicAuthPassword authData == DT.encodeUtf8 password) $\n    throwError (InvalidRequest \"INVALID_AUTHORIZATION_HEADER\")\n",
      "hash": "2962f645eb54497b3905674e057940067f013548e8b9a0880978907440c556a6",
      "size": 2467
    },
    "/lib/mobility-core/src/Kernel/External/Payment/Stripe/Config.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n{-# LANGUAGE DerivingStrategies #-}\n\nmodule Kernel.External.Payment.Stripe.Config where\n\nimport Data.Aeson\nimport Kernel.External.Encryption\nimport Kernel.External.Payment.Stripe.Types.Accounts\nimport Kernel.Prelude\n\ndata StripeCfg = StripeCfg\n  { apiKey :: EncryptedField 'AsEncrypted Text,\n    returnUrl :: BaseUrl,\n    refreshUrl :: BaseUrl,\n    url :: BaseUrl,\n    businessProfile :: Maybe BusinessProfile\n  }\n  deriving stock (Show, Eq, Generic)\n  deriving anyclass (FromJSON, ToJSON)\n",
      "hash": "0583bb10f53046e152aeb195fe42ab913b1665665c5dbfd21165a51eda53fa70",
      "size": 1183
    },
    "/lib/mobility-core/src/Kernel/External/Payment/Stripe/Flow.hs": {
      "type": "content",
      "content": "module Kernel.External.Payment.Stripe.Flow where\n\nimport qualified Data.Text.Encoding as DT\nimport EulerHS.Types as Euler\nimport Kernel.External.Payment.Stripe.Types\nimport Kernel.Prelude\nimport Kernel.Tools.Metrics.CoreMetrics as Metrics\nimport Kernel.Types.Common\nimport Kernel.Utils.Common (CallAPI, callApiUnwrappingApiError)\nimport Servant hiding (throwError)\n\ncallStripeAPI :: CallAPI m api res\ncallStripeAPI url eulerClient description proxy = do\n  callApiUnwrappingApiError (identity @StripeError) Nothing Nothing Nothing url eulerClient description proxy\n\nmkBasicAuthData :: Text -> BasicAuthData\nmkBasicAuthData apiKey =\n  BasicAuthData\n    { basicAuthUsername = DT.encodeUtf8 apiKey,\n      basicAuthPassword = \"\"\n    }\n\n-- https://docs.stripe.com/api/accounts/create\n\n-------------------------------------------- Connect Account APIs --------------------------------------------\ntype CreateAccountAPI =\n  \"v1\"\n    :> \"accounts\"\n    :> BasicAuth \"secretkey-password\" BasicAuthData\n    :> ReqBody '[FormUrlEncoded] AccountsReq\n    :> Post '[JSON] AccountResp\n\ncreateAccount ::\n  ( Metrics.CoreMetrics m,\n    MonadFlow m\n  ) =>\n  BaseUrl ->\n  Text ->\n  AccountsReq ->\n  m AccountResp\ncreateAccount url apiKey req = do\n  let proxy = Proxy @CreateAccountAPI\n      eulerClient = Euler.client proxy (mkBasicAuthData apiKey) req\n  callStripeAPI url eulerClient \"create-account\" proxy\n\ntype CreateAccountLinkAPI =\n  \"v1\"\n    :> \"account_links\"\n    :> BasicAuth \"secretkey-password\" BasicAuthData\n    :> ReqBody '[FormUrlEncoded] AccountLinkReq\n    :> Post '[JSON] AccountLinkObject\n\ncreateAccountLink ::\n  ( Metrics.CoreMetrics m,\n    MonadFlow m\n  ) =>\n  BaseUrl ->\n  Text ->\n  AccountLinkReq ->\n  m AccountLinkObject\ncreateAccountLink url apiKey req = do\n  let proxy = Proxy @CreateAccountLinkAPI\n      eulerClient = Euler.client proxy (mkBasicAuthData apiKey) req\n  callStripeAPI url eulerClient \"create-account-link\" proxy\n\ntype GetAccountAPI =\n  \"v1\"\n    :> \"accounts\"\n    :> BasicAuth \"secretkey-password\" BasicAuthData\n    :> Capture \"id\" AccountId\n    :> Get '[JSON] AccountResp\n\ngetAccount ::\n  ( Metrics.CoreMetrics m,\n    MonadFlow m\n  ) =>\n  BaseUrl ->\n  Text ->\n  AccountId ->\n  m AccountResp\ngetAccount url apiKey accountId = do\n  let proxy = Proxy @GetAccountAPI\n      eulerClient = Euler.client proxy (mkBasicAuthData apiKey) accountId\n  callStripeAPI url eulerClient \"get-account\" proxy\n\n-------------------------------------------- Customer APIs --------------------------------------------\ntype CreateCustomerAPI =\n  \"v1\"\n    :> \"customers\"\n    :> BasicAuth \"secretkey-password\" BasicAuthData\n    :> ReqBody '[FormUrlEncoded] CustomerReq\n    :> Post '[JSON] CustomerObject\n\ncreateCustomer ::\n  ( Metrics.CoreMetrics m,\n    MonadFlow m\n  ) =>\n  BaseUrl ->\n  Text ->\n  CustomerReq ->\n  m CustomerObject\ncreateCustomer url apiKey customerReq = do\n  let proxy = Proxy @CreateCustomerAPI\n      eulerClient = Euler.client proxy (mkBasicAuthData apiKey) customerReq\n  callStripeAPI url eulerClient \"create-customer\" proxy\n\ntype UpdateCustomerAPI =\n  \"v1\"\n    :> \"customers\"\n    :> Capture \"id\" CustomerId\n    :> BasicAuth \"secretkey-password\" BasicAuthData\n    :> ReqBody '[FormUrlEncoded] UpdateCustomerReq\n    :> Post '[JSON] CustomerObject\n\nupdateCustomer ::\n  ( Metrics.CoreMetrics m,\n    MonadFlow m\n  ) =>\n  BaseUrl ->\n  Text ->\n  CustomerId ->\n  UpdateCustomerReq ->\n  m CustomerObject\nupdateCustomer url apiKey customerId customerReq = do\n  let proxy = Proxy @UpdateCustomerAPI\n      eulerClient = Euler.client proxy customerId (mkBasicAuthData apiKey) customerReq\n  callStripeAPI url eulerClient \"update-customer\" proxy\n\ntype GetCustomerAPI =\n  \"v1\"\n    :> \"customers\"\n    :> Capture \"id\" CustomerId\n    :> BasicAuth \"secretkey-password\" BasicAuthData\n    :> Get '[JSON] CustomerObject\n\ngetCustomer ::\n  ( Metrics.CoreMetrics m,\n    MonadFlow m\n  ) =>\n  BaseUrl ->\n  Text ->\n  CustomerId ->\n  m CustomerObject\ngetCustomer url apiKey customerId = do\n  let proxy = Proxy @GetCustomerAPI\n      eulerClient = Euler.client proxy customerId (mkBasicAuthData apiKey)\n  callStripeAPI url eulerClient \"get-customer\" proxy\n\n-------------------------------------------- Payment Intent APIs --------------------------------------------\ntype CreatePaymentIntentAPI =\n  \"v1\"\n    :> \"payment_intents\"\n    :> BasicAuth \"secretkey-password\" BasicAuthData\n    :> ReqBody '[FormUrlEncoded] PaymentIntentReq\n    :> Post '[JSON] PaymentIntentObject\n\ncreatePaymentIntent ::\n  ( Metrics.CoreMetrics m,\n    MonadFlow m\n  ) =>\n  BaseUrl ->\n  Text ->\n  PaymentIntentReq ->\n  m PaymentIntentObject\ncreatePaymentIntent url apiKey paymentIntentReq = do\n  let proxy = Proxy @CreatePaymentIntentAPI\n      eulerClient = Euler.client proxy (mkBasicAuthData apiKey) paymentIntentReq\n  callStripeAPI url eulerClient \"create-payment-intent\" proxy\n\ntype CancelPaymentIntentAPI =\n  \"v1\"\n    :> \"payment_intents\"\n    :> BasicAuth \"secretkey-password\" BasicAuthData\n    :> Capture \"id\" PaymentIntentId\n    :> \"cancel\"\n    :> Post '[JSON] PaymentIntentObject\n\ncancelPaymentIntent ::\n  ( Metrics.CoreMetrics m,\n    MonadFlow m\n  ) =>\n  BaseUrl ->\n  Text ->\n  PaymentIntentId ->\n  m PaymentIntentObject\ncancelPaymentIntent url apiKey paymentIntentId = do\n  let proxy = Proxy @CancelPaymentIntentAPI\n      eulerClient = Euler.client proxy (mkBasicAuthData apiKey) paymentIntentId\n  callStripeAPI url eulerClient \"cancel-payment-intent\" proxy\n\ntype GetPaymentIntentAPI =\n  \"v1\"\n    :> \"payment_intents\"\n    :> Capture \"id\" PaymentIntentId\n    :> BasicAuth \"secretkey-password\" BasicAuthData\n    :> Get '[JSON] PaymentIntentObject\n\ngetPaymentIntent ::\n  ( Metrics.CoreMetrics m,\n    MonadFlow m\n  ) =>\n  BaseUrl ->\n  Text ->\n  PaymentIntentId ->\n  m PaymentIntentObject\ngetPaymentIntent url apiKey paymentIntentId = do\n  let proxy = Proxy @GetPaymentIntentAPI\n      eulerClient = Euler.client proxy paymentIntentId (mkBasicAuthData apiKey)\n  callStripeAPI url eulerClient \"get-payment-intent\" proxy\n\ntype ConfirmPaymentIntentAPI =\n  \"v1\"\n    :> \"payment_intents\"\n    :> Capture \"id\" PaymentIntentId\n    :> \"confirm\"\n    :> BasicAuth \"secretkey-password\" BasicAuthData\n    :> ReqBody '[FormUrlEncoded] ConfirmPaymentIntentReq\n    :> Post '[JSON] PaymentIntentObject\n\nconfirmPaymentIntent ::\n  ( Metrics.CoreMetrics m,\n    MonadFlow m\n  ) =>\n  BaseUrl ->\n  Text ->\n  PaymentIntentId ->\n  ConfirmPaymentIntentReq ->\n  m PaymentIntentObject\nconfirmPaymentIntent url apiKey paymentIntentId confirmPaymentIntentReq = do\n  let proxy = Proxy @ConfirmPaymentIntentAPI\n      eulerClient = Euler.client proxy paymentIntentId (mkBasicAuthData apiKey) confirmPaymentIntentReq\n  callStripeAPI url eulerClient \"confirm-payment-intent\" proxy\n\ntype CapturePaymentIntentAPI =\n  \"v1\"\n    :> \"payment_intents\"\n    :> Capture \"id\" PaymentIntentId\n    :> \"capture\"\n    :> BasicAuth \"secretkey-password\" BasicAuthData\n    :> ReqBody '[FormUrlEncoded] CapturePaymentIntentReq\n    :> Post '[JSON] PaymentIntentObject\n\ncapturePaymentIntent ::\n  ( Metrics.CoreMetrics m,\n    MonadFlow m\n  ) =>\n  BaseUrl ->\n  Text ->\n  PaymentIntentId ->\n  CapturePaymentIntentReq ->\n  m PaymentIntentObject\ncapturePaymentIntent url apiKey paymentIntentId capturePaymentIntentReq = do\n  let proxy = Proxy @CapturePaymentIntentAPI\n      eulerClient = Euler.client proxy paymentIntentId (mkBasicAuthData apiKey) capturePaymentIntentReq\n  callStripeAPI url eulerClient \"capture-payment-intent\" proxy\n\ntype IncrementAuthorizationPaymentIntentAPI =\n  \"v1\"\n    :> \"payment_intents\"\n    :> Capture \"id\" PaymentIntentId\n    :> \"increment_authorization\"\n    :> BasicAuth \"secretkey-password\" BasicAuthData\n    :> ReqBody '[FormUrlEncoded] IncrementAuthorizationReq\n    :> Post '[JSON] PaymentIntentObject\n\nincrementAuthorizationPaymentIntent ::\n  ( Metrics.CoreMetrics m,\n    MonadFlow m\n  ) =>\n  BaseUrl ->\n  Text ->\n  PaymentIntentId ->\n  IncrementAuthorizationReq ->\n  m PaymentIntentObject\nincrementAuthorizationPaymentIntent url apiKey paymentIntentId incrementAuthorizationReq = do\n  let proxy = Proxy @IncrementAuthorizationPaymentIntentAPI\n      eulerClient = Euler.client proxy paymentIntentId (mkBasicAuthData apiKey) incrementAuthorizationReq\n  callStripeAPI url eulerClient \"increment-authorization-payment-intent\" proxy\n\n-------------------------------------------- Setup Intent APIs --------------------------------------------\ntype CreateSetupIntentAPI =\n  \"v1\"\n    :> \"setup_intents\"\n    :> BasicAuth \"secretkey-password\" BasicAuthData\n    :> ReqBody '[FormUrlEncoded] SetupIntentReq\n    :> Post '[JSON] SetupIntentObject\n\ncreateSetupIntent ::\n  ( Metrics.CoreMetrics m,\n    MonadFlow m\n  ) =>\n  BaseUrl ->\n  Text ->\n  SetupIntentReq ->\n  m SetupIntentObject\ncreateSetupIntent url apiKey setupIntentReq = do\n  let proxy = Proxy @CreateSetupIntentAPI\n      eulerClient = Euler.client proxy (mkBasicAuthData apiKey) setupIntentReq\n  callStripeAPI url eulerClient \"create-setup-intent\" proxy\n\n-------------------------------------------- Card APIs --------------------------------------------\ntype CreateCardAPI =\n  \"v1\"\n    :> \"customers\"\n    :> Capture \"id\" CustomerId\n    :> \"sources\"\n    :> BasicAuth \"secretkey-password\" BasicAuthData\n    :> ReqBody '[FormUrlEncoded] CardReq\n    :> Post '[JSON] CardObject\n\ncreateCard ::\n  ( Metrics.CoreMetrics m,\n    MonadFlow m\n  ) =>\n  BaseUrl ->\n  Text ->\n  CustomerId ->\n  CardReq ->\n  m CardObject\ncreateCard url apiKey customerId cardReq = do\n  let proxy = Proxy @CreateCardAPI\n      eulerClient = Euler.client proxy customerId (mkBasicAuthData apiKey) cardReq\n  callStripeAPI url eulerClient \"create-card\" proxy\n\ntype DeleteCardAPI =\n  \"v1\"\n    :> \"customers\"\n    :> Capture \"id\" CustomerId\n    :> \"sources\"\n    :> Capture \"card_id\" PaymentMethodId\n    :> BasicAuth \"secretkey-password\" BasicAuthData\n    :> Delete '[JSON] DeleteCardResp\n\ndeleteCard ::\n  ( Metrics.CoreMetrics m,\n    MonadFlow m\n  ) =>\n  BaseUrl ->\n  Text ->\n  CustomerId ->\n  PaymentMethodId ->\n  m DeleteCardResp\ndeleteCard url apiKey customerId cardId = do\n  let proxy = Proxy @DeleteCardAPI\n      eulerClient = Euler.client proxy customerId cardId (mkBasicAuthData apiKey)\n  callStripeAPI url eulerClient \"delete-card\" proxy\n\ntype UpdateCardAPI =\n  \"v1\"\n    :> \"customers\"\n    :> Capture \"id\" CustomerId\n    :> \"sources\"\n    :> Capture \"card_id\" PaymentMethodId\n    :> BasicAuth \"secretkey-password\" BasicAuthData\n    :> ReqBody '[FormUrlEncoded] UpdateCardReq\n    :> Post '[JSON] CardObject\n\nupdateCard ::\n  ( Metrics.CoreMetrics m,\n    MonadFlow m\n  ) =>\n  BaseUrl ->\n  Text ->\n  CustomerId ->\n  PaymentMethodId ->\n  UpdateCardReq ->\n  m CardObject\nupdateCard url apiKey customerId cardId updateCardReq = do\n  let proxy = Proxy @UpdateCardAPI\n      eulerClient = Euler.client proxy customerId cardId (mkBasicAuthData apiKey) updateCardReq\n  callStripeAPI url eulerClient \"update-card\" proxy\n\ntype GetCardAPI =\n  \"v1\"\n    :> \"customers\"\n    :> Capture \"id\" CustomerId\n    :> \"cards\"\n    :> Capture \"card_id\" PaymentMethodId\n    :> BasicAuth \"secretkey-password\" BasicAuthData\n    :> Get '[JSON] CardObject\n\ngetCard ::\n  ( Metrics.CoreMetrics m,\n    MonadFlow m\n  ) =>\n  BaseUrl ->\n  Text ->\n  CustomerId ->\n  PaymentMethodId ->\n  m CardObject\ngetCard url apiKey customerId cardId = do\n  let proxy = Proxy @GetCardAPI\n      eulerClient = Euler.client proxy customerId cardId (mkBasicAuthData apiKey)\n  callStripeAPI url eulerClient \"get-card\" proxy\n\ntype GetCardListAPI =\n  \"v1\"\n    :> \"customers\"\n    :> Capture \"id\" CustomerId\n    :> \"cards\"\n    :> BasicAuth \"secretkey-password\" BasicAuthData\n    :> Get '[JSON] CardList\n\ngetCardList ::\n  ( Metrics.CoreMetrics m,\n    MonadFlow m\n  ) =>\n  BaseUrl ->\n  Text ->\n  CustomerId ->\n  m CardList\ngetCardList url apiKey customerId = do\n  let proxy = Proxy @GetCardListAPI\n      eulerClient = Euler.client proxy customerId (mkBasicAuthData apiKey)\n  callStripeAPI url eulerClient \"get-card-list\" proxy\n\n---------------------------------------- PaymentMethod APIs ---------------------------------------\ntype GetPaymentMethodListAPI =\n  \"v1\"\n    :> \"customers\"\n    :> Capture \"id\" CustomerId\n    :> \"payment_methods\"\n    :> BasicAuth \"secretkey-password\" BasicAuthData\n    :> Get '[JSON] PaymentMethodList\n\ngetPaymentMethodList ::\n  ( Metrics.CoreMetrics m,\n    MonadFlow m\n  ) =>\n  BaseUrl ->\n  Text ->\n  CustomerId ->\n  m PaymentMethodList\ngetPaymentMethodList url apiKey customerId = do\n  let proxy = Proxy @GetPaymentMethodListAPI\n      eulerClient = Euler.client proxy customerId (mkBasicAuthData apiKey)\n  callStripeAPI url eulerClient \"get-payment-method-list\" proxy\n\ntype DetachPaymentMethodAPI =\n  \"v1\"\n    :> \"payment_methods\"\n    :> Capture \"id\" PaymentMethodId\n    :> \"detach\"\n    :> BasicAuth \"secretkey-password\" BasicAuthData\n    :> Post '[JSON] PaymentMethod\n\ndetachPaymentMethod ::\n  ( Metrics.CoreMetrics m,\n    MonadFlow m\n  ) =>\n  BaseUrl ->\n  Text ->\n  PaymentMethodId ->\n  m PaymentMethod\ndetachPaymentMethod url apiKey paymentMethodId = do\n  let proxy = Proxy @DetachPaymentMethodAPI\n      eulerClient = Euler.client proxy paymentMethodId (mkBasicAuthData apiKey)\n  callStripeAPI url eulerClient \"detach-payment-method\" proxy\n\ntype ClonePaymentMethodAPI =\n  \"v1\"\n    :> \"payment_methods\"\n    :> MandatoryHeader \"Stripe-Account\" Text\n    :> BasicAuth \"secretkey-password\" BasicAuthData\n    :> ReqBody '[FormUrlEncoded] ClonePaymentMethodReq\n    :> Post '[JSON] PaymentMethod\n\nclonePaymentMethod ::\n  ( Metrics.CoreMetrics m,\n    MonadFlow m\n  ) =>\n  BaseUrl ->\n  Text ->\n  Text ->\n  ClonePaymentMethodReq ->\n  m PaymentMethod\nclonePaymentMethod url apiKey connectedAccountId clonePaymentMethodReq = do\n  let proxy = Proxy @ClonePaymentMethodAPI\n      eulerClient = Euler.client proxy connectedAccountId (mkBasicAuthData apiKey) clonePaymentMethodReq\n  callStripeAPI url eulerClient \"create-payment-method\" proxy\n\n-------------------------------------------- Ephemeral Keys APIs --------------------------------------------\ntype CreateEphemeralKeysAPI =\n  \"v1\"\n    :> \"ephemeral_keys\"\n    :> BasicAuth \"secretkey-password\" BasicAuthData\n    :> Header \"Stripe-Version\" Text\n    :> ReqBody '[FormUrlEncoded] EphemeralKeysReq\n    :> Post '[JSON] EphemeralKeysResp\n\ncreateEphemeralKeys ::\n  ( Metrics.CoreMetrics m,\n    MonadFlow m\n  ) =>\n  BaseUrl ->\n  Text ->\n  EphemeralKeysReq ->\n  m EphemeralKeysResp\ncreateEphemeralKeys url apiKey ephemeralKeysReq = do\n  let proxy = Proxy @CreateEphemeralKeysAPI\n      eulerClient = Euler.client proxy (mkBasicAuthData apiKey) (Just \"2024-04-10\") ephemeralKeysReq\n  callStripeAPI url eulerClient \"create-ephemeralKeys\" proxy\n",
      "hash": "ee18c0c5bf61aa0405eceac86bcd2e9e07cc6dc234bca8bd92e76574baf0ddfa",
      "size": 14581
    },
    "/lib/mobility-core/src/Kernel/External/Payment/Stripe/Types.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n\nmodule Kernel.External.Payment.Stripe.Types\n  ( module Reexport,\n  )\nwhere\n\nimport Kernel.External.Payment.Stripe.Types.Accounts as Reexport\nimport Kernel.External.Payment.Stripe.Types.Card as Reexport\nimport Kernel.External.Payment.Stripe.Types.Common as Reexport\nimport Kernel.External.Payment.Stripe.Types.Customer as Reexport\nimport Kernel.External.Payment.Stripe.Types.Error as Reexport\nimport Kernel.External.Payment.Stripe.Types.PaymentIntent as Reexport\nimport Kernel.External.Payment.Stripe.Types.SetupIntent as Reexport\n",
      "hash": "9624702c23007bb5acca20664a45ca1ae8a35fec33ac99ec59d4b80273b177c1",
      "size": 1224
    },
    "/lib/mobility-core/src/Kernel/External/Payment/Stripe/Types/Accounts.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n{-# LANGUAGE DerivingStrategies #-}\n{-# LANGUAGE InstanceSigs #-}\n\nmodule Kernel.External.Payment.Stripe.Types.Accounts where\n\nimport Data.Aeson\nimport qualified Data.HashMap.Strict as HM\nimport qualified Data.Text as T\nimport Data.Time.Clock.POSIX (POSIXTime)\nimport Kernel.External.Payment.Stripe.Types.Common\nimport Kernel.Prelude\nimport Kernel.Utils.Common\nimport Kernel.Utils.JSON\nimport Servant\nimport Web.FormUrlEncoded\n\ndata AccountType\n  = Standard\n  | Express\n  | Custom\n  deriving stock (Show, Eq, Generic, Read)\n  deriving anyclass (ToSchema)\n\ninstance ToHttpApiData AccountType where\n  toQueryParam :: AccountType -> Text\n  toQueryParam = T.pack . recursiveStrip . camelToSnake . show\n\ninstance FromJSON AccountType where\n  parseJSON = genericParseJSON constructorsWithCapitalToSnakeCase\n\ninstance ToJSON AccountType where\n  toJSON = genericToJSON constructorsWithCapitalToSnakeCase\n\n-- A value indicating who is liable when this account cant pay back negative balances resulting from payments. Defaults to Stripe\ndata AccountLossesPayer = AccountLossesPayerStripe | AccountLossesPayerApplication\n  deriving stock (Show, Eq, Generic, Read)\n  deriving anyclass (ToSchema)\n\naccountLossesPayerJsonOptions :: Options\naccountLossesPayerJsonOptions =\n  defaultOptions\n    { constructorTagModifier = \\case\n        \"AccountLossesPayerStripe\" -> \"stripe\"\n        \"AccountLossesPayerApplication\" -> \"application\"\n        x -> x\n    }\n\ninstance ToHttpApiData AccountLossesPayer where\n  toQueryParam :: AccountLossesPayer -> Text\n  toQueryParam AccountLossesPayerStripe = \"stripe\"\n  toQueryParam AccountLossesPayerApplication = \"application\"\n\ninstance FromJSON AccountLossesPayer where\n  parseJSON = genericParseJSON accountLossesPayerJsonOptions\n\ninstance ToJSON AccountLossesPayer where\n  toJSON = genericToJSON accountLossesPayerJsonOptions\n\nnewtype AccountLosses = AccountLosses\n  { payments :: AccountLossesPayer\n  }\n  deriving stock (Show, Eq, Generic, Read)\n  deriving anyclass (FromJSON, ToJSON, ToSchema, ToForm)\n\n-- A value indicating the responsible payer of Stripe fees on this account. Defaults to Account\ndata AccountFeePayer = AccountFeePayerAccount | AccountFeePayerApplication\n  deriving stock (Show, Eq, Generic, Read)\n  deriving anyclass (ToSchema)\n\naccountFeePayerJsonOptions :: Options\naccountFeePayerJsonOptions =\n  defaultOptions\n    { constructorTagModifier = \\case\n        \"AccountFeePayerAccount\" -> \"account\"\n        \"AccountFeePayerApplication\" -> \"application\"\n        x -> x\n    }\n\ninstance ToHttpApiData AccountFeePayer where\n  toQueryParam :: AccountFeePayer -> Text\n  toQueryParam AccountFeePayerAccount = \"account\"\n  toQueryParam AccountFeePayerApplication = \"application\"\n\ninstance FromJSON AccountFeePayer where\n  parseJSON = genericParseJSON accountFeePayerJsonOptions\n\ninstance ToJSON AccountFeePayer where\n  toJSON = genericToJSON accountFeePayerJsonOptions\n\nnewtype AccountFees = AccountFees\n  { payer :: AccountFeePayer\n  }\n  deriving stock (Show, Eq, Generic, Read)\n  deriving anyclass (FromJSON, ToJSON, ToSchema)\n\n-- A value indicating responsibility for collecting updated information when requirements on the account are due or change. Defaults to Stripe.\ndata AccountRquirementCollector = AccountRquirementCollectorStripe | AccountRquirementCollectorApplication\n  deriving stock (Show, Eq, Generic, Read)\n  deriving anyclass (ToSchema)\n\naccountRquirementCollectorJsonOptions :: Options\naccountRquirementCollectorJsonOptions =\n  defaultOptions\n    { constructorTagModifier = \\case\n        \"AccountRquirementCollectorStripe\" -> \"stripe\"\n        \"AccountRquirementCollectorApplication\" -> \"application\"\n        x -> x\n    }\n\ninstance ToHttpApiData AccountRquirementCollector where\n  toQueryParam :: AccountRquirementCollector -> Text\n  toQueryParam AccountRquirementCollectorStripe = \"stripe\"\n  toQueryParam AccountRquirementCollectorApplication = \"application\"\n\ninstance FromJSON AccountRquirementCollector where\n  parseJSON = genericParseJSON accountRquirementCollectorJsonOptions\n\ninstance ToJSON AccountRquirementCollector where\n  toJSON = genericToJSON accountRquirementCollectorJsonOptions\n\n-- A hash of configuration for Stripe-hosted dashboards\ndata AccountDashboardType = AccountDashboardExpress | AccountDashboardFull | AccountDashboardNone\n  deriving stock (Show, Eq, Generic, Read)\n  deriving anyclass (ToSchema)\n\naccountDashboardTypeJsonOptions :: Options\naccountDashboardTypeJsonOptions =\n  defaultOptions\n    { constructorTagModifier = \\case\n        \"AccountDashboardExpress\" -> \"express\"\n        \"AccountDashboardFull\" -> \"full\"\n        \"AccountDashboardNone\" -> \"none\"\n        x -> x\n    }\n\ninstance ToHttpApiData AccountDashboardType where\n  toQueryParam :: AccountDashboardType -> Text\n  toQueryParam AccountDashboardExpress = \"express\"\n  toQueryParam AccountDashboardFull = \"full\"\n  toQueryParam AccountDashboardNone = \"none\"\n\ninstance FromJSON AccountDashboardType where\n  parseJSON = genericParseJSON accountDashboardTypeJsonOptions\n\ninstance ToJSON AccountDashboardType where\n  toJSON = genericToJSON accountDashboardTypeJsonOptions\n\nnewtype AccountDashboard = AccountDashboard\n  { _type :: AccountDashboardType\n  }\n  deriving stock (Show, Eq, Generic, Read)\n  deriving anyclass (ToSchema)\n\ninstance FromJSON AccountDashboard where\n  parseJSON = genericParseJSON stripPrefixUnderscoreIfAny\n\ninstance ToJSON AccountDashboard where\n  toJSON = genericToJSON stripPrefixUnderscoreIfAny\n\ndata AccountController = AccountController\n  { fees :: Maybe AccountFees,\n    losses :: Maybe AccountLosses,\n    requirement_collection :: Maybe AccountRquirementCollector,\n    stripe_dashboard :: Maybe AccountDashboard\n  }\n  deriving stock (Show, Eq, Generic, Read)\n  deriving anyclass (FromJSON, ToJSON, ToSchema)\n\ndata BusinessType = Individual | Company | GovernmentEntity | NonProfit\n  deriving stock (Show, Eq, Generic, Read)\n  deriving anyclass (ToSchema)\n\ninstance ToHttpApiData BusinessType where\n  toQueryParam :: BusinessType -> Text\n  toQueryParam = T.pack . recursiveStrip . camelToSnake . show\n\ninstance FromJSON BusinessType where\n  parseJSON = genericParseJSON constructorsWithCapitalToSnakeCase\n\ninstance ToJSON BusinessType where\n  toJSON = genericToJSON constructorsWithCapitalToSnakeCase\n\ndata AccountCapabilities = AccountCapabilities\n  { card_payments :: CardPayments,\n    -- cashapp_payments :: CashAppPayments,\n    transfers :: Transfers\n  }\n  deriving stock (Show, Eq, Generic, Read)\n  deriving anyclass (FromJSON, ToJSON, ToSchema)\n\nnewtype CardPayments = CardPayments\n  { requested :: Bool\n  }\n  deriving stock (Show, Eq, Generic, Read)\n  deriving anyclass (FromJSON, ToJSON, ToSchema)\n\nnewtype Transfers = Transfers\n  { requested :: Bool\n  }\n  deriving stock (Show, Eq, Generic, Read)\n  deriving anyclass (FromJSON, ToJSON, ToSchema)\n\nnewtype CashAppPayments = CashAppPayments\n  { requested :: Bool\n  }\n  deriving stock (Show, Eq, Generic, Read)\n  deriving anyclass (FromJSON, ToJSON, ToSchema)\n\nnewtype AccountSettings = AccountSettings\n  { payouts :: PayoutsSettings\n  }\n  deriving stock (Show, Eq, Generic, Read)\n  deriving anyclass (FromJSON, ToJSON, ToSchema)\n\ndata PayoutsSettings = PayoutsSettings\n  { debit_negative_balances :: Bool,\n    statement_descriptor :: Text\n  }\n  deriving stock (Show, Eq, Generic, Read)\n  deriving anyclass (FromJSON, ToJSON, ToSchema)\n\ndata DateOfBirth = DateOfBirth\n  { day :: Int,\n    month :: Int,\n    year :: Int\n  }\n  deriving stock (Show, Eq, Generic, Read)\n  deriving anyclass (FromJSON, ToJSON, ToSchema)\n\ndata Address = Address\n  { city :: Maybe Text,\n    country :: Maybe Text,\n    line1 :: Maybe Text,\n    line2 :: Maybe Text,\n    postal_code :: Maybe Text,\n    state :: Maybe Text\n  }\n  deriving stock (Show, Eq, Generic, Read)\n  deriving anyclass (FromJSON, ToJSON, ToSchema)\n\ndata IndividualDetails = IndividualDetails\n  { first_name :: Text,\n    last_name :: Maybe Text,\n    dob :: Maybe DateOfBirth,\n    address :: Maybe Address,\n    email :: Maybe Text,\n    id_number :: Maybe Text,\n    phone :: Text,\n    ssn_last_4 :: Maybe Text\n  }\n  deriving stock (Show, Eq, Generic, Read)\n  deriving anyclass (FromJSON, ToJSON, ToSchema)\n\ndata AccountsReq = AccountsReq\n  { _type :: Maybe AccountType,\n    country :: Text, -- default to US, will fix later\n    email :: Maybe Text,\n    controller :: Maybe AccountController,\n    capabilities :: Maybe AccountCapabilities,\n    business_type :: BusinessType,\n    settings :: Maybe AccountSettings,\n    business_profile :: Maybe BusinessProfile, -- not for individual account\n    individual :: Maybe IndividualDetails\n    -- tos_acceptance :: Maybe TosAcceptance, -- can be revisit later\n    -- metadata :: Maybe Metadata, -- can be used to store additional information\n  }\n  deriving stock (Show, Eq, Generic, Read)\n  deriving anyclass (ToSchema)\n\ninstance ToForm AccountsReq where\n  toForm AccountsReq {..} =\n    Form $\n      foldl' insertOrAppend HM.empty $\n        [ (\"country\", toQueryParam country),\n          (\"business_type\", toQueryParam business_type)\n        ]\n          ++ catMaybes\n            [ (\"type\",) <$> toQueryParam <$> _type,\n              (\"email\",) <$> toQueryParam <$> email,\n              (\"capabilities[card_payments][requested]\",) <$> (toQueryParam . (.card_payments.requested)) <$> capabilities,\n              -- (\"capabilities[cashapp_payments][requested]\",) <$> (toQueryParam . (.cashapp_payments.requested)) <$> capabilities,\n              (\"capabilities[transfers][requested]\",) <$> (toQueryParam . (.transfers.requested)) <$> capabilities,\n              (\"controller[fees][payer]\",) <$> (toQueryParam . (.payer)) <$> ((.fees) =<< controller),\n              (\"controller[losses][payments]\",) <$> (toQueryParam . (.payments)) <$> ((.losses) =<< controller),\n              (\"controller[requirement_collection]\",) <$> toQueryParam <$> ((.requirement_collection) =<< controller),\n              (\"controller[stripe_dashboard][type]\",) <$> (toQueryParam . (._type)) <$> ((.stripe_dashboard) =<< controller),\n              (\"settings[payouts][debit_negative_balances]\",) <$> (toQueryParam . (.payouts.debit_negative_balances)) <$> settings,\n              (\"settings[payouts][statement_descriptor]\",) <$> (toQueryParam . (.payouts.statement_descriptor)) <$> settings\n            ]\n          ++ maybe [] individualToForm individual\n          ++ maybe [] businessProfileToForm business_profile\n\ninsertOrAppend :: HM.HashMap Text [Text] -> (Text, Text) -> HM.HashMap Text [Text]\ninsertOrAppend hm (k, v) = HM.insertWith (++) k [v] hm\n\nindividualToForm :: IndividualDetails -> [(Text, Text)]\nindividualToForm IndividualDetails {..} =\n  [ (\"individual[first_name]\", toQueryParam first_name),\n    (\"individual[phone]\", toQueryParam phone)\n  ]\n    ++ catMaybes\n      [ (\"individual[last_name]\",) <$> toQueryParam <$> last_name,\n        (\"individual[email]\",) <$> toQueryParam <$> email,\n        (\"individual[id_number]\",) <$> toQueryParam <$> id_number,\n        (\"individual[ssn_last_4]\",) <$> toQueryParam <$> ssn_last_4\n      ]\n    ++ maybe [] dobToForm dob\n    ++ maybe [] addressToForm address\n\ndobToForm :: DateOfBirth -> [(Text, Text)]\ndobToForm DateOfBirth {..} =\n  [ (\"individual[dob][day]\", toQueryParam day),\n    (\"individual[dob][month]\", toQueryParam month),\n    (\"individual[dob][year]\", toQueryParam year)\n  ]\n\naddressToForm :: Address -> [(Text, Text)]\naddressToForm Address {..} =\n  catMaybes\n    [ (\"individual[address][city]\",) <$> toQueryParam <$> city,\n      (\"individual[address][country]\",) <$> toQueryParam <$> country,\n      (\"individual[address][line1]\",) <$> toQueryParam <$> line1,\n      (\"individual[address][line2]\",) <$> toQueryParam <$> line2,\n      (\"individual[address][postal_code]\",) <$> toQueryParam <$> postal_code,\n      (\"individual[address][state]\",) <$> toQueryParam <$> state\n    ]\n\nbusinessProfileToForm :: BusinessProfile -> [(Text, Text)]\nbusinessProfileToForm BusinessProfile {..} =\n  catMaybes\n    [ (\"business_profile[mcc]\",) <$> toQueryParam <$> mcc,\n      (\"business_profile[product_description]\",) <$> toQueryParam <$> product_description,\n      (\"business_profile[support_phone]\",) <$> toQueryParam <$> support_phone,\n      (\"business_profile[url]\",) <$> toQueryParam <$> url\n    ]\n    ++ maybe [] businessSupportAdressToForm support_address\n\nbusinessSupportAdressToForm :: BusinessSupportAddress -> [(Text, Text)]\nbusinessSupportAdressToForm BusinessSupportAddress {..} =\n  catMaybes\n    [ (\"business_profile[support_address][city]\",) <$> toQueryParam <$> city,\n      (\"business_profile[support_address][country]\",) <$> toQueryParam <$> country,\n      (\"business_profile[support_address][line1]\",) <$> toQueryParam <$> line1,\n      (\"business_profile[support_address][line2]\",) <$> toQueryParam <$> line2,\n      (\"business_profile[support_address][postal_code]\",) <$> toQueryParam <$> postal_code,\n      (\"business_profile[support_address][state]\",) <$> toQueryParam <$> state\n    ]\n\ninstance FromJSON AccountsReq where\n  parseJSON = genericParseJSON stripPrefixUnderscoreIfAny\n\ninstance ToJSON AccountsReq where\n  toJSON = genericToJSON stripPrefixUnderscoreIfAny\n\ndata BusinessProfile = BusinessProfile\n  { mcc :: Maybe Text,\n    product_description :: Maybe Text,\n    support_phone :: Maybe Text,\n    url :: Maybe Text,\n    support_address :: Maybe BusinessSupportAddress\n  }\n  deriving stock (Show, Eq, Generic, Read)\n  deriving anyclass (FromJSON, ToJSON, ToSchema)\n\ndata BusinessSupportAddress = BusinessSupportAddress\n  { city :: Maybe Text,\n    country :: Maybe Text,\n    line1 :: Maybe Text,\n    line2 :: Maybe Text,\n    postal_code :: Maybe Text,\n    state :: Maybe Text\n  }\n  deriving stock (Show, Eq, Generic, Read)\n  deriving anyclass (FromJSON, ToJSON, ToSchema)\n\ndata AccountResp = AccountResp\n  { id :: AccountId,\n    _object :: Text,\n    charges_enabled :: Bool,\n    details_submitted :: Bool\n    -- Other paramters can be explored on basis of requirement.\n    -- business_profile :: Maybe BusinessProfile,\n    -- country :: Text,\n    -- created :: Int,\n    -- default_currency :: Text,\n    -- email :: Maybe Text,\n    -- external_accounts :: ExternalAccounts,\n    -- individual :: IndividualDetails,\n    -- metadata :: Metadata,\n    -- payouts_enabled :: Bool,\n    -- requirements :: Requirements,\n    -- settings :: Settings,\n    -- tos_acceptance :: TosAcceptance,\n    -- type :: AccountType\n  }\n  deriving stock (Show, Eq, Generic, Read)\n  deriving anyclass (ToSchema)\n\ninstance FromJSON AccountResp where\n  parseJSON = genericParseJSON stripPrefixUnderscoreIfAny\n\ninstance ToJSON AccountResp where\n  toJSON = genericToJSON stripPrefixUnderscoreIfAny\n\n----- ACCOUNT LINKS ----------------------------\ndata AccountLinkType = AccountOnboarding | AccountUpdate\n  deriving stock (Show, Eq, Generic, Read)\n  deriving anyclass (ToSchema)\n\ninstance ToHttpApiData AccountLinkType where\n  toQueryParam :: AccountLinkType -> Text\n  toQueryParam = T.pack . recursiveStrip . camelToSnake . show\n\ninstance FromJSON AccountLinkType where\n  parseJSON = genericParseJSON constructorsWithCapitalToSnakeCase\n\ninstance ToJSON AccountLinkType where\n  toJSON = genericToJSON constructorsWithCapitalToSnakeCase\n\ndata CollectionOptionsFields = CurrentlyDue | EventuallyDue\n  deriving stock (Show, Eq, Generic, Read)\n  deriving anyclass (ToSchema)\n\ninstance ToHttpApiData CollectionOptionsFields where\n  toQueryParam :: CollectionOptionsFields -> Text\n  toQueryParam = T.pack . recursiveStrip . camelToSnake . show\n\ninstance FromJSON CollectionOptionsFields where\n  parseJSON = genericParseJSON constructorsWithCapitalToSnakeCase\n\ninstance ToJSON CollectionOptionsFields where\n  toJSON = genericToJSON constructorsWithCapitalToSnakeCase\n\ndata CollectionOptionsFutureRequirements = Include | Omit\n  deriving stock (Show, Eq, Generic, Read)\n  deriving anyclass (ToSchema)\n\ninstance ToHttpApiData CollectionOptionsFutureRequirements where\n  toQueryParam :: CollectionOptionsFutureRequirements -> Text\n  toQueryParam = T.pack . recursiveStrip . camelToSnake . show\n\ninstance FromJSON CollectionOptionsFutureRequirements where\n  parseJSON = genericParseJSON constructorsWithCapitalToSnakeCase\n\ninstance ToJSON CollectionOptionsFutureRequirements where\n  toJSON = genericToJSON constructorsWithCapitalToSnakeCase\n\ndata CollectionOptions = CollectionOptions\n  { fields :: CollectionOptionsFields,\n    future_requirements :: CollectionOptionsFutureRequirements\n  }\n  deriving stock (Show, Eq, Generic, Read)\n  deriving anyclass (FromJSON, ToJSON, ToSchema)\n\ndata AccountLinkReq = AccountLinkReq\n  { account :: Text,\n    refresh_url :: Text,\n    return_url :: Text,\n    _type :: AccountLinkType,\n    collection_options :: Maybe CollectionOptions\n  }\n  deriving stock (Show, Eq, Generic, Read)\n  deriving anyclass (ToSchema)\n\ninstance ToForm AccountLinkReq where\n  toForm AccountLinkReq {..} =\n    Form $\n      foldl' insertOrAppend HM.empty $\n        [ (\"account\", toQueryParam account),\n          (\"refresh_url\", toQueryParam refresh_url),\n          (\"return_url\", toQueryParam return_url),\n          (\"type\", toQueryParam _type)\n        ]\n          ++ catMaybes\n            [ (\"collection_options[fields]\",) <$> (toQueryParam . (.fields)) <$> collection_options,\n              (\"collection_options[future_requirements]\",) <$> (toQueryParam . (.future_requirements)) <$> collection_options\n            ]\n\ninstance FromJSON AccountLinkReq where\n  parseJSON = genericParseJSON stripPrefixUnderscoreIfAny\n\ninstance ToJSON AccountLinkReq where\n  toJSON = genericToJSON stripPrefixUnderscoreIfAny\n\ndata AccountLinkObject = AccountLinkObject\n  { expires_at :: POSIXTime,\n    url :: Text,\n    _object :: Text,\n    created :: POSIXTime\n  }\n  deriving stock (Show, Eq, Generic, Read)\n  deriving anyclass (ToSchema)\n\ninstance FromJSON AccountLinkObject where\n  parseJSON = genericParseJSON stripPrefixUnderscoreIfAny\n\ninstance ToJSON AccountLinkObject where\n  toJSON = genericToJSON stripPrefixUnderscoreIfAny\n",
      "hash": "7a6eb1c78848f740f5bf369482af1137d1f509d5f37c90bd74851fd567e763fa",
      "size": 18622
    },
    "/lib/mobility-core/src/Kernel/External/Payment/Stripe/Types/Card.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n{-# LANGUAGE DerivingStrategies #-}\n{-# LANGUAGE InstanceSigs #-}\n\nmodule Kernel.External.Payment.Stripe.Types.Card where\n\nimport Data.Aeson\nimport qualified Data.HashMap.Strict as HM\nimport qualified Data.Text as T\nimport Kernel.External.Payment.Stripe.Types.Common\nimport Kernel.Prelude\nimport Kernel.Utils.Common (recursiveStrip)\nimport Kernel.Utils.JSON\nimport Web.FormUrlEncoded\nimport Web.HttpApiData (ToHttpApiData (..))\n\ndata CardObject = CardObject\n  { id :: PaymentMethodId,\n    name :: Maybe Text,\n    brand :: Text,\n    country :: Maybe Text,\n    customer :: Maybe Text,\n    cvc_check :: Maybe CVCCheck,\n    exp_month :: Int,\n    exp_year :: Int,\n    funding :: Maybe Text,\n    fingerprint :: Maybe Text,\n    last4 :: Text\n  }\n  deriving stock (Show, Eq, Generic, Read)\n  deriving anyclass (FromJSON, ToJSON, ToSchema)\n\ndata CVCCheck = Pass | Fail | Unavailable | Unchecked\n  deriving stock (Show, Eq, Generic, Read)\n  deriving anyclass (ToSchema)\n\ninstance FromJSON CVCCheck where\n  parseJSON = genericParseJSON constructorsWithLowerCase\n\ninstance ToJSON CVCCheck where\n  toJSON = genericToJSON constructorsWithLowerCase\n\nnewtype CardReq = CardReq\n  { source :: CardReqSource\n  }\n  deriving stock (Show, Eq, Generic, Read)\n  deriving anyclass (FromJSON, ToJSON, ToSchema)\n\ndata CardReqSource = CardReqSource\n  { exp_month :: Int,\n    exp_year :: Int,\n    number :: Text,\n    _object :: PaymentSourceType,\n    cvc :: Text,\n    name :: Maybe Text\n  }\n  deriving stock (Show, Eq, Generic, Read)\n  deriving anyclass (ToSchema)\n\ninstance ToForm CardReq where\n  toForm CardReq {source = CardReqSource {..}} =\n    Form $\n      HM.fromList\n        [ (\"source[exp_month]\", [toQueryParam exp_month]),\n          (\"source[exp_year]\", [toQueryParam exp_year]),\n          (\"source[number]\", [toQueryParam number]),\n          (\"source[object]\", [toQueryParam _object]),\n          (\"source[cvc]\", [toQueryParam cvc])\n        ]\n        <> maybeToForm \"source[name]\" name\n    where\n      maybeToForm :: ToHttpApiData a => Text -> Maybe a -> HM.HashMap Text [Text]\n      maybeToForm key = maybe HM.empty (\\value -> HM.singleton key [toQueryParam value])\n\ninstance FromJSON CardReqSource where\n  parseJSON = genericParseJSON stripPrefixUnderscoreIfAny\n\ninstance ToJSON CardReqSource where\n  toJSON = genericToJSON stripPrefixUnderscoreIfAny\n\ndata PaymentSourceType = Card | Wallet\n  deriving stock (Show, Eq, Generic, Read)\n  deriving anyclass (ToSchema)\n\ninstance ToHttpApiData PaymentSourceType where\n  toQueryParam :: PaymentSourceType -> Text\n  toQueryParam = T.pack . recursiveStrip . camelToSnake . show\n\ninstance FromJSON PaymentSourceType where\n  parseJSON = genericParseJSON constructorsWithLowerCase\n\ninstance ToJSON PaymentSourceType where\n  toJSON = genericToJSON constructorsWithLowerCase\n\ndata UpdateCardReq = UpdateCardReq\n  { exp_month :: Maybe Int,\n    exp_year :: Maybe Int,\n    name :: Maybe Text\n  }\n  deriving stock (Show, Eq, Generic, Read)\n  deriving anyclass (FromJSON, ToJSON, ToSchema)\n\ninstance ToForm UpdateCardReq where\n  toForm UpdateCardReq {..} =\n    Form $\n      HM.fromList $\n        catMaybes\n          [ (\"exp_month\",) . pure <$> toQueryParam <$> exp_month,\n            (\"exp_year\",) . pure <$> toQueryParam <$> exp_year,\n            (\"name\",) . pure <$> toQueryParam <$> name\n          ]\n\ndata DeleteCardResp = DeleteCardResp\n  { id :: PaymentMethodId,\n    deleted :: Bool\n  }\n  deriving stock (Show, Eq, Generic, Read)\n  deriving anyclass (FromJSON, ToJSON, ToSchema)\n\ndata CardList = CardList\n  { _data :: [CardObject],\n    has_more :: Bool\n  }\n  deriving stock (Show, Eq, Generic, Read)\n  deriving anyclass (ToSchema)\n\ninstance FromJSON CardList where\n  parseJSON = genericParseJSON stripPrefixUnderscoreIfAny\n\ninstance ToJSON CardList where\n  toJSON = genericToJSON stripPrefixUnderscoreIfAny\n\ndata PaymentMethodList = PaymentMethodList\n  { _data :: [PaymentMethod],\n    has_more :: Bool\n  }\n  deriving stock (Show, Eq, Generic, Read)\n  deriving anyclass (ToSchema)\n\ninstance FromJSON PaymentMethodList where\n  parseJSON = genericParseJSON stripPrefixUnderscoreIfAny\n\ninstance ToJSON PaymentMethodList where\n  toJSON = genericToJSON stripPrefixUnderscoreIfAny\n\ndata PaymentMethod = PaymentMethod\n  { id :: PaymentMethodId,\n    card :: CardPaymentMethod\n    -- later more types\n  }\n  deriving stock (Show, Eq, Generic, Read)\n  deriving anyclass (FromJSON, ToJSON, ToSchema)\n\ndata CardPaymentMethod = CardPaymentMethod\n  { brand :: Text,\n    country :: Maybe Text,\n    customer :: Maybe Text,\n    exp_month :: Int,\n    exp_year :: Int,\n    funding :: Maybe Text,\n    fingerprint :: Maybe Text,\n    last4 :: Text\n  }\n  deriving stock (Show, Eq, Generic, Read)\n  deriving anyclass (FromJSON, ToJSON, ToSchema)\n\ndata ClonePaymentMethodReq = ClonePaymentMethodReq\n  { payment_method :: PaymentMethodId,\n    customer :: CustomerId\n  }\n  deriving stock (Show, Eq, Generic, Read)\n  deriving anyclass (ToJSON, ToSchema)\n\ninstance ToForm ClonePaymentMethodReq where\n  toForm ClonePaymentMethodReq {..} =\n    Form $\n      HM.fromList $\n        [ (\"payment_method\", [toQueryParam payment_method]),\n          (\"customer\", [toQueryParam customer])\n        ]\n",
      "hash": "1bec74c7384da24bb1c1756bcb457c8c729133b39527fc7d36b4277ec1795d4e",
      "size": 5870
    },
    "/lib/mobility-core/src/Kernel/External/Payment/Stripe/Types/Common.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n{-# LANGUAGE DerivingStrategies #-}\n{-# LANGUAGE InstanceSigs #-}\n\nmodule Kernel.External.Payment.Stripe.Types.Common where\n\nimport Data.Aeson\nimport Kernel.Prelude\nimport Web.HttpApiData (ToHttpApiData (..))\n\ntype AccountId = Text\n\ntype CustomerId = Text\n\ntype PaymentIntentId = Text\n\ntype SetupIntentId = Text\n\ntype PaymentMethodId = Text\n\ndata AutomaticPayementMethods = AutomaticPayementMethods\n  { enabled :: Bool,\n    allow_redirects :: AutomaticPayementMethodsAllowRedirects\n  }\n  deriving stock (Show, Eq, Generic, Read)\n  deriving anyclass (FromJSON, ToJSON, ToSchema)\n\ndata AutomaticPayementMethodsAllowRedirects = AlwaysRedirect | NeverRedirect\n  deriving stock (Show, Eq, Generic, Read)\n  deriving anyclass (ToSchema)\n\ninstance ToHttpApiData AutomaticPayementMethodsAllowRedirects where\n  toQueryParam :: AutomaticPayementMethodsAllowRedirects -> Text\n  toQueryParam AlwaysRedirect = \"redirect\"\n  toQueryParam NeverRedirect = \"never\"\n\nautomaticPayementMethodsAllowRedirectsJsonOptions :: Options\nautomaticPayementMethodsAllowRedirectsJsonOptions =\n  defaultOptions\n    { constructorTagModifier = \\case\n        \"AlwaysRedirect\" -> \"redirect\"\n        \"NeverRedirect\" -> \"never\"\n        x -> x\n    }\n\ninstance FromJSON AutomaticPayementMethodsAllowRedirects where\n  parseJSON = genericParseJSON automaticPayementMethodsAllowRedirectsJsonOptions\n\ninstance ToJSON AutomaticPayementMethodsAllowRedirects where\n  toJSON = genericToJSON automaticPayementMethodsAllowRedirectsJsonOptions\n\ndata SetupFutureUsage = FutureUsageOffSession | FutureUsageOnSession\n  deriving stock (Show, Eq, Generic, Read)\n  deriving anyclass (ToSchema)\n\nsetupFutureUsageJsonOptions :: Options\nsetupFutureUsageJsonOptions =\n  defaultOptions\n    { constructorTagModifier = \\case\n        \"FutureUsageOffSession\" -> \"off_session\"\n        \"FutureUsageOnSession\" -> \"on_session\"\n        x -> x\n    }\n\ninstance ToHttpApiData SetupFutureUsage where\n  toQueryParam :: SetupFutureUsage -> Text\n  toQueryParam FutureUsageOffSession = \"off_session\"\n  toQueryParam FutureUsageOnSession = \"on_session\"\n\ninstance FromJSON SetupFutureUsage where\n  parseJSON = genericParseJSON setupFutureUsageJsonOptions\n\ninstance ToJSON SetupFutureUsage where\n  toJSON = genericToJSON setupFutureUsageJsonOptions\n\ndata PaymentIntentStatus = Cancelled | Processing | RequiresAction | RequiresCapture | RequiresConfirmation | RequiresPaymentMethod | Succeeded\n  deriving stock (Show, Eq, Generic, Read)\n  deriving anyclass (ToSchema)\n\npaymentIntentStatusJsonOptions :: Options\npaymentIntentStatusJsonOptions =\n  defaultOptions\n    { constructorTagModifier = \\case\n        \"Cancelled\" -> \"cancelled\"\n        \"Processing\" -> \"processing\"\n        \"RequiresAction\" -> \"requires_action\"\n        \"RequiresCapture\" -> \"requires_capture\"\n        \"RequiresConfirmation\" -> \"requires_confirmation\"\n        \"RequiresPaymentMethod\" -> \"requires_payment_method\"\n        \"Succeeded\" -> \"succeeded\"\n        x -> x\n    }\n\ninstance FromJSON PaymentIntentStatus where\n  parseJSON = genericParseJSON paymentIntentStatusJsonOptions\n\ninstance ToJSON PaymentIntentStatus where\n  toJSON = genericToJSON paymentIntentStatusJsonOptions\n",
      "hash": "ef6fe737f6cfeb243c8b569d74916a8f9457b9b6d1d157c0a5b7a11a2e59ca8a",
      "size": 3853
    },
    "/lib/mobility-core/src/Kernel/External/Payment/Stripe/Types/Customer.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n{-# LANGUAGE DerivingStrategies #-}\n\nmodule Kernel.External.Payment.Stripe.Types.Customer where\n\nimport Data.Aeson\nimport qualified Data.HashMap.Strict as HM\nimport Kernel.External.Payment.Stripe.Types.Common\nimport Kernel.Prelude\nimport Web.FormUrlEncoded\nimport Web.HttpApiData (ToHttpApiData (..))\n\ndata CustomerReq = CustomerReq\n  { email :: Text,\n    name :: Text,\n    payment_method :: Maybe Text,\n    source :: Maybe Text,\n    phone :: Maybe Text\n  }\n  deriving stock (Show, Eq, Generic, Read)\n  deriving anyclass (FromJSON, ToJSON, ToSchema)\n\ninstance ToForm CustomerReq where\n  toForm CustomerReq {..} =\n    Form $\n      HM.fromList $\n        [ (\"email\", [toQueryParam email]),\n          (\"name\", [toQueryParam name])\n        ]\n          ++ catMaybes\n            [ (\"payment_method\",) . pure <$> toQueryParam <$> payment_method,\n              (\"source\",) . pure <$> toQueryParam <$> source,\n              (\"phone\",) . pure <$> toQueryParam <$> phone\n            ]\n\ndata UpdateCustomerReq = UpdateCustomerReq\n  { email :: Maybe Text,\n    name :: Maybe Text,\n    source :: Maybe Text,\n    phone :: Maybe Text\n  }\n  deriving stock (Show, Eq, Generic, Read)\n  deriving anyclass (FromJSON, ToJSON, ToSchema)\n\ninstance ToForm UpdateCustomerReq where\n  toForm UpdateCustomerReq {..} =\n    Form $\n      HM.fromList $\n        catMaybes\n          [ (\"email\",) . pure <$> toQueryParam <$> email,\n            (\"name\",) . pure <$> toQueryParam <$> name,\n            (\"source\",) . pure <$> toQueryParam <$> source,\n            (\"phone\",) . pure <$> toQueryParam <$> phone\n          ]\n\ndata CustomerObject = CustomerObject\n  { id :: CustomerId,\n    email :: Maybe Text,\n    name :: Maybe Text,\n    default_source :: Maybe Text,\n    phone :: Maybe Text\n  }\n  deriving stock (Show, Eq, Generic, Read)\n  deriving anyclass (FromJSON, ToJSON, ToSchema)\n\nnewtype EphemeralKeysReq = EphemeralKeysReq\n  { customer :: CustomerId\n  }\n  deriving stock (Show, Eq, Generic, Read)\n  deriving anyclass (ToSchema)\n\ninstance ToForm EphemeralKeysReq\n\nnewtype EphemeralKeysResp = EphemeralKeysResp\n  { secret :: Text\n  }\n  deriving stock (Show, Eq, Generic, Read)\n  deriving anyclass (FromJSON, ToJSON, ToSchema)\n",
      "hash": "47a2c4a9f6fd10b470d401ef57de045e4453ca2a71076f7f44f9f002447d20be",
      "size": 2881
    },
    "/lib/mobility-core/src/Kernel/External/Payment/Stripe/Types/Error.hs": {
      "type": "content",
      "content": "{-\n Copyright 2022-23, Juspay India Pvt Ltd\n\n This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program\n\n is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n\n or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of\n\n the GNU Affero General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n{-# LANGUAGE DeriveAnyClass #-}\n{-# LANGUAGE TemplateHaskell #-}\n\nmodule Kernel.External.Payment.Stripe.Types.Error where\n\nimport Control.Applicative ((<|>))\nimport Data.Aeson\nimport Data.Char (toUpper)\nimport Data.List (intercalate)\nimport qualified Data.Text as T\nimport Kernel.Prelude\nimport Kernel.Types.Error.BaseError\nimport Kernel.Types.Error.BaseError.HTTPError\nimport Kernel.Types.Error.BaseError.HTTPError.FromResponse (FromResponse (fromResponse))\nimport Kernel.Utils.JSON\nimport Servant.Client (ResponseF (responseBody))\nimport qualified Text.Show\n\nnewtype StripeErrorResp = StripeErrorResp\n  { _error :: StripeErrorBody\n  }\n  deriving (Eq, Generic, Show)\n\ninstance FromJSON StripeErrorResp where\n  parseJSON = genericParseJSON stripPrefixUnderscoreIfAny\n\ninstance ToJSON StripeErrorResp where\n  toJSON = genericToJSON stripPrefixUnderscoreIfAny\n\ndata StripeErrorBody = StripeErrorBody\n  { _type :: Text,\n    _code :: Maybe Text,\n    _message :: Maybe Text\n  }\n  deriving (Eq, Generic, Show)\n\ninstance FromJSON StripeErrorBody where\n  parseJSON = genericParseJSON stripPrefixUnderscoreIfAny\n\ninstance ToJSON StripeErrorBody where\n  toJSON = genericToJSON stripPrefixUnderscoreIfAny\n\n{-\napi_error:\tAPI errors cover any other type of problem (e.g., a temporary problem with Stripes servers), and are extremely uncommon.\ncard_error:\tCard errors are the most common type of error you should expect to handle. They result when the user enters a card that cant be charged for some reason.\nidempotency_error:\tIdempotency errors occur when an Idempotency-Key is re-used on a request that does not match the first requests API endpoint and parameters.\ninvalid_request_error:\tInvalid request errors arise when your request has invalid parameters.\nsource: https://docs.stripe.com/api/errors\n-}\ndata StripeError\n  = ApiError StripeErrorInfo -- issue from stripe side. ideally shouldn't happen, but if it does, just cancel booking and show user something went wrong please try again\n  | CardError StripeErrorInfo -- issue from user side, ask user to retry with another card and can show proper error message too to the user\n  | IdempotencyError StripeErrorInfo -- not sure when it will come. ideally shouldn't happen, but if it does, just cancel booking and show user something went wrong please try again\n  | InvalidRequestError StripeErrorInfo -- issue from our side. ideally shouldn't happen, but if it does, just cancel booking and show user something went wrong please try again\n  | SomethingWentWrong Text -- ideally shouldn't happen, but if it does, just cancel booking and show user something went wrong please try again\n  deriving (Eq, Show, IsBecknAPIError)\n\ndata StripeErrorInfo = StripeErrorInfo\n  { errorCode :: Maybe Text,\n    errorMessage :: Maybe Text\n  }\n  deriving (Eq, Generic)\n\ninstance Show StripeErrorInfo where\n  show (StripeErrorInfo code msg) =\n    maybe (showCode code) T.unpack msg\n    where\n      showCode :: Maybe Text -> String\n      showCode = maybe \"\" snakeToHuman\n\n      snakeToHuman :: Text -> String\n      snakeToHuman = intercalate \" \" . map (capitalize . show) . T.splitOn \"_\"\n\n      capitalize :: [Char] -> [Char]\n      capitalize [] = []\n      capitalize (x : xs) = toUpper x : xs\n\ninstanceExceptionWithParent 'HTTPException ''StripeError\n\ninstance FromResponse StripeError where\n  fromResponse resp = do\n    let mRespBody = decode $ responseBody resp\n    case mRespBody of\n      Just (resp_ :: StripeErrorResp) -> do\n        let respBody = resp_._error\n        let errorInfo = StripeErrorInfo respBody._code respBody._message\n        case respBody._type of\n          \"api_error\" -> Just $ ApiError errorInfo\n          \"card_error\" -> Just $ CardError errorInfo\n          \"idempotency_error\" -> Just $ IdempotencyError errorInfo\n          \"invalid_request_error\" -> Just $ InvalidRequestError errorInfo\n          _ -> Just $ SomethingWentWrong $ fromMaybe \"Something went wrong\" (respBody._message <|> respBody._code)\n      _ -> Just $ SomethingWentWrong \"Something went wrong\"\n\ninstance IsBaseError StripeError where\n  toMessage = \\case\n    ApiError info -> Just $ \"API Error: \" <> show info\n    CardError info -> Just $ \"Card Error: \" <> show info\n    IdempotencyError info -> Just $ \"Idempotency Error: \" <> show info\n    InvalidRequestError info -> Just $ \"Invalid Request Error: \" <> show info\n    SomethingWentWrong msg -> Just msg\n\ninstance IsHTTPError StripeError where\n  toErrorCode = \\case\n    ApiError _ -> \"STRIPE_API_ERROR\"\n    CardError _ -> \"STRIPE_CARD_ERROR\"\n    IdempotencyError _ -> \"STRIPE_IDEMPOTENCY_ERROR\"\n    InvalidRequestError _ -> \"STRIPE_INVALID_REQUEST_ERROR\"\n    SomethingWentWrong _ -> \"STRIPE_INTERNAL_ERROR\"\n\n  toHttpCode = \\case\n    ApiError _ -> E500\n    CardError _ -> E400\n    IdempotencyError _ -> E400\n    InvalidRequestError _ -> E400\n    SomethingWentWrong _ -> E500\n\ninstance IsAPIError StripeError\n",
      "hash": "37e023f8a11d3cf8fbc74f66c617e43d537762b757fb62e37baa2ce04ebaab37",
      "size": 5575
    },
    "/lib/mobility-core/src/Kernel/External/Payment/Stripe/Types/PaymentIntent.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n{-# LANGUAGE DerivingStrategies #-}\n{-# LANGUAGE InstanceSigs #-}\n\nmodule Kernel.External.Payment.Stripe.Types.PaymentIntent where\n\nimport Data.Aeson\nimport qualified Data.HashMap.Strict as HM\nimport Kernel.External.Payment.Stripe.Types.Common\nimport Kernel.Prelude\nimport Kernel.Types.Price\nimport Web.FormUrlEncoded\nimport Web.HttpApiData (ToHttpApiData (..))\n\ndata PaymentIntentReq = PaymentIntentReq\n  { amount :: Int,\n    currency :: Currency,\n    -- automatic_payment_methods :: AutomaticPayementMethods,\n    confirm :: Bool,\n    customer :: CustomerId,\n    description :: Maybe Text,\n    payment_method :: PaymentMethodId,\n    receipt_email :: Maybe Text,\n    setup_future_usage :: Maybe SetupFutureUsage,\n    application_fee_amount :: Int,\n    capture_method :: CaptureMethod,\n    confirmation_method :: ConfirmationMethod,\n    on_behalf_of :: AccountId,\n    use_stripe_sdk :: Bool,\n    return_url :: Text,\n    transfer_data :: TransferData\n  }\n  deriving stock (Show, Eq, Generic, Read)\n  deriving anyclass (FromJSON, ToJSON, ToSchema)\n\ninstance ToForm PaymentIntentReq where\n  toForm PaymentIntentReq {..} =\n    Form $\n      HM.fromListWith\n        (++)\n        [ (\"amount\", [toQueryParam amount]),\n          (\"currency\", [show currency]),\n          -- (\"automatic_payment_methods[enabled]\", [toQueryParam (automatic_payment_methods.enabled)]),\n          -- (\"automatic_payment_methods[allow_redirects]\", [toQueryParam (automatic_payment_methods.allow_redirects)]),\n          (\"confirm\", [toQueryParam confirm]),\n          (\"customer\", [toQueryParam customer]),\n          (\"payment_method\", [toQueryParam payment_method]),\n          (\"application_fee_amount\", [toQueryParam application_fee_amount]),\n          (\"capture_method\", [toQueryParam capture_method]),\n          (\"confirmation_method\", [toQueryParam confirmation_method]),\n          (\"on_behalf_of\", [toQueryParam on_behalf_of]),\n          (\"use_stripe_sdk\", [toQueryParam use_stripe_sdk]),\n          (\"return_url\", [toQueryParam return_url]),\n          (\"transfer_data[destination]\", [toQueryParam transfer_data.destination])\n        ]\n        <> maybeToForm \"description\" description\n        <> maybeToForm \"receipt_email\" receipt_email\n        <> maybeToForm \"setup_future_usage\" setup_future_usage\n    where\n      maybeToForm :: ToHttpApiData a => Text -> Maybe a -> HM.HashMap Text [Text]\n      maybeToForm key = maybe HM.empty (\\value -> HM.singleton key [toQueryParam value])\n\nnewtype TransferData = TransferData\n  { destination :: AccountId\n  }\n  deriving stock (Show, Eq, Generic, Read)\n  deriving anyclass (FromJSON, ToJSON, ToSchema)\n\ndata CaptureMethod = AutomaticCaptureMethod | AutomaticAsyncCaptureMethod | ManualCaptureMethod\n  deriving stock (Show, Eq, Generic, Read)\n  deriving anyclass (ToSchema)\n\ncaptureMethodJsonOptions :: Options\ncaptureMethodJsonOptions =\n  defaultOptions\n    { constructorTagModifier = \\case\n        \"AutomaticCaptureMethod\" -> \"automatic\"\n        \"AutomaticAsyncCaptureMethod\" -> \"automatic_async\"\n        \"ManualCaptureMethod\" -> \"manual\"\n        x -> x\n    }\n\ninstance ToHttpApiData CaptureMethod where\n  toQueryParam :: CaptureMethod -> Text\n  toQueryParam AutomaticCaptureMethod = \"automatic\"\n  toQueryParam AutomaticAsyncCaptureMethod = \"automatic_async\"\n  toQueryParam ManualCaptureMethod = \"manual\"\n\ninstance FromJSON CaptureMethod where\n  parseJSON = genericParseJSON captureMethodJsonOptions\n\ninstance ToJSON CaptureMethod where\n  toJSON = genericToJSON captureMethodJsonOptions\n\ndata ConfirmationMethod = AutomaticConfirmationMethod | ManualConfirmationMethod\n  deriving stock (Show, Eq, Generic, Read)\n  deriving anyclass (ToSchema)\n\nconfirmationMethodJsonOptions :: Options\nconfirmationMethodJsonOptions =\n  defaultOptions\n    { constructorTagModifier = \\case\n        \"AutomaticConfirmationMethod\" -> \"automatic\"\n        \"ManualConfirmationMethod\" -> \"manual\"\n        x -> x\n    }\n\ninstance ToHttpApiData ConfirmationMethod where\n  toQueryParam :: ConfirmationMethod -> Text\n  toQueryParam AutomaticConfirmationMethod = \"automatic\"\n  toQueryParam ManualConfirmationMethod = \"manual\"\n\ninstance FromJSON ConfirmationMethod where\n  parseJSON = genericParseJSON confirmationMethodJsonOptions\n\ninstance ToJSON ConfirmationMethod where\n  toJSON = genericToJSON confirmationMethodJsonOptions\n\ndata PaymentIntentObject = PaymentIntentObject\n  { id :: PaymentIntentId,\n    amount :: Maybe Int,\n    client_secret :: Text,\n    latest_charge :: Maybe Text,\n    status :: PaymentIntentStatus,\n    -- automatic_payment_methods :: Maybe AutomaticPayementMethods,\n    -- confirm :: Maybe Bool,\n    customer_id :: Maybe CustomerId,\n    description :: Maybe Text,\n    payment_method :: Maybe Text,\n    receipt_email :: Maybe Text,\n    -- setup_future_usage :: Maybe SetupFutureUsage,\n    application_fee_amount :: Maybe Int,\n    -- capture_method :: Maybe CaptureMethod,\n    -- confirmation_method :: Maybe ConfirmationMethod,\n    on_behalf_of :: Maybe AccountId,\n    use_stripe_sdk :: Maybe Bool\n  }\n  deriving stock (Show, Eq, Generic, Read)\n  deriving anyclass (FromJSON, ToJSON, ToSchema)\n\nnewtype ConfirmPaymentIntentReq = ConfirmPaymentIntentReq\n  { payment_method :: PaymentMethodId\n  }\n  deriving stock (Show, Eq, Generic, Read)\n  deriving anyclass (FromJSON, ToJSON, ToSchema)\n\ninstance ToForm ConfirmPaymentIntentReq where\n  toForm ConfirmPaymentIntentReq {..} = Form $ HM.singleton \"payment_method\" [toQueryParam payment_method]\n\ndata CapturePaymentIntentReq = CapturePaymentIntentReq\n  { amount_to_capture :: Int,\n    application_fee_amount :: Int\n  }\n  deriving stock (Show, Eq, Generic, Read)\n  deriving anyclass (FromJSON, ToJSON, ToSchema)\n\ninstance ToForm CapturePaymentIntentReq where\n  toForm CapturePaymentIntentReq {..} =\n    Form $\n      HM.fromList\n        [ (\"amount_to_capture\", [toQueryParam amount_to_capture]),\n          (\"application_fee_amount\", [toQueryParam application_fee_amount])\n        ]\n\ndata IncrementAuthorizationReq = IncrementAuthorizationReq\n  { amount :: Int,\n    application_fee_amount :: Int\n  }\n  deriving stock (Show, Eq, Generic, Read)\n  deriving anyclass (FromJSON, ToJSON, ToSchema)\n\ninstance ToForm IncrementAuthorizationReq where\n  toForm IncrementAuthorizationReq {..} =\n    Form $\n      HM.fromList\n        [ (\"amount\", [toQueryParam amount]),\n          (\"application_fee_amount\", [toQueryParam application_fee_amount])\n        ]\n",
      "hash": "77fbc348ed81c39fc2e2c6777e4535b95d1e2716b84630bfaadcb5e9468ef220",
      "size": 7084
    },
    "/lib/mobility-core/src/Kernel/External/Payment/Stripe/Types/SetupIntent.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n{-# LANGUAGE DerivingStrategies #-}\n\nmodule Kernel.External.Payment.Stripe.Types.SetupIntent where\n\nimport qualified Data.HashMap.Strict as HM\nimport Kernel.External.Payment.Stripe.Types.Common\nimport Kernel.Prelude\nimport Web.FormUrlEncoded\nimport Web.HttpApiData (ToHttpApiData (..))\n\ndata SetupIntentReq = SetupIntentReq\n  { automatic_payment_methods :: AutomaticPayementMethods,\n    confirm :: Bool,\n    customer :: CustomerId,\n    description :: Maybe Text,\n    payment_method :: Maybe Text,\n    usage :: Maybe SetupFutureUsage,\n    use_stripe_sdk :: Bool\n  }\n  deriving stock (Show, Eq, Generic, Read)\n  deriving anyclass (FromJSON, ToJSON, ToSchema)\n\ninstance ToForm SetupIntentReq where\n  toForm SetupIntentReq {..} =\n    Form $\n      HM.fromList\n        [ (\"automatic_payment_methods[enabled]\", [toQueryParam (automatic_payment_methods.enabled)]),\n          (\"automatic_payment_methods[allow_redirects]\", [toQueryParam (automatic_payment_methods.allow_redirects)]),\n          (\"confirm\", [toQueryParam confirm]),\n          (\"customer\", [toQueryParam customer]),\n          (\"use_stripe_sdk\", [toQueryParam use_stripe_sdk])\n        ]\n        <> maybeToForm \"description\" description\n        <> maybeToForm \"payment_method\" payment_method\n        <> maybeToForm \"usage\" usage\n    where\n      maybeToForm :: ToHttpApiData a => Text -> Maybe a -> HM.HashMap Text [Text]\n      maybeToForm key = maybe HM.empty (\\value -> HM.singleton key [toQueryParam value])\n\ndata SetupIntentObject = SetupIntentObject\n  { id :: SetupIntentId,\n    client_secret :: Text,\n    latest_charge :: Maybe Text,\n    status :: PaymentIntentStatus,\n    confirm :: Maybe Bool,\n    customer :: Maybe CustomerId,\n    description :: Maybe Text,\n    payment_method :: Maybe Text\n  }\n  deriving stock (Show, Eq, Generic, Read)\n  deriving anyclass (FromJSON, ToJSON, ToSchema)\n",
      "hash": "ef48f65e0668a4182d2b6bc6928b4b286f3d80a436fa4ef83480b0ca6e83b1f8",
      "size": 2541
    },
    "/lib/mobility-core/src/Kernel/External/Payment/Types.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n{-# LANGUAGE TemplateHaskell #-}\n\nmodule Kernel.External.Payment.Types where\n\nimport Data.Aeson.Types\nimport EulerHS.Prelude\nimport Kernel.Beam.Lib.UtilsTH (mkBeamInstancesForEnumAndList)\nimport Kernel.Storage.Esqueleto (derivePersistField)\n\ndata PaymentService = AAJuspay | Juspay | Stripe\n  deriving (Show, Read, Eq, Ord, Generic)\n\n$(mkBeamInstancesForEnumAndList ''PaymentService)\nderivePersistField \"PaymentService\"\n\n-- Generic instances for type with single value will not work\ninstance FromJSON PaymentService where\n  parseJSON (String \"Juspay\") = pure Juspay\n  parseJSON (String \"AAJuspay\") = pure AAJuspay\n  parseJSON (String \"Stripe\") = pure Stripe\n  parseJSON (String _) = parseFail \"Expected \\\"Juspay\\\"\"\n  parseJSON e = typeMismatch \"String\" e\n\ninstance ToJSON PaymentService where\n  toJSON = String . show\n",
      "hash": "a15d0c451d225c75b08e1fe54079e1ed59fd113e03a4b26452d13848e771cc84",
      "size": 1511
    },
    "/lib/mobility-core/src/Kernel/External/Payout/Interface.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\nmodule Kernel.External.Payout.Interface\n  ( module Reexport,\n    module Kernel.External.Payout.Interface,\n  )\nwhere\n\nimport qualified Kernel.External.Payout.Interface.Juspay as Juspay\nimport Kernel.External.Payout.Interface.Types as Reexport\nimport Kernel.External.Payout.Types as Reexport\nimport Kernel.Prelude\nimport Kernel.Tools.Metrics.CoreMetrics (CoreMetrics)\nimport Kernel.Utils.Common\n\ncreatePayoutOrder ::\n  ( EncFlow m r,\n    CoreMetrics m,\n    HasFlowEnv m r '[\"selfBaseUrl\" ::: BaseUrl]\n  ) =>\n  PayoutServiceConfig ->\n  Maybe Text ->\n  CreatePayoutOrderReq ->\n  m CreatePayoutOrderResp\ncreatePayoutOrder serviceConfig mRoutingId req = case serviceConfig of\n  JuspayConfig cfg -> Juspay.createPayoutOrder cfg mRoutingId req\n\npayoutOrderStatus ::\n  ( EncFlow m r,\n    CoreMetrics m\n  ) =>\n  PayoutServiceConfig ->\n  Maybe Text ->\n  PayoutOrderStatusReq ->\n  m PayoutOrderStatusResp\npayoutOrderStatus serviceConfig mRoutingId req = case serviceConfig of\n  JuspayConfig cfg -> Juspay.payoutOrderStatus cfg req.orderId mRoutingId req.mbExpand\n",
      "hash": "d451e823343dd066b3befcad4b6f9209a26c472b81583b10d79844a883e5b5a8",
      "size": 1744
    },
    "/lib/mobility-core/src/Kernel/External/Payout/Interface/Juspay.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n{-# LANGUAGE PackageImports #-}\n\nmodule Kernel.External.Payout.Interface.Juspay\n  ( module Reexport,\n    payoutOrderStatusWebhook,\n    createPayoutOrder,\n    payoutOrderStatus,\n  )\nwhere\n\nimport qualified Data.Aeson as A\nimport qualified Data.ByteString.Lazy as BL\nimport qualified Data.HashMap.Strict as HM\nimport qualified Data.Text as T\nimport qualified Data.Text.Encoding as TE\nimport Kernel.External.Encryption\nimport Kernel.External.Payout.Interface.Types\nimport Kernel.External.Payout.Juspay.Config as Reexport\nimport qualified Kernel.External.Payout.Juspay.Flow as Juspay\nimport qualified Kernel.External.Payout.Juspay.Types as Juspay\nimport qualified Kernel.External.Payout.Juspay.Types.Payout as Payout\nimport qualified Kernel.External.Payout.Juspay.Webhook as Juspay\nimport Kernel.Prelude\nimport qualified Kernel.Tools.Metrics.CoreMetrics as Metrics\nimport Kernel.Types.Common\nimport Kernel.Types.Error\nimport Kernel.Types.Field\nimport Kernel.Utils.Error.Throwing (fromMaybeM)\nimport Kernel.Utils.Logging (logDebug)\nimport Servant hiding (throwError)\n\ncreatePayoutOrder ::\n  ( Metrics.CoreMetrics m,\n    EncFlow m r,\n    HasFlowEnv m r '[\"selfBaseUrl\" ::: BaseUrl]\n  ) =>\n  JuspayConfig ->\n  Maybe Text ->\n  CreatePayoutOrderReq ->\n  m CreatePayoutOrderResp\ncreatePayoutOrder config mRoutingId req = do\n  let url = config.url\n      merchantId = config.merchantId\n  apiKey <- decrypt config.apiKey\n  orderReq <- mkCreatePayoutOrderReq req\n  mkCreatePayoutOrderResp <$> Juspay.createPayoutOrder url apiKey merchantId mRoutingId orderReq\n  where\n    mkCreatePayoutOrderReq CreatePayoutOrderReq {..} = do\n      webhookDetails <- case isDynamicWebhookRequired of\n        True -> Just <$> mkDynamicWebhookDetails\n        False -> pure Nothing\n      return $\n        Juspay.CreatePayoutOrderReq\n          { amount = realToFrac amount,\n            fulfillments =\n              Just\n                [ Juspay.PayoutOrderReqFulfillment\n                    { amount = realToFrac amount,\n                      beneficiaryDetails =\n                        Just $\n                          Juspay.BeneficiaryDetails\n                            { details =\n                                Just\n                                  Payout.AccountDetails\n                                    { name = customerName,\n                                      vpa = Just customerVpa,\n                                      mobileNo = Just customerPhone\n                                    },\n                              detailsType = Just Juspay.UPI_ID\n                            },\n                      additionalInfo =\n                        Just $\n                          Payout.AdditionalInfo\n                            { webhookDetails = webhookDetails,\n                              remark = Just remark,\n                              isRetriable = Nothing,\n                              attemptThreshold = Nothing\n                            },\n                      udf1 = Nothing,\n                      udf2 = Nothing,\n                      udf3 = Nothing,\n                      udf4 = Nothing,\n                      udf5 = Nothing,\n                      preferredMethodList = Nothing\n                    }\n                ],\n            udf1 = Nothing,\n            udf2 = Nothing,\n            udf3 = Nothing,\n            udf4 = Nothing,\n            udf5 = Nothing,\n            orderType = orderType,\n            ..\n          }\n    mkCreatePayoutOrderResp Payout.PayoutOrderResp {..} = do\n      CreatePayoutOrderResp\n        { amount = realToFrac amount,\n          ..\n        }\n\n    mkDynamicWebhookDetails = do\n      appBaseUrl <- asks (.selfBaseUrl)\n      password_ <- decrypt config.password\n      dynamicWebhookUrl <- config.dynamicWebhookUrl & fromMaybeM (InvalidRequest \"Dynamic webhook URL not found\")\n      let baseUrl = appBaseUrl {baseUrlPath = baseUrlPath appBaseUrl <> (T.unpack dynamicWebhookUrl)}\n          url = showBaseUrl baseUrl\n      let customHeaderList = [(\"X-MerchantId\", config.merchantId)] :: [(Text, Text)]\n          customHeader :: Text = TE.decodeUtf8 $ BL.toStrict $ A.encode $ HM.fromList customHeaderList\n      logDebug $ \"WebhookDetails: username: \" <> show config.username <> \" dynamicWebhookUrl: \" <> show dynamicWebhookUrl <> \" password: \" <> show password_ <> \" header: \" <> show customHeader <> \" webhookUrl: \" <> show url\n      return $ Payout.WebhookDetails {username = Just config.username, password = Just password_, customHeader = Just customHeader, url = Just url}\n\npayoutOrderStatus ::\n  ( Metrics.CoreMetrics m,\n    EncFlow m r\n  ) =>\n  JuspayConfig ->\n  Text ->\n  Maybe Text ->\n  Maybe Expand ->\n  m PayoutOrderStatusResp\npayoutOrderStatus config orderId' mRoutingId mbExpand = do\n  let url = config.url\n      merchantId = config.merchantId\n  apiKey <- decrypt config.apiKey\n  mkPayoutOrderStatusResp <$> Juspay.payoutOrderStatus url apiKey merchantId mRoutingId orderId' mbExpand\n  where\n    mkPayoutOrderStatusResp Payout.PayoutOrderResp {..} = do\n      CreatePayoutOrderResp\n        { amount = realToFrac amount,\n          ..\n        }\n\npayoutOrderStatusWebhook ::\n  EncFlow m r =>\n  PayoutServiceConfig ->\n  BasicAuthData ->\n  A.Value ->\n  m (Maybe OrderStatusPayoutResp)\npayoutOrderStatusWebhook payoutConfig authData val = do\n  response <- Juspay.payoutOrderStatusWebhook payoutConfig authData val\n  return $ mkWebhookOrderStatusPayoutResp <$> response\n\nmkWebhookOrderStatusPayoutResp :: Juspay.PayoutWebhookReq -> OrderStatusPayoutResp\nmkWebhookOrderStatusPayoutResp payoutReq = case payoutReq.label of\n  Just \"ORDER\" -> parsePayoutWebhook -- consuming only order level webhooks\n  _ -> BadStatusResp\n  where\n    parsePayoutWebhook =\n      OrderStatusPayoutResp\n        { payoutOrderId = payoutReq.info.merchantOrderId,\n          payoutStatus = payoutReq.info.status,\n          orderType = payoutReq.info._type,\n          merchantCustomerId = payoutReq.info.merchantCustomerId,\n          amount = realToFrac payoutReq.info.amount,\n          createdAt = payoutReq.info.createdAt,\n          updatedAt = payoutReq.info.updatedAt\n        }\n",
      "hash": "e8d1499c70bbabaedd5da18e3adfc1a7958422c7b89501bd07824590b3898f21",
      "size": 6778
    },
    "/lib/mobility-core/src/Kernel/External/Payout/Interface/Types.hs": {
      "type": "content",
      "content": "{-# LANGUAGE DerivingStrategies #-}\n{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n{-# LANGUAGE OverloadedLists #-}\n{-# LANGUAGE TemplateHaskell #-}\n{-# OPTIONS_GHC -Wwarn=incomplete-record-updates #-}\n\nmodule Kernel.External.Payout.Interface.Types\n  ( module Kernel.External.Payout.Interface.Types,\n    module Reexport,\n  )\nwhere\n\nimport Kernel.Beam.Lib.UtilsTH (mkBeamInstancesForEnum)\nimport qualified Kernel.External.Payout.Juspay.Config as Juspay\nimport Kernel.External.Payout.Juspay.Types as Reexport (Fulfillment (..), PayoutOrderStatus (..))\nimport Kernel.Prelude\nimport Kernel.Storage.Esqueleto (derivePersistField)\nimport Kernel.Types.Common hiding (Currency)\nimport Servant.API (ToHttpApiData (..))\n\ndata PayoutServiceConfig = JuspayConfig Juspay.JuspayConfig\n  deriving (Show, Eq, Generic, ToJSON, FromJSON)\n\ndata OrderStatusPayoutResp\n  = OrderStatusPayoutResp\n      { payoutOrderId :: Text,\n        payoutStatus :: PayoutOrderStatus,\n        orderType :: Maybe Text,\n        merchantCustomerId :: Maybe Text,\n        amount :: HighPrecMoney,\n        createdAt :: Maybe Text,\n        updatedAt :: Maybe Text\n      }\n  | BadStatusResp\n  deriving stock (Show, Read, Eq, Generic)\n  deriving anyclass (FromJSON, ToJSON, ToSchema)\n\ndata CreatePayoutOrderReq = CreatePayoutOrderReq\n  { orderId :: Text,\n    amount :: HighPrecMoney,\n    customerPhone :: Text,\n    customerEmail :: Text,\n    customerId :: Text,\n    orderType :: Text,\n    remark :: Text,\n    customerName :: Text,\n    customerVpa :: Text,\n    isDynamicWebhookRequired :: Bool\n  }\n  deriving stock (Show, Eq, Generic)\n  deriving anyclass (FromJSON, ToJSON, ToSchema)\n\ndata CreatePayoutOrderResp = CreatePayoutOrderResp\n  { orderId :: Text,\n    status :: PayoutOrderStatus,\n    orderType :: Maybe Text,\n    udf1 :: Maybe Text,\n    udf2 :: Maybe Text,\n    udf3 :: Maybe Text,\n    udf4 :: Maybe Text,\n    udf5 :: Maybe Text,\n    amount :: HighPrecMoney,\n    refunds :: Maybe [Text],\n    payments :: Maybe [Text],\n    fulfillments :: Maybe [Fulfillment],\n    customerId :: Maybe Text\n  }\n  deriving (Show, Generic)\n  deriving anyclass (FromJSON, ToJSON, ToSchema)\n\ndata Expand = ExpandFulfillment | ExpandPayment | ExpandRefund\n  deriving (Show, Eq, Generic, FromJSON, ToJSON, ToSchema, Ord, Read)\n\n$(mkBeamInstancesForEnum ''Expand)\n\nderivePersistField \"Expand\"\n\ninstance ToHttpApiData Expand where\n  toUrlPiece ExpandFulfillment = \"fulfillment\"\n  toUrlPiece ExpandPayment = \"payment\"\n  toUrlPiece ExpandRefund = \"refund\"\n\ndata PayoutOrderStatusReq = PayoutOrderStatusReq\n  { orderId :: Text,\n    mbExpand :: Maybe Expand\n  }\n  deriving (Show, Generic)\n  deriving anyclass (FromJSON, ToJSON)\n\ntype PayoutOrderStatusResp = CreatePayoutOrderResp\n",
      "hash": "eee321b5e957353440f4f02d8901bb58768b7bfb9e207a9d2f8c3bb8b18ddc27",
      "size": 3358
    },
    "/lib/mobility-core/src/Kernel/External/Payout/Juspay/Config.hs": {
      "type": "content",
      "content": "{-\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n{-# LANGUAGE DerivingStrategies #-}\n\nmodule Kernel.External.Payout.Juspay.Config where\n\nimport Data.Aeson\nimport Kernel.External.Encryption\nimport Kernel.Prelude\n\ndata JuspayConfig = JuspayConfig\n  { apiKey :: EncryptedField 'AsEncrypted Text,\n    returnUrl :: BaseUrl,\n    url :: BaseUrl,\n    merchantId :: Text,\n    username :: Text,\n    password :: EncryptedField 'AsEncrypted Text,\n    gatewayReferenceId :: Maybe Text,\n    dynamicWebhookUrl :: Maybe Text\n  }\n  deriving stock (Show, Eq, Generic)\n  deriving anyclass (FromJSON, ToJSON)\n",
      "hash": "4d2ffdd9579b43d6c1bf32f4123bcd878b570b7cb720a1b116fcaf9ff1ca4f67",
      "size": 1190
    },
    "/lib/mobility-core/src/Kernel/External/Payout/Juspay/Flow.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n\nmodule Kernel.External.Payout.Juspay.Flow where\n\nimport qualified Data.Text.Encoding as DT\nimport EulerHS.Types as Euler\nimport qualified Kernel.External.Payout.Interface.Types as Payout\nimport Kernel.External.Payout.Juspay.Types\nimport Kernel.Prelude\nimport Kernel.Tools.Metrics.CoreMetrics as Metrics\nimport Kernel.Types.Common\nimport Kernel.Types.Error (GenericError (InternalError))\nimport Kernel.Utils.Common (callAPI, fromEitherM)\nimport Servant hiding (throwError)\n\nmkBasicAuthData :: Text -> BasicAuthData\nmkBasicAuthData apiKey =\n  BasicAuthData\n    { basicAuthUsername = DT.encodeUtf8 apiKey,\n      basicAuthPassword = \"\"\n    }\n\ntype CreatePayoutOrderAPI =\n  \"payout\" :> \"merchant\" :> \"v1\" :> \"orders\"\n    :> BasicAuth \"username-password\" BasicAuthData\n    :> Header \"x-merchantid\" Text\n    :> Header \"x-routing-id\" Text\n    :> ReqBody '[JSON] CreatePayoutOrderReq\n    :> Post '[JSON] CreatePayoutOrderResp\n\ncreatePayoutOrder ::\n  (Metrics.CoreMetrics m, MonadFlow m) =>\n  BaseUrl ->\n  Text ->\n  Text ->\n  Maybe Text ->\n  CreatePayoutOrderReq ->\n  m CreatePayoutOrderResp\ncreatePayoutOrder url apiKey merchantId mRoutingId req = do\n  let proxy = Proxy @CreatePayoutOrderAPI\n      eulerClient = Euler.client proxy (mkBasicAuthData apiKey) (Just merchantId) mRoutingId req\n  callAPI url eulerClient \"create-payout-order\" proxy\n    >>= fromEitherM (\\err -> InternalError $ \"Failed to call create payout order API: \" <> show err)\n\ntype PayoutOrderStatusAPI =\n  \"payout\" :> \"merchant\" :> \"v1\" :> \"orders\"\n    :> Capture \"orderId\" Text\n    :> BasicAuth \"username-password\" BasicAuthData\n    :> QueryParam \"expand\" Payout.Expand\n    :> Header \"x-merchantid\" Text\n    :> Header \"x-routing-id\" Text\n    :> Get '[JSON] PayoutOrderStatusResp\n\npayoutOrderStatus ::\n  (Metrics.CoreMetrics m, MonadFlow m) =>\n  BaseUrl ->\n  Text ->\n  Text ->\n  Maybe Text ->\n  Text ->\n  Maybe Payout.Expand ->\n  m PayoutOrderStatusResp\npayoutOrderStatus url apiKey merchantId mRoutingId orderId mbExpand = do\n  let proxy = Proxy @PayoutOrderStatusAPI\n      eulerClient = Euler.client proxy orderId (mkBasicAuthData apiKey) mbExpand (Just merchantId) mRoutingId\n  callAPI url eulerClient \"payout-order-status\" proxy\n    >>= fromEitherM (\\err -> InternalError $ \"Failed to call payout order status API: \" <> show err)\n",
      "hash": "594d20c767c596443ecaddf9e4d8129602d213d33564e45d4f8808d055e3112c",
      "size": 2989
    },
    "/lib/mobility-core/src/Kernel/External/Payout/Juspay/Types.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n\nmodule Kernel.External.Payout.Juspay.Types\n  ( module Reexport,\n  )\nwhere\n\nimport Kernel.External.Payout.Juspay.Types.Payout as Reexport\nimport Kernel.External.Payout.Juspay.Types.Webhook as Reexport\n  ( PayoutInfo (..),\n    PayoutWebhookReq (..),\n  )\n",
      "hash": "d63fb34343cbca52bede355fd19472a1e688fec4be9407e2b3beb82121175765",
      "size": 946
    },
    "/lib/mobility-core/src/Kernel/External/Payout/Juspay/Types/Payout.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n{-# LANGUAGE DerivingStrategies #-}\n{-# LANGUAGE TemplateHaskell #-}\n\nmodule Kernel.External.Payout.Juspay.Types.Payout where\n\nimport Data.Aeson as A\nimport Kernel.Beam.Lib.UtilsTH (mkBeamInstancesForEnum)\nimport Kernel.Prelude\n\n--------------------------------------------------------------------------\n-- Payout Create Order Types\n\ndata PayoutOrderStatus\n  = READY_FOR_FULFILLMENT\n  | FULFILLMENTS_SCHEDULED\n  | FULFILLMENTS_FAILURE\n  | FULFILLMENTS_SUCCESSFUL\n  | FULFILLMENTS_CANCELLED\n  | FULFILLMENTS_MANUAL_REVIEW\n  | FULFILLED_PARTIALLY\n  | INITIATED\n  | FAILURE\n  | SUCCESS\n  | DISCARDED\n  | MANUAL_REVIEW\n  | CANCELLED\n  | GATEWAY_SWITCHED\n  | ERROR\n  | INVALID\n  | VALID\n  | CONFLICTED\n  | REVERSED\n  deriving (Show, Generic, Ord, Read, FromJSON, ToJSON, ToSchema, Eq)\n\n$(mkBeamInstancesForEnum ''PayoutOrderStatus)\n\ndata WebhookDetails = WebhookDetails\n  { username :: Maybe Text,\n    password :: Maybe Text,\n    url :: Maybe Text,\n    customHeader :: Maybe Text\n  }\n  deriving (Show, Generic, ToSchema, Eq)\n  deriving anyclass (FromJSON, ToJSON)\n\ndata AdditionalInfo = AdditionalInfo\n  { webhookDetails :: Maybe WebhookDetails,\n    remark :: Maybe Text,\n    isRetriable :: Maybe Bool,\n    attemptThreshold :: Maybe Int\n  }\n  deriving (Show, Generic, ToSchema)\n  deriving anyclass (FromJSON, ToJSON)\n\ndata AccountDetailsType = UPI_ID | ACCOUNT_IFSC\n  deriving (Show, Generic, Read, Ord, Eq, ToSchema)\n  deriving anyclass (FromJSON, ToJSON)\n\n$(mkBeamInstancesForEnum ''AccountDetailsType)\n\ndata AccountDetails = AccountDetails\n  { name :: Text,\n    vpa :: Maybe Text,\n    mobileNo :: Maybe Text\n  }\n  deriving (Show, Generic, ToSchema)\n  deriving anyclass (FromJSON, ToJSON)\n\ndata BeneficiaryDetails = BeneficiaryDetails\n  { details :: Maybe AccountDetails,\n    detailsType :: Maybe AccountDetailsType\n  }\n  deriving (Show, Generic, ToSchema)\n\njsonOptions_ :: Options\njsonOptions_ =\n  defaultOptions\n    { fieldLabelModifier = \\case\n        \"detailsType\" -> \"type\"\n        other -> other\n    }\n\ninstance FromJSON BeneficiaryDetails where\n  parseJSON = genericParseJSON jsonOptions_\n\ninstance ToJSON BeneficiaryDetails where\n  toJSON = genericToJSON jsonOptions_\n\ndata TxnResponse = TxnResponse\n  { status :: Text,\n    requestId :: Maybe Text,\n    amount :: Maybe Double\n  }\n  deriving (Show, Generic, ToSchema)\n  deriving anyclass (FromJSON, ToJSON)\n\ndata Transaction = Transaction\n  { txnResponse :: Maybe TxnResponse,\n    updatedAt :: Text,\n    transactionRef :: Text,\n    status :: Text,\n    responseMessage :: Maybe Text,\n    responseCode :: Maybe Text,\n    gatewayRefId :: Maybe Text,\n    fulfillmentMethod :: Maybe Text,\n    epgTxnId :: Maybe Text,\n    createdAt :: Text,\n    amount :: Double\n  }\n  deriving (Show, Generic, ToSchema)\n  deriving anyclass (FromJSON, ToJSON)\n\ndata Fulfillment = Fulfillment\n  { id :: Text,\n    udf2 :: Maybe Text,\n    udf1 :: Maybe Text,\n    status :: Text,\n    statusUpdatedAt :: Maybe Text,\n    preferredMethodList :: Maybe [Text],\n    merchantCustomerId :: Maybe Text,\n    fulfillmentMethodList :: Maybe [Text],\n    beneficiaryDetails :: Maybe BeneficiaryDetails,\n    amount :: Double,\n    additionalInfo :: Maybe AdditionalInfo,\n    transactions :: Maybe [Transaction],\n    createdAt :: Maybe Text,\n    updatedAt :: Text\n  }\n  deriving (Show, Generic, ToSchema)\n  deriving anyclass (FromJSON, ToJSON)\n\ndata PayoutOrderResp = PayoutOrderResp\n  { orderId :: Text,\n    status :: PayoutOrderStatus,\n    orderType :: Maybe Text,\n    udf1 :: Maybe Text,\n    udf2 :: Maybe Text,\n    udf3 :: Maybe Text,\n    udf4 :: Maybe Text,\n    udf5 :: Maybe Text,\n    amount :: Double,\n    refunds :: Maybe [Text], -- will always be Nothing in CreatePayoutOrderResp\n    payments :: Maybe [Text],\n    fulfillments :: Maybe [Fulfillment],\n    customerId :: Maybe Text\n  }\n  deriving (Show, Generic, ToSchema)\n\ninstance FromJSON PayoutOrderResp where\n  parseJSON = withObject \"PayoutOrderResp\" $ \\v ->\n    PayoutOrderResp\n      <$> v .: \"orderId\"\n      <*> v .: \"status\"\n      <*> v .:? \"type\"\n      <*> v .:? \"udf1\"\n      <*> v .:? \"udf2\"\n      <*> v .:? \"udf3\"\n      <*> v .:? \"udf4\"\n      <*> v .:? \"udf5\"\n      <*> v .: \"amount\"\n      <*> v .:? \"refunds\"\n      <*> v .:? \"payments\"\n      <*> v .:? \"fulfillments\"\n      <*> v .:? \"customerId\"\n\ninstance ToJSON PayoutOrderResp where\n  toJSON req =\n    object $\n      catMaybes\n        [ Just $ \"orderId\" .= req.orderId,\n          Just $ \"status\" .= req.status,\n          Just $ \"type\" .= req.orderType,\n          (\"udf1\" .=) <$> req.udf1,\n          (\"udf2\" .=) <$> req.udf2,\n          (\"udf3\" .=) <$> req.udf3,\n          (\"udf4\" .=) <$> req.udf4,\n          (\"udf5\" .=) <$> req.udf5,\n          Just $ \"amount\" .= req.amount,\n          (\"refunds\" .=) <$> req.refunds,\n          (\"payments\" .=) <$> req.fulfillments,\n          (\"fulfillments\" .=) <$> req.fulfillments,\n          Just $ \"customerId\" .= req.customerId\n        ]\n\ndata PayoutOrderReqFulfillment = PayoutOrderReqFulfillment\n  { udf1 :: Maybe Text,\n    udf2 :: Maybe Text,\n    udf3 :: Maybe Text,\n    udf4 :: Maybe Text,\n    udf5 :: Maybe Text,\n    preferredMethodList :: Maybe [Text],\n    amount :: Double,\n    additionalInfo :: Maybe AdditionalInfo,\n    beneficiaryDetails :: Maybe BeneficiaryDetails\n  }\n  deriving stock (Show, Generic)\n  deriving anyclass (FromJSON, ToJSON)\n\ndata CreatePayoutOrderReq = CreatePayoutOrderReq\n  { orderId :: Text,\n    orderType :: Text, -- FULFILL_ONLY for payout order creation\n    customerId :: Text,\n    amount :: Double,\n    udf1 :: Maybe Text,\n    udf2 :: Maybe Text,\n    udf3 :: Maybe Text,\n    udf4 :: Maybe Text,\n    udf5 :: Maybe Text,\n    customerPhone :: Text,\n    customerEmail :: Text,\n    fulfillments :: Maybe [PayoutOrderReqFulfillment]\n  }\n  deriving stock (Show, Generic)\n\ninstance ToJSON CreatePayoutOrderReq where\n  toJSON req =\n    object $\n      catMaybes\n        [ Just $ \"orderId\" .= req.orderId,\n          Just $ \"type\" .= req.orderType,\n          Just $ \"customerId\" .= req.customerId,\n          Just $ \"amount\" .= req.amount,\n          (\"udf1\" .=) <$> req.udf1,\n          (\"udf2\" .=) <$> req.udf2,\n          (\"udf3\" .=) <$> req.udf3,\n          (\"udf4\" .=) <$> req.udf4,\n          (\"udf5\" .=) <$> req.udf5,\n          Just $ \"customerPhone\" .= req.customerPhone,\n          Just $ \"customerEmail\" .= req.customerEmail,\n          (\"fulfillments\" .=) <$> req.fulfillments\n        ]\n\ninstance FromJSON CreatePayoutOrderReq where\n  parseJSON = withObject \"CreatePayoutOrderReq\" $ \\v ->\n    CreatePayoutOrderReq\n      <$> v .: \"orderId\"\n      <*> v .: \"type\"\n      <*> v .: \"customerId\"\n      <*> v .: \"amount\"\n      <*> v .:? \"udf1\"\n      <*> v .:? \"udf2\"\n      <*> v .:? \"udf3\"\n      <*> v .:? \"udf4\"\n      <*> v .:? \"udf5\"\n      <*> v .: \"customerPhone\"\n      <*> v .: \"customerEmail\"\n      <*> v .:? \"fulfillments\"\n\n---------------------------------------------------------------------------\n-- Payout Order Status Types\n\ntype PayoutOrderStatusResp = PayoutOrderResp\n\ntype CreatePayoutOrderResp = PayoutOrderResp\n",
      "hash": "6469e84eeeacf76d43e85135fbb9e5e1df5683347401a132a2bcd8ed55dc7128",
      "size": 7705
    },
    "/lib/mobility-core/src/Kernel/External/Payout/Juspay/Types/Webhook.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n{-# LANGUAGE DerivingVia #-}\n{-# LANGUAGE ScopedTypeVariables #-}\n\nmodule Kernel.External.Payout.Juspay.Types.Webhook where\n\nimport Data.Aeson\nimport qualified Kernel.External.Payout.Juspay.Types.Payout as Payout\nimport Kernel.Prelude\nimport Kernel.Utils.JSON\n\ndata PayoutWebhookReq = PayoutWebhookReq\n  { id :: Text,\n    label :: Maybe Text,\n    value :: Maybe Text,\n    category :: Maybe Text,\n    info :: PayoutInfo\n  }\n  deriving stock (Show, Generic)\n  deriving anyclass (FromJSON, ToJSON, ToSchema)\n\ndata PayoutInfo = PayoutInfo\n  { id :: Text,\n    status :: Payout.PayoutOrderStatus,\n    _type :: Maybe Text,\n    merchantOrderId :: Text,\n    amount :: Double,\n    merchantCustomerId :: Maybe Text,\n    createdAt :: Maybe Text,\n    updatedAt :: Maybe Text\n  }\n  deriving (Show, Generic, ToSchema)\n\ninstance FromJSON PayoutInfo where\n  parseJSON = genericParseJSON stripPrefixUnderscoreIfAny\n\ninstance ToJSON PayoutInfo where\n  toJSON = genericToJSON stripPrefixUnderscoreIfAny\n",
      "hash": "38028f3476fd5bbaee924ecfe1d57b426fd18957f7e63800d2a7fe621de4872a",
      "size": 1676
    },
    "/lib/mobility-core/src/Kernel/External/Payout/Juspay/Webhook.hs": {
      "type": "content",
      "content": "{-\n Copyright 2022-23, Juspay India Pvt Ltd\n\n This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program\n\n is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n\n or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of\n\n the GNU Affero General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n\nmodule Kernel.External.Payout.Juspay.Webhook where\n\nimport Data.Aeson.Types as DAT\nimport qualified Data.Text.Encoding as DT\nimport EulerHS.Prelude\nimport Kernel.External.Encryption\nimport Kernel.External.Payout.Interface.Types\nimport qualified Kernel.External.Payout.Juspay.Types as Juspay\nimport Kernel.Types.Error\nimport Kernel.Utils.Common\nimport Servant hiding (throwError)\n\ntype JuspayPayoutWebhookAPI =\n  \"service\" :> \"juspay\" :> \"payout\"\n    :> BasicAuth \"username-password\" BasicAuthData\n    :> ReqBody '[JSON] Value\n    :> Post '[JSON] AckResponse\n\npayoutOrderStatusWebhook ::\n  EncFlow m r =>\n  PayoutServiceConfig ->\n  BasicAuthData ->\n  Value ->\n  m (Maybe Juspay.PayoutWebhookReq)\npayoutOrderStatusWebhook payoutConfig authData val = do\n  withLogTag \"webhookPayoutOrderStatus\" $ do\n    let mResp = fromJSON val\n    case mResp of\n      DAT.Success (resp :: Juspay.PayoutWebhookReq) -> do\n        void $ verifyAuth payoutConfig authData\n        pure (Just resp)\n      DAT.Error err -> do\n        logInfo $ \"PayoutOrderStatus Parsing failed :: \" <> show err\n        pure Nothing\n\nverifyAuth ::\n  EncFlow m r =>\n  PayoutServiceConfig ->\n  BasicAuthData ->\n  m ()\nverifyAuth config authData = do\n  (username, password) <- case config of\n    JuspayConfig cfg -> do\n      cfgPassword <- decrypt cfg.password\n      return (cfg.username, cfgPassword)\n  unless (basicAuthUsername authData == DT.encodeUtf8 username && basicAuthPassword authData == DT.encodeUtf8 password) $\n    throwError (InvalidRequest \"INVALID_AUTHORIZATION_HEADER\")\n",
      "hash": "f889d4bb5280ae97a7cb040d1075ff292862ae16692c7e9816dc4a08a4fd21ce",
      "size": 2229
    },
    "/lib/mobility-core/src/Kernel/External/Payout/Types.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n{-# LANGUAGE TemplateHaskell #-}\n\nmodule Kernel.External.Payout.Types where\n\nimport Data.Aeson.Types\nimport EulerHS.Prelude\nimport Kernel.Beam.Lib.UtilsTH (mkBeamInstancesForEnumAndList)\nimport Kernel.Storage.Esqueleto (derivePersistField)\n\ndata PayoutService = AAJuspay | Juspay\n  deriving (Show, Read, Eq, Ord, Generic)\n\n$(mkBeamInstancesForEnumAndList ''PayoutService)\nderivePersistField \"PayoutService\"\n\n-- Generic instances for type with single value will not work\ninstance FromJSON PayoutService where\n  parseJSON (String \"AAJuspay\") = pure AAJuspay\n  parseJSON (String \"Juspay\") = pure Juspay\n  parseJSON (String _) = parseFail \"Expected \\\"Juspay\\\"\"\n  parseJSON e = typeMismatch \"String\" e\n\ninstance ToJSON PayoutService where\n  toJSON = String . show\n",
      "hash": "e2b3c60d30cd374118fb3c6f011459a2bad0e7ee980eaca15d9c2c03742bbc97",
      "size": 1452
    },
    "/lib/mobility-core/src/Kernel/External/SMS.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n\nmodule Kernel.External.SMS (module Reexport) where\n\nimport Kernel.External.SMS.Interface as Reexport\n",
      "hash": "7f07410ff86c0f6a55af43ff92d032803ffcb6e91036fd6ec63f6de5d54089f3",
      "size": 795
    },
    "/lib/mobility-core/src/Kernel/External/SMS/DigoEngage/API.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n\nmodule Kernel.External.SMS.DigoEngage.API where\n\nimport EulerHS.Prelude\nimport Kernel.External.SMS.DigoEngage.Types\nimport Servant hiding (throwError)\n\ntype DigoEngageAPI =\n  \"v1\" :> \"messaging\"\n    :> \"sms\"\n    :> Header \"X-Authorization\" Text\n    :> Header \"Authorization\" Text\n    :> ReqBody '[JSON] SubmitSmsReq\n    :> Post '[JSON] SubmitSmsRes\n\ndigoConnectAPI :: Proxy DigoEngageAPI\ndigoConnectAPI = Proxy\n",
      "hash": "d462e7e8a9305ec45a2fc7d26be769084755e0ca60c58a3fe61953682a685356",
      "size": 1105
    },
    "/lib/mobility-core/src/Kernel/External/SMS/DigoEngage/Config.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n\nmodule Kernel.External.SMS.DigoEngage.Config where\n\nimport Data.Aeson (FromJSON (..), ToJSON (..), defaultOptions, fieldLabelModifier, genericParseJSON, genericToJSON)\nimport Data.Text (Text)\nimport GHC.Generics (Generic)\nimport Kernel.External.Encryption\nimport Kernel.External.SMS.DigoEngage.Types\nimport Kernel.Prelude (Eq, HasField (hasField), Show)\nimport Servant.Client (BaseUrl)\n\ndata DigoEngageSmsCfg = DigoEngageSmsCfg\n  { apiKey :: EncryptedField 'AsEncrypted Text,\n    apiToken :: EncryptedField 'AsEncrypted Text,\n    from :: Text,\n    username :: Text,\n    url :: BaseUrl,\n    tiny :: Text,\n    messageType :: Text,\n    tlv :: TLVForSmsCfg,\n    dlr :: ClientDomain\n  }\n  deriving (Show, Eq, Generic)\n\ninstance FromJSON DigoEngageSmsCfg where\n  parseJSON =\n    genericParseJSON\n      defaultOptions\n        { fieldLabelModifier = \\case\n            \"messageType\" -> \"type\"\n            other -> other\n        }\n\ninstance ToJSON DigoEngageSmsCfg where\n  toJSON =\n    genericToJSON\n      defaultOptions\n        { fieldLabelModifier = \\case\n            \"messageType\" -> \"type\"\n            other -> other\n        }\n",
      "hash": "405741a1343335705763e4ebad6c03f72c577ce43f57fff95b7b1fa0055341c3",
      "size": 1815
    },
    "/lib/mobility-core/src/Kernel/External/SMS/DigoEngage/Flow.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n\nmodule Kernel.External.SMS.DigoEngage.Flow where\n\nimport EulerHS.Prelude\nimport EulerHS.Types as ET\nimport Kernel.External.Encryption (decrypt)\nimport Kernel.External.SMS.DigoEngage.API\nimport Kernel.External.SMS.DigoEngage.Config\nimport Kernel.External.SMS.DigoEngage.Types\nimport Kernel.Tools.Metrics.CoreMetrics (CoreMetrics)\nimport Kernel.Types.Common\nimport Kernel.Types.Error\nimport Kernel.Utils.Common as B\nimport Servant.Client\n\nsendOTPApi ::\n  ( CoreMetrics m,\n    MonadFlow m,\n    EncFlow m r\n  ) =>\n  DigoEngageSmsCfg ->\n  SubmitSmsReq ->\n  m SubmitSmsRes\nsendOTPApi digoEngageSmsCfg req = do\n  apiKey_ <- decrypt digoEngageSmsCfg.apiKey\n  apiToken_ <- decrypt digoEngageSmsCfg.apiToken\n  let authHeader = Just $ \"Bearer \" <> apiKey_\n  let authToken = Just $ \"Basic \" <> apiToken_\n  let eulerClient = ET.client (Proxy @DigoEngageAPI)\n  res <-\n    callAPI\n      digoEngageSmsCfg.url\n      (eulerClient authToken authHeader req)\n      \"sendOTPApi\"\n      (Proxy @DigoEngageAPI)\n      >>= checkDigoEngageOptError digoEngageSmsCfg.url\n  logDebug $ \"DigoEngage response: \" <> show res\n  pure res\n\ncheckDigoEngageOptError :: (MonadThrow m, B.Log m) => BaseUrl -> Either ClientError SubmitSmsRes -> m SubmitSmsRes\ncheckDigoEngageOptError url res =\n  fromEitherM (digoEngageOptError url) res >>= validateResponseStatus\n\nvalidateResponseStatus :: (MonadThrow m, B.Log m) => SubmitSmsRes -> m SubmitSmsRes\nvalidateResponseStatus (SmsSuccess res) = pure (SmsSuccess res)\nvalidateResponseStatus (SmsError err) =\n  case err.status of\n    0 -> case err.errorDetails of\n      Just details -> do\n        logDebug $ \"DigoEngage validation error: \" <> show details\n        throwError $ DigoEngageValidationError err.message\n      Nothing -> throwError DigoEngageUnknownServerError\n    _ -> throwError DigoEngageUnknownServerError\n\ndigoEngageOptError :: BaseUrl -> ClientError -> ExternalAPICallError\ndigoEngageOptError = ExternalAPICallError (Just \"DIGOENGAGE_OPT_API_ERROR\")\n",
      "hash": "3a2f7ed9c253db86e36bc5f1b7c0ee66d9840e5a9b30caf89f50ea4e0edd7f08",
      "size": 2662
    },
    "/lib/mobility-core/src/Kernel/External/SMS/DigoEngage/Types.hs": {
      "type": "content",
      "content": "{-# LANGUAGE DeriveAnyClass #-}\n{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n{-# LANGUAGE DeriveGeneric #-}\n{-# LANGUAGE OverloadedStrings #-}\n{-# LANGUAGE ScopedTypeVariables #-}\n{-# LANGUAGE UndecidableInstances #-}\n\nmodule Kernel.External.SMS.DigoEngage.Types where\n\nimport Control.Applicative ((<|>))\nimport Data.Aeson (FromJSON (..), ToJSON (..), defaultOptions, genericParseJSON, genericToJSON)\nimport Data.Aeson.Types (Options (..))\nimport Data.Functor ((<$>))\nimport Data.Int (Int)\nimport Data.Text (Text)\nimport GHC.Generics (Generic)\nimport Kernel.Prelude (Eq, HasField (hasField), Maybe, Show)\nimport Servant.Client (BaseUrl)\n\ndata SubmitSmsReq = SubmitSmsReq\n  { from :: Text,\n    to :: Text,\n    msg :: Text,\n    dlr :: ClientDomain,\n    messageType :: Text,\n    tiny :: Text,\n    tlv :: TLVForSmsReq\n  }\n  deriving (Generic, Eq, Show)\n\ninstance FromJSON SubmitSmsReq where\n  parseJSON =\n    genericParseJSON\n      defaultOptions\n        { fieldLabelModifier = \\case\n            \"messageType\" -> \"type\"\n            other -> other\n        }\n\ninstance ToJSON SubmitSmsReq where\n  toJSON =\n    genericToJSON\n      defaultOptions\n        { fieldLabelModifier = \\case\n            \"messageType\" -> \"type\"\n            other -> other\n        }\n\ndata ClientDomain = ClientDomain\n  { mask :: Int,\n    url :: BaseUrl\n  }\n  deriving (Show, Eq, Generic, FromJSON, ToJSON)\n\ncustomOptions :: Options\ncustomOptions =\n  defaultOptions\n    { fieldLabelModifier = \\case\n        \"peId\" -> \"PE_ID\"\n        \"templateId\" -> \"TEMPLATE_ID\"\n        \"telemarketerId\" -> \"TELEMARKETER_ID\"\n        other -> other\n    }\n\ndata TLVForSmsReq = TLVForSmsReq\n  { peId :: Text,\n    templateId :: Text,\n    telemarketerId :: Text\n  }\n  deriving (Show, Generic, Eq)\n\ninstance FromJSON TLVForSmsReq where\n  parseJSON = genericParseJSON customOptions\n\ninstance ToJSON TLVForSmsReq where\n  toJSON = genericToJSON customOptions\n\ndata TLVForSmsCfg = TLVForSmsCfg\n  { peId :: Text,\n    telemarketerId :: Text\n  }\n  deriving (Show, Generic, Eq)\n\ninstance FromJSON TLVForSmsCfg where\n  parseJSON = genericParseJSON customOptions\n\ninstance ToJSON TLVForSmsCfg where\n  toJSON = genericToJSON customOptions\n\n-- Response when the SMS is successfully sent\ndata SmsSuccessResponse = SmsSuccessResponse\n  { id :: Text\n  }\n  deriving (Show, Generic)\n\ninstance FromJSON SmsSuccessResponse\n\ninstance ToJSON SmsSuccessResponse\n\n-- Response when there's an error (e.g., validation error)\ndata SmsErrorResponse = SmsErrorResponse\n  { status :: Int,\n    message :: Text,\n    errorDetails :: Maybe [SmsErrorDetail] -- Some errors might not have \"data\"\n  }\n  deriving (Show, Generic)\n\ninstance FromJSON SmsErrorResponse\n\ninstance ToJSON SmsErrorResponse\n\n-- Structure of validation error details\ndata SmsErrorDetail = SmsErrorDetail\n  { msg :: Text,\n    param :: Text,\n    location :: Text\n  }\n  deriving (Show, Generic)\n\ninstance FromJSON SmsErrorDetail\n\ninstance ToJSON SmsErrorDetail\n\n-- Final type to wrap both cases\ndata SubmitSmsRes\n  = SmsSuccess SmsSuccessResponse\n  | SmsError SmsErrorResponse\n  deriving (Show, Generic)\n\ninstance FromJSON SubmitSmsRes where\n  parseJSON v =\n    (SmsSuccess <$> parseJSON v) <|> (SmsError <$> parseJSON v)\n\ninstance ToJSON SubmitSmsRes where\n  toJSON (SmsSuccess res) = toJSON res\n  toJSON (SmsError err) = toJSON err\n",
      "hash": "8e033c88e595ff008a90db772d2137fdaf17efb70f9c21f19d7d8b78bf791cb7",
      "size": 3959
    },
    "/lib/mobility-core/src/Kernel/External/SMS/ExotelSms/API.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n\nmodule Kernel.External.SMS.ExotelSms.API where\n\nimport EulerHS.Prelude\nimport Kernel.External.SMS.ExotelSms.Types\nimport Servant hiding (throwError)\n\ntype ExotelConnectAPI =\n  BasicAuth \"apikey-apitoken\" BasicAuthData\n    :> ReqBody '[FormUrlEncoded] SubmitSmsReq\n    :> Post '[JSON] SubmitSmsResp\n\nexotelConnectAPI :: Proxy ExotelConnectAPI\nexotelConnectAPI = Proxy\n",
      "hash": "664bdea991874b1e801c5bb79d64322bd5e4d7e8f7f8d07403f7cba31cf2104d",
      "size": 1061
    },
    "/lib/mobility-core/src/Kernel/External/SMS/ExotelSms/Config.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n\nmodule Kernel.External.SMS.ExotelSms.Config where\n\nimport Kernel.External.Encryption\nimport Kernel.External.SMS.ExotelSms.Types\nimport Kernel.Prelude\n\ndata ExotelSmsCfg = ExotelSmsCfg\n  { apiKey :: EncryptedField 'AsEncrypted Text,\n    apiToken :: EncryptedField 'AsEncrypted Text,\n    sid :: ExotelSmsSID,\n    url :: ExotelURL\n  }\n  deriving (Show, Eq, Generic, ToJSON, FromJSON)\n",
      "hash": "2bdebdb7eef3060f082c9e5fee5057f992b56f2347e61daeb55493ac5674511a",
      "size": 1075
    },
    "/lib/mobility-core/src/Kernel/External/SMS/ExotelSms/Flow.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n\nmodule Kernel.External.SMS.ExotelSms.Flow where\n\nimport Data.Text as T\nimport EulerHS.Prelude\nimport EulerHS.Types as ET\nimport qualified Kernel.External.SMS.ExotelSms.API as API\nimport Kernel.External.SMS.ExotelSms.Types\nimport Kernel.Tools.Metrics.CoreMetrics (CoreMetrics)\nimport Kernel.Types.Common\nimport Kernel.Types.Error\nimport Kernel.Utils.Common as B\nimport Servant hiding (throwError)\nimport Servant.Client\n\ndefaultBaseUrlSms :: ExotelSmsSID -> ExotelURL -> BaseUrl\ndefaultBaseUrlSms sid exoUrl =\n  BaseUrl\n    { baseUrlScheme = Https,\n      baseUrlHost = getExotelAccountURL exoUrl,\n      baseUrlPort = 443,\n      baseUrlPath =\n        T.unpack $\n          \"/v1/Accounts/\"\n            <> getExotelSmsSID sid\n            <> \"/Sms/send.json\"\n    }\n\nsendOTPApi ::\n  ( CoreMetrics m,\n    MonadFlow m\n  ) =>\n  ExotelURL ->\n  BasicAuthData ->\n  ExotelSmsSID ->\n  Text ->\n  Text ->\n  Text ->\n  m\n    SubmitSmsResp\nsendOTPApi\n  url\n  authData\n  sid\n  otpSmsTemplate\n  phoneNumber\n  sender = do\n    let submitSmsReq = SubmitSmsReq sender phoneNumber otpSmsTemplate\n    let auth = authData\n    callExotelAPI\n      (defaultBaseUrlSms sid url)\n      (callExotel auth submitSmsReq)\n      \"sendOTPApi\"\n      API.exotelConnectAPI\n    where\n      callExotel auth submitSmsReq = ET.client API.exotelConnectAPI auth submitSmsReq\n\ncallExotelAPI :: CallAPI env api a\ncallExotelAPI =\n  callApiUnwrappingApiError\n    (identity @ExotelError)\n    Nothing\n    (Just \"EXOTEL_NOT_AVAILABLE\")\n    Nothing\n",
      "hash": "09cb405a055ef3ec243c57dbb63e5862ac2910c5576656291ddb2abe09c64700",
      "size": 2183
    },
    "/lib/mobility-core/src/Kernel/External/SMS/ExotelSms/Types.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n{-# LANGUAGE DeriveDataTypeable #-}\n{-# LANGUAGE DeriveGeneric #-}\n{-# LANGUAGE DerivingStrategies #-}\n{-# LANGUAGE GeneralizedNewtypeDeriving #-}\n{-# LANGUAGE OverloadedLists #-}\n{-# LANGUAGE OverloadedStrings #-}\n{-# LANGUAGE ScopedTypeVariables #-}\n{-# LANGUAGE StandaloneDeriving #-}\n{-# LANGUAGE TemplateHaskell #-}\n{-# LANGUAGE UndecidableInstances #-}\n\nmodule Kernel.External.SMS.ExotelSms.Types where\n\nimport Control.Lens.TH\nimport Data.Aeson.Casing\nimport Data.Aeson.TH\nimport Data.OpenApi (ToSchema)\nimport Data.Text as T\nimport Data.Text.Conversions\nimport EulerHS.Prelude\nimport Kernel.External.Call.Exotel.Types (ExotelAccountSID)\nimport Kernel.Storage.Esqueleto (derivePersistField)\nimport Kernel.Utils.JSON\nimport Kernel.Utils.TH\nimport Web.FormUrlEncoded (ToForm, toForm)\nimport Web.Internal.HttpApiData\n\ntype OtpTemplate = Text\n\n-- | Exotel Url token\nnewtype ExotelURL = ExotelURL\n  { getExotelAccountURL :: String\n  }\n  deriving newtype (Show)\n\nderiveIdentifierInstances ''ExotelURL\n\ndata SubmitSmsReq = SubmitSmsReq\n  { from :: Text,\n    -- String; Your customer's phone number.\n    -- If landline number, prefix it with STD code; Ex: 080XXXX2400\n    to :: Text,\n    -- Mobile number to which SMS has to be sent. Preferably in E.164 format. If not set, our system will try to match it with a\n    -- country and route the SMS\n    body :: Text\n    -- \tString; Content of your SMS; Max Length of the body cannot exceed\n    -- 2000 characters\n  }\n  deriving (Generic, Eq, Show)\n\ninstance ToForm SubmitSmsReq where\n  toForm SubmitSmsReq {..} =\n    [ (\"From\", toQueryParam from),\n      (\"To\", toQueryParam to),\n      (\"Body\", toQueryParam body)\n    ]\n\n-- | SMS direction\ndata ExotelSmsDirection\n  = INBOUND\n  | -- Incoming call\n\n    OUTBOUND_CALL\n  | --  messages initiated during a call\n    OUTBOUND_API\n  | -- messages initiated during a call\n\n    OUTBOUND_REPLY\n  -- messages initiated in response to an incoming message\n  deriving (Show, Eq, Read, Generic, ToSchema)\n\n$(deriveJSON constructorsWithHyphensToLowerOptions ''ExotelSmsDirection)\n\n-- | Overall sms status\ndata ExotelSmsStatus\n  = QUEUED\n  | -- SMS you have sent has been queued internally for delivery\n    SENDING\n  | -- in process of sending the SMS to upstream provider/gateway\n    FAILED_DND\n  | -- The delivery of the SMS failed because the number belongs to the TRAI NCPR list. This is applicable only for promotional SMS\n    SUBMITTED\n  | -- This means that the SMS you have sent has been submitted from our system to SMS Gateway\n    SENT\n  | --  The SMS was successfully delivered to the handset\n    FAILED\n  | -- The delivery of SMS failed. Please see DetailedStatusCode and DetailedStatus for further details.\n\n    INVALID_STATUS\n  deriving (Show, Eq, Read, Generic, ToSchema)\n\ninstance FromText ExotelSmsStatus where\n  fromText a =\n    case a of\n      \"queued\" -> QUEUED\n      \"sending\" -> SENDING\n      \"failed-dnd\" -> FAILED_DND\n      \"submitted\" -> SUBMITTED\n      \"failed\" -> FAILED\n      \"sent\" -> SENT\n      _ -> INVALID_STATUS\n\n$(deriveJSON constructorsWithHyphensToLowerOptions ''ExotelSmsStatus)\n\nderivePersistField \"ExotelSmsStatus\"\n\n-- an alpha-numeric unique identifier of the SMS\nnewtype ExotelSmsSID = ExotelSmsSID\n  { getExotelSmsSID :: Text\n  }\n  deriving (Show)\n\nderiveIdentifierInstances ''ExotelSmsSID\n\n-- | Exotel response body\ndata SubmitSmsRespBody = SubmitSmsRespBody\n  { exoSid :: ExotelSmsSID,\n    -- string; an alpha-numeric unique identifier of the call\n    exoAccountSid :: ExotelAccountSID,\n    -- Exotel account SID\n    exoFrom :: Text,\n    -- The phone number that will be called first\n    exoTo :: Text,\n    -- Your customer's phone number\n    exoDateCreated :: Text,\n    -- Time in format YYYY-MM-DD HH:mm:ss; The time when the SMS was received at our server\n    exoDateUpdated :: Text,\n    -- \tTime in format YYYY-MM-DD HH:mm:ss; The time when any property of this SMS was last updated by our server\n    exoDateSent :: Maybe Text,\n    -- Time in format YYYY-MM-DD HH:mm:ss; The time when the SMS was delivered to the recepient\n    exoBody :: Text,\n    -- String; The body of the SMS message sent\n    exoStatus :: ExotelSmsStatus,\n    exoDetailedStatus :: Maybe Text,\n    exoDetailedStatusCode :: Maybe Int,\n    exoPrice :: Maybe Double,\n    exoDirection :: ExotelSmsDirection,\n    -- \tExotels Detailed Status code corresponding to the DetailedStatus. Use this field to build decision making in your code\n    exoUri :: Text,\n    exoSmsUnits :: Maybe Int\n  }\n  deriving (Eq, Show, Generic)\n\n$(makeLenses ''SubmitSmsRespBody)\n\n$(deriveFromJSON (aesonPrefix pascalCase) ''SubmitSmsRespBody)\n$(deriveToJSON (aesonPrefix pascalCase) ''SubmitSmsRespBody)\n\n--  Exotel Sms response on success\nnewtype SubmitSmsResp = SubmitSmsResp\n  { exoSMSMessage :: SubmitSmsRespBody\n  }\n  deriving (Eq, Show, Generic)\n\n$(makeLenses ''SubmitSmsResp)\n\n$(deriveFromJSON (aesonPrefix pascalCase) ''SubmitSmsResp)\n$(deriveToJSON (aesonPrefix pascalCase) ''SubmitSmsResp)\n",
      "hash": "4b2cf7f5d2c7b98c9a3510fb80c0192c0c5fadfb346558cc10506c8c8f468c1c",
      "size": 5662
    },
    "/lib/mobility-core/src/Kernel/External/SMS/GupShup/API.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n\nmodule Kernel.External.SMS.GupShup.API where\n\nimport EulerHS.Prelude\nimport Kernel.External.SMS.GupShup.Types\nimport Kernel.Types.App\n  ( MandatoryQueryParam,\n  )\nimport Servant\n\ntype ServiceAPI =\n  \"GatewayAPI\"\n    :> \"rest\"\n    :> MandatoryQueryParam \"method\" Text\n    :> MandatoryQueryParam \"v\" Double\n    :> MandatoryQueryParam \"userid\" Text\n    :> MandatoryQueryParam \"password\" Text\n    :> MandatoryQueryParam \"send_to\" Text\n    :> MandatoryQueryParam \"msg\" Text\n    :> MandatoryQueryParam \"msg_type\" Text\n    :> MandatoryQueryParam \"auth_scheme\" Text\n    :> MandatoryQueryParam \"format\" Text\n    :> MandatoryQueryParam \"principalEntityId\" Text\n    :> MandatoryQueryParam \"dltTemplateId\" Text\n    :> MandatoryQueryParam \"mask\" Text\n    :> Get '[JSON] SubmitSmsRes\n\ngupShupConnectAPI :: Proxy ServiceAPI\ngupShupConnectAPI = Proxy\n",
      "hash": "3e3773d7b37dfd9f6a444c99f4a7d1384e1c2957ebdb1607b2cfe3641d9ec870",
      "size": 1529
    },
    "/lib/mobility-core/src/Kernel/External/SMS/GupShup/Config.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n\nmodule Kernel.External.SMS.GupShup.Config where\n\nimport Kernel.External.Encryption\nimport Kernel.Prelude\n\ndata GupShupCfg = GupShupCfg\n  { userName :: EncryptedField 'AsEncrypted Text,\n    password :: EncryptedField 'AsEncrypted Text,\n    url :: BaseUrl,\n    templateId :: EncryptedField 'AsEncrypted Text,\n    entityId :: EncryptedField 'AsEncrypted Text\n  }\n  deriving (Show, Eq, Generic, ToJSON, FromJSON)\n",
      "hash": "4013b57ef5caa4c282a1a0164032cdde3153561cc56b9ab403faa8d4c1b9d372",
      "size": 1103
    },
    "/lib/mobility-core/src/Kernel/External/SMS/GupShup/Flow.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n\nmodule Kernel.External.SMS.GupShup.Flow where\n\nimport Data.Text as T\nimport EulerHS.Prelude\nimport EulerHS.Types as ET\nimport Kernel.External.Encryption\nimport qualified Kernel.External.SMS.GupShup.API as API\nimport Kernel.External.SMS.GupShup.Config\nimport Kernel.External.SMS.GupShup.Types\n  ( SubmitSmsRes,\n  )\nimport Kernel.Tools.Metrics.CoreMetrics (CoreMetrics)\nimport Kernel.Types.Common\nimport Kernel.Types.Error\nimport Kernel.Utils.Common as B\nimport Servant.Client.Core (ClientError)\n\nsendOTPApi ::\n  ( CoreMetrics m,\n    MonadFlow m,\n    EncFlow m r\n  ) =>\n  Text ->\n  Text ->\n  Text ->\n  Text ->\n  Text ->\n  Text ->\n  Text ->\n  GupShupCfg ->\n  m SubmitSmsRes\nsendOTPApi\n  otpSmsTemplate\n  phoneNumber\n  gupShupUserId\n  gupShupPassword\n  gupShupEntityId\n  gupShupTemplateId\n  gupShupSender\n  gupShupSmsCfg =\n    callAPI\n      gupShupSmsCfg.url\n      (callGupShup \"SendMessage\" 1.1 gupShupUserId gupShupPassword phoneNumber otpSmsTemplate \"TEXT\" \"plain\" \"json\" gupShupEntityId gupShupTemplateId gupShupSender)\n      \"sendOTPApi\"\n      API.gupShupConnectAPI\n      >>= checkGupShupOptError gupShupSmsCfg.url\n    where\n      callGupShup = ET.client API.gupShupConnectAPI\n\ncheckGupShupOptError :: (MonadThrow m, B.Log m) => BaseUrl -> Either ClientError SubmitSmsRes -> m SubmitSmsRes\ncheckGupShupOptError url res =\n  fromEitherM (gupShupOptError url) res >>= validateResponseStatus\n\nvalidateResponseStatus :: (MonadThrow m, B.Log m) => SubmitSmsRes -> m SubmitSmsRes\nvalidateResponseStatus response = do\n  let resp = response.response\n  case resp.status of\n    \"success\" -> pure response\n    _ -> do\n      case resp.id of\n        \"100\" -> throwError GupShupUnknownServerError\n        \"101\" -> throwError GupShupInvalidRequest\n        \"102\" -> throwError GupShupUnauthorized\n        \"103\" -> throwError GupShupUserIdNotFound\n        \"105\" -> throwError GupShupInvalidPhoneNumber\n        \"106\" -> throwError GupShupWrongMethodService\n        \"175\" -> throwError GupShupInterNationalPhoneNumber\n        \"322\" -> throwError GupShupTooManyRequests\n        _ -> throwError GupShupUnknownServerError\n\ngupShupOptError :: BaseUrl -> ClientError -> ExternalAPICallError\ngupShupOptError = ExternalAPICallError (Just \"GUPSHUP_OPT_API_ERROR\")\n",
      "hash": "2b5cdf93f19b6947d43a438c0240f0bb5265c896f12fa0e7c6eaeb9c5301b29f",
      "size": 2931
    },
    "/lib/mobility-core/src/Kernel/External/SMS/GupShup/Types.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n{-# LANGUAGE DeriveGeneric #-}\n{-# LANGUAGE ScopedTypeVariables #-}\n{-# LANGUAGE UndecidableInstances #-}\n\nmodule Kernel.External.SMS.GupShup.Types where\n\nimport Data.Text (Text)\nimport Kernel.Prelude (Eq, FromJSON, Generic, HasField (hasField), ToJSON)\n\nnewtype SubmitSmsRes = SubmitSmsRes\n  { response :: SmsResponse\n  }\n  deriving (Generic, ToJSON, FromJSON, Eq)\n\ndata SmsResponse = SmsResponse\n  { id :: Text,\n    phone :: Text,\n    details :: Text,\n    status :: Text\n  }\n  deriving (Generic, ToJSON, FromJSON, Eq)\n",
      "hash": "9a11d711264236bf7160aa4eb50f8b31060fc947a1749ed8fa77cc689fe9ab76",
      "size": 1213
    },
    "/lib/mobility-core/src/Kernel/External/SMS/Interface.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n{-# LANGUAGE TypeApplications #-}\n\nmodule Kernel.External.SMS.Interface\n  ( module Reexport,\n    sendSMS,\n    checkSmsResult,\n  )\nwhere\n\nimport EulerHS.Prelude\nimport Kernel.External.SMS.DigoEngage.Config as Reexport\nimport Kernel.External.SMS.ExotelSms.Config as Reexport\nimport Kernel.External.SMS.GupShup.Config as Reexport\nimport qualified Kernel.External.SMS.Interface.DigoEngageSms as DigoEngageSms\nimport qualified Kernel.External.SMS.Interface.ExotelSms as ExotelSms\nimport qualified Kernel.External.SMS.Interface.GupShup as GupShup\nimport qualified Kernel.External.SMS.Interface.MyValueFirst as MyValueFirst\nimport qualified Kernel.External.SMS.Interface.TwillioSms as TwillioSms\nimport Kernel.External.SMS.Interface.Types as Reexport\nimport Kernel.External.SMS.MyValueFirst.Config as Reexport\nimport Kernel.External.SMS.Types as Reexport\nimport Kernel.Tools.Metrics.CoreMetrics (CoreMetrics)\nimport Kernel.Types.Common\nimport Kernel.Types.Error\nimport Kernel.Utils.Common\n\nsendSMS :: (EncFlow m r, EsqDBFlow m r, CoreMetrics m) => SmsHandler m -> SendSMSReq -> m SendSMSRes\nsendSMS SmsHandler {..} req = do\n  prividersPriorityList <- getProvidersPriorityList\n  when (null prividersPriorityList) $ throwError $ InternalError \"No sms serive provider configured\"\n  sendSmsWithFallback prividersPriorityList\n  where\n    sendSmsWithFallback [] = throwError $ InternalError \"Not able to send sms with all the configured providers\"\n    sendSmsWithFallback (preferredProvider : restProviders) = do\n      smsConfig <- getProviderConfig preferredProvider\n      result <- try @_ @SomeException $ sendSMS' smsConfig req\n      case result of\n        Left _ -> sendSmsWithFallback restProviders\n        Right res -> case res of\n          UnknownError -> sendSmsWithFallback restProviders\n          Fail -> sendSmsWithFallback restProviders\n          _ -> pure res\n\nsendSMS' ::\n  ( EncFlow m r,\n    CoreMetrics m\n  ) =>\n  SmsServiceConfig ->\n  SendSMSReq ->\n  m SendSMSRes\nsendSMS' serviceConfig req = do\n  case serviceConfig of\n    ExotelSmsConfig cfg -> ExotelSms.sendOTP cfg req\n    MyValueFirstConfig cfg -> MyValueFirst.sendOTP cfg req\n    GupShupConfig cfg -> GupShup.sendOTP cfg req\n    TwillioSmsConfig cfg -> TwillioSms.sendOTP cfg req\n    DigoEngageSmsConfig cfg -> DigoEngageSms.sendOTP cfg req\n\ncheckSmsResult ::\n  (Log m, MonadThrow m) => SendSMSRes -> m ()\ncheckSmsResult txt =\n  case txt of\n    Success -> pure ()\n    Fail -> throwError SMSInvalidNumber\n    Pending -> pure ()\n    _ -> throwError SMSInvalidNumber\n",
      "hash": "e4524977ec48282ea5de77aeecb60400ae934cdb4f9e143faac61ab1eb8beed1",
      "size": 3217
    },
    "/lib/mobility-core/src/Kernel/External/SMS/Interface/DigoEngageSms.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n\nmodule Kernel.External.SMS.Interface.DigoEngageSms\n  ( module Reexport,\n    sendOTP,\n  )\nwhere\n\nimport EulerHS.Prelude\nimport Kernel.External.Encryption\nimport Kernel.External.SMS.DigoEngage.Config\nimport qualified Kernel.External.SMS.DigoEngage.Flow as Flow\nimport Kernel.External.SMS.DigoEngage.Types (ClientDomain (..), SubmitSmsReq (..), SubmitSmsRes (..), TLVForSmsReq (..))\nimport Kernel.External.SMS.Interface.Types as IT\nimport Kernel.External.SMS.Types as Reexport\nimport Kernel.Tools.Metrics.CoreMetrics (CoreMetrics)\nimport Kernel.Types.Common\n\nsendOTP ::\n  ( CoreMetrics m,\n    MonadFlow m,\n    EncFlow m r,\n    Log m\n  ) =>\n  DigoEngageSmsCfg ->\n  IT.SendSMSReq ->\n  m IT.SendSMSRes\nsendOTP cfg smsReq = do\n  let digoReq =\n        SubmitSmsReq\n          { from = cfg.from,\n            to = smsReq.phoneNumber,\n            msg = smsReq.smsBody,\n            dlr = ClientDomain {mask = cfg.dlr.mask, url = cfg.dlr.url},\n            messageType = cfg.messageType,\n            tiny = cfg.tiny,\n            tlv = TLVForSmsReq {peId = cfg.tlv.peId, templateId = smsReq.templateId, telemarketerId = cfg.tlv.telemarketerId}\n          }\n  res <- Flow.sendOTPApi cfg digoReq\n  return $ returnSmsResultDigoEngage res\n\nreturnSmsResultDigoEngage :: SubmitSmsRes -> IT.SendSMSRes\nreturnSmsResultDigoEngage (SmsSuccess _) = Success\nreturnSmsResultDigoEngage (SmsError _) = Fail\n",
      "hash": "08d5992356d2b665be51c9dfbcc1b204c86bbdac3e770da3c2deeb515f4380ac",
      "size": 2069
    },
    "/lib/mobility-core/src/Kernel/External/SMS/Interface/ExotelSms.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n\nmodule Kernel.External.SMS.Interface.ExotelSms\n  ( module Reexport,\n    sendOTP,\n  )\nwhere\n\nimport qualified Data.Text.Encoding as DT\nimport EulerHS.Prelude\nimport Kernel.External.Encryption\nimport Kernel.External.SMS.ExotelSms.Config\nimport qualified Kernel.External.SMS.ExotelSms.Flow as Ex\nimport Kernel.External.SMS.ExotelSms.Types\nimport Kernel.External.SMS.Interface.Types as IT\nimport Kernel.External.SMS.Types as Reexport\nimport Kernel.Tools.Metrics.CoreMetrics (CoreMetrics)\nimport Kernel.Types.Common\nimport Servant\n\nsendOTP ::\n  ( CoreMetrics m,\n    MonadFlow m,\n    EncFlow m r,\n    Log m\n  ) =>\n  ExotelSmsCfg ->\n  IT.SendSMSReq ->\n  m IT.SendSMSRes\nsendOTP exoCfg SendSMSReq {..} = do\n  let sid = exoCfg.sid\n  apiKey <- decrypt exoCfg.apiKey\n  apiToken <- decrypt exoCfg.apiToken\n  let exoUrl = exoCfg.url\n      exoOtpSmsTemplate = smsBody\n      exoPhoneNumber = phoneNumber\n      senderName = sender\n      authData =\n        BasicAuthData\n          (DT.encodeUtf8 apiKey)\n          (DT.encodeUtf8 apiToken)\n  res <- Ex.sendOTPApi exoUrl authData sid exoOtpSmsTemplate exoPhoneNumber senderName\n  return $ returnSmsResultExo res.exoSMSMessage.exoStatus\n\nreturnSmsResultExo :: ExotelSmsStatus -> IT.SendSMSRes\nreturnSmsResultExo txt =\n  case txt of\n    SENT -> Success\n    FAILED -> Fail\n    FAILED_DND -> Fail\n    QUEUED -> Pending\n    SENDING -> Pending\n    _ -> UnknownError\n",
      "hash": "26c2814c1b6d16a80c2f10d5288b0b3fd589ba9eb81d70d8e38bfc242db061ea",
      "size": 2085
    },
    "/lib/mobility-core/src/Kernel/External/SMS/Interface/GupShup.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n\nmodule Kernel.External.SMS.Interface.GupShup\n  ( module Reexport,\n    sendOTP,\n  )\nwhere\n\nimport EulerHS.Prelude\nimport Kernel.External.Encryption\nimport Kernel.External.SMS.GupShup.Config\nimport qualified Kernel.External.SMS.GupShup.Flow as GF\nimport Kernel.External.SMS.Interface.Types as IT\nimport Kernel.External.SMS.Types as Reexport\nimport Kernel.Tools.Metrics.CoreMetrics (CoreMetrics)\nimport Kernel.Types.Common\n\nsendOTP ::\n  ( CoreMetrics m,\n    MonadFlow m,\n    EncFlow m r,\n    Log m\n  ) =>\n  GupShupCfg ->\n  IT.SendSMSReq ->\n  m IT.SendSMSRes\nsendOTP gupShupCfg SendSMSReq {..} = do\n  let gupShupOtpSmsTemplate = smsBody\n  let gupShupPhoneNumber = phoneNumber\n  gupShupUserId <- decrypt gupShupCfg.userName\n  gupShupPassword <- decrypt gupShupCfg.password\n  gupShupTemplateId <- decrypt gupShupCfg.templateId\n  gupShupEntityId <- decrypt gupShupCfg.entityId\n  res <- GF.sendOTPApi gupShupOtpSmsTemplate gupShupPhoneNumber gupShupUserId gupShupPassword gupShupEntityId gupShupTemplateId sender gupShupCfg\n  return $ returnSmsResultGupShup res.response.status\n\nreturnSmsResultGupShup :: Text -> IT.SendSMSRes\nreturnSmsResultGupShup txt = case txt of\n  \"success\" -> Success\n  _ -> Fail\n",
      "hash": "9c57731887d112e3642640c45dad1c8c14cda35695b55b87f8208bd24bfe5e0c",
      "size": 1889
    },
    "/lib/mobility-core/src/Kernel/External/SMS/Interface/MyValueFirst.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n\nmodule Kernel.External.SMS.Interface.MyValueFirst\n  ( module Reexport,\n    sendOTP,\n  )\nwhere\n\nimport EulerHS.Prelude\nimport Kernel.External.Encryption\nimport Kernel.External.SMS.Interface.Types as IT\nimport Kernel.External.SMS.MyValueFirst.Config\nimport qualified Kernel.External.SMS.MyValueFirst.Flow as MVF\nimport Kernel.External.SMS.MyValueFirst.Types as MT\nimport Kernel.External.SMS.Types as Reexport\nimport Kernel.Tools.Metrics.CoreMetrics (CoreMetrics)\nimport Kernel.Types.Common\n\nsendOTP ::\n  ( CoreMetrics m,\n    MonadFlow m,\n    EncFlow m r,\n    Log m\n  ) =>\n  MyValueFirstCfg ->\n  IT.SendSMSReq ->\n  m IT.SendSMSRes\nsendOTP smsCfg SendSMSReq {..} = do\n  let urlAddress = smsCfg.url\n      otpSmsTemp = smsBody\n      phone = phoneNumber\n      senderName = sender\n  token <- decrypt smsCfg.token\n  res <- MVF.sendOTPApi urlAddress token otpSmsTemp phone senderName\n\n  return $ returnSmsResultMVF res\n\nreturnSmsResultMVF :: MT.SubmitSmsRes -> IT.SendSMSRes\nreturnSmsResultMVF txt =\n  case txt of\n    Sent -> Success\n    BadNumber -> Fail\n    _ -> IT.UnknownError\n",
      "hash": "f90286c85aa1e575428913a37af6ad3f268811bd57ca59fa8726070b2e8429d5",
      "size": 1765
    },
    "/lib/mobility-core/src/Kernel/External/SMS/Interface/TwillioSms.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n\nmodule Kernel.External.SMS.Interface.TwillioSms\n  ( module Reexport,\n    sendOTP,\n  )\nwhere\n\nimport EulerHS.Prelude\nimport Kernel.External.Encryption\nimport Kernel.External.SMS.Interface.Types as IT\nimport Kernel.External.SMS.TwillioSms.Config\nimport qualified Kernel.External.SMS.TwillioSms.Flow as Ex\nimport Kernel.External.SMS.TwillioSms.Types\nimport Kernel.External.SMS.Types as Reexport\nimport Kernel.Tools.Metrics.CoreMetrics (CoreMetrics)\nimport Kernel.Types.Common\n\nsendOTP ::\n  ( CoreMetrics m,\n    MonadFlow m,\n    EncFlow m r,\n    Log m\n  ) =>\n  TwillioSmsCfg ->\n  IT.SendSMSReq ->\n  m IT.SendSMSRes\nsendOTP cfg SendSMSReq {..} = do\n  messageServiceId <- decrypt cfg.messageServiceId\n  let twillioReq = TwillioSmsReq {to = phoneNumber, body = smsBody, messagingServiceSid = messageServiceId}\n  res <- Ex.sendOTPApi cfg twillioReq\n  return $ returnSmsResult res.status\n\nreturnSmsResult :: TwillioSmsStatus -> IT.SendSMSRes\nreturnSmsResult status =\n  case status of\n    ACCEPTED -> Success\n    SENT -> Success\n    DELIVERED -> Success\n    RECEIVED -> Success\n    READ -> Success\n    QUEUED -> Pending\n    SCHEDULED -> Pending\n    SENDING -> Pending\n    RECEIVING -> Pending\n    UNDELIVERED -> Fail\n    FAILED -> Fail\n    CANCELED -> Fail\n",
      "hash": "54fbc322b92e9a3feb80de032cc5974e95c90fd5e034d6254b017edd6ecd43b4",
      "size": 1941
    },
    "/lib/mobility-core/src/Kernel/External/SMS/Interface/Types.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n{-# LANGUAGE DeriveGeneric #-}\n{-# LANGUAGE DerivingVia #-}\n{-# OPTIONS_GHC -Wno-orphans #-}\n\nmodule Kernel.External.SMS.Interface.Types\n  ( module Kernel.External.SMS.Interface.Types,\n  )\nwhere\n\nimport Data.ByteString.Lazy (fromStrict, toStrict)\nimport qualified Data.Text as T\nimport qualified Data.Text.Encoding as T\nimport Deriving.Aeson\nimport qualified Kernel.External.SMS.DigoEngage.Config as DigoEngageSms\nimport qualified Kernel.External.SMS.ExotelSms.Config as ExotelSms\nimport qualified Kernel.External.SMS.GupShup.Config as GupShup\nimport qualified Kernel.External.SMS.MyValueFirst.Config as MyValueFirst\nimport qualified Kernel.External.SMS.TwillioSms.Config as TwillioSms\nimport qualified Kernel.External.SMS.Types as T\nimport Kernel.Prelude\nimport Kernel.Types.Servant\nimport Servant\n\ndata SmsHandler m = SmsHandler\n  { getProvidersPriorityList :: m [T.SmsService],\n    getProviderConfig :: T.SmsService -> m SmsServiceConfig\n  }\n\ndata SmsServiceConfig = MyValueFirstConfig MyValueFirst.MyValueFirstCfg | ExotelSmsConfig ExotelSms.ExotelSmsCfg | GupShupConfig GupShup.GupShupCfg | TwillioSmsConfig TwillioSms.TwillioSmsCfg | DigoEngageSmsConfig DigoEngageSms.DigoEngageSmsCfg\n  deriving stock (Show, Eq, Generic)\n  deriving (FromJSON, ToJSON) via CustomJSON '[SumTaggedObject \"tag\" \"content\"] SmsServiceConfig\n\ndata SendSMSReq = SendSMSReq\n  { smsBody :: Text,\n    phoneNumber :: Text,\n    sender :: Text,\n    templateId :: Text\n  }\n  deriving (Generic, FromJSON, ToJSON, ToSchema)\n\ndata SendSMSRes = Success | Fail | Pending | UnknownError\n  deriving (Generic, FromJSON, ToJSON, Show, Eq)\n\ninstance MimeUnrender PlainText_ISO_8859_1 SendSMSRes where\n  mimeUnrender _ = Right . parseSendSMSRes . T.decodeLatin1 . toStrict\n\ninstance MimeRender PlainText_ISO_8859_1 SendSMSRes where\n  mimeRender _ = fromStrict . T.encodeUtf8 . sendOtpResToText\n\nparseSendSMSRes :: Text -> SendSMSRes\nparseSendSMSRes txt\n  | \"Success\" `T.isPrefixOf` txt = Success\n  | \"Fail\" `T.isPrefixOf` txt = Fail\n  | \"Pending\" `T.isPrefixOf` txt = Pending\n  | otherwise = UnknownError\n\nsendOtpResToText :: SendSMSRes -> Text\nsendOtpResToText = \\case\n  Success -> \"Success sms\"\n  Fail -> \"Fail\"\n  Pending -> \"Pending\"\n  UnknownError -> \"unknown request\"\n",
      "hash": "f15da2adafceb51ee421e5f7383fc7b08692aaf1ae15237817ffb90dc8b01238",
      "size": 2930
    },
    "/lib/mobility-core/src/Kernel/External/SMS/MyValueFirst/API.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n\nmodule Kernel.External.SMS.MyValueFirst.API where\n\nimport EulerHS.Prelude\nimport qualified EulerHS.Types as ET\nimport Kernel.External.SMS.MyValueFirst.Types\nimport Kernel.Types.App\n  ( MandatoryQueryParam,\n  )\nimport Kernel.Types.Servant\nimport Servant\n\ntype ServiceAPI =\n  \"smpp\"\n    :> \"sendsms\"\n    :> Header \"Authorization\" Text\n    :> MandatoryQueryParam \"from\" Text\n    :> MandatoryQueryParam \"to\" Text\n    :> MandatoryQueryParam \"text\" Text\n    :> Post '[PlainText_ISO_8859_1] SubmitSmsRes\n\nserviceAPI :: Proxy ServiceAPI\nserviceAPI = Proxy\n\nsubmitSms :: SubmitSms -> ET.EulerClient SubmitSmsRes\nsubmitSms SubmitSms {..} = ET.client serviceAPI (Just $ \"Bearer \" <> token) from to text\n",
      "hash": "15b9d4f2f9ffd6689cd0f923a0670995b105a6ff79af120c8784da25e1ec71f1",
      "size": 1386
    },
    "/lib/mobility-core/src/Kernel/External/SMS/MyValueFirst/Config.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n\nmodule Kernel.External.SMS.MyValueFirst.Config where\n\nimport Kernel.External.Encryption\nimport Kernel.Prelude\n\ndata MyValueFirstCfg = MyValueFirstCfg\n  { username :: EncryptedField 'AsEncrypted Text,\n    password :: EncryptedField 'AsEncrypted Text,\n    url :: BaseUrl,\n    token :: EncryptedField 'AsEncrypted Text\n  }\n  deriving (Show, Eq, Generic, ToJSON, FromJSON)\n",
      "hash": "a30540a8be4dff4e6104c36fa92c1050cc3e313bd7a5e4537528a491e8f9bb1a",
      "size": 1063
    },
    "/lib/mobility-core/src/Kernel/External/SMS/MyValueFirst/Flow.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n\nmodule Kernel.External.SMS.MyValueFirst.Flow where\n\nimport EulerHS.Prelude\nimport qualified Kernel.External.SMS.MyValueFirst.API as API\nimport Kernel.External.SMS.MyValueFirst.Types (SubmitSms (..), SubmitSmsRes (..))\nimport Kernel.Sms.Config (SmsConfig)\nimport Kernel.Tools.Metrics.CoreMetrics (CoreMetrics)\nimport Kernel.Types.Common\nimport Kernel.Types.Error\nimport Kernel.Utils.Common\n\nsubmitSms ::\n  ( CoreMetrics m,\n    MonadFlow m\n  ) =>\n  BaseUrl ->\n  SubmitSms ->\n  m SubmitSmsRes\nsubmitSms url params = do\n  callAPI url (API.submitSms params) \"submitSms\" API.serviceAPI\n    >>= fromEitherM (ExternalAPICallError (Just \"UNABLE_TO_SEND_SMS\") url)\n\ntype OtpTemplate = Text\n\ntype OrgName = Text\n\ntype InviteTemplate = Text\n\nsendOTPApi ::\n  ( CoreMetrics m,\n    MonadFlow m\n  ) =>\n  BaseUrl ->\n  Text ->\n  Text ->\n  Text ->\n  Text ->\n  m SubmitSmsRes\nsendOTPApi url token otpSmsTemplate phoneNumber sender = do\n  submitSms\n    url\n    SubmitSms\n      { from = sender,\n        to = phoneNumber,\n        text = otpSmsTemplate,\n        token = token\n      }\n\nsendSms ::\n  ( CoreMetrics m,\n    MonadFlow m\n  ) =>\n  SmsConfig ->\n  Text ->\n  Text ->\n  m SubmitSmsRes\nsendSms smsCfg smsTemplate phoneNumber = do\n  let smsCred = smsCfg.credConfig\n      url = smsCfg.url\n  case smsCred.token of\n    Just token -> do\n      submitSms\n        url\n        SubmitSms\n          { from = smsCfg.sender,\n            to = phoneNumber,\n            text = smsTemplate,\n            token = token\n          }\n    Nothing -> throwError $ InternalError \"token is null\"\n\ncheckSmsResult :: (Log m, MonadThrow m) => SubmitSmsRes -> m ()\ncheckSmsResult =\n  \\case\n    Sent -> pure ()\n    BadNumber -> throwError SMSInvalidNumber\n    InvalidReceiver -> throwError SMSInvalidNumber\n    err -> throwError $ SMSError err\n",
      "hash": "91daee0ad63acf0008a6a26effd5025fc700a5afa43a1eeda04ad61813e95be1",
      "size": 2487
    },
    "/lib/mobility-core/src/Kernel/External/SMS/MyValueFirst/Types.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n\nmodule Kernel.External.SMS.MyValueFirst.Types where\n\nimport Data.ByteString.Lazy (fromStrict, toStrict)\nimport qualified Data.Text as T\nimport qualified Data.Text.Encoding as T\nimport EulerHS.Prelude hiding (encodeUtf8, fromStrict, toStrict)\nimport Kernel.Types.Servant\nimport Servant\n\ndata SubmitSms = SubmitSms\n  { -- | Login of myfirstvalue.com account.\n    -- | Author name assigned to SMS.\n    from :: Text,\n    -- | Phone number.\n    to :: Text,\n    -- | SMS contents.\n    text :: Text,\n    -----\n    token :: Text\n  }\n  deriving (Show)\n\ndata SubmitSmsRes\n  = Sent\n  | BadNumber\n  | InvalidReceiver\n  | EmptyNumber\n  | MissingSender\n  | EmptyText\n  | UnknownError\n  | AuthorizationFailure\n  deriving (Generic, FromJSON, ToJSON, Show, Eq)\n\ninstance MimeUnrender PlainText_ISO_8859_1 SubmitSmsRes where\n  mimeUnrender _ = Right . parseSubmitSmsRes . T.decodeLatin1 . toStrict\n\ninstance MimeRender PlainText_ISO_8859_1 SubmitSmsRes where\n  mimeRender _ = fromStrict . T.encodeUtf8 . submitSmsResToText\n\nparseSubmitSmsRes :: Text -> SubmitSmsRes\nparseSubmitSmsRes txt\n  | \"Sent.\" `T.isPrefixOf` txt = Sent\n  | \"Number\" `T.isPrefixOf` txt = BadNumber\n  | \"Invalid Receiver\" `T.isPrefixOf` txt = InvalidReceiver\n  | \"Empty receiver number\" `T.isPrefixOf` txt = EmptyNumber\n  | \"Sender\" `T.isPrefixOf` txt = MissingSender\n  | \"Empty text not allowed\" `T.isPrefixOf` txt = EmptyText\n  | \"unknown\" `T.isPrefixOf` txt = UnknownError\n  | \"Authorization\" `T.isPrefixOf` txt = AuthorizationFailure\n  | otherwise = UnknownError\n\nsubmitSmsResToText :: SubmitSmsRes -> Text\nsubmitSmsResToText = \\case\n  Sent -> \"Sent.\"\n  BadNumber -> \"Number(s) has/have been denied by white-and/or black-lists.\"\n  InvalidReceiver -> \"Invalid Receiver\"\n  EmptyNumber -> \"Empty receiver number not allowed, rejected\"\n  MissingSender -> \"Sender missing and no global set, rejected\"\n  EmptyText -> \"Empty text not allowed, rejected.\"\n  UnknownError -> \"unknown request\"\n  AuthorizationFailure -> \"Authorization failed for sendsms\"\n",
      "hash": "65424a190f95877237e9882c96e6272fca5ec2465fbb7d176703dfa70c174cd5",
      "size": 2695
    },
    "/lib/mobility-core/src/Kernel/External/SMS/TwillioSms/API.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n\nmodule Kernel.External.SMS.TwillioSms.API where\n\nimport EulerHS.Prelude\nimport Kernel.External.SMS.TwillioSms.Types\nimport Servant hiding (throwError)\n\ntype TwillioSMSAPI =\n  \"Accounts\"\n    :> Capture \"AccountSID\" Text\n    :> \"Messages.json\"\n    :> BasicAuth \"accountSid:authtoken\" BasicAuthData\n    :> ReqBody '[FormUrlEncoded] TwillioSmsReq\n    :> Post '[JSON] TwillioSmsResp\n\ntwillioSMSAPI :: Proxy TwillioSMSAPI\ntwillioSMSAPI = Proxy\n",
      "hash": "e9a55feb312d96e3eea6ee1c0d4016db589a0e547cfebdef67f10d6a31de38ea",
      "size": 1132
    },
    "/lib/mobility-core/src/Kernel/External/SMS/TwillioSms/Config.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n\nmodule Kernel.External.SMS.TwillioSms.Config where\n\nimport Kernel.External.Encryption\nimport Kernel.Prelude\n\ndata TwillioSmsCfg = TwillioSmsCfg\n  { messageServiceId :: EncryptedField 'AsEncrypted Text,\n    accountSid :: EncryptedField 'AsEncrypted Text,\n    authToken :: EncryptedField 'AsEncrypted Text,\n    url :: BaseUrl\n  }\n  deriving (Show, Eq, Generic, ToJSON, FromJSON)\n",
      "hash": "88964996b98561ffe720fd4c96ee9e2f3212b3e5eeef0a32dfb0e1c441ee3636",
      "size": 1071
    },
    "/lib/mobility-core/src/Kernel/External/SMS/TwillioSms/Flow.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n\nmodule Kernel.External.SMS.TwillioSms.Flow where\n\nimport qualified Data.Text.Encoding as DT\nimport EulerHS.Prelude\nimport EulerHS.Types as ET\nimport Kernel.External.Encryption\nimport qualified Kernel.External.SMS.TwillioSms.API as API\nimport Kernel.External.SMS.TwillioSms.Config\nimport Kernel.External.SMS.TwillioSms.Types\nimport Kernel.Tools.Metrics.CoreMetrics (CoreMetrics)\nimport Kernel.Types.Common\nimport Kernel.Types.Error\nimport Kernel.Utils.Common as B\nimport Servant hiding (throwError)\nimport Servant.Client.Core (ClientError)\n\nsendOTPApi ::\n  ( CoreMetrics m,\n    MonadFlow m,\n    EncFlow m r\n  ) =>\n  TwillioSmsCfg ->\n  TwillioSmsReq ->\n  m TwillioSmsResp\nsendOTPApi twillioConfigs req = do\n  accountsid <- decrypt twillioConfigs.accountSid\n  authtoken <- decrypt twillioConfigs.authToken\n  let authData = BasicAuthData (DT.encodeUtf8 accountsid) (DT.encodeUtf8 authtoken)\n  callAPI\n    twillioConfigs.url\n    (callTwillioSmsAPI accountsid authData req)\n    \"sendOTPApi\"\n    API.twillioSMSAPI\n    >>= checkTwillioSmsError twillioConfigs.url\n  where\n    callTwillioSmsAPI = ET.client API.twillioSMSAPI\n\ncheckTwillioSmsError :: (MonadThrow m, B.Log m) => BaseUrl -> Either ClientError TwillioSmsResp -> m TwillioSmsResp\ncheckTwillioSmsError url res =\n  fromEitherM (twillioError url) res >>= validateResponseStatus\n\nvalidateResponseStatus :: (MonadThrow m, B.Log m) => TwillioSmsResp -> m TwillioSmsResp\nvalidateResponseStatus resp = do\n  case elem (resp.status) [FAILED, UNDELIVERED] of\n    True -> do\n      case resp.errorCode of\n        Just \"400\" -> throwError TwillioBadRequest\n        Just \"403\" -> throwError TwillioForbidden\n        Just \"404\" -> throwError TwillioAPIDoesNotExist\n        Just \"410\" -> throwError TwillioUnknownError\n        Just \"503\" -> throwError TwillioInternalServerError\n        Just \"10001\" -> throwError TwillioAccountNotActive\n        Just \"10002\" -> throwError TwillioTrialAccountFound\n        Just \"10004\" -> throwError TwillioConcurrencyLimitExceeded\n        Just \"11100\" -> throwError TwillioInvalidURLFormat\n        _ -> throwError TwillioUnknownError\n    False -> return resp\n\ntwillioError :: BaseUrl -> ClientError -> ExternalAPICallError\ntwillioError = ExternalAPICallError (Just \"TWILLIO_OPT_API_ERROR\")\n",
      "hash": "68227ea140737df7b06b63179a254a819555e1dda35bdc4b8c46888f109e668e",
      "size": 2953
    },
    "/lib/mobility-core/src/Kernel/External/SMS/TwillioSms/Types.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n{-# LANGUAGE DeriveDataTypeable #-}\n{-# LANGUAGE DeriveGeneric #-}\n{-# LANGUAGE DerivingStrategies #-}\n{-# LANGUAGE GeneralizedNewtypeDeriving #-}\n{-# LANGUAGE OverloadedLists #-}\n{-# LANGUAGE OverloadedStrings #-}\n{-# LANGUAGE ScopedTypeVariables #-}\n{-# LANGUAGE StandaloneDeriving #-}\n{-# LANGUAGE TemplateHaskell #-}\n{-# LANGUAGE UndecidableInstances #-}\n\nmodule Kernel.External.SMS.TwillioSms.Types where\n\nimport Data.Aeson\nimport Data.Aeson.TH\nimport Kernel.Prelude\nimport Kernel.Utils.JSON\nimport Web.FormUrlEncoded (ToForm, toForm)\nimport Web.Internal.HttpApiData\n\ndata TwillioSmsStatus = ACCEPTED | SCHEDULED | CANCELED | QUEUED | SENDING | SENT | FAILED | DELIVERED | UNDELIVERED | RECEIVING | RECEIVED | READ\n  deriving (Generic, Show, Eq, ToSchema)\n\n$(deriveJSON constructorsToLowerOptions ''TwillioSmsStatus)\n\ndata TwillioSmsDirection = INBOUND | OUTBOUND_API | OUTBOUND_CALL | OUTBOUND_REPLY\n  deriving (Generic, Show, Eq, ToSchema)\n\n$(deriveJSON constructorsWithHyphensToLowerOptions ''TwillioSmsDirection)\n\ndata TwillioSmsResp = TwillioSmsResp\n  { apiVersion :: Text,\n    body :: Text,\n    dateCreated :: Text,\n    direction :: TwillioSmsDirection,\n    errorCode :: Maybe Text,\n    errorMessage :: Maybe Text,\n    from :: Maybe Text,\n    numSegments :: Text,\n    sid :: Text,\n    status :: TwillioSmsStatus,\n    to :: Text\n  }\n  deriving (Generic, Show, Eq, ToSchema)\n\ninstance ToJSON TwillioSmsResp where\n  toJSON = genericToJSON constructorsWithSnakeCase\n\ninstance FromJSON TwillioSmsResp where\n  parseJSON = genericParseJSON constructorsWithSnakeCase\n\ndata TwillioSmsReq = TwillioSmsReq\n  { to :: Text,\n    body :: Text,\n    messagingServiceSid :: Text\n  }\n  deriving (Generic, ToJSON, FromJSON, Eq, ToSchema)\n\ninstance ToForm TwillioSmsReq where\n  toForm TwillioSmsReq {..} =\n    [ (\"To\", toQueryParam to),\n      (\"Body\", toQueryParam body),\n      (\"MessagingServiceSid\", toQueryParam messagingServiceSid)\n    ]\n",
      "hash": "724e8654ced470f336cb34fa564567b39d3eca89ebfff0fd06adb2eab6dbd829",
      "size": 2625
    },
    "/lib/mobility-core/src/Kernel/External/SMS/Types.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n{-# LANGUAGE InstanceSigs #-}\n{-# LANGUAGE TemplateHaskell #-}\n\nmodule Kernel.External.SMS.Types\n  ( module Kernel.External.SMS.Types,\n  )\nwhere\n\nimport Data.OpenApi\nimport Database.Beam.Backend\nimport EulerHS.Prelude\nimport Kernel.Beam.Lib.UtilsTH (mkBeamInstancesForList)\nimport Kernel.Storage.Esqueleto (derivePersistField)\n\ndata SmsService = MyValueFirst | ExotelSms | GupShup | TwillioSms | DigoEngage\n  deriving (Show, Read, Eq, Ord, Generic, ToJSON, FromJSON, ToSchema)\n\ninstance HasSqlValueSyntax be String => HasSqlValueSyntax be SmsService where\n  sqlValueSyntax = autoSqlValueSyntax\n\n$(mkBeamInstancesForList ''SmsService)\n\navailableSmsServices :: [SmsService]\navailableSmsServices = [MyValueFirst, ExotelSms, GupShup, TwillioSms, DigoEngage]\n\nderivePersistField \"SmsService\"\n",
      "hash": "0a8191261bc80224da12e22f506cb12cc58c7b4ab81ca43f2b176c66db4d4714",
      "size": 1480
    },
    "/lib/mobility-core/src/Kernel/External/SharedLogic/HyperVerge/Error.hs": {
      "type": "content",
      "content": "{-\n Copyright 2022-23, Juspay India Pvt Ltd\n\n This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program\n\n is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n\n or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of\n\n the GNU Affero General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n{-# LANGUAGE DeriveAnyClass #-}\n{-# LANGUAGE TemplateHaskell #-}\n\nmodule Kernel.External.SharedLogic.HyperVerge.Error where\n\nimport Kernel.Prelude\nimport Kernel.Types.Error.BaseError\nimport Kernel.Types.Error.BaseError.HTTPError\n\ndata HyperVergeError\n  = HVUnauthorizedError\n  | HVBadRequestError Text\n  | HVError Text\n  | HVBadInputError Text\n  | HVMissingPayloadError Text\n  deriving (Eq, Show, IsBecknAPIError)\n\ninstanceExceptionWithParent 'HTTPException ''HyperVergeError\n\ninstance IsBaseError HyperVergeError where\n  toMessage = \\case\n    HVUnauthorizedError -> Just \"Invalid Credentaials, Please provide valida appId and appKey.\"\n    HVBadRequestError msg -> Just $ \"Bad Request with message: \" <> msg\n    HVError msg -> Just $ \"HyperVerge Error with message: \" <> msg\n    HVBadInputError msg -> Just $ \"Bad Input with message: \" <> msg\n    HVMissingPayloadError msg -> Just $ \"Missing payload in a 200 Hyperverge Response !!!!! Due to : \" <> msg\n\ninstance IsHTTPError HyperVergeError where\n  toErrorCode = \\case\n    HVUnauthorizedError -> \"HV_UNAUTHORIZED\"\n    HVBadRequestError _ -> \"HV_BAD_REQUEST\"\n    HVError _ -> \"HV_ERROR\"\n    HVBadInputError _ -> \"HV_BAD_INPUT\"\n    HVMissingPayloadError _ -> \"HV_MISSING_PAYLOAD_ERROR\"\n\n  toHttpCode = \\case\n    HVUnauthorizedError -> E401\n    HVBadRequestError _ -> E400\n    HVError _ -> E400\n    HVBadInputError _ -> E400\n    HVMissingPayloadError _ -> E400\n\ninstance IsAPIError HyperVergeError\n",
      "hash": "f8fda8b5bb996e4913adcf8d855411cb8bab926adb9818aede76f8e4480b12ba",
      "size": 2132
    },
    "/lib/mobility-core/src/Kernel/External/SharedLogic/HyperVerge/Functions.hs": {
      "type": "content",
      "content": "module Kernel.External.SharedLogic.HyperVerge.Functions where\n\nimport qualified Data.HashMap.Internal as HMap\nimport qualified Data.Text as DT\nimport Kernel.Prelude\nimport qualified Network.HTTP.Client as Http\nimport qualified Network.HTTP.Client.TLS as Http\n\nprepareHyperVergeHttpManager :: Int -> HMap.HashMap DT.Text Http.ManagerSettings\nprepareHyperVergeHttpManager timeout =\n  HMap.singleton (DT.pack hyperVergeHttpManagerKey) $\n    Http.tlsManagerSettings {Http.managerResponseTimeout = Http.responseTimeoutMicro (timeout * 1000)}\n\nhyperVergeHttpManagerKey :: String\nhyperVergeHttpManagerKey = \"hyperverge-http-manager\"\n",
      "hash": "38318b8d322e71fb7eb60df7d1d1db0c416d454f43f40a47d86ab1f950b82be7",
      "size": 626
    },
    "/lib/mobility-core/src/Kernel/External/Slack/Flow.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n\nmodule Kernel.External.Slack.Flow where\n\nimport Data.Maybe\nimport qualified Data.Text as T\nimport EulerHS.Prelude\nimport qualified EulerHS.Types as ET\nimport Kernel.External.Slack.Types\nimport Kernel.Tools.Metrics.CoreMetrics (CoreMetrics)\nimport Kernel.Types.Common\nimport Kernel.Utils.Common hiding (Error)\nimport Servant hiding (throwError)\nimport Servant.Client\n\n-- | Slack API interface\ntype SlackConnectAPI =\n  Header \"Authorization\" Text\n    :> ReqBody '[JSON] SlackRequest\n    :> Post '[JSON] SlackResponse\n\nslackConnectAPI :: Proxy SlackConnectAPI\nslackConnectAPI = Proxy\n\ndefaultBaseUrl :: BaseUrl\ndefaultBaseUrl =\n  BaseUrl\n    { baseUrlScheme = Https,\n      baseUrlHost = \"slack.com\",\n      baseUrlPort = 443,\n      baseUrlPath = T.unpack \"/api/chat.postMessage\"\n    }\n\npostMessage ::\n  ( CoreMetrics m,\n    HasFlowEnv m r '[\"slackCfg\" ::: SlackConfig]\n  ) =>\n  T.Text ->\n  m SlackResponse\npostMessage message = do\n  withLogTag \"Slack\" $ do\n    SlackConfig {..} <- asks (.slackCfg)\n    let slackRequest =\n          SlackRequest\n            { channel = channelName,\n              blocks = Just [Block {_type = \"section\", _text = Block {_type = \"plain_text\", _text = message}}]\n            }\n    callSlackAPI\n      defaultBaseUrl\n      (callSlack slackToken slackRequest)\n      \"PostMessage\"\n      slackConnectAPI\n  where\n    callSlack token slackRequest = ET.client slackConnectAPI (Just $ \"Bearer \" <> token) slackRequest\n\ncallSlackAPI :: CallAPI env api a\ncallSlackAPI =\n  callApiUnwrappingApiError\n    (identity @Error)\n    Nothing\n    Nothing\n    Nothing\n",
      "hash": "a948115f4dc2e2faebfe4e761b9e2e2b7eec74fe11092f8992dc946d660a536a",
      "size": 2264
    },
    "/lib/mobility-core/src/Kernel/External/Slack/Types.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n{-# LANGUAGE DeriveGeneric #-}\n{-# LANGUAGE DerivingStrategies #-}\n{-# LANGUAGE GeneralizedNewtypeDeriving #-}\n{-# LANGUAGE ScopedTypeVariables #-}\n{-# LANGUAGE StandaloneDeriving #-}\n{-# LANGUAGE TemplateHaskell #-}\n{-# LANGUAGE UndecidableInstances #-}\n\nmodule Kernel.External.Slack.Types where\n\nimport Data.Aeson.Types\nimport Data.OpenApi\nimport EulerHS.Prelude hiding (state)\nimport Kernel.Types.Error.BaseError.HTTPError hiding (Error)\nimport Kernel.Types.Error.BaseError.HTTPError.FromResponse\nimport Kernel.Utils.Dhall (FromDhall)\nimport Kernel.Utils.JSON\n\ndata SlackConfig = SlackConfig\n  { slackToken :: Text,\n    channelName :: Text\n  }\n  deriving (Generic, Eq, Show, FromJSON, ToJSON, FromDhall)\n\ndata SlackRequest = SlackRequest\n  { channel :: Text,\n    blocks :: Maybe [Block (Block Text)]\n  }\n  deriving (Generic, Eq, Show, FromJSON, ToJSON)\n\ndata Block a = Block\n  { _type :: Text,\n    _text :: a\n  }\n  deriving (Generic, Eq, Show)\n\ninstance (FromJSON a) => FromJSON (Block a) where\n  parseJSON = genericParseJSON stripPrefixUnderscoreIfAny\n\ninstance (ToJSON a) => ToJSON (Block a) where\n  toJSON = genericToJSON stripPrefixUnderscoreIfAny\n\ndata SlackResponse = SlackResponse\n  {ok :: Bool, _error :: Maybe Text}\n  deriving (Generic, Eq, Show, FromJSON, ToJSON)\n\nnewtype Error = Error {message :: Text}\n  deriving (Show, Generic)\n\ninstance IsAPIError Error\n\nderiving newtype instance ToJSON Error\n\nderiving newtype instance FromJSON Error\n\nderiving newtype instance ToSchema Error\n\ninstance FromResponse Error where\n  fromResponse = fromJsonResponse\n\ninstance IsBaseError Error where\n  toMessage _ = Just \"SLACK_ERROR\"\n\ninstance IsHTTPError Error where\n  toErrorCode _ = \"CORE002\"\n  toHttpCode _ = E404\n\ninstance IsBecknAPIError Error where\n  toType _ = DOMAIN_ERROR -- only to satisfy current tests, FIXME maybe\n\ninstanceExceptionWithParent 'HTTPException ''Error\n",
      "hash": "77eab71b48fb11b7ee0182867a565815550d91ad8f0a956c2308353679f75900",
      "size": 2573
    },
    "/lib/mobility-core/src/Kernel/External/Ticket/Interface.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n\nmodule Kernel.External.Ticket.Interface\n  ( createTicket,\n    updateTicket,\n    addAndUpdateKaptureCustomer,\n    kaptureEncryption,\n  )\nwhere\n\nimport qualified Kernel.External.Ticket.Interface.Kapture as Kapture\nimport Kernel.External.Ticket.Interface.Types\nimport qualified Kernel.External.Ticket.Kapture.Types as KT\nimport Kernel.Tools.Metrics.CoreMetrics (CoreMetrics)\nimport Kernel.Types.Common\n\ncreateTicket ::\n  ( EncFlow m r,\n    CoreMetrics m\n  ) =>\n  IssueTicketServiceConfig ->\n  CreateTicketReq ->\n  m KT.CreateTicketResp\ncreateTicket serviceConfig req = case serviceConfig of\n  KaptureConfig cfg -> Kapture.createTicket cfg req\n\nupdateTicket ::\n  ( EncFlow m r,\n    CoreMetrics m\n  ) =>\n  IssueTicketServiceConfig ->\n  UpdateTicketReq ->\n  m KT.UpdateTicketResp\nupdateTicket serviceConfig req = case serviceConfig of\n  KaptureConfig cfg -> Kapture.updateTicket cfg req\n\naddAndUpdateKaptureCustomer ::\n  ( EncFlow m r,\n    CoreMetrics m\n  ) =>\n  IssueTicketServiceConfig ->\n  KaptureCustomerReq ->\n  m KT.KaptureCustomerResp\naddAndUpdateKaptureCustomer serviceConfig req = case serviceConfig of\n  KaptureConfig cfg -> Kapture.addAndUpdateKaptureCustomer cfg req\n\nkaptureEncryption ::\n  ( EncFlow m r,\n    CoreMetrics m\n  ) =>\n  IssueTicketServiceConfig ->\n  KaptureEncryptionReq ->\n  m KT.KaptureEncryptionResp\nkaptureEncryption serviceConfig req = case serviceConfig of\n  KaptureConfig cfg -> Kapture.kaptureEncryption cfg req\n",
      "hash": "a678ac40d663bd43cb99e77e9a04b75ca7c6ab7338d8e74cbcfcf6c908575e1a",
      "size": 2133
    },
    "/lib/mobility-core/src/Kernel/External/Ticket/Interface/Kapture.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n\nmodule Kernel.External.Ticket.Interface.Kapture\n  ( createTicket,\n    updateTicket,\n    addAndUpdateKaptureCustomer,\n    kaptureEncryption,\n  )\nwhere\n\nimport Kernel.External.Encryption\nimport qualified Kernel.External.Ticket.Interface.Types as IT\nimport Kernel.External.Ticket.Kapture.Config\nimport qualified Kernel.External.Ticket.Kapture.Flow as KF\nimport Kernel.External.Ticket.Kapture.Types as Kapture\nimport Kernel.Prelude\nimport qualified Kernel.Tools.Metrics.CoreMetrics as Metrics\nimport Kernel.Types.Error\nimport Kernel.Utils.Error.Throwing (throwError)\n\ncreateTicket ::\n  ( Metrics.CoreMetrics m,\n    EncFlow m r\n  ) =>\n  KaptureCfg ->\n  IT.CreateTicketReq ->\n  m Kapture.CreateTicketResp\ncreateTicket config req = do\n  auth <- decrypt config.auth\n  KF.createTicketAPI config.url config.version auth (mkCreateTicketReq req)\n\nmkCreateTicketReq :: IT.CreateTicketReq -> Kapture.CreateTicketReq\nmkCreateTicketReq IT.CreateTicketReq {..} =\n  Kapture.CreateTicketReq\n    { title = category,\n      ticketDetails = issueDescription,\n      disposition,\n      queue,\n      customerId = personId,\n      customerName = name,\n      phone = phoneNo,\n      issueDetails = mkIssueDetails,\n      rideDetails = mkRideDescriptionDriver <$> rideDescription,\n      classification = classification\n    }\n  where\n    mkIssueDetails =\n      Kapture.IssueDetails {..}\n\nmkRideDescriptionDriver :: IT.RideInfo -> Kapture.RideInfo\nmkRideDescriptionDriver IT.RideInfo {..} =\n  Kapture.RideInfo\n    { pickupLocationLat = Just pickupLocation.lat,\n      pickupLocationLon = Just pickupLocation.lon,\n      pickupLocationStreet = pickupLocation.street,\n      pickupLocationCity = pickupLocation.city,\n      pickupLocationState = pickupLocation.state,\n      pickupLocationCountry = pickupLocation.country,\n      pickupLocationBuilding = pickupLocation.building,\n      pickupLocationArea = pickupLocation.area,\n      dropLocationLat = (.lat) <$> dropLocation,\n      dropLocationLon = (.lon) <$> dropLocation,\n      dropLocationStreet = (.street) =<< dropLocation,\n      dropLocationCity = (.city) =<< dropLocation,\n      dropLocationState = (.state) =<< dropLocation,\n      dropLocationCountry = (.country) =<< dropLocation,\n      dropLocationBuilding = (.building) =<< dropLocation,\n      dropLocationArea = (.area) =<< dropLocation,\n      ..\n    }\n\nupdateTicket ::\n  ( Metrics.CoreMetrics m,\n    EncFlow m r\n  ) =>\n  KaptureCfg ->\n  IT.UpdateTicketReq ->\n  m Kapture.UpdateTicketResp\nupdateTicket config req = do\n  auth <- decrypt config.auth\n  KF.updateTicketAPI config.url config.version auth (mkUpdateTicketReq req)\n\nmkUpdateTicketReq :: IT.UpdateTicketReq -> Kapture.UpdateTicketReq\nmkUpdateTicketReq IT.UpdateTicketReq {..} =\n  Kapture.UpdateTicketReq\n    { comment = comment,\n      ticket_id = ticketId,\n      sub_status = show subStatus\n    }\n\naddAndUpdateKaptureCustomer ::\n  ( Metrics.CoreMetrics m,\n    EncFlow m r\n  ) =>\n  KaptureCfg ->\n  IT.KaptureCustomerReq ->\n  m Kapture.KaptureCustomerResp\naddAndUpdateKaptureCustomer config req = do\n  apiKey' <- decrypt config.auth\n  KF.addAndUpdateKaptureCustomer config.url apiKey' (mkKaptureCustomerReq req)\n  where\n    mkKaptureCustomerReq IT.KaptureCustomerReq {..} = Kapture.KaptureCustomerReq {..}\n\nkaptureEncryption ::\n  (Metrics.CoreMetrics m, EncFlow m r) =>\n  KaptureCfg ->\n  IT.KaptureEncryptionReq ->\n  m Kapture.KaptureEncryptionResp\nkaptureEncryption config req = do\n  let mKey = case req.ticketType of\n        IT.RIDE_RELATED -> config.encryptionKey\n        IT.APP_RELATED -> config.appEncryptionKey\n  case mKey of\n    Nothing -> throwError $ InternalError \"Kapture encryption key is not configured\"\n    Just key -> do\n      encryptionKey <- decrypt key\n      case config.encryptionUrl of\n        Nothing -> throwError $ InternalError \"Kapture encryption URL is not configured\"\n        Just url -> KF.kaptureEncryption url req.customerCode encryptionKey\n",
      "hash": "54baddc4378d4cf946f093676c226f5bf3ac200e37865d2ccb5c37520d6c8451",
      "size": 4593
    },
    "/lib/mobility-core/src/Kernel/External/Ticket/Interface/Types.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n{-# LANGUAGE TemplateHaskell #-}\n\nmodule Kernel.External.Ticket.Interface.Types\n  ( module Reexport,\n    module Kernel.External.Ticket.Interface.Types,\n  )\nwhere\n\nimport qualified Data.Text as T\nimport Deriving.Aeson\nimport Kernel.Beam.Lib.UtilsTH (mkBeamInstancesForEnum)\nimport Kernel.External.Ticket.Kapture.Config as Kapture\nimport Kernel.External.Ticket.Kapture.Types as Reexport (Classification (..), CreateTicketResp (..), KaptureCustomerResp (..), KaptureEncryptionResp (..), UpdateTicketResp (..))\nimport Kernel.External.Ticket.Types as Reexport\nimport Kernel.Prelude\nimport Kernel.Types.Common (Money)\nimport Kernel.Types.HideSecrets\nimport Servant.API (FromHttpApiData (..), ToHttpApiData (..))\n\nnewtype IssueTicketServiceConfig = KaptureConfig Kapture.KaptureCfg\n  deriving (Show, Eq, Generic, ToJSON, FromJSON)\n\ndata CreateTicketReq = CreateTicketReq\n  { category :: Text,\n    subCategory :: Maybe Text,\n    disposition :: Text,\n    queue :: Text,\n    issueId :: Maybe Text,\n    issueDescription :: Text,\n    mediaFiles :: Maybe [Text],\n    name :: Maybe Text,\n    phoneNo :: Maybe Text,\n    personId :: Text,\n    classification :: Classification,\n    rideDescription :: Maybe RideInfo,\n    becknIssueId :: Maybe Text\n  }\n  deriving (Show, Eq, Generic, ToJSON, FromJSON, ToSchema)\n\ninstance HideSecrets CreateTicketReq where\n  hideSecrets = identity\n\ndata RideInfo = RideInfo\n  { rideShortId :: Text,\n    rideCity :: Text,\n    vehicleCategory :: Maybe Text,\n    vehicleServiceTier :: Maybe Text,\n    customerName :: Maybe Text,\n    customerPhoneNo :: Maybe Text,\n    driverName :: Maybe Text,\n    driverPhoneNo :: Maybe Text,\n    vehicleNo :: Text,\n    status :: Text,\n    rideCreatedAt :: UTCTime,\n    pickupLocation :: Location,\n    dropLocation :: Maybe Location,\n    fare :: Maybe Money\n  }\n  deriving (Show, Eq, Generic, ToJSON, FromJSON, ToSchema)\n\ndata Location = Location\n  { lat :: Double,\n    lon :: Double,\n    street :: Maybe Text,\n    city :: Maybe Text,\n    state :: Maybe Text,\n    country :: Maybe Text,\n    building :: Maybe Text,\n    areaCode :: Maybe Text,\n    area :: Maybe Text\n  }\n  deriving (Show, Eq, Generic, ToJSON, FromJSON, ToSchema)\n\ndata UpdateTicketReq = UpdateTicketReq\n  { comment :: Text,\n    ticketId :: Text,\n    subStatus :: SubStatus\n  }\n\ndata SubStatus = OP | IN | RS | PE | CL | CRS\n  deriving (Eq, Show, Generic, ToJSON, FromJSON, ToSchema)\n\n-- SubStatusName\t  SubStatus Key\n-- OPEN\t            OP\n-- PENDING INTERNAL\tIN\n-- RESOLVED\t        RS\n-- PENDING EXTERNAL\tPE\n-- CLOSED\t          CL\n-- REOPENED         CRS\n\ndata KaptureCustomerReq = KaptureCustomerReq\n  { customerId :: Text,\n    name :: Text,\n    phone :: Text,\n    email :: Text,\n    customerCode :: Text\n  }\n  deriving (Show, Eq, Generic, ToJSON, FromJSON)\n\ndata KaptureEncryptionReq = KaptureEncryptionReq\n  { customerCode :: Text,\n    ticketType :: TicketType\n  }\n  deriving (Show, Eq, Generic, ToJSON, FromJSON)\n\ndata TicketType = APP_RELATED | RIDE_RELATED\n  deriving (Show, Read, Eq, Generic, ToJSON, FromJSON, ToSchema, ToParamSchema)\n\n$(mkBeamInstancesForEnum ''TicketType)\n\ninstance FromHttpApiData TicketType where\n  parseQueryParam txt = case T.toUpper txt of\n    \"APP_RELATED\" -> Right APP_RELATED\n    \"RIDE_RELATED\" -> Right RIDE_RELATED\n    _ -> Left $ \"Invalid TicketType: \" <> txt\n\ninstance ToHttpApiData TicketType where\n  toQueryParam APP_RELATED = \"APP_RELATED\"\n  toQueryParam RIDE_RELATED = \"RIDE_RELATED\"\n",
      "hash": "da12830314dd8351e072a36b2e07178fbd4b01088ce753060e0e8505d0e1992b",
      "size": 4133
    },
    "/lib/mobility-core/src/Kernel/External/Ticket/Kapture/Config.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n\nmodule Kernel.External.Ticket.Kapture.Config where\n\nimport Kernel.External.Encryption\nimport Kernel.Prelude\n\ndata KaptureCfg = KaptureCfg\n  { auth :: EncryptedField 'AsEncrypted Text,\n    version :: Text,\n    url :: BaseUrl,\n    encryptionUrl :: Maybe BaseUrl,\n    encryptionKey :: Maybe (EncryptedField 'AsEncrypted Text),\n    appEncryptionKey :: Maybe (EncryptedField 'AsEncrypted Text)\n  }\n  deriving (Show, Eq, Generic, ToJSON, FromJSON)\n",
      "hash": "2c33c6e9735c1315b38ac2fcd786fad3cad7a7e384afb59b2ae1d9f9bffc9f65",
      "size": 1136
    },
    "/lib/mobility-core/src/Kernel/External/Ticket/Kapture/Flow.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n\nmodule Kernel.External.Ticket.Kapture.Flow\n  ( createTicketAPI,\n    updateTicketAPI,\n    addAndUpdateKaptureCustomer,\n    kaptureEncryption,\n  )\nwhere\n\nimport EulerHS.Types as Euler\nimport qualified Kernel.External.Ticket.Kapture.Types as Kapture\nimport Kernel.Prelude\nimport Kernel.Tools.Metrics.CoreMetrics as Metrics\nimport Kernel.Types.Common\nimport Kernel.Types.Error (GenericError (InternalError))\nimport Kernel.Utils.Common (callAPI, fromEitherM)\nimport Servant hiding (throwError)\n\ntype KaptureCreateTicketAPI =\n  \"add-ticket-from-other-source.html\"\n    :> Capture \"version\" Text\n    :> Header \"Authorization\" Text\n    :> ReqBody '[JSON] Kapture.CreateTicketReq\n    :> Post '[JSON] Kapture.CreateTicketResp\n\ntype KaptureUpdateTicketAPI =\n  \"update-ticket-from-other-source.html\"\n    :> Capture \"version\" Text\n    :> Header \"Authorization\" Text\n    :> Header \"x-api-key\" Text\n    :> Header \"x-api-type\" Text\n    :> ReqBody '[JSON] Kapture.UpdateTicketReq\n    :> Post '[JSON] Kapture.UpdateTicketResp\n\ncreateTicketAPI ::\n  ( Metrics.CoreMetrics m,\n    MonadFlow m\n  ) =>\n  BaseUrl ->\n  Text ->\n  Text ->\n  Kapture.CreateTicketReq ->\n  m Kapture.CreateTicketResp\ncreateTicketAPI url version auth req = do\n  let eulerClient = Euler.client (Proxy @KaptureCreateTicketAPI)\n  callAPI url (eulerClient version (Just auth) req) \"createTicketAPI\" (Proxy @KaptureCreateTicketAPI)\n    >>= fromEitherM (\\err -> InternalError $ \"Failed to call create ticket API: \" <> show err)\n\nupdateTicketAPI ::\n  ( Metrics.CoreMetrics m,\n    MonadFlow m\n  ) =>\n  BaseUrl ->\n  Text ->\n  Text ->\n  Kapture.UpdateTicketReq ->\n  m Kapture.UpdateTicketResp\nupdateTicketAPI url version auth req = do\n  let eulerClient = Euler.client (Proxy @KaptureUpdateTicketAPI)\n  callAPI url (eulerClient version (Just auth) (Just auth) (Just \"TICKET\") req) \"updateTicketAPI\" (Proxy @KaptureUpdateTicketAPI)\n    >>= fromEitherM (\\err -> InternalError $ \"Failed to call update ticket API: \" <> show err)\n\ntype AddAndUpdateKaptureCustomerAPI =\n  \"add-update-customer-from-other-source.html\"\n    :> Header \"Authorization\" Text\n    :> Header \"x-api-key\" Text\n    :> Header \"x-api-type\" Text\n    :> ReqBody '[JSON] [Kapture.KaptureCustomerReq]\n    :> Post '[JSON] Kapture.KaptureCustomerResp\n\naddAndUpdateKaptureCustomer ::\n  (Metrics.CoreMetrics m, MonadFlow m) =>\n  BaseUrl ->\n  Text ->\n  Kapture.KaptureCustomerReq ->\n  m Kapture.KaptureCustomerResp\naddAndUpdateKaptureCustomer url apiKey req = do\n  let eulerClient = Euler.client (Proxy @AddAndUpdateKaptureCustomerAPI) (Just apiKey) (Just apiKey) (Just \"TICKET\") [req]\n  callAPI url eulerClient \"add-and-update-kapture-customer\" (Proxy @AddAndUpdateKaptureCustomerAPI)\n    >>= fromEitherM (\\err -> InternalError $ \"Failed to call add and update kapture customer API: \" <> show err)\n\ntype KaptureEncryptionAPI =\n  \"customer-code-encryption\"\n    :> QueryParam \"customer_code\" Text\n    :> QueryParam \"encryption_key\" Text\n    :> Get '[JSON] Kapture.KaptureEncryptionResp\n\nkaptureEncryption ::\n  (Metrics.CoreMetrics m, MonadFlow m) =>\n  BaseUrl ->\n  Text ->\n  Text ->\n  m Kapture.KaptureEncryptionResp\nkaptureEncryption url customerCode encryptionKey = do\n  let eulerClient = Euler.client (Proxy @KaptureEncryptionAPI) (Just customerCode) (Just encryptionKey)\n  callAPI url eulerClient \"kapture-encryption\" (Proxy @KaptureEncryptionAPI)\n    >>= fromEitherM (\\err -> InternalError $ \"Failed to call kapture encryption API: \" <> show err)\n",
      "hash": "e89f0d6026d1f50beae3115ca33646a31cce4b054c3b40d5a7e2d2f42e5b3337",
      "size": 4140
    },
    "/lib/mobility-core/src/Kernel/External/Ticket/Kapture/Types.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n{-# LANGUAGE DerivingStrategies #-}\n\nmodule Kernel.External.Ticket.Kapture.Types\n  ( module Kernel.External.Ticket.Kapture.Types,\n  )\nwhere\n\nimport Data.Aeson\nimport Kernel.Prelude\nimport Kernel.Types.Common (Money)\nimport Kernel.Utils.JSON\n\ndata Classification = DRIVER | CUSTOMER\n  deriving stock (Show, Eq, Generic)\n  deriving anyclass (FromJSON, ToJSON, ToSchema)\n\ndata CreateTicketReq = CreateTicketReq\n  { title :: Text,\n    ticketDetails :: Text,\n    disposition :: Text,\n    queue :: Text,\n    customerId :: Text,\n    customerName :: Maybe Text,\n    phone :: Maybe Text,\n    issueDetails :: IssueDetails,\n    rideDetails :: Maybe RideInfo,\n    classification :: Classification\n  }\n  deriving stock (Show, Eq, Generic)\n\ninstance ToJSON CreateTicketReq where\n  toJSON = genericToJSON constructorsWithSnakeCase\n\ndata UpdateTicketReq = UpdateTicketReq\n  { comment :: Text,\n    ticket_id :: Text,\n    sub_status :: Text\n  }\n  deriving stock (Show, Eq, Generic)\n\ninstance ToJSON UpdateTicketReq where\n  toJSON = genericToJSON constructorsWithSnakeCase\n\ndata IssueDetails = IssueDetails\n  { issueDescription :: Text,\n    issueId :: Maybe Text,\n    mediaFiles :: Maybe [Text],\n    subCategory :: Maybe Text,\n    category :: Text\n  }\n  deriving stock (Show, Eq, Generic)\n\ninstance ToJSON IssueDetails where\n  toJSON = genericToJSON constructorsWithSnakeCase\n\ndata RideInfo = RideInfo\n  { rideShortId :: Text,\n    rideCity :: Text,\n    customerName :: Maybe Text,\n    customerPhoneNo :: Maybe Text,\n    driverName :: Maybe Text,\n    driverPhoneNo :: Maybe Text,\n    vehicleNo :: Text,\n    status :: Text,\n    rideCreatedAt :: UTCTime,\n    vehicleCategory :: Maybe Text,\n    vehicleServiceTier :: Maybe Text,\n    pickupLocationLat :: Maybe Double,\n    pickupLocationLon :: Maybe Double,\n    pickupLocationStreet :: Maybe Text,\n    pickupLocationCity :: Maybe Text,\n    pickupLocationState :: Maybe Text,\n    pickupLocationCountry :: Maybe Text,\n    pickupLocationBuilding :: Maybe Text,\n    pickupLocationArea :: Maybe Text,\n    dropLocationLat :: Maybe Double,\n    dropLocationLon :: Maybe Double,\n    dropLocationStreet :: Maybe Text,\n    dropLocationCity :: Maybe Text,\n    dropLocationState :: Maybe Text,\n    dropLocationCountry :: Maybe Text,\n    dropLocationBuilding :: Maybe Text,\n    dropLocationArea :: Maybe Text,\n    fare :: Maybe Money\n  }\n  deriving stock (Show, Eq, Generic)\n\ninstance ToJSON RideInfo where\n  toJSON = genericToJSON constructorsWithLowerCase\n\ndata CreateTicketResp = CreateTicketResp\n  { additionalDetails :: AdditionalDetails,\n    ticketId :: Text,\n    ticket :: TicketDetails\n  }\n  deriving stock (Show, Eq, Generic)\n  deriving anyclass (ToSchema)\n\njsonOptions :: Options\njsonOptions =\n  defaultOptions\n    { fieldLabelModifier = \\case\n        \"additionalDetails\" -> \"Additional_details\"\n        \"ticketId\" -> \"ticket_id\"\n        other -> other\n    }\n\ninstance FromJSON CreateTicketResp where\n  parseJSON = genericParseJSON jsonOptions\n\ninstance ToJSON CreateTicketResp where\n  toJSON = genericToJSON jsonOptions\n\ndata UpdateTicketResp = UpdateTicketResp\n  { message :: Text,\n    status :: Text,\n    ticket :: TicketDetails\n  }\n  deriving stock (Show, Eq, Generic)\n\ninstance FromJSON UpdateTicketResp where\n  parseJSON = genericParseJSON jsonOptions\n\ninstance ToJSON UpdateTicketResp where\n  toJSON = genericToJSON jsonOptions\n\nnewtype AdditionalDetails = AdditionalDetails\n  { issueDetails :: [IssueResp]\n  }\n  deriving stock (Show, Eq, Generic)\n  deriving anyclass (ToSchema)\n\ninstance FromJSON AdditionalDetails where\n  parseJSON = genericParseJSON constructorsWithSnakeCase\n\ninstance ToJSON AdditionalDetails where\n  toJSON = genericToJSON constructorsWithSnakeCase\n\nnewtype IssueResp = IssueResp\n  { issueId :: Maybe Text\n  }\n  deriving stock (Show, Eq, Generic)\n  deriving anyclass (ToSchema)\n\ninstance FromJSON IssueResp where\n  parseJSON = genericParseJSON constructorsWithSnakeCase\n\ninstance ToJSON IssueResp where\n  toJSON = genericToJSON constructorsWithSnakeCase\n\nnewtype TicketDetails = TicketDetails\n  { subStatus :: Text\n  }\n  deriving stock (Show, Eq, Generic)\n  deriving anyclass (ToSchema)\n\ninstance FromJSON TicketDetails where\n  parseJSON = genericParseJSON constructorsWithLowerCase\n\ninstance ToJSON TicketDetails where\n  toJSON = genericToJSON constructorsWithLowerCase\n\ndata KaptureCustomerReq = KaptureCustomerReq\n  { customerId :: Text,\n    name :: Text,\n    phone :: Text,\n    email :: Text,\n    customerCode :: Text\n  }\n  deriving stock (Show, Eq, Generic)\n  deriving anyclass (ToSchema)\n\ninstance ToJSON KaptureCustomerReq where\n  toJSON = genericToJSON constructorsWithSnakeCase\n\ndata KaptureCustomerResp = KaptureCustomerResp\n  { message :: Text,\n    status :: Text,\n    kaptureCustomerId :: Text\n  }\n  deriving stock (Show, Eq, Generic)\n  deriving anyclass (ToSchema)\n\ninstance FromJSON KaptureCustomerResp where\n  parseJSON = withObject \"KaptureCustomerResp\" $ \\v ->\n    KaptureCustomerResp\n      <$> v .: \"message\"\n      <*> v .: \"status\"\n      <*> v .: \"Kapture Customer Id\"\n\ninstance ToJSON KaptureCustomerResp where\n  toJSON (KaptureCustomerResp message status kaptureCustomerId) =\n    object\n      [ \"message\" .= message,\n        \"status\" .= status,\n        \"Kapture Customer Id\" .= kaptureCustomerId\n      ]\n\ndata KaptureEncryptionResp = KaptureEncryptionResp\n  { success :: Bool,\n    encrytedCc :: Text,\n    encryptedIv :: Text\n  }\n  deriving stock (Show, Eq, Generic)\n  deriving anyclass (ToSchema)\n\ninstance FromJSON KaptureEncryptionResp where\n  parseJSON = genericParseJSON constructorsWithSnakeCase\n\ninstance ToJSON KaptureEncryptionResp where\n  toJSON = genericToJSON constructorsWithSnakeCase\n",
      "hash": "ad50a68d4bc2c5c06e3021a9d1ffa479f2303f5467227ac3405006bf0877109e",
      "size": 6362
    },
    "/lib/mobility-core/src/Kernel/External/Ticket/Types.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n{-# LANGUAGE TemplateHaskell #-}\n\nmodule Kernel.External.Ticket.Types\n  ( module Kernel.External.Ticket.Types,\n  )\nwhere\n\nimport qualified Data.Aeson as A\nimport Data.OpenApi\nimport qualified Data.Text as T\nimport EulerHS.Prelude\nimport Kernel.Beam.Lib.UtilsTH (mkBeamInstancesForEnum)\nimport qualified Kernel.Prelude as KP\nimport Kernel.Storage.Esqueleto (derivePersistField)\n\ndata IssueTicketService = Kapture\n  deriving (Show, Read, Eq, Ord, Generic, ToSchema)\n\ninstance FromJSON IssueTicketService where -- remove this instance once you add more constructors to IssueTicketService type.\n  parseJSON (A.String val) = maybe (fail (\"failed to parse String \" <> show val <> \" in IssueTicketService type\")) pure (KP.readMaybe $ T.unpack val)\n  parseJSON (A.Array _) = pure Kapture\n  parseJSON e = fail $ \"unexpected type, expected String for IssueTicketService \" <> show e\n\ninstance ToJSON IssueTicketService where\n  toJSON Kapture = A.String (show Kapture)\n\n$(mkBeamInstancesForEnum ''IssueTicketService)\n\nderivePersistField \"IssueTicketService\"\n",
      "hash": "9fad885432cbc0530a85374b9f3a8f2d5958357a92a796652818a6d128b0d246",
      "size": 1739
    },
    "/lib/mobility-core/src/Kernel/External/Tokenize.hs": {
      "type": "content",
      "content": "module Kernel.External.Tokenize\n  ( module Reexport,\n    prepareJourneyMonitoringHttpManager,\n  )\nwhere\n\nimport Kernel.External.Tokenize.Interface as Reexport\nimport Kernel.External.Tokenize.Interface.Types as Reexport\nimport Kernel.External.Tokenize.JourneyMonitoring.Flow (prepareJourneyMonitoringHttpManager)\nimport Kernel.External.Tokenize.Types as Reexport\n",
      "hash": "f9b2fb8bd6a77a00a99ccb96a5335f4ade07a6f3288bbbb0702fffb573d87fb8",
      "size": 362
    },
    "/lib/mobility-core/src/Kernel/External/Tokenize/Gullak/Flow.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n\nmodule Kernel.External.Tokenize.Gullak.Flow where\n\nimport qualified Data.Aeson as A\nimport qualified Data.Text.Encoding as DT\nimport EulerHS.Types (client)\nimport qualified Kernel.External.Tokenize.Gullak.Types as Gullak\nimport Kernel.Prelude\nimport Kernel.Tools.Metrics.CoreMetrics (CoreMetrics)\nimport Kernel.Types.Error (GenericError (InternalError))\nimport Kernel.Utils.Common\nimport Servant hiding (throwError)\n\ntype GullakOnboardingAPI =\n  \"customer\"\n    :> \"onboard\"\n    :> BasicAuth \"username-password\" BasicAuthData\n    :> ReqBody '[JSON] Gullak.OnboardingReq\n    :> Post '[JSON] Gullak.OnboardingAndLoginRes\n\ntype GullakLoginAPI =\n  \"customer\"\n    :> \"authenticate\"\n    :> BasicAuth \"username-password\" BasicAuthData\n    :> ReqBody '[JSON] Gullak.LoginReq\n    :> Post '[JSON] Gullak.OnboardingAndLoginRes\n\ngullakOnboarding ::\n  ( CoreMetrics m,\n    MonadFlow m\n  ) =>\n  BaseUrl ->\n  Text ->\n  Text ->\n  Gullak.OnboardingReq ->\n  m Gullak.OnboardingAndLoginRes\ngullakOnboarding url apiKey merchantId req = do\n  let eulerClient = client (Proxy @GullakOnboardingAPI)\n  let basicAuthData =\n        BasicAuthData\n          { basicAuthUsername = DT.encodeUtf8 merchantId,\n            basicAuthPassword = DT.encodeUtf8 apiKey\n          }\n  void $ logDebug $ \"Gullak Onboarding req\" <> (show $ A.encode req)\n  callAPI url (eulerClient basicAuthData req) \"Gullak onbaording\" (Proxy @GullakOnboardingAPI)\n    >>= fromEitherM (\\err -> InternalError $ \"Failed to call Gullak onbaording API: \" <> show err)\n\ngullakLogin ::\n  ( CoreMetrics m,\n    MonadFlow m\n  ) =>\n  BaseUrl ->\n  Text ->\n  Text ->\n  Gullak.LoginReq ->\n  m Gullak.OnboardingAndLoginRes\ngullakLogin url apiKey merchantId req = do\n  let eulerClient = client (Proxy @GullakLoginAPI)\n  let basicAuthData =\n        BasicAuthData\n          { basicAuthUsername = DT.encodeUtf8 merchantId,\n            basicAuthPassword = DT.encodeUtf8 apiKey\n          }\n  void $ logDebug $ \"Gullak login req\" <> (show $ A.encode req)\n  callAPI url (eulerClient basicAuthData req) \"Gullak login\" (Proxy @GullakLoginAPI)\n    >>= fromEitherM (\\err -> InternalError $ \"Failed to call Gullak login API: \" <> show err)\n",
      "hash": "42e1e1092f2eaaaf1bcc45baed9dadfba4f98bc1efaf4087e2da9cd6ac43493a",
      "size": 2847
    },
    "/lib/mobility-core/src/Kernel/External/Tokenize/Gullak/Types.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n{-# LANGUAGE DerivingStrategies #-}\n\nmodule Kernel.External.Tokenize.Gullak.Types where\n\nimport Kernel.External.Encryption\nimport Kernel.Prelude hiding (error)\n\ndata GullakConfig = GullakConfig\n  { url :: BaseUrl,\n    udf :: Maybe Text,\n    merchantId :: Text,\n    apiKey :: EncryptedField 'AsEncrypted Text\n  }\n  deriving stock (Show, Eq, Generic)\n  deriving anyclass (FromJSON, ToJSON)\n\ndata OnboardingAndLoginRes = OnboardingAndLoginRes\n  { status :: Text,\n    loginToken :: LoginToken\n  }\n  deriving stock (Show, Eq, Generic)\n  deriving anyclass (FromJSON, ToJSON)\n\ndata OnboardingReq = OnboardingReq\n  { merchantUserId :: Text,\n    mobile :: Text,\n    email :: Maybe Text,\n    dob :: Maybe Text,\n    pan :: Maybe Text,\n    name :: Maybe Text,\n    isKycVerified :: Maybe Bool,\n    address :: Maybe Address,\n    languageDetails :: Maybe LanguageDetails,\n    locationDetails :: Maybe LocationDetails\n  }\n  deriving stock (Show, Eq, Generic)\n  deriving anyclass (FromJSON, ToJSON)\n\ndata LanguageDetails = LanguageDetails\n  { defaultLanguage :: Text,\n    languagesKnown :: [Text]\n  }\n  deriving stock (Show, Eq, Generic)\n  deriving anyclass (FromJSON, ToJSON)\n\ndata LocationDetails = LocationDetails\n  { sparseCoordinates :: [Double],\n    state :: Text,\n    city :: Text\n  }\n  deriving stock (Show, Eq, Generic)\n  deriving anyclass (FromJSON, ToJSON)\n\nnewtype LoginReq = LoginReq\n  { merchantUserId :: Text\n  }\n  deriving stock (Show, Eq, Generic)\n  deriving anyclass (FromJSON, ToJSON)\n\ndata LoginToken = LoginToken\n  { accessToken :: Text,\n    expiryDate :: Text\n  }\n  deriving stock (Show, Eq, Generic)\n  deriving anyclass (FromJSON, ToJSON)\n\ndata Address = Address\n  { name :: Text,\n    mobileNo :: Text,\n    state :: Text,\n    city :: Text,\n    pincode :: Text,\n    address :: Text\n  }\n  deriving stock (Show, Eq, Generic)\n  deriving anyclass (FromJSON, ToJSON)\n",
      "hash": "6fa0929e47a4abb72898e99f643502ec0f77bd008f840819570c367ec4e05af8",
      "size": 2560
    },
    "/lib/mobility-core/src/Kernel/External/Tokenize/HyperVerge/Flow.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\nmodule Kernel.External.Tokenize.HyperVerge.Flow where\n\nimport qualified Data.Text as DT\nimport EulerHS.Types (EulerClient, ManagerSelector (..), client)\nimport Kernel.External.SharedLogic.HyperVerge.Error\nimport Kernel.External.SharedLogic.HyperVerge.Functions (hyperVergeHttpManagerKey)\nimport qualified Kernel.External.Tokenize.HyperVerge.Types as HyperVergeTypes\nimport Kernel.Prelude\nimport Kernel.Tools.Metrics.CoreMetrics (CoreMetrics)\nimport Kernel.Types.Error (ExternalAPICallError (..))\nimport Kernel.Utils.Common\nimport Servant hiding (throwError)\nimport Servant.Client.Core (ClientError)\n\ntype HyperVergeTokenizeAPI =\n  \"login\"\n    :> ReqBody '[JSON] HyperVergeTypes.HyperVergeTokenizeRequest\n    :> Post '[JSON] HyperVergeTypes.HyperVergeTokenizeResponse\n\ntokenizeClient :: HyperVergeTypes.HyperVergeTokenizeRequest -> EulerClient HyperVergeTypes.HyperVergeTokenizeResponse\ntokenizeClient = client (Proxy :: Proxy HyperVergeTokenizeAPI)\n\ntokenize ::\n  ( HasCallStack,\n    MonadFlow m,\n    CoreMetrics m\n  ) =>\n  BaseUrl ->\n  HyperVergeTypes.HyperVergeTokenizeRequest ->\n  m HyperVergeTypes.HyperVergeTokenizeResponse\ntokenize url req = do\n  callAPI' (Just $ ManagerSelector $ DT.pack hyperVergeHttpManagerKey) url (tokenizeClient req) \"HV-tokenize-API\" (Proxy @HyperVergeTokenizeAPI) >>= checkHyperVergeTokenizeResponse url\n\ncheckHyperVergeTokenizeResponse ::\n  ( HasCallStack,\n    MonadFlow m,\n    CoreMetrics m\n  ) =>\n  BaseUrl ->\n  Either ClientError HyperVergeTypes.HyperVergeTokenizeResponse ->\n  m HyperVergeTypes.HyperVergeTokenizeResponse\ncheckHyperVergeTokenizeResponse url resp = fromEitherM (hyperVergeError url) resp >>= validateHyperVergeTokenizeResponse\n\nhyperVergeError :: BaseUrl -> ClientError -> ExternalAPICallError\nhyperVergeError = ExternalAPICallError (Just \"HYPERVERGE_API_ERROR\")\n\nvalidateHyperVergeTokenizeResponse :: (MonadThrow m, Log m) => HyperVergeTypes.HyperVergeTokenizeResponse -> m HyperVergeTypes.HyperVergeTokenizeResponse\nvalidateHyperVergeTokenizeResponse resp = do\n  logDebug $ \"HyperVerge Tokenize Response: \" <> show resp\n  case resp.statusCode of\n    (Just \"401\") -> throwError $ HVUnauthorizedError\n    (Just \"400\") -> throwError $ HVBadRequestError (fromMaybe \"\" resp.error)\n    (Just \"200\") -> return resp\n    _ -> throwError $ HVError (\"The response from HV is : \" <> show resp)\n",
      "hash": "a4b65edaa48c88259d5a718bdcb061344a8b054950f0a28d62c86efba0573115",
      "size": 3030
    },
    "/lib/mobility-core/src/Kernel/External/Tokenize/HyperVerge/Types.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n{-# LANGUAGE DerivingStrategies #-}\n\nmodule Kernel.External.Tokenize.HyperVerge.Types where\n\nimport Kernel.External.Encryption\nimport Kernel.Prelude hiding (error)\n\ndata HyperVergeTokenizeConfig = HyperVergeTokenizeConfig\n  { url :: BaseUrl,\n    appId :: Text,\n    appKey :: EncryptedField 'AsEncrypted Text\n  }\n  deriving stock (Show, Eq, Generic)\n  deriving anyclass (FromJSON, ToJSON)\n\ndata HyperVergeTokenizeRequest = HyperVergeTokenizeRequest\n  { appId :: Text,\n    appKey :: Text,\n    expiry :: Int\n  }\n  deriving (Show, Eq, Generic, FromJSON, ToJSON)\n\nnewtype ResultData = ResultData\n  { token :: Text\n  }\n  deriving (Show, Eq, Generic, FromJSON, ToJSON)\n\ndata HyperVergeTokenizeResponse = HyperVergeTokenizeResponse\n  { status :: Maybe Text,\n    statusCode :: Maybe Text,\n    result :: Maybe ResultData,\n    error :: Maybe Text,\n    message :: Maybe Text\n  }\n  deriving (Show, Eq, Generic, FromJSON, ToJSON)\n",
      "hash": "26cc6e88f4230ecfde4e70d5f8ed358b0c582efa1cf19576853b0d043e747793",
      "size": 1609
    },
    "/lib/mobility-core/src/Kernel/External/Tokenize/Interface.hs": {
      "type": "content",
      "content": "{-\n Copyright 2022-23, Juspay India Pvt Ltd\n\n This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program\n\n is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n\n or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of\n\n the GNU Affero General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\nmodule Kernel.External.Tokenize.Interface where\n\nimport Kernel.External.Encryption as Common (EncFlow)\nimport qualified Kernel.External.Tokenize.Interface.Gullak as GullakInt\nimport qualified Kernel.External.Tokenize.Interface.HyperVerge as HyperVergeInt\nimport qualified Kernel.External.Tokenize.Interface.JourneyMonitoring as JourneyMonitoringInt\nimport qualified Kernel.External.Tokenize.Interface.Types as InterfaceTypes\nimport Kernel.Tools.Metrics.CoreMetrics (CoreMetrics)\nimport Kernel.Types.Error\nimport Kernel.Utils.Error.Throwing (throwError)\n\ntokenize ::\n  ( EncFlow m r,\n    CoreMetrics m\n  ) =>\n  InterfaceTypes.TokenizationServiceConfig ->\n  InterfaceTypes.TokenizationReq ->\n  m InterfaceTypes.TokenizationResp\ntokenize serviceConfig req =\n  case serviceConfig of\n    InterfaceTypes.HyperVergeTokenizationServiceConfig config -> HyperVergeInt.tokenize config req\n    InterfaceTypes.JourneyMonitoringTokenizationServiceConfig config -> JourneyMonitoringInt.tokenize config req\n    _ -> throwError (InternalError \"Unsupported Tokenization Service\")\n\nonboard ::\n  ( CoreMetrics m,\n    EncFlow m r\n  ) =>\n  InterfaceTypes.TokenizationServiceConfig ->\n  InterfaceTypes.OnboardingReq ->\n  m InterfaceTypes.OnboardingAndLoginRes\nonboard serviceConfig req = do\n  case serviceConfig of\n    InterfaceTypes.GullakTokenizationServiceConfig config -> GullakInt.gullakOnboarding config req\n    _ -> throwError (InternalError \"Unsupported Tokenization Service\")\n\nlogin ::\n  ( CoreMetrics m,\n    EncFlow m r\n  ) =>\n  InterfaceTypes.TokenizationServiceConfig ->\n  InterfaceTypes.LoginReq ->\n  m InterfaceTypes.OnboardingAndLoginRes\nlogin serviceConfig req = do\n  case serviceConfig of\n    InterfaceTypes.GullakTokenizationServiceConfig config -> GullakInt.gullakLogin config req\n    _ -> throwError (InternalError \"Unsupported Tokenization Service\")\n",
      "hash": "82d7e5f76228c192bc758ca939928e06aa3617e8c34814208de12c29b67640aa",
      "size": 2535
    },
    "/lib/mobility-core/src/Kernel/External/Tokenize/Interface/Error.hs": {
      "type": "content",
      "content": "{-\n Copyright 2022-23, Juspay India Pvt Ltd\n\n This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program\n\n is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n\n or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of\n\n the GNU Affero General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n{-# LANGUAGE DeriveAnyClass #-}\n{-# LANGUAGE TemplateHaskell #-}\n\nmodule Kernel.External.Tokenize.Interface.Error where\n\nimport Kernel.Prelude\nimport Kernel.Types.Error.BaseError\nimport Kernel.Types.Error.BaseError.HTTPError\n\ndata TokenizationError\n  = TokenNotFound Text\n  | ExpiryNotFound Text\n  deriving (Eq, Show, IsBecknAPIError)\n\ninstanceExceptionWithParent 'HTTPException ''TokenizationError\n\ninstance IsBaseError TokenizationError where\n  toMessage = \\case\n    TokenNotFound svcName -> Just $ \"Token Not found in Tokenization response of service provider\" <> svcName\n    ExpiryNotFound svcName -> Just $ \"Expiry Not found in Tokenization response of service provider\" <> svcName\n\ninstance IsHTTPError TokenizationError where\n  toErrorCode = \\case\n    TokenNotFound _ -> \"TOKEN_NOT_FOUND\"\n    ExpiryNotFound _ -> \"EXPIRY_NOT_FOUND\"\n\n  toHttpCode = \\case\n    TokenNotFound _ -> E500\n    ExpiryNotFound _ -> E500\n\ninstance IsAPIError TokenizationError\n",
      "hash": "f2a4ab9e06861cdf7bceabf0f32589392ac2bfcd09f5d01157d7fc5617e00e4b",
      "size": 1644
    },
    "/lib/mobility-core/src/Kernel/External/Tokenize/Interface/Gullak.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n\nmodule Kernel.External.Tokenize.Interface.Gullak where\n\nimport Kernel.External.Encryption (EncFlow, decrypt)\nimport qualified Kernel.External.Tokenize.Gullak.Flow as GullakFlow\nimport qualified Kernel.External.Tokenize.Gullak.Types as GullakTypes\nimport qualified Kernel.External.Tokenize.Interface.Types as InterfaceTypes\nimport Kernel.Prelude\nimport Kernel.Tools.Metrics.CoreMetrics (CoreMetrics)\n\ngullakLogin ::\n  ( CoreMetrics m,\n    EncFlow m r\n  ) =>\n  GullakTypes.GullakConfig ->\n  InterfaceTypes.LoginReq ->\n  m InterfaceTypes.OnboardingAndLoginRes\ngullakLogin config req = do\n  apikey' <- decrypt config.apiKey\n  mkReqOnboardingAndLoginRes <$> GullakFlow.gullakLogin config.url apikey' config.merchantId (mkReqLoginReq req)\n  where\n    mkReqLoginReq :: InterfaceTypes.LoginReq -> GullakTypes.LoginReq\n    mkReqLoginReq InterfaceTypes.LoginReq {..} = GullakTypes.LoginReq {..}\n\ngullakOnboarding ::\n  ( CoreMetrics m,\n    EncFlow m r\n  ) =>\n  GullakTypes.GullakConfig ->\n  InterfaceTypes.OnboardingReq ->\n  m InterfaceTypes.OnboardingAndLoginRes\ngullakOnboarding config req = do\n  apikey' <- decrypt config.apiKey\n  mkReqOnboardingAndLoginRes <$> GullakFlow.gullakOnboarding config.url apikey' config.merchantId (mkReqOnboardingReq req)\n  where\n    mkReqOnboardingReq :: InterfaceTypes.OnboardingReq -> GullakTypes.OnboardingReq\n    mkReqOnboardingReq InterfaceTypes.OnboardingReq {..} = GullakTypes.OnboardingReq {languageDetails = mkReqLanguageDetails <$> languageDetails, address = mkReqAddress <$> address, locationDetails = mkReqlocationDetails <$> locationDetails, ..}\n\n    mkReqLanguageDetails :: InterfaceTypes.LanguageDetails -> GullakTypes.LanguageDetails\n    mkReqLanguageDetails InterfaceTypes.LanguageDetails {..} = GullakTypes.LanguageDetails {..}\n\n    mkReqlocationDetails :: InterfaceTypes.LocationDetails -> GullakTypes.LocationDetails\n    mkReqlocationDetails InterfaceTypes.LocationDetails {..} = GullakTypes.LocationDetails {..}\n\n    mkReqAddress :: InterfaceTypes.Address -> GullakTypes.Address\n    mkReqAddress InterfaceTypes.Address {..} = GullakTypes.Address {..}\n\nmkReqOnboardingAndLoginRes :: GullakTypes.OnboardingAndLoginRes -> InterfaceTypes.OnboardingAndLoginRes\nmkReqOnboardingAndLoginRes GullakTypes.OnboardingAndLoginRes {..} = InterfaceTypes.OnboardingAndLoginRes {loginToken = mkReqLoginToken loginToken, ..}\n\nmkReqLoginToken :: GullakTypes.LoginToken -> InterfaceTypes.LoginToken\nmkReqLoginToken GullakTypes.LoginToken {..} = InterfaceTypes.LoginToken {..}\n",
      "hash": "ad21cd5e9203e0ecf0cad95585063b090b23a77b5b8b7f10a37dc911ef990703",
      "size": 3194
    },
    "/lib/mobility-core/src/Kernel/External/Tokenize/Interface/HyperVerge.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n\nmodule Kernel.External.Tokenize.Interface.HyperVerge where\n\nimport Kernel.External.Encryption (EncFlow, decrypt)\nimport qualified Kernel.External.Tokenize.HyperVerge.Flow as HyperVergeFlow\nimport qualified Kernel.External.Tokenize.HyperVerge.Types as HyperVergeTypes\nimport Kernel.External.Tokenize.Interface.Error\nimport qualified Kernel.External.Tokenize.Interface.Types as InterfaceTypes\nimport Kernel.Prelude hiding (error)\nimport Kernel.Tools.Metrics.CoreMetrics (CoreMetrics)\nimport Kernel.Utils.Error.Throwing (fromMaybeM)\n\ntokenize ::\n  ( CoreMetrics m,\n    EncFlow m r\n  ) =>\n  HyperVergeTypes.HyperVergeTokenizeConfig ->\n  InterfaceTypes.TokenizationReq ->\n  m InterfaceTypes.TokenizationResp\ntokenize config req = do\n  hvReq <- makeHyperVergeTokenizeRequest config req\n  resp <- HyperVergeFlow.tokenize config.url hvReq\n  makeHyperVergeTokenizeResp resp\n  where\n    makeHyperVergeTokenizeRequest :: EncFlow m r => HyperVergeTypes.HyperVergeTokenizeConfig -> InterfaceTypes.TokenizationReq -> m HyperVergeTypes.HyperVergeTokenizeRequest\n    makeHyperVergeTokenizeRequest HyperVergeTypes.HyperVergeTokenizeConfig {..} InterfaceTypes.TokenizationReq {..} = do\n      appkey' <- decrypt appKey\n      return $\n        HyperVergeTypes.HyperVergeTokenizeRequest\n          { appKey = appkey',\n            expiry = fromMaybe 0 expiry,\n            ..\n          }\n    makeHyperVergeTokenizeResp HyperVergeTypes.HyperVergeTokenizeResponse {..} = do\n      token <- fromMaybeM (TokenNotFound \"HyperVerge\") $ result <&> (.token)\n      let expiresAt = Nothing\n      return $ InterfaceTypes.TokenizationResp {..}\n",
      "hash": "0c3398330707a1c44a1d14c57ed816427cfe86fd0040a0f2682de486349902ca",
      "size": 2300
    },
    "/lib/mobility-core/src/Kernel/External/Tokenize/Interface/JourneyMonitoring.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n\nmodule Kernel.External.Tokenize.Interface.JourneyMonitoring where\n\nimport qualified Data.Aeson as A\nimport qualified Data.Text as T\nimport Kernel.External.Encryption (EncFlow)\nimport Kernel.External.Tokenize.Interface.Error\nimport qualified Kernel.External.Tokenize.Interface.Types as InterfaceTypes\nimport qualified Kernel.External.Tokenize.JourneyMonitoring.Flow as JourneyMonitoringFlow\nimport qualified Kernel.External.Tokenize.JourneyMonitoring.Types as JourneyMonitoringTypes\nimport Kernel.Prelude hiding (error)\nimport Kernel.Tools.Metrics.CoreMetrics (CoreMetrics)\nimport Kernel.Utils.Error.Throwing (fromMaybeM)\n\ntokenize ::\n  ( CoreMetrics m,\n    EncFlow m r\n  ) =>\n  JourneyMonitoringTypes.JourneyMonitoringTokenizeConfig ->\n  InterfaceTypes.TokenizationReq ->\n  m InterfaceTypes.TokenizationResp\ntokenize config _ = do\n  resp <- JourneyMonitoringFlow.tokenize config\n  makeJourneyMonitoringTokenizeResp resp\n  where\n    makeJourneyMonitoringTokenizeResp JourneyMonitoringTypes.JourneyMonitoringTokenizeResponse {..} = do\n      token <- fromMaybeM (TokenNotFound \"JourneyMonitoring\") $ ((.accessToken) =<< tokenData)\n      let expiresAt = parseTime =<< (.expiresAt) =<< tokenData\n      return $ InterfaceTypes.TokenizationResp {..}\n\nparseTime :: Text -> Maybe UTCTime\nparseTime time = A.decode $ A.encode modifyText\n  where\n    modifyText = T.replace \" \" \"T\" time <> \"Z\"\n",
      "hash": "669ce32412c958bbc507d65d8e39575deb784178f91b87850812f6eb034957a9",
      "size": 2076
    },
    "/lib/mobility-core/src/Kernel/External/Tokenize/Interface/Types.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n{-# LANGUAGE DerivingStrategies #-}\n\nmodule Kernel.External.Tokenize.Interface.Types where\n\nimport qualified Kernel.External.Tokenize.Gullak.Types as GUKTypes\nimport qualified Kernel.External.Tokenize.HyperVerge.Types as HVTypes\nimport Kernel.External.Tokenize.JourneyMonitoring.Types as JMTypes\nimport Kernel.Prelude\n\ndata TokenizationServiceConfig = HyperVergeTokenizationServiceConfig HVTypes.HyperVergeTokenizeConfig | JourneyMonitoringTokenizationServiceConfig JMTypes.JourneyMonitoringTokenizeConfig | GullakTokenizationServiceConfig GUKTypes.GullakConfig\n  deriving (Show, Eq, Generic, ToJSON, FromJSON)\n\nnewtype TokenizationReq = TokenizationReq\n  { expiry :: Maybe Int\n  }\n  deriving (Show, Eq, Generic, FromJSON, ToJSON)\n\ndata TokenizationResp = TokenizationResp\n  { token :: Text,\n    expiresAt :: Maybe UTCTime\n  }\n  deriving (Show, Eq, Generic, FromJSON, ToJSON)\n\ndata OnboardingAndLoginRes = OnboardingAndLoginRes\n  { status :: Text,\n    loginToken :: LoginToken\n  }\n  deriving stock (Show, Eq, Generic)\n  deriving anyclass (FromJSON, ToJSON)\n\ndata OnboardingReq = OnboardingReq\n  { merchantUserId :: Text,\n    mobile :: Text,\n    email :: Maybe Text,\n    dob :: Maybe Text,\n    pan :: Maybe Text,\n    name :: Maybe Text,\n    isKycVerified :: Maybe Bool,\n    address :: Maybe Address,\n    languageDetails :: Maybe LanguageDetails,\n    locationDetails :: Maybe LocationDetails\n  }\n  deriving stock (Show, Eq, Generic)\n  deriving anyclass (FromJSON, ToJSON)\n\ndata LanguageDetails = LanguageDetails\n  { defaultLanguage :: Text,\n    languagesKnown :: [Text]\n  }\n  deriving stock (Show, Eq, Generic)\n  deriving anyclass (FromJSON, ToJSON)\n\ndata LocationDetails = LocationDetails\n  { sparseCoordinates :: [Double],\n    state :: Text,\n    city :: Text\n  }\n  deriving stock (Show, Eq, Generic)\n  deriving anyclass (FromJSON, ToJSON)\n\nnewtype LoginReq = LoginReq\n  { merchantUserId :: Text\n  }\n  deriving stock (Show, Eq, Generic)\n  deriving anyclass (FromJSON, ToJSON)\n\ndata LoginToken = LoginToken\n  { accessToken :: Text,\n    expiryDate :: Text\n  }\n  deriving stock (Show, Eq, Generic)\n  deriving anyclass (FromJSON, ToJSON)\n\ndata Address = Address\n  { name :: Text,\n    mobileNo :: Text,\n    state :: Text,\n    city :: Text,\n    pincode :: Text,\n    address :: Text\n  }\n  deriving stock (Show, Eq, Generic)\n  deriving anyclass (FromJSON, ToJSON)\n",
      "hash": "00d7400c90d9ef5fa31bf9ec1b678c4531cacb197356b21821a8c407a5fb68d1",
      "size": 3048
    },
    "/lib/mobility-core/src/Kernel/External/Tokenize/JourneyMonitoring/Error.hs": {
      "type": "content",
      "content": "{-\n Copyright 2022-23, Juspay India Pvt Ltd\n\n This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program\n\n is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n\n or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of\n\n the GNU Affero General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n{-# LANGUAGE DeriveAnyClass #-}\n{-# LANGUAGE TemplateHaskell #-}\n\nmodule Kernel.External.Tokenize.JourneyMonitoring.Error where\n\nimport Kernel.Prelude\nimport Kernel.Types.Error.BaseError\nimport Kernel.Types.Error.BaseError.HTTPError\n\ndata JourneyMonitoringError\n  = JMUnauthorizedError\n  | JMError Text\n  deriving (Eq, Show, IsBecknAPIError)\n\ninstanceExceptionWithParent 'HTTPException ''JourneyMonitoringError\n\ninstance IsBaseError JourneyMonitoringError where\n  toMessage = \\case\n    JMUnauthorizedError -> Just \"Invalid Credentaials, Please provide valid username and password.\"\n    JMError msg -> Just $ \"JourneyMonitoring Error with message: \" <> msg\n\ninstance IsHTTPError JourneyMonitoringError where\n  toErrorCode = \\case\n    JMUnauthorizedError -> \"JM_UNAUTHORIZED\"\n    JMError _ -> \"JM_ERROR\"\n\n  toHttpCode = \\case\n    JMUnauthorizedError -> E401\n    JMError _ -> E400\n\ninstance IsAPIError JourneyMonitoringError\n",
      "hash": "2ad4456d34ca3ac0b70f5745fccc132eb17077202d836cf9ed65d45e542f3ef7",
      "size": 1609
    },
    "/lib/mobility-core/src/Kernel/External/Tokenize/JourneyMonitoring/Flow.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\nmodule Kernel.External.Tokenize.JourneyMonitoring.Flow where\n\nimport qualified Data.HashMap.Internal as HMap\nimport qualified Data.Text as DT\nimport qualified Data.Text.Encoding as DE\nimport EulerHS.Types (ManagerSelector (..), client)\nimport Kernel.External.Encryption (decrypt)\nimport qualified Kernel.External.Tokenize.JourneyMonitoring.Types as JourneyMonitoringTypes\nimport Kernel.Prelude\nimport Kernel.Tools.Metrics.CoreMetrics (CoreMetrics)\nimport Kernel.Types.Error (ExternalAPICallError (..))\nimport Kernel.Utils.Common\nimport qualified Network.HTTP.Client as Http\nimport qualified Network.HTTP.Client.TLS as Http\nimport Servant hiding (throwError)\nimport Servant.Client.Core (ClientError)\n\ntype JourneyMonitoringTokenizeAPI =\n  \"WBJMONRestAPI\" :> \"user\" :> \"auth\" :> \"generateToken\"\n    :> BasicAuth \"username-password\" BasicAuthData\n    :> Post '[JSON] JourneyMonitoringTypes.JourneyMonitoringTokenizeResponse\n\ntokenize ::\n  ( HasCallStack,\n    MonadFlow m,\n    CoreMetrics m,\n    EncFlow m r\n  ) =>\n  JourneyMonitoringTypes.JourneyMonitoringTokenizeConfig ->\n  m JourneyMonitoringTypes.JourneyMonitoringTokenizeResponse\ntokenize JourneyMonitoringTypes.JourneyMonitoringTokenizeConfig {..} = do\n  username_ <- decrypt username\n  password_ <- decrypt password\n  let authData = BasicAuthData (DE.encodeUtf8 $ username_) (DE.encodeUtf8 $ password_)\n  callAPI' ((Just $ ManagerSelector $ DT.pack journeyMonitoringHttpManagerKey)) url (client (Proxy @JourneyMonitoringTokenizeAPI) authData) \"generateToken\" (Proxy @JourneyMonitoringTokenizeAPI) >>= checkJourneyMonitoringTokenizeResponse url\n\ncheckJourneyMonitoringTokenizeResponse ::\n  ( HasCallStack,\n    MonadFlow m,\n    CoreMetrics m\n  ) =>\n  BaseUrl ->\n  Either ClientError JourneyMonitoringTypes.JourneyMonitoringTokenizeResponse ->\n  m JourneyMonitoringTypes.JourneyMonitoringTokenizeResponse\ncheckJourneyMonitoringTokenizeResponse url resp = fromEitherM (journeyMonitoringError url) resp >>= validateJourneyMonitoringTokenizeResponse\n\njourneyMonitoringError :: BaseUrl -> ClientError -> ExternalAPICallError\njourneyMonitoringError = ExternalAPICallError (Just \"JOURNEY_MONITORING_API_ERROR\")\n\nvalidateJourneyMonitoringTokenizeResponse :: (MonadThrow m, Log m) => JourneyMonitoringTypes.JourneyMonitoringTokenizeResponse -> m JourneyMonitoringTypes.JourneyMonitoringTokenizeResponse\nvalidateJourneyMonitoringTokenizeResponse resp = do\n  logDebug $ \"JourneyMonitoring Tokenize Response: \" <> show resp\n  pure resp\n\nprepareJourneyMonitoringHttpManager :: Int -> HMap.HashMap DT.Text Http.ManagerSettings\nprepareJourneyMonitoringHttpManager timeout =\n  HMap.singleton (DT.pack journeyMonitoringHttpManagerKey) $\n    Http.tlsManagerSettings {Http.managerResponseTimeout = Http.responseTimeoutMicro (timeout * 1000)}\n\njourneyMonitoringHttpManagerKey :: String\njourneyMonitoringHttpManagerKey = \"JourneyMonitoring-http-manager\"\n",
      "hash": "1ac8bf55e74c80bdb4741d3e00b5653e8f25b7bb71412ca2084e07f90c7efa03",
      "size": 3578
    },
    "/lib/mobility-core/src/Kernel/External/Tokenize/JourneyMonitoring/Types.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n{-# LANGUAGE DerivingStrategies #-}\n\nmodule Kernel.External.Tokenize.JourneyMonitoring.Types where\n\nimport Data.Aeson\nimport Kernel.External.Encryption\nimport Kernel.Prelude hiding (error)\n\ndata JourneyMonitoringTokenizeConfig = JourneyMonitoringTokenizeConfig\n  { url :: BaseUrl,\n    username :: EncryptedField 'AsEncrypted Text,\n    password :: EncryptedField 'AsEncrypted Text\n  }\n  deriving stock (Show, Eq, Generic)\n  deriving anyclass (FromJSON, ToJSON)\n\ndata TokenInfo = TokenInfo\n  { accessToken :: Maybe Text,\n    createdAt :: Maybe Text,\n    expiresAt :: Maybe Text\n  }\n  deriving (Show, Eq, Generic)\n\ndata JourneyMonitoringTokenizeResponse = JourneyMonitoringTokenizeResponse\n  { version :: Maybe Text,\n    status :: Maybe Int,\n    message :: Maybe Text,\n    tokenData :: Maybe TokenInfo\n  }\n  deriving (Show, Eq, Generic)\n\njsonOptions :: Options\njsonOptions =\n  defaultOptions\n    { fieldLabelModifier = \\case\n        \"tokenData\" -> \"data\"\n        other -> other\n    }\n\njsonOptionsData :: Options\njsonOptionsData =\n  defaultOptions\n    { fieldLabelModifier = \\case\n        \"accessToken\" -> \"access_token\"\n        \"createdAt\" -> \"created_at\"\n        \"expiresAt\" -> \"expires_at\"\n        other -> other\n    }\n\ninstance FromJSON TokenInfo where\n  parseJSON = genericParseJSON jsonOptionsData\n\ninstance ToJSON TokenInfo where\n  toJSON = genericToJSON jsonOptionsData\n\ninstance FromJSON JourneyMonitoringTokenizeResponse where\n  parseJSON = genericParseJSON jsonOptions\n\ninstance ToJSON JourneyMonitoringTokenizeResponse where\n  toJSON = genericToJSON jsonOptions\n",
      "hash": "4e1694adebead99b8f343d1426b9ff34e896f37904eb2cf487b71f890578bd24",
      "size": 2263
    },
    "/lib/mobility-core/src/Kernel/External/Tokenize/Types.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\nmodule Kernel.External.Tokenize.Types where\n\nimport Data.Text (unpack)\nimport Kernel.Prelude\nimport Servant.API (FromHttpApiData (..))\n\ndata TokenizationService = HyperVerge | JourneyMonitoring | Gullak\n  deriving (Show, Read, Eq, Ord, Generic, ToJSON, FromJSON, ToSchema, ToParamSchema)\n\ninstance FromHttpApiData TokenizationService where\n  parseUrlPiece = pure . read . unpack\n",
      "hash": "01f9a4dc5bc16c9f1011330fc7f00d1ba4911fa1ade1a6fe86dc31d92556b9a3",
      "size": 1072
    },
    "/lib/mobility-core/src/Kernel/External/Types.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n{-# LANGUAGE DerivingVia #-}\n{-# LANGUAGE TemplateHaskell #-}\n\nmodule Kernel.External.Types where\n\nimport qualified Data.Map as M\nimport Data.OpenApi\nimport Database.Beam\nimport EulerHS.Prelude\nimport Kernel.Beam.Lib.UtilsTH (mkBeamInstancesForEnumAndList)\nimport Kernel.Streaming.Kafka.Producer.Types (HasKafkaProducer)\nimport Kernel.Types.CacheFlow (CacheFlow)\nimport Kernel.Types.Common\nimport Kernel.Utils.Dhall\nimport Kernel.Utils.GenericPretty (PrettyShow, Showable (Showable))\nimport Servant.API (FromHttpApiData (..), ToHttpApiData (..))\n\ndata Language\n  = ENGLISH\n  | HINDI\n  | KANNADA\n  | TAMIL\n  | MALAYALAM\n  | BENGALI\n  | FRENCH\n  | TELUGU\n  | ODIA\n  | DUTCH\n  deriving (Eq, Show, Ord, Read, Generic, ToJSON, FromJSON, ToParamSchema, ToSchema, Enum, Bounded)\n  deriving (PrettyShow) via Showable Language\n\n$(mkBeamInstancesForEnumAndList ''Language)\n\ninstance FromHttpApiData Language where\n  parseUrlPiece \"en\" = pure ENGLISH\n  parseUrlPiece \"hi\" = pure HINDI\n  parseUrlPiece \"kn\" = pure KANNADA\n  parseUrlPiece \"ml\" = pure MALAYALAM\n  parseUrlPiece \"ta\" = pure TAMIL\n  parseUrlPiece \"bn\" = pure BENGALI\n  parseUrlPiece \"fr\" = pure FRENCH\n  parseUrlPiece \"te\" = pure TELUGU\n  parseUrlPiece \"or\" = pure ODIA\n  parseUrlPiece \"nl\" = pure DUTCH\n  parseUrlPiece _ = Left \"Unable to parse Language\"\n\ninstance ToHttpApiData Language where\n  toUrlPiece ENGLISH = \"en\"\n  toUrlPiece HINDI = \"hi\"\n  toUrlPiece KANNADA = \"kn\"\n  toUrlPiece MALAYALAM = \"ml\"\n  toUrlPiece TAMIL = \"ta\"\n  toUrlPiece BENGALI = \"bn\"\n  toUrlPiece FRENCH = \"fr\"\n  toUrlPiece TELUGU = \"te\"\n  toUrlPiece ODIA = \"or\"\n  toUrlPiece DUTCH = \"nl\"\n\ntype ServiceFlow m r = (EncFlow m r, EsqDBFlow m r, CacheFlow m r, HasKafkaProducer r)\n\ntype VerificationFlow m r = (MonadFlow m, CacheFlow m r, EsqDBFlow m r, MonadReader r m, EncFlow m r, HasKafkaProducer r)\n\ndata SchedulerType = RedisBased | DbBased deriving (Show, Enum, Eq, Read, Generic, FromDhall)\n\ntype HasSchedulerName r = HasField \"schedulerSetName\" r Text\n\ntype HasMaxShards r = HasField \"maxShards\" r Int\n\ntype HasSchedulerType r = HasField \"schedulerType\" r SchedulerType\n\ntype HasJobInfoMap r = HasField \"jobInfoMap\" r (M.Map Text Bool)\n\ntype SchedulerFlow r = (HasSchedulerName r, HasMaxShards r, HasSchedulerType r, HasJobInfoMap r)\n",
      "hash": "da79732266f46e61f438e28973520c6ca0fb1c0958289621c02b3db0236f74f4",
      "size": 2960
    },
    "/lib/mobility-core/src/Kernel/External/Verification.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n\nmodule Kernel.External.Verification (module Reexport) where\n\nimport Kernel.External.Verification.Interface as Reexport\n",
      "hash": "75d31dfcdd08aa7915b42bc9315e04cb2793ec322ce9992f4fe468c7113224c2",
      "size": 813
    },
    "/lib/mobility-core/src/Kernel/External/Verification/GovtData/Client.hs": {
      "type": "content",
      "content": "{-\n Copyright 2022-23, Juspay India Pvt Ltd\n\n This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program\n\n is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n\n or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of\n\n the GNU Affero General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n\nmodule Kernel.External.Verification.GovtData.Client\n  ( verifyRC,\n  )\nwhere\n\nimport Kernel.Beam.Lib.UtilsTH\nimport Kernel.External.Verification.GovtData.Storage.Beam as BeamGRC\nimport qualified Kernel.External.Verification.GovtData.Storage.Query as QGD\nimport Kernel.External.Verification.Interface.Types\nimport qualified Kernel.External.Verification.Types as VT\nimport Kernel.Prelude\nimport Kernel.Types.Common\nimport Kernel.Types.Error\nimport Kernel.Utils.Common\n\nverifyRC ::\n  (HasSchemaName BeamGRC.GovtDataRCT, MonadFlow m, EsqDBFlow m r, CacheFlow m r) =>\n  VerifyRCReq ->\n  m VerifyRCResp\nverifyRC req = do\n  res <- QGD.findByRCNumber req.rcNumber >>= fromMaybeM (InternalError \"rcNumber is not found in GovtData.\")\n  pure $\n    SyncResp\n      VT.RCVerificationResponse\n        { registrationDate = Nothing,\n          registrationNumber = res.registrationNumber,\n          fitnessUpto = res.permitValidityUpto,\n          insuranceValidity = res.permitValidityUpto,\n          vehicleClass = res.bodyType,\n          vehicleCategory = Nothing,\n          seatingCapacity = toJSON <$> res.seatingCapacity,\n          manufacturer = res.manufacturer,\n          permitValidityFrom = res.permitValidityFrom,\n          permitValidityUpto = res.permitValidityUpto,\n          pucValidityUpto = Nothing,\n          manufacturerModel = res.manufacturerModel,\n          mYManufacturing = Nothing,\n          color = Nothing,\n          fuelType = res.fuelType,\n          bodyType = res.bodyType,\n          status = Nothing,\n          grossVehicleWeight = Nothing,\n          unladdenWeight = Nothing\n        }\n",
      "hash": "ce5648050f8710e31f08629020f73f4c128aa612dc07d0b4a1a1d45abc37217e",
      "size": 2286
    },
    "/lib/mobility-core/src/Kernel/External/Verification/GovtData/Storage/Beam.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n{-# LANGUAGE DerivingStrategies #-}\n{-# LANGUAGE StandaloneDeriving #-}\n{-# LANGUAGE TemplateHaskell #-}\n\nmodule Kernel.External.Verification.GovtData.Storage.Beam where\n\nimport qualified Database.Beam as B\nimport Kernel.Beam.Lib.UtilsTH (enableKVPG, mkTableInstancesGenericSchema)\nimport Kernel.Prelude\n\ndata GovtDataRCT f = GovtDataRCT\n  { id :: B.C f Text,\n    merchantOperatingCityId :: B.C f Text,\n    ownerSerialNumber :: B.C f (Maybe Text),\n    registrationNumber :: B.C f (Maybe Text),\n    manufacturerModel :: B.C f (Maybe Text),\n    permitValidityFrom :: B.C f (Maybe Text),\n    permitValidityUpto :: B.C f (Maybe Text),\n    manufacturer :: B.C f (Maybe Text),\n    bodyType :: B.C f (Maybe Text),\n    numberOfCylinder :: B.C f (Maybe Int),\n    fuelType :: B.C f (Maybe Text),\n    seatingCapacity :: B.C f (Maybe Int),\n    fromDate :: B.C f (Maybe Text),\n    toDate :: B.C f (Maybe Text),\n    createdAt :: B.C f UTCTime\n  }\n  deriving (Generic, B.Beamable)\n\ninstance B.Table GovtDataRCT where\n  data PrimaryKey GovtDataRCT f\n    = Id (B.C f Text)\n    deriving (Generic, B.Beamable)\n  primaryKey = Id . id\n\ntype GovtDataRC = GovtDataRCT Identity\n\n$(enableKVPG ''GovtDataRCT ['id] [])\n\n$(mkTableInstancesGenericSchema ''GovtDataRCT \"govt_data_r_c\")\n",
      "hash": "a7827772225f3712da2417b094eaafcae05dd6d0303493dd8498f2b8f6fb288b",
      "size": 1949
    },
    "/lib/mobility-core/src/Kernel/External/Verification/GovtData/Storage/Query.hs": {
      "type": "content",
      "content": "{-\n Copyright 2022-23, Juspay India Pvt Ltd\n\n This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program\n\n is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n\n or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of\n\n the GNU Affero General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n{-# OPTIONS_GHC -Wno-orphans #-}\n\nmodule Kernel.External.Verification.GovtData.Storage.Query where\n\nimport Kernel.Beam.Functions (FromTType' (fromTType'), ToTType' (toTType'), createWithKV, findAllWithOptionsKV)\nimport Kernel.Beam.Lib.UtilsTH\nimport Kernel.External.Verification.GovtData.Storage.Beam as BeamGRC\nimport qualified Kernel.External.Verification.GovtData.Types as GD\nimport Kernel.Prelude\nimport Kernel.Types.Common\nimport Kernel.Utils.Common\nimport qualified Sequelize as Se\n\ncreate :: (HasSchemaName BeamGRC.GovtDataRCT, MonadFlow m, EsqDBFlow m r) => GD.GovtDataResponse -> m ()\ncreate = createWithKV\n\nfindByRCNumber :: (HasSchemaName BeamGRC.GovtDataRCT, MonadFlow m, EsqDBFlow m r, CacheFlow m r) => Text -> m (Maybe GD.GovtDataResponse)\nfindByRCNumber rcNumber = findAllWithOptionsKV [Se.Is BeamGRC.registrationNumber $ Se.Eq (Just rcNumber)] (Se.Desc BeamGRC.createdAt) (Just 1) Nothing <&> listToMaybe\n\ninstance FromTType' BeamGRC.GovtDataRC GD.GovtDataResponse where\n  fromTType' BeamGRC.GovtDataRCT {..} = do\n    pure $\n      Just\n        GD.GovtDataResponse\n          { ..\n          }\n\ninstance ToTType' BeamGRC.GovtDataRC GD.GovtDataResponse where\n  toTType' GD.GovtDataResponse {..} = do\n    BeamGRC.GovtDataRCT\n      { ..\n      }\n",
      "hash": "e796b695c214501eed66b8bf9af44f47e9854294bbdffe3f38930b69c452aff4",
      "size": 1943
    },
    "/lib/mobility-core/src/Kernel/External/Verification/GovtData/Types.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\nmodule Kernel.External.Verification.GovtData.Types where\n\nimport Data.Time (UTCTime)\nimport EulerHS.Prelude hiding (id, state)\n\ndata GovtDataResponse = GovtDataResponse\n  { id :: Text,\n    merchantOperatingCityId :: Text,\n    ownerSerialNumber :: Maybe Text,\n    registrationNumber :: Maybe Text,\n    manufacturerModel :: Maybe Text,\n    permitValidityFrom :: Maybe Text,\n    permitValidityUpto :: Maybe Text,\n    manufacturer :: Maybe Text,\n    bodyType :: Maybe Text,\n    numberOfCylinder :: Maybe Int,\n    fuelType :: Maybe Text,\n    seatingCapacity :: Maybe Int,\n    fromDate :: Maybe Text,\n    toDate :: Maybe Text,\n    createdAt :: UTCTime\n  }\n  deriving (Show, Generic, ToJSON, FromJSON, Eq)\n",
      "hash": "ba3590c15083ed9be7be12f88c539c30ad6a098fefa9dce4cd43bb67ea546d3d",
      "size": 1392
    },
    "/lib/mobility-core/src/Kernel/External/Verification/HyperVerge/Flow.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n\nmodule Kernel.External.Verification.HyperVerge.Flow where\n\nimport qualified Data.Aeson as DA\nimport qualified Data.Text as DT\nimport EulerHS.Types (EulerClient, ManagerSelector (..), client)\nimport Kernel.External.Encryption\nimport Kernel.External.SharedLogic.HyperVerge.Error\nimport Kernel.External.SharedLogic.HyperVerge.Functions (hyperVergeHttpManagerKey)\nimport qualified Kernel.External.Verification.HyperVerge.Types as HyperVergeTypes\nimport Kernel.Prelude\nimport Kernel.Tools.Metrics.CoreMetrics (CoreMetrics)\nimport Kernel.Types.Error (ExternalAPICallError (..))\nimport Kernel.Utils.Common\nimport qualified Kernel.Utils.Text as KUT\nimport Servant hiding (throwError)\nimport Servant.Client.Core\n\ntype HyperVergeSdkVerificationAPI =\n  \"v1\"\n    :> \"output\"\n    :> Header \"appId\" Text\n    :> Header \"appKey\" Text\n    :> ReqBody '[JSON] HyperVergeTypes.HyperVergeSdkVerificationReq\n    :> Post '[JSON] HyperVergeTypes.HyperVergeSdkVerificationRes\n\nverificationClient :: Maybe Text -> Maybe Text -> HyperVergeTypes.HyperVergeSdkVerificationReq -> EulerClient HyperVergeTypes.HyperVergeSdkVerificationRes\nverificationClient = client (Proxy :: Proxy HyperVergeSdkVerificationAPI)\n\nverifySdkResp ::\n  ( HasCallStack,\n    EncFlow m r,\n    MonadFlow m,\n    CoreMetrics m\n  ) =>\n  HyperVergeTypes.HyperVergeVerificationCfg ->\n  HyperVergeTypes.HyperVergeSdkVerificationReq ->\n  m HyperVergeTypes.HyperVergeSdkVerificationRes\nverifySdkResp cfg req = do\n  decrypt cfg.appKey >>= \\key -> callAPI' (Just $ ManagerSelector $ DT.pack hyperVergeHttpManagerKey) cfg.url (verificationClient (Just cfg.appId) (Just key) req) \"HV-SDK_Verification-API\" (Proxy @HyperVergeSdkVerificationAPI) >>= checkHyperVergeSdkVerificationResponse cfg.url\n\ncheckHyperVergeSdkVerificationResponse ::\n  ( HasCallStack,\n    MonadFlow m,\n    CoreMetrics m\n  ) =>\n  BaseUrl ->\n  Either ClientError HyperVergeTypes.HyperVergeSdkVerificationRes ->\n  m HyperVergeTypes.HyperVergeSdkVerificationRes\ncheckHyperVergeSdkVerificationResponse url resp = fromEitherM (hyperVergeError url) resp >>= validateHyperVergeSdkVerificationResponse\n\nhyperVergeError :: BaseUrl -> ClientError -> ExternalAPICallError\nhyperVergeError = ExternalAPICallError (Just \"HYPERVERGE_API_ERROR\")\n\nvalidateHyperVergeSdkVerificationResponse :: (MonadThrow m, Log m) => HyperVergeTypes.HyperVergeSdkVerificationRes -> m HyperVergeTypes.HyperVergeSdkVerificationRes\nvalidateHyperVergeSdkVerificationResponse resp = do\n  logDebug $ \"HyperVerge SDK Verification Response: \" <> show resp\n  case resp.statusCode of\n    Just 401 -> throwError HVUnauthorizedError\n    Just 400 -> throwError $ HVBadRequestError (fromMaybe \"No Message found in resp or Failed to parse error !!!!\" $ join (resp.result <&> (.error)))\n    Just 422 -> throwError $ HVBadInputError (fromMaybe \"No Message found in resp or Failed to parse error !!!!\" $ join (resp.result <&> (.error)))\n    Just 200 -> return resp\n    _ -> throwError $ HVError (\"The response from HV is : \" <> show resp)\n\ntype VerifyRCAsyncAPI =\n  \"v1\"\n    :> \"async\"\n    :> \"RCVerification\"\n    :> Header \"appId\" Text\n    :> Header \"appKey\" Text\n    :> Header \"transactionId\" Text\n    :> ReqBody '[JSON] HyperVergeTypes.VerifyRCAsyncReq\n    :> Post '[JSON] HyperVergeTypes.VerifyRCAsyncResp\n\nrcAsyncVerificationClient :: Maybe Text -> Maybe Text -> Maybe Text -> HyperVergeTypes.VerifyRCAsyncReq -> EulerClient HyperVergeTypes.VerifyRCAsyncResp\nrcAsyncVerificationClient = client (Proxy :: Proxy VerifyRCAsyncAPI)\n\nverifyRCAsync ::\n  ( HasCallStack,\n    EncFlow m r,\n    MonadFlow m,\n    CoreMetrics m\n  ) =>\n  HyperVergeTypes.HyperVergeRCDLVerificationConfig ->\n  Text ->\n  HyperVergeTypes.VerifyRCAsyncReq ->\n  m HyperVergeTypes.VerifyRCAsyncResp\nverifyRCAsync cfg transactionId req = do\n  decrypt cfg.appKey >>= \\key -> callAPI' (Just $ ManagerSelector $ DT.pack hyperVergeHttpManagerKey) cfg.url (rcAsyncVerificationClient (Just cfg.appId) (Just key) (Just transactionId) req) \"HV-RC_ASYNC_VERIFICATION-API\" (Proxy @VerifyRCAsyncAPI) >>= checkHyperVergeRCAsyncVerificationResp cfg.url\n\ncheckHyperVergeRCAsyncVerificationResp ::\n  ( HasCallStack,\n    MonadFlow m,\n    CoreMetrics m\n  ) =>\n  BaseUrl ->\n  Either ClientError HyperVergeTypes.VerifyRCAsyncResp ->\n  m HyperVergeTypes.VerifyRCAsyncResp\ncheckHyperVergeRCAsyncVerificationResp url resp = fromEitherM (hyperVergeError url) resp >>= validateHyperVergeRCAsyncVerificationResponse\n\nvalidateHyperVergeRCAsyncVerificationResponse :: (MonadThrow m, Log m) => HyperVergeTypes.VerifyRCAsyncResp -> m HyperVergeTypes.VerifyRCAsyncResp\nvalidateHyperVergeRCAsyncVerificationResponse resp = do\n  logDebug $ \"HyperVerge RC Verification Response: \" <> show resp\n  case resp.statusCode of\n    401 -> throwError HVUnauthorizedError\n    400 -> throwError $ HVBadRequestError (fromMaybe \"No Message found in resp or Failed to parse error !!!!\" resp.message)\n    200 -> return resp\n    _ -> throwError $ HVError (\"The response from HV is : \" <> show resp)\n\ntype VerifyDLAsyncAPI =\n  \"v1\"\n    :> \"async\"\n    :> \"checkDL\"\n    :> Header \"appId\" Text\n    :> Header \"appKey\" Text\n    :> Header \"transactionId\" Text\n    :> ReqBody '[JSON] HyperVergeTypes.HyperVergeDLVerificationReq\n    :> Post '[JSON] HyperVergeTypes.HyperVergeDLVerificationResp\n\ndlAsyncVerificationClient :: Maybe Text -> Maybe Text -> Maybe Text -> HyperVergeTypes.HyperVergeDLVerificationReq -> EulerClient HyperVergeTypes.HyperVergeDLVerificationResp\ndlAsyncVerificationClient = client (Proxy :: Proxy VerifyDLAsyncAPI)\n\nverifyDLAsync ::\n  ( HasCallStack,\n    EncFlow m r,\n    MonadFlow m,\n    CoreMetrics m\n  ) =>\n  HyperVergeTypes.HyperVergeRCDLVerificationConfig ->\n  Text ->\n  HyperVergeTypes.HyperVergeDLVerificationReq ->\n  m HyperVergeTypes.HyperVergeDLVerificationResp\nverifyDLAsync cfg transactionId req = do\n  decrypt cfg.appKey >>= \\key -> callAPI' (Just $ ManagerSelector $ DT.pack hyperVergeHttpManagerKey) cfg.url (dlAsyncVerificationClient (Just cfg.appId) (Just key) (Just transactionId) req) \"HV-DL_ASYNC_VERIFICATION-API\" (Proxy @VerifyDLAsyncAPI) >>= checkHyperVergeDLAsyncVerificationResp cfg.url\n\ncheckHyperVergeDLAsyncVerificationResp ::\n  ( HasCallStack,\n    MonadFlow m,\n    CoreMetrics m\n  ) =>\n  BaseUrl ->\n  Either ClientError HyperVergeTypes.HyperVergeDLVerificationResp ->\n  m HyperVergeTypes.HyperVergeDLVerificationResp\ncheckHyperVergeDLAsyncVerificationResp url resp = fromEitherM (hyperVergeError url) resp >>= validateHyperVergeDLAsyncVerificationResponse\n\nvalidateHyperVergeDLAsyncVerificationResponse :: (MonadThrow m, Log m) => HyperVergeTypes.HyperVergeDLVerificationResp -> m HyperVergeTypes.HyperVergeDLVerificationResp\nvalidateHyperVergeDLAsyncVerificationResponse resp = do\n  logDebug $ \"HyperVerge DL Verification Response: \" <> show resp\n  case resp.statusCode of\n    401 -> throwError HVUnauthorizedError\n    400 -> throwError $ HVBadRequestError (fromMaybe \"No Message found in resp or Failed to parse error !!!!\" resp.error)\n    200 -> return resp\n    _ -> throwError $ HVError (\"The response from HV is : \" <> show resp)\n\ntype GetVerificationStatusAPI =\n  \"v1\"\n    :> \"async\"\n    :> Header \"appId\" Text\n    :> Header \"appKey\" Text\n    :> Capture \"workflowId\" Text\n    :> MandatoryQueryParam \"requestId\" Text\n    :> Get '[JSON] DA.Value\n\ngetVerificationStatusClient :: Maybe Text -> Maybe Text -> Text -> Text -> EulerClient DA.Value\ngetVerificationStatusClient = client (Proxy :: Proxy GetVerificationStatusAPI)\n\ngetVerificationStatus ::\n  ( HasCallStack,\n    EncFlow m r,\n    MonadFlow m,\n    CoreMetrics m\n  ) =>\n  HyperVergeTypes.HyperVergeRCDLVerificationConfig ->\n  Text ->\n  Text ->\n  m (HyperVergeTypes.GetVerificationStatusResp, Text)\ngetVerificationStatus cfg workflowId reqId = do\n  decrypt cfg.appKey >>= \\key -> callAPI' (Just $ ManagerSelector $ DT.pack hyperVergeHttpManagerKey) cfg.url (getVerificationStatusClient (Just cfg.appId) (Just key) workflowId reqId) \"HV-GET_VERIFICATION_RESULT-API\" (Proxy @GetVerificationStatusAPI) >>= checkHyperVergeGetVerificationStatusResp cfg.url\n\ncheckHyperVergeGetVerificationStatusResp ::\n  ( HasCallStack,\n    MonadFlow m,\n    CoreMetrics m\n  ) =>\n  BaseUrl ->\n  Either ClientError DA.Value ->\n  m (HyperVergeTypes.GetVerificationStatusResp, Text)\ncheckHyperVergeGetVerificationStatusResp url resp = fromEitherM (hyperVergeError url) resp >>= \\rsp -> (,KUT.encodeToText rsp) <$> (validateHyperVergeGetVerificationStatusResp =<< convertValueToRespType rsp)\n  where\n    convertValueToRespType :: (MonadThrow m, Log m) => DA.Value -> m HyperVergeTypes.GetVerificationStatusResp\n    convertValueToRespType rsp = case DA.fromJSON rsp of\n      DA.Error err -> throwError $ HVError (\"Could not parse HyperVerge getVerificationStatus resp. Reason: \" <> DT.pack err <> \"Resp: \" <> show rsp)\n      DA.Success pyload -> return pyload\n\nvalidateHyperVergeGetVerificationStatusResp :: (MonadThrow m, Log m) => HyperVergeTypes.GetVerificationStatusResp -> m HyperVergeTypes.GetVerificationStatusResp\nvalidateHyperVergeGetVerificationStatusResp resp = do\n  logDebug $ \"HyperVerge getVerificationStatus Response: \" <> show resp\n  case resp.statusCode of\n    401 -> throwError HVUnauthorizedError\n    400 -> throwError $ HVBadRequestError (fromMaybe \"No Message found in resp or Failed to parse error !!!!\" resp.message)\n    200 -> if isNothing resp.result then throwError (HVMissingPayloadError $ fromMaybe (\"Unknown reason !!!!! Resp : \" <> show resp) resp.message) else return resp\n    _ -> throwError $ HVError (\"The response from HV is : \" <> show resp)\n",
      "hash": "89737a0ef893908691dfe1108b34b88043e04b4186a3026cd1dc7654f8e01d55",
      "size": 10216
    },
    "/lib/mobility-core/src/Kernel/External/Verification/HyperVerge/Types.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n{-# LANGUAGE DerivingStrategies #-}\n\nmodule Kernel.External.Verification.HyperVerge.Types where\n\nimport Control.Applicative ((<|>))\nimport Data.Aeson\nimport Kernel.External.Encryption\nimport Kernel.Prelude hiding (error, length)\n\ndata HyperVergeVerificationCfg = HyperVergeVerificationCfg\n  { url :: BaseUrl,\n    appId :: Text,\n    appKey :: EncryptedField 'AsEncrypted Text\n  }\n  deriving stock (Show, Eq, Generic)\n  deriving anyclass (FromJSON, ToJSON)\n\ndata HyperVergeRCDLVerificationConfig = HyperVergeRCDLVerificationConfig\n  { username :: Text,\n    password :: EncryptedField 'AsEncrypted Text,\n    url :: BaseUrl,\n    appId :: Text,\n    appKey :: EncryptedField 'AsEncrypted Text\n  }\n  deriving stock (Show, Eq, Generic)\n  deriving anyclass (FromJSON, ToJSON)\n\nnewtype HyperVergeSdkVerificationReq = HyperVergeSdkVerificationReq\n  { transactionId :: Text\n  }\n  deriving (Show, Eq, Generic, FromJSON, ToJSON)\n\nnewtype Metadata = Metadata\n  { requestId :: Maybe Text\n  }\n  deriving (Show, Eq, Generic, FromJSON, ToJSON)\n\ndata Sources = Sources\n  { source :: Maybe Text,\n    subSource :: Maybe Text,\n    values :: Maybe Object\n  }\n  deriving (Show, Eq, Generic, FromJSON, ToJSON)\n\nnewtype SelfieFlow = SelfieFlow\n  { selfieURL :: Text\n  }\n  deriving (Show, Eq, Generic, FromJSON, ToJSON)\n\ndata AadhaarFlow = AadhaarFlow\n  { idNumber :: Maybe Text,\n    fullName :: Maybe Text,\n    dob :: Maybe Text,\n    address :: Maybe Text,\n    city :: Maybe Text,\n    pincode :: Maybe Text,\n    aadhaarFrontURL :: Text,\n    aadhaarBackURL :: Maybe Text\n  }\n  deriving (Show, Eq, Generic, FromJSON, ToJSON)\n\ndata PanFlow = PanFlow\n  { pan :: Maybe Text,\n    name :: Maybe Text,\n    dob :: Maybe Text,\n    gender :: Maybe Text,\n    panURL :: Text\n  }\n  deriving (Show, Eq, Generic, FromJSON, ToJSON)\n\ndata UserDetails = HVSelfieFlow SelfieFlow | HVAadhaarFlow AadhaarFlow | HVPanFlow PanFlow\n  deriving (Show, Eq, Generic, ToJSON)\n\ninstance FromJSON UserDetails where\n  parseJSON = withObject \"UserDetails\" $ \\v ->\n    (HVAadhaarFlow <$> parseJSON (Object v))\n      <|> (HVPanFlow <$> parseJSON (Object v))\n      <|> (HVSelfieFlow <$> parseJSON (Object v))\n\ndata HVResult = HVResult\n  { flags :: Maybe [Sources],\n    userDetails :: Maybe UserDetails,\n    status :: Maybe Text,\n    transactionId :: Maybe Text,\n    failureReason :: Maybe Text,\n    error :: Maybe Text\n  }\n  deriving (Show, Eq, Generic, FromJSON, ToJSON)\n\ndata HyperVergeSdkVerificationRes = HyperVergeSdkVerificationRes\n  { status :: Maybe Text,\n    statusCode :: Maybe Int,\n    metadata :: Maybe Metadata,\n    result :: Maybe HVResult\n  }\n  deriving (Show, Eq, Generic, FromJSON, ToJSON)\n\nnewtype VerifyRCAsyncReq = VerifyRCAsyncReq\n  { reg_no :: Text\n  }\n  deriving (Show, Eq, Generic, FromJSON, ToJSON)\n\ntype VerifyRCAsyncResp = HyperVergeVerificationAsyncResp\n\ndata HyperVergeVerificationAsyncResp = HyperVergeVerificationAsyncResp\n  { status :: Text,\n    statusCode :: Int,\n    metaData :: Maybe VerifyRCDLAsyncMetaData,\n    result :: Maybe VerifyRCDLAsyncResult,\n    error :: Maybe Text,\n    message :: Maybe Text\n  }\n  deriving (Show, Eq, Generic)\n\ninstance FromJSON HyperVergeVerificationAsyncResp where\n  parseJSON = withObject \"HyperVergeVerificationAsyncResp\" $ \\v -> do\n    status <- v .: \"status\"\n    statusCode <- v .: \"statusCode\"\n    metaData <- v .:? \"metadata\"\n    result <- v .:? \"result\"\n    error <- v .:? \"error\"\n    message <- v .:? \"message\"\n    return $ HyperVergeVerificationAsyncResp {..}\n\ninstance ToJSON HyperVergeVerificationAsyncResp where\n  toJSON (HyperVergeVerificationAsyncResp {..}) =\n    object\n      [ \"status\" .= status,\n        \"statusCode\" .= statusCode,\n        \"metadata\" .= metaData,\n        \"result\" .= result,\n        \"error\" .= error,\n        \"message\" .= message\n      ]\n\ndata VerifyRCDLAsyncMetaData = VerifyRCDLAsyncMetaData\n  { transactionId :: Maybe Text,\n    requestId :: Maybe Text\n  }\n  deriving (Show, Eq, Generic, FromJSON, ToJSON)\n\nnewtype VerifyRCDLAsyncResult = VerifyRCDLAsyncResult\n  { actionStatus :: Maybe Text\n  }\n  deriving (Show, Eq, Generic, FromJSON, ToJSON)\n\ndata HyperVergeDLVerificationReq = HyperVergeDLVerificationReq\n  { dlNumber :: Text,\n    dob :: Text,\n    returnState :: Bool\n  }\n  deriving (Show, Eq, Generic)\n\ninstance FromJSON HyperVergeDLVerificationReq where\n  parseJSON = withObject \"HyperVergeDLVerificationReq\" $ \\v -> do\n    dlNumber <- v .: \"dlNumber\"\n    dob <- v .: \"dob\"\n    returnState <- (== String \"yes\") <$> (v .: \"returnState\")\n    return HyperVergeDLVerificationReq {..}\n\ninstance ToJSON HyperVergeDLVerificationReq where\n  toJSON (HyperVergeDLVerificationReq dlNumber dob returnState) =\n    object\n      [ \"dlNumber\" .= dlNumber,\n        \"dob\" .= dob,\n        \"returnState\" .= bool (String \"no\") (String \"yes\") returnState\n      ]\n\ntype HyperVergeDLVerificationResp = HyperVergeVerificationAsyncResp\n\ndata GetVerificationStatusResp = GetVerificationStatusResp\n  { status :: Text,\n    statusCode :: Int,\n    result :: Maybe VerificationStatusResult,\n    message :: Maybe Text\n  }\n  deriving (Show, Eq, Generic, FromJSON, ToJSON)\n\ndata VerificationStatusResult = VerificationStatusResult\n  { apiStatusCode :: Int,\n    apiOutput :: VerificationAPIResp\n  }\n  deriving (Show, Eq, Generic, FromJSON, ToJSON)\n\ndata VerificationAPIResp = VerificationAPIResp\n  { status :: Text,\n    statusCode :: Text,\n    result :: Maybe VerificationResultData,\n    metaData :: Maybe VerifyRCDLAsyncMetaData,\n    error :: Maybe Text\n  }\n  deriving (Show, Eq, Generic, FromJSON, ToJSON)\n\ndata VerificationResultData = RCVerificationResultData RCVerificationData | DLVerificationResultData DLVerificationData\n  deriving (Show, Eq, Generic, ToJSON)\n\ninstance FromJSON VerificationResultData where\n  parseJSON v =\n    let tryParse :: (FromJSON a) => (a -> VerificationResultData) -> Result VerificationResultData\n        tryParse constructor = constructor <$> fromJSON v\n     in case tryParse RCVerificationResultData of\n          Success result -> return result\n          _ -> case tryParse DLVerificationResultData of\n            Success result -> return result\n            Error str -> fail $ \"Could not parse VerificationResultData !!!! Message:\" <> str\n\ndata RCVerificationData = RCVerificationData\n  { message :: Text,\n    response_type :: Maybe Text,\n    rcInfo :: Maybe RCInfo\n  }\n  deriving (Show, Eq, Generic, FromJSON, ToJSON)\n\ndata RCInfo = RCInfo\n  { state_code :: Maybe Text,\n    state :: Maybe Text,\n    office_code :: Maybe Int,\n    office_name :: Maybe Text,\n    reg_no :: Maybe Text,\n    reg_date :: Maybe Text,\n    purchase_date :: Maybe Text,\n    owner_count :: Maybe Int,\n    owner_name :: Maybe Text,\n    owner_father_name :: Maybe Text,\n    current_address_line1 :: Maybe Text,\n    current_address_line2 :: Maybe Text,\n    current_address_line3 :: Maybe Text,\n    current_district_name :: Maybe Text,\n    current_state :: Maybe Text,\n    current_state_name :: Maybe Text,\n    current_pincode :: Maybe Integer,\n    current_full_address :: Maybe Text,\n    permanent_address_line1 :: Maybe Text,\n    permanent_address_line2 :: Maybe Text,\n    permanent_address_line3 :: Maybe Text,\n    permanent_district_name :: Maybe Text,\n    permanent_state :: Maybe Text,\n    permanent_state_name :: Maybe Text,\n    permanent_pincode :: Maybe Integer,\n    permanent_full_address :: Maybe Text,\n    owner_code_descr :: Maybe Text,\n    reg_type_descr :: Maybe Text,\n    vehicle_class_desc :: Maybe Text,\n    chassis_no :: Maybe Text,\n    engine_no :: Maybe Text,\n    vehicle_manufacturer_name :: Maybe Text,\n    model_code :: Maybe Text,\n    model :: Maybe Text,\n    body_type :: Maybe Text,\n    cylinders_no :: Maybe Int,\n    vehicle_hp :: Maybe Float,\n    vehicle_seat_capacity :: Maybe Int,\n    vehicle_standing_capacity :: Maybe Int,\n    vehicle_sleeper_capacity :: Maybe Int,\n    unladen_weight :: Maybe Float,\n    vehicle_gross_weight :: Maybe Float,\n    vehicle_gross_comb_weight :: Maybe Float,\n    fuel_descr :: Maybe Text,\n    color :: Maybe Text,\n    manufacturing_mon :: Maybe Int,\n    manufacturing_yr :: Maybe Int,\n    norms_descr :: Maybe Text,\n    wheelbase :: Maybe Int,\n    cubic_cap :: Maybe Float,\n    floor_area :: Maybe Float,\n    ac_fitted :: Maybe Text,\n    audio_fitted :: Maybe Text,\n    video_fitted :: Maybe Text,\n    vehicle_catg :: Maybe Text,\n    sale_amount :: Maybe Float,\n    length :: Maybe Float,\n    width :: Maybe Float,\n    height :: Maybe Float,\n    reg_upto :: Maybe Text,\n    fit_upto :: Maybe Text,\n    imported_vehicle :: Maybe Text,\n    status :: Maybe Text,\n    vehicle_type :: Maybe Text,\n    tax_mode :: Maybe Text,\n    vehicle_insurance_details :: Maybe InsuranceData,\n    vehicle_pucc_details :: Maybe PUCDetails,\n    permit_details :: Maybe PermitData,\n    latest_tax_details :: Maybe TaxDetails,\n    financer_details :: Maybe FinancerDetails\n  }\n  deriving (Show, Eq, Generic, FromJSON, ToJSON)\n\ndata PermitData = PermitData\n  { appl_no :: Maybe Text,\n    pmt_no :: Maybe Text,\n    reg_no :: Maybe Text,\n    rcpt_no :: Maybe Text,\n    purpose :: Maybe Text,\n    permit_type :: Maybe Text,\n    permit_catg :: Maybe Text,\n    permit_issued_on :: Maybe Text,\n    permit_valid_from :: Maybe Text,\n    permit_valid_upto :: Maybe Text\n  }\n  deriving (Show, Eq, Generic, FromJSON, ToJSON)\n\ndata OwnerData = OwnerData\n  { serial :: Maybe Text,\n    name :: Maybe Text,\n    fatherName :: Maybe Text,\n    presentAddress :: Maybe Text,\n    permanentAddress :: Maybe Text\n  }\n  deriving (Show, Eq, Generic, FromJSON, ToJSON)\n\ndata InsuranceData = InsuranceData\n  { insurance_from :: Maybe Text,\n    insurance_upto :: Maybe Text,\n    insurance_company_code :: Maybe Int,\n    insurance_company_name :: Maybe Text,\n    opdt :: Maybe Text,\n    policy_no :: Maybe Text,\n    reg_no :: Maybe Text\n  }\n  deriving (Show, Eq, Generic, FromJSON, ToJSON)\n\ndata TaxDetails = TaxDetails\n  { reg_no :: Maybe Text,\n    tax_mode :: Maybe Text,\n    payment_mode :: Maybe Text,\n    tax_amt :: Maybe Float,\n    tax_fine :: Maybe Float,\n    rcpt_dt :: Maybe Text,\n    tax_from :: Maybe Text,\n    tax_upto :: Maybe Text,\n    collected_by :: Maybe Text,\n    rcpt_no :: Maybe Text\n  }\n  deriving (Show, Eq, Generic, FromJSON, ToJSON)\n\ndata FinancerDetails = FinancerDetails\n  { hp_type :: Maybe Text,\n    financer_name :: Maybe Text,\n    financer_address_line1 :: Maybe Text,\n    financer_address_line2 :: Maybe Text,\n    financer_address_line3 :: Maybe Text,\n    financer_district :: Maybe Int,\n    financer_pincode :: Maybe Int,\n    financer_state :: Maybe Text,\n    financer_full_address :: Maybe Text,\n    hypothecation_dt :: Maybe Text,\n    op_dt :: Maybe Text\n  }\n  deriving (Show, Eq, Generic, FromJSON, ToJSON)\n\ndata PUCDetails = PUCDetails\n  { pucc_from :: Maybe Text,\n    pucc_upto :: Maybe Text,\n    pucc_centreno :: Maybe Text,\n    pucc_no :: Maybe Text,\n    op_dt :: Maybe Text\n  }\n  deriving (Show, Eq, Generic, FromJSON, ToJSON)\n\ndata DLVerificationData = DLVerificationData\n  { issue_date :: Maybe Text,\n    father :: Maybe Text,\n    name :: Maybe Text,\n    img :: Maybe Text,\n    blood_group :: Maybe Text,\n    dob :: Maybe Text,\n    dl_number :: Maybe Text,\n    validity :: Maybe DLValidityInfo,\n    cov_details :: Maybe [CovDetails],\n    address :: Maybe Text,\n    state :: Maybe Text\n  }\n  deriving (Show, Eq, Generic)\n\ninstance FromJSON DLVerificationData where\n  parseJSON = withObject \"DLVerificationData\" $ \\v -> do\n    issue_date <- v .:? \"issue_date\"\n    father <- v .:? \"father/husband\"\n    name <- v .:? \"name\"\n    img <- v .:? \"img\"\n    blood_group <- v .:? \"blood_group\"\n    dob <- v .:? \"dob\"\n    dl_number <- v .:? \"dl_number\"\n    validity <- v .:? \"validity\"\n    cov_details <- v .:? \"cov_details\"\n    address <- v .:? \"address\"\n    state <- v .:? \"state\"\n    return DLVerificationData {..}\n\ninstance ToJSON DLVerificationData where\n  toJSON (DLVerificationData {..}) =\n    object\n      [ \"issue_date\" .= issue_date,\n        \"father/husband\" .= father,\n        \"name\" .= name,\n        \"img\" .= img,\n        \"blood_group\" .= blood_group,\n        \"dob\" .= dob,\n        \"dl_number\" .= dl_number,\n        \"validity\" .= validity,\n        \"cov_details\" .= cov_details,\n        \"address\" .= address,\n        \"state\" .= state\n      ]\n\ndata DLValidityInfo = DLValidityInfo\n  { transport :: Maybe Text,\n    nonTransport :: Maybe Text\n  }\n  deriving (Show, Eq, Generic)\n\ninstance FromJSON DLValidityInfo where\n  parseJSON = withObject \"DLValidityInfo\" $ \\v -> do\n    transport <- v .:? \"transport\"\n    nonTransport <- v .:? \"non-transport\"\n    return DLValidityInfo {..}\n\ninstance ToJSON DLValidityInfo where\n  toJSON (DLValidityInfo transport nonTransport) =\n    object\n      [ \"transport\" .= transport,\n        \"non-transport\" .= nonTransport\n      ]\n\ndata CovDetails = CovDetails\n  { cov :: Text,\n    issue_date :: Maybe Text\n  }\n  deriving (Show, Eq, Generic, FromJSON, ToJSON)\n",
      "hash": "e0aa9a987501db1d788e94c0111a03dedbfdb51b9982fec7c35037b68668119e",
      "size": 13543
    },
    "/lib/mobility-core/src/Kernel/External/Verification/Idfy/Auth.hs": {
      "type": "content",
      "content": "{-\n Copyright 2022-23, Juspay India Pvt Ltd\n\n This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program\n\n is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n\n or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of\n\n the GNU Affero General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n\nmodule Kernel.External.Verification.Idfy.Auth where\n\nimport qualified Data.HashMap.Strict as HMS\nimport EulerHS.Prelude\nimport Kernel.External.Encryption\nimport Kernel.External.Verification.Idfy.Config\nimport Kernel.Tools.Metrics.CoreMetrics.Types\nimport Kernel.Types.Error\nimport Kernel.Utils.Common\nimport Kernel.Utils.IOLogging\nimport Network.HTTP.Client as Http\nimport Network.HTTP.Client.TLS as Http\n\nverifyAuth ::\n  ( EncFlow m r,\n    HasField \"isShuttingDown\" r (TMVar ()),\n    HasField \"coreMetrics\" r CoreMetricsContainer,\n    HasField \"loggerEnv\" r LoggerEnv,\n    Log m\n  ) =>\n  IdfyCfg ->\n  Maybe Text ->\n  m ()\nverifyAuth cfg authSecret = do\n  cfgSecret <- decrypt cfg.secret\n  unless (authSecret == Just cfgSecret) $ throwError (InvalidRequest \"INVALID_AUTHORIZATION_HEADER\")\n\nprepareIdfyHttpManager :: Int -> HashMap Text Http.ManagerSettings\nprepareIdfyHttpManager timeout =\n  HMS.singleton idfyHttpManagerKey $\n    Http.tlsManagerSettings {Http.managerResponseTimeout = Http.responseTimeoutMicro (timeout * 1000)}\n\nidfyHttpManagerKey :: Text\nidfyHttpManagerKey = \"idfy-http-manager\"\n",
      "hash": "e7489b1bc41ebb5f88d8fdd633edc3142bd31ff2f72816e799caefcaba5507ee",
      "size": 1787
    },
    "/lib/mobility-core/src/Kernel/External/Verification/Idfy/Client.hs": {
      "type": "content",
      "content": "{-\n Copyright 2022-23, Juspay India Pvt Ltd\n\n This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program\n\n is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n\n or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of\n\n the GNU Affero General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n\nmodule Kernel.External.Verification.Idfy.Client\n  ( verifyDLAsync,\n    verifyRCAsync,\n    validateImage,\n    extractRCImage,\n    extractDLImage,\n    extractPanImage,\n    extractGSTImage,\n    extractAadhaarImage,\n    getTask,\n    VerifyDLAPI,\n    VerifyRCAPI,\n    ValidateImage,\n    ExtractDLImage,\n    ExtractPanImage,\n    ExtractGSTImage,\n    ExtractRCAPI,\n    ExtractAadhaarImage,\n  )\nwhere\n\nimport qualified Data.Aeson as DA\nimport qualified Data.Text as DT\nimport EulerHS.Prelude\nimport qualified EulerHS.Types as T\nimport Kernel.External.Verification.Idfy.Auth\nimport Kernel.External.Verification.Idfy.Config\nimport Kernel.External.Verification.Idfy.Types.Error\nimport Kernel.External.Verification.Idfy.Types.Request\nimport Kernel.External.Verification.Idfy.Types.Response\nimport Kernel.Tools.Metrics.CoreMetrics.Types\nimport Kernel.Types.Common\nimport Kernel.Types.Error (IdfyCallError (..))\nimport Kernel.Utils.Common hiding (Error)\nimport qualified Kernel.Utils.Text as KUT\nimport Servant (Get, Header, JSON, Post, ReqBody, (:>))\n\ntype VerifyDLAPI =\n  \"v3\" :> \"tasks\" :> \"async\" :> \"verify_with_source\" :> \"ind_driving_license\"\n    :> Header \"api-key\" ApiKey\n    :> Header \"account-id\" AccountId\n    :> ReqBody '[JSON] DLVerificationRequest\n    :> Post '[JSON] IdfySuccess\n\nverifyDLAPI :: Proxy VerifyDLAPI\nverifyDLAPI = Proxy\n\nverifyDLAsync ::\n  ( MonadFlow m,\n    CoreMetrics m\n  ) =>\n  ApiKey ->\n  AccountId ->\n  BaseUrl ->\n  DLVerificationRequest ->\n  m IdfySuccess\nverifyDLAsync apiKey accountId url req = callIdfyAPI url task \"verifyDLAsync\" verifyDLAPI\n  where\n    task =\n      T.client\n        verifyDLAPI\n        (Just apiKey)\n        (Just accountId)\n        req\n\ntype VerifyRCAPI =\n  \"v3\" :> \"tasks\" :> \"async\" :> \"verify_with_source\" :> \"ind_rc_plus\"\n    :> Header \"api-key\" ApiKey\n    :> Header \"account-id\" AccountId\n    :> ReqBody '[JSON] RCVerificationRequest\n    :> Post '[JSON] IdfySuccess\n\nverifyRCAPI :: Proxy VerifyRCAPI\nverifyRCAPI = Proxy\n\nverifyRCAsync ::\n  ( MonadFlow m,\n    CoreMetrics m\n  ) =>\n  ApiKey ->\n  AccountId ->\n  BaseUrl ->\n  RCVerificationRequest ->\n  m IdfySuccess\nverifyRCAsync apiKey accountId url req = callIdfyAPI url task \"verifyRCAsync\" verifyRCAPI\n  where\n    task =\n      T.client\n        verifyRCAPI\n        (Just apiKey)\n        (Just accountId)\n        req\n\ntype ValidateImage =\n  \"v3\" :> \"tasks\" :> \"sync\" :> \"validate\" :> \"document\"\n    :> Header \"api-key\" ApiKey\n    :> Header \"account-id\" AccountId\n    :> ReqBody '[JSON] ImageValidateRequest\n    :> Post '[JSON] ImageValidateResponse\n\nvalidateImageAPI :: Proxy ValidateImage\nvalidateImageAPI = Proxy\n\nvalidateImage ::\n  ( MonadFlow m,\n    CoreMetrics m\n  ) =>\n  ApiKey ->\n  AccountId ->\n  BaseUrl ->\n  ImageValidateRequest ->\n  m ImageValidateResponse\nvalidateImage apiKey accountId url req = callIdfyAPI url task \"validateImage\" validateImageAPI\n  where\n    task =\n      T.client\n        validateImageAPI\n        (Just apiKey)\n        (Just accountId)\n        req\n\ntype ExtractRCAPI =\n  \"v3\" :> \"tasks\" :> \"sync\" :> \"extract\" :> \"ind_rc\"\n    :> Header \"api-key\" ApiKey\n    :> Header \"account-id\" AccountId\n    :> ReqBody '[JSON] ImageExtractRequest\n    :> Post '[JSON] RCExtractResponse\n\nextractRCAPI :: Proxy ExtractRCAPI\nextractRCAPI = Proxy\n\nextractRCImage ::\n  ( MonadFlow m,\n    CoreMetrics m\n  ) =>\n  ApiKey ->\n  AccountId ->\n  BaseUrl ->\n  ImageExtractRequest ->\n  m RCExtractResponse\nextractRCImage apiKey accountId url req = callIdfyAPI url task \"extractRCImage\" extractRCAPI\n  where\n    task =\n      T.client\n        extractRCAPI\n        (Just apiKey)\n        (Just accountId)\n        req\n\ntype ExtractDLImage =\n  \"v3\" :> \"tasks\" :> \"sync\" :> \"extract\" :> \"ind_driving_license\"\n    :> Header \"api-key\" ApiKey\n    :> Header \"account-id\" AccountId\n    :> ReqBody '[JSON] ImageExtractRequest\n    :> Post '[JSON] DLExtractResponse\n\nextractDLAPI :: Proxy ExtractDLImage\nextractDLAPI = Proxy\n\nextractDLImage ::\n  ( MonadFlow m,\n    CoreMetrics m\n  ) =>\n  ApiKey ->\n  AccountId ->\n  BaseUrl ->\n  ImageExtractRequest ->\n  m DLExtractResponse\nextractDLImage apiKey accountId url req = callIdfyAPI url task \"extractDLImage\" extractDLAPI\n  where\n    task =\n      T.client\n        extractDLAPI\n        (Just apiKey)\n        (Just accountId)\n        req\n\ntype ExtractPanImage =\n  \"v3\" :> \"tasks\" :> \"sync\" :> \"extract\" :> \"ind_pan\"\n    :> Header \"api-key\" ApiKey\n    :> Header \"account-id\" AccountId\n    :> ReqBody '[JSON] ImageExtractRequest\n    :> Post '[JSON] PanExtractionResponse\n\nextractPanAPI :: Proxy ExtractPanImage\nextractPanAPI = Proxy\n\nextractPanImage ::\n  ( MonadFlow m,\n    CoreMetrics m\n  ) =>\n  ApiKey ->\n  AccountId ->\n  BaseUrl ->\n  ImageExtractRequest ->\n  m PanExtractionResponse\nextractPanImage apiKey accountId url req = callIdfyAPI url task \"extractPanImage\" extractPanAPI\n  where\n    task =\n      T.client\n        extractPanAPI\n        (Just apiKey)\n        (Just accountId)\n        req\n\ntype ExtractGSTImage =\n  \"v3\" :> \"tasks\" :> \"sync\" :> \"extract\" :> \"ind_gst_certificate\"\n    :> Header \"api-key\" ApiKey\n    :> Header \"account-id\" AccountId\n    :> ReqBody '[JSON] ImageExtractRequest\n    :> Post '[JSON] GSTExtractionResponse\n\nextractGSTAPI :: Proxy ExtractGSTImage\nextractGSTAPI = Proxy\n\nextractGSTImage ::\n  ( MonadFlow m,\n    CoreMetrics m\n  ) =>\n  ApiKey ->\n  AccountId ->\n  BaseUrl ->\n  ImageExtractRequest ->\n  m GSTExtractionResponse\nextractGSTImage apiKey accountId url req = callIdfyAPI url task \"extractGSTImage\" extractGSTAPI\n  where\n    task =\n      T.client\n        extractGSTAPI\n        (Just apiKey)\n        (Just accountId)\n        req\n\ntype ExtractAadhaarImage =\n  \"v3\" :> \"tasks\" :> \"sync\" :> \"extract\" :> \"ind_aadhaar\"\n    :> Header \"api-key\" ApiKey\n    :> Header \"account-id\" AccountId\n    :> ReqBody '[JSON] AadharVerificationReqest\n    :> Post '[JSON] AadhaarExtractionResponse\n\nextractAadhaarAPI :: Proxy ExtractAadhaarImage\nextractAadhaarAPI = Proxy\n\nextractAadhaarImage ::\n  ( MonadFlow m,\n    CoreMetrics m\n  ) =>\n  ApiKey ->\n  AccountId ->\n  BaseUrl ->\n  AadharVerificationReqest ->\n  m AadhaarExtractionResponse\nextractAadhaarImage apiKey accountId url req = callIdfyAPI url task \"extractAadhaarImage\" extractAadhaarAPI\n  where\n    task =\n      T.client\n        extractAadhaarAPI\n        (Just apiKey)\n        (Just accountId)\n        req\n\ntype GetTaskAPI =\n  \"v3\" :> \"tasks\"\n    :> Header \"api-key\" ApiKey\n    :> Header \"account-id\" AccountId\n    :> MandatoryQueryParam \"request_id\" Text\n    :> Get '[JSON] DA.Value\n\ngetTaskApi :: Proxy GetTaskAPI\ngetTaskApi = Proxy\n\ngetTask ::\n  ( MonadFlow m,\n    CoreMetrics m\n  ) =>\n  ApiKey ->\n  AccountId ->\n  BaseUrl ->\n  Text ->\n  m (VerificationResponse, Text)\ngetTask apiKey accountId url request_id = do\n  (resp :: DA.Value) <- callIdfyAPI url task \"getTask\" getTaskApi\n  convertValueToRespType resp <&> (,KUT.encodeToText resp)\n  where\n    task =\n      T.client\n        getTaskApi\n        (Just apiKey)\n        (Just accountId)\n        request_id\n    convertValueToRespType :: (MonadThrow m, Log m) => DA.Value -> m VerificationResponse\n    convertValueToRespType rsp = case DA.fromJSON rsp of\n      DA.Error err -> throwError $ IdfyCallError (\"Could not parse Idfy getTask resp. Reason: \" <> DT.pack err <> \"Resp: \" <> show rsp)\n      DA.Success pyload -> return pyload\n\ncallIdfyAPI :: CallAPI env api res\ncallIdfyAPI = callApiUnwrappingApiError (identity @IdfyError) (Just $ T.ManagerSelector idfyHttpManagerKey) (Just \"IDFY_ERROR\") Nothing\n",
      "hash": "e3aad3feb67bc10950750c355cc2cb9422cebd3b244fc29b9b13fa79b47d0e69",
      "size": 8146
    },
    "/lib/mobility-core/src/Kernel/External/Verification/Idfy/Config.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n{-# LANGUAGE DerivingStrategies #-}\n\nmodule Kernel.External.Verification.Idfy.Config where\n\nimport Kernel.External.Encryption\nimport Kernel.Prelude\n\ndata IdfyCfg = IdfyCfg\n  { accountId :: EncryptedField 'AsEncrypted AccountId,\n    apiKey :: EncryptedField 'AsEncrypted ApiKey,\n    secret :: EncryptedField 'AsEncrypted Text,\n    url :: BaseUrl\n  }\n  deriving stock (Show, Eq, Generic)\n  deriving anyclass (FromJSON, ToJSON)\n\ntype AccountId = Text\n\ntype ApiKey = Text\n",
      "hash": "816e07f1d8a15c1d5648910963a2925369e53f5053586ed156523a5997050ebe",
      "size": 1161
    },
    "/lib/mobility-core/src/Kernel/External/Verification/Idfy/Flow.hs": {
      "type": "content",
      "content": "{-\n Copyright 2022-23, Juspay India Pvt Ltd\n\n This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program\n\n is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n\n or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of\n\n the GNU Affero General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n\nmodule Kernel.External.Verification.Idfy.Flow\n  ( IdfyWebhookAPI,\n  )\nwhere\n\nimport EulerHS.Prelude\nimport Kernel.Types.Common\nimport Kernel.Utils.Common hiding (Error)\nimport Servant hiding (throwError)\n\ntype IdfyWebhookAPI =\n  \"service\" :> \"idfy\" :> \"verification\"\n    :> Header \"Authorization\" Text\n    :> ReqBody '[JSON] Value\n    :> Post '[JSON] AckResponse\n",
      "hash": "4b930be2376196f9e3639407e86d3ab5e3da3f5cbd4b3c105c0fbf3b39176df2",
      "size": 1051
    },
    "/lib/mobility-core/src/Kernel/External/Verification/Idfy/Types.hs": {
      "type": "content",
      "content": "module Kernel.External.Verification.Idfy.Types\n  ( module Reexport,\n  )\nwhere\n\nimport Kernel.External.Verification.Idfy.Types.Error as Reexport\nimport Kernel.External.Verification.Idfy.Types.Request as Reexport\nimport Kernel.External.Verification.Idfy.Types.Response as Reexport\n",
      "hash": "6cc33c183c1cd099da85d1c9873ff86cd0d2d4c619896f625ab98e056c359d5c",
      "size": 279
    },
    "/lib/mobility-core/src/Kernel/External/Verification/Idfy/Types/Error.hs": {
      "type": "content",
      "content": "{-\n Copyright 2022-23, Juspay India Pvt Ltd\n\n This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program\n\n is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n\n or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of\n\n the GNU Affero General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n{-# LANGUAGE DeriveAnyClass #-}\n{-# LANGUAGE TemplateHaskell #-}\n\nmodule Kernel.External.Verification.Idfy.Types.Error where\n\nimport Kernel.Types.Error.BaseError\nimport Kernel.Types.Error.BaseError.HTTPError\nimport Kernel.Types.Error.BaseError.HTTPError.FromResponse (FromResponse (fromResponse))\nimport Network.HTTP.Types (Status (statusCode))\nimport Servant.Client (ResponseF (responseStatusCode))\nimport Prelude\n\ndata IdfyError\n  = IdfyNotConfigured\n  | IdfyBadRequest\n  | IdfyInvalidCredentials\n  | IdfyMissingCredentials\n  | IdfyNotFound\n  | IdfySizeLimitExceed\n  | IdfyUnprocessableEntity\n  | IdfyRateLimitExceed\n  | IdfyInternalServer\n  | IdfyBadGateway\n  deriving (Eq, Show, IsBecknAPIError)\n\ninstanceExceptionWithParent 'HTTPException ''IdfyError\n\ninstance FromResponse IdfyError where\n  fromResponse resp = case statusCode $ responseStatusCode resp of\n    400 -> Just IdfyBadRequest\n    401 -> Just IdfyMissingCredentials\n    403 -> Just IdfyInvalidCredentials\n    404 -> Just IdfyNotFound\n    413 -> Just IdfySizeLimitExceed\n    422 -> Just IdfyUnprocessableEntity\n    429 -> Just IdfyRateLimitExceed\n    500 -> Just IdfyInternalServer\n    502 -> Just IdfyBadGateway\n    _ -> Just IdfyInternalServer\n\ninstance IsBaseError IdfyError where\n  toMessage = \\case\n    IdfyNotConfigured -> Just \"Idfy env variables aren't properly set.\"\n    IdfyBadRequest -> Just \"Bad request. Please check for the input.\"\n    IdfyInvalidCredentials -> Just \"Something went wrong on our end. Please try again.\"\n    IdfyMissingCredentials -> Just \"Something went wrong on our end. Please try again.\"\n    IdfyNotFound -> Just \"Something went wrong on our end. Please try again.\"\n    IdfySizeLimitExceed -> Just \"Image size is more than 2MB. Please check for the size.\"\n    IdfyUnprocessableEntity -> Just \"Unprocessable image. Please check for the image.\"\n    IdfyRateLimitExceed -> Just \"Something went wrong on our end. Please try again.\"\n    IdfyInternalServer -> Just \"Something went wrong on our end. Please try again.\"\n    IdfyBadGateway -> Just \"Something went wrong on our end. Please try again.\"\n\ninstance IsHTTPError IdfyError where\n  toErrorCode = \\case\n    IdfyNotConfigured -> \"IDFY_NOT_CONFIGURED\"\n    IdfyBadRequest -> \"BAD_REQUEST\"\n    IdfyInvalidCredentials -> \"INTERNAL_SERVER_ERROR\"\n    IdfyMissingCredentials -> \"INTERNAL_SERVER_ERROR\"\n    IdfyNotFound -> \"INTERNAL_SERVER_ERROR\"\n    IdfySizeLimitExceed -> \"SIZE_LIMIT_EXCEED\"\n    IdfyUnprocessableEntity -> \"UNPROCESSABLE_ENTITY\"\n    IdfyRateLimitExceed -> \"INTERNAL_SERVER_ERROR\"\n    IdfyInternalServer -> \"INTERNAL_SERVER_ERROR\"\n    IdfyBadGateway -> \"INTERNAL_SERVER_ERROR\"\n\n  toHttpCode = \\case\n    IdfyNotConfigured -> E500\n    IdfyBadRequest -> E400\n    IdfyInvalidCredentials -> E500\n    IdfyMissingCredentials -> E500\n    IdfyNotFound -> E500\n    IdfySizeLimitExceed -> E400\n    IdfyUnprocessableEntity -> E400\n    IdfyRateLimitExceed -> E500\n    IdfyInternalServer -> E500\n    IdfyBadGateway -> E500\n\ninstance IsAPIError IdfyError\n",
      "hash": "c4fbb61fab2b96b5951a230d570ec4c707b9f4389ff77597201ea62959d392cf",
      "size": 3684
    },
    "/lib/mobility-core/src/Kernel/External/Verification/Idfy/Types/Request.hs": {
      "type": "content",
      "content": "{-\n Copyright 2022-23, Juspay India Pvt Ltd\n\n This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program\n\n is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n\n or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of\n\n the GNU Affero General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n{-# LANGUAGE DerivingStrategies #-}\n\nmodule Kernel.External.Verification.Idfy.Types.Request where\n\nimport Data.OpenApi\n  ( ToSchema (..),\n    fromAesonOptions,\n    genericDeclareNamedSchema,\n  )\nimport EulerHS.Prelude\nimport Kernel.Utils.JSON (stripPrefixUnderscoreIfAny)\n\ntype ImageValidateRequest = IdfyRequest ValidateRequest\n\ntype ImageExtractRequest = IdfyRequest ExtractRequest\n\ntype DLVerificationRequest = IdfyRequest DLVerificationData\n\ntype AadharVerificationReqest = IdfyRequest AadharVerificationData\n\ntype RCVerificationRequest = IdfyRequest RCVerificationData\n\ndata IdfyRequest a = IdfyRequest\n  { task_id :: Text,\n    group_id :: Text,\n    _data :: a\n  }\n  deriving (Show, Generic)\n\ninstance (ToSchema a) => ToSchema (IdfyRequest a) where\n  declareNamedSchema = genericDeclareNamedSchema $ fromAesonOptions stripPrefixUnderscoreIfAny\n\ninstance (FromJSON a) => FromJSON (IdfyRequest a) where\n  parseJSON = genericParseJSON stripPrefixUnderscoreIfAny\n\ninstance (ToJSON a) => ToJSON (IdfyRequest a) where\n  toJSON = genericToJSON stripPrefixUnderscoreIfAny\n\n-- validate image request\ndata ValidateRequest = ValidateRequest\n  { document1 :: Text,\n    doc_type :: Text\n  }\n  deriving (Show, Generic, ToJSON, FromJSON, ToSchema)\n\n-- extract image request\ndata ExtractRequest = ExtractRequest\n  { document1 :: Text,\n    document2 :: Maybe Text\n  }\n  deriving (Show, Generic, ToJSON, FromJSON, ToSchema)\n\n-- DL verification request\ndata DLVerificationData = DLVerificationData\n  { id_number :: Text,\n    date_of_birth :: Text\n  }\n  deriving (Show, Generic, ToJSON, FromJSON, ToSchema)\n\n-- RC verification request\ndata RCVerificationData = RCVerificationData\n  {rc_number :: Text, _a :: Maybe Text}\n  deriving (Show, Generic, ToJSON, FromJSON, ToSchema)\n\ndata AadharVerificationData = AadharVerificationData\n  { document1 :: Text,\n    document2 :: Maybe Text,\n    consent :: Text\n  }\n  deriving (Show, Generic, ToJSON, FromJSON, ToSchema)\n",
      "hash": "374b478c25b9c6aacdf88ade4ccbfd7fa9bdbbde3f9dcb224127f80f3c0c023e",
      "size": 2632
    },
    "/lib/mobility-core/src/Kernel/External/Verification/Idfy/Types/Response.hs": {
      "type": "content",
      "content": "{-\n Copyright 2022-23, Juspay India Pvt Ltd\n\n This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program\n\n is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n\n or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of\n\n the GNU Affero General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n{-# LANGUAGE DerivingStrategies #-}\n\nmodule Kernel.External.Verification.Idfy.Types.Response where\n\nimport Data.Aeson hiding (Error)\nimport qualified Data.Aeson as A\nimport Data.OpenApi hiding (name)\nimport EulerHS.Prelude hiding (state)\nimport Kernel.Types.App ()\nimport Kernel.Utils.JSON\nimport Kernel.Utils.Time\n\ntype ImageValidateResponse = IdfyResponse ValidateResponse\n\ntype RCExtractResponse = IdfyResponse (ExtractionOutput RCExtractionOutput)\n\ntype DLExtractResponse = IdfyResponse (ExtractionOutput DLExtractionOutput)\n\ntype PanExtractionResponse = IdfyResponse (ExtractionOutput PanExtractionOutput)\n\ntype GSTExtractionResponse = IdfyResponse (ExtractionOutput GSTExtractionOutput)\n\ntype AadhaarExtractionResponse = IdfyResponse AadhaarResult\n\ntype VerificationResponse = IdfyResponse IdfyResult\n\ntype VerificationResponseList = [IdfyResponse IdfyResult]\n\ntype IdfyResult = Output DLVerificationOutput RCVerificationOutput\n\ndata IdfyResponse a = IdfyResponse\n  { action :: Text,\n    completed_at :: UTCTime,\n    created_at :: UTCTime,\n    group_id :: Text,\n    request_id :: Text,\n    result :: Maybe a,\n    status :: Text,\n    task_id :: Text,\n    _type :: Text\n  }\n  deriving (Show, Generic)\n\ninstance (ToSchema a) => ToSchema (IdfyResponse a) where\n  declareNamedSchema = genericDeclareNamedSchema $ fromAesonOptions stripPrefixUnderscoreIfAny\n\ninstance (FromJSON a) => FromJSON (IdfyResponse a) where\n  parseJSON = genericParseJSON stripPrefixUnderscoreIfAny\n\ninstance (ToJSON a) => ToJSON (IdfyResponse a) where\n  toJSON = genericToJSON stripPrefixUnderscoreIfAny\n\ndata IdfySuccess = IdfySuccess {request_id :: Text, _a :: Maybe Text}\n  deriving (Show, Generic, ToJSON, FromJSON, ToSchema)\n\n-- RC Result\nnewtype ExtractionOutput a = ExtractionOutput {extraction_output :: a}\n  deriving (Show, Generic)\n\ninstance (ToSchema a) => ToSchema (ExtractionOutput a)\n\ninstance (ToJSON a) => ToJSON (ExtractionOutput a)\n\ninstance (FromJSON a) => FromJSON (ExtractionOutput a)\n\n-- DL Result\nnewtype SourceOutput a = SourceOutput {source_output :: a}\n  deriving (Show, Generic)\n\ninstance (ToSchema a) => ToSchema (SourceOutput a)\n\ninstance (ToJSON a) => ToJSON (SourceOutput a)\n\ninstance (FromJSON a) => FromJSON (SourceOutput a)\n\ndata Output a b = Output {source_output :: Maybe a, extraction_output :: Maybe b}\n  deriving (Show, Generic, ToJSON, FromJSON, ToSchema)\n\n-- RC verification response\ndata RCVerificationOutput = RCVerificationOutput\n  { avg_gross_vehicle_weight :: Maybe Text,\n    axle_configuration :: Maybe Text,\n    chassis_number :: Maybe Text,\n    emission_norms :: Maybe Text,\n    color :: Maybe Text,\n    colour :: Maybe Text,\n    engine_number :: Maybe Text,\n    fitness_upto :: Maybe Text,\n    fuel_type :: Maybe Text,\n    insurance_details :: Maybe Text,\n    insurance_validity :: Maybe Text,\n    manufacturer :: Maybe Text,\n    mv_tax_upto :: Maybe Text,\n    owner_name :: Maybe Text,\n    permit_type :: Maybe Text,\n    permit_validity_upto :: Maybe Text,\n    permit_issue_date :: Maybe Text,\n    permit_number :: Maybe Text,\n    puc_validity_upto :: Maybe Text,\n    registration_date :: Maybe Text,\n    registration_number :: Maybe Text,\n    rto_name :: Maybe Text,\n    status :: Maybe Text,\n    vehicle_class :: Maybe Text,\n    vehicle_financier :: Maybe Text,\n    noc_valid_upto :: Maybe Text,\n    seating_capacity :: Maybe A.Value,\n    variant :: Maybe Text,\n    npermit_upto :: Maybe Text,\n    manufacturer_model :: Maybe Text,\n    standing_capacity :: Maybe A.Value,\n    status_message :: Maybe Text,\n    number_of_cylinder :: Maybe A.Value,\n    puc_valid_upto :: Maybe Text,\n    permanent_address :: Maybe Text,\n    permit_no :: Maybe A.Value,\n    father_name :: Maybe Text,\n    status_verfy_date :: Maybe Text,\n    m_y_manufacturing :: Maybe Text,\n    gross_vehicle_weight :: Maybe A.Value,\n    registered_place :: Maybe Text,\n    insurance_policy_no :: Maybe A.Value,\n    noc_details :: Maybe Text,\n    npermit_issued_by :: Maybe Text,\n    sleeper_capacity :: Maybe A.Value,\n    current_address :: Maybe Text,\n    status_verification :: Maybe Text,\n    permit_validity_from :: Maybe Text,\n    puc_number :: Maybe A.Value,\n    owner_mobile_no :: Maybe A.Value,\n    blacklist_status :: Maybe Text,\n    body_type :: Maybe Text,\n    unladden_weight :: Maybe A.Value,\n    insurance_name :: Maybe Text,\n    owner_serial_number :: Maybe A.Value,\n    vehicle_category :: Maybe Text,\n    npermit_no :: Maybe A.Value,\n    cubic_capacity :: Maybe A.Value,\n    norms_type :: Maybe Text,\n    financer :: Maybe Text,\n    wheelbase :: Maybe A.Value\n  }\n  deriving (Show, Generic, ToJSON, FromJSON, ToSchema)\n\n-- DL Verification response\ndata DLVerificationOutput = DLVerificationOutput\n  { address :: Maybe Text,\n    badge_details :: Maybe Text,\n    card_serial_no :: Maybe Text,\n    city :: Maybe Text,\n    date_of_issue :: Maybe Text,\n    date_of_last_transaction :: Maybe Text,\n    dl_status :: Maybe Text,\n    dob :: Maybe Text,\n    face_image :: Maybe Text,\n    gender :: Maybe Text,\n    hazardous_valid_till :: Maybe Text,\n    hill_valid_till :: Maybe Text,\n    id_number :: Maybe Text,\n    issuing_rto_name :: Maybe Text,\n    last_transacted_at :: Maybe Text,\n    name :: Maybe Text,\n    nt_validity_from :: Maybe Text,\n    nt_validity_to :: Maybe Text,\n    relatives_name :: Maybe Text,\n    source :: Maybe Text,\n    status :: Maybe Text,\n    t_validity_from :: Maybe Text,\n    t_validity_to :: Maybe Text,\n    cov_details :: Maybe [CovDetail]\n  }\n  deriving (Show, Generic, ToJSON, FromJSON, ToSchema)\n\ndata CovDetail = CovDetail\n  { category :: Maybe Text,\n    cov :: Text,\n    issue_date :: Maybe Text\n  }\n  deriving (Show, Generic, ToJSON, FromJSON, ToSchema)\n\n-- validate image\ndata ValidateResponse = ValidateResponse\n  { detected_doc_type :: Text,\n    is_readable :: Maybe Bool,\n    readability :: ReadabilityBody\n  }\n  deriving (Show, Generic, ToJSON, FromJSON, ToSchema)\n\ndata ReadabilityBody = ReadabilityBody\n  { confidence :: Maybe Int,\n    dummyField :: Maybe Text\n  }\n  deriving (Show, Generic, ToJSON, FromJSON, ToSchema)\n\n-- DL extract response\ndata DLExtractionOutput = DLExtractionOutput\n  { id_number :: Maybe Text,\n    name_on_card :: Maybe Text,\n    fathers_name :: Maybe Text,\n    date_of_birth :: Maybe Text,\n    date_of_validity :: Maybe Text,\n    address :: Maybe Text,\n    district :: Maybe Text,\n    street_address :: Maybe Text,\n    pincode :: Maybe Text,\n    state :: Maybe Text,\n    issue_dates :: Maybe ValidateIssueDate,\n    _type :: [Text],\n    validity :: Maybe Validity,\n    status :: Maybe Text\n  }\n  deriving (Show, Generic)\n\ninstance ToSchema DLExtractionOutput where\n  declareNamedSchema = genericDeclareNamedSchema $ fromAesonOptions stripPrefixUnderscoreIfAny\n\ninstance FromJSON DLExtractionOutput where\n  parseJSON = genericParseJSON stripPrefixUnderscoreIfAny\n\ninstance ToJSON DLExtractionOutput where\n  toJSON = genericToJSON stripPrefixUnderscoreIfAny\n\ndata Validity = Validity\n  { nt :: Maybe Text,\n    t :: Maybe Text\n  }\n  deriving (Show, Generic)\n\ninstance ToSchema Validity where\n  declareNamedSchema = genericDeclareNamedSchema $ fromAesonOptions constructorsToUpperOptions\n\ninstance FromJSON Validity where\n  parseJSON = genericParseJSON constructorsToUpperOptions\n\ninstance ToJSON Validity where\n  toJSON = genericToJSON constructorsToUpperOptions\n\ndata ValidateIssueDate = ValidateIssueDate\n  { lmv :: Maybe Text,\n    mcwg :: Maybe Text,\n    trans :: Maybe Text\n  }\n  deriving (Show, Generic)\n\ninstance ToSchema ValidateIssueDate where\n  declareNamedSchema = genericDeclareNamedSchema $ fromAesonOptions constructorsToUpperOptions\n\ninstance FromJSON ValidateIssueDate where\n  parseJSON = genericParseJSON constructorsToUpperOptions\n\ninstance ToJSON ValidateIssueDate where\n  toJSON = genericToJSON constructorsToUpperOptions\n\n-- RC Extraction\ndata RCExtractionOutput = RCExtractionOutput\n  { address :: Maybe Text,\n    body :: Maybe Text,\n    chassis_number :: Maybe Text,\n    _class :: Maybe Text,\n    colour :: Maybe Text,\n    cubic_capacity :: Maybe Text,\n    document1_side :: Maybe Text,\n    document2_side :: Maybe Text,\n    engine_number :: Maybe Text,\n    fathers_name :: Maybe Text,\n    fuel :: Maybe Text,\n    manufacturer :: Maybe Text,\n    manufacturing_date :: Maybe Text,\n    model :: Maybe Text,\n    owner_name :: Maybe Text,\n    registration_date :: Maybe Text,\n    registration_number :: Maybe Text,\n    rto_district :: Maybe Text,\n    state :: Maybe Text,\n    wheel_base :: Maybe Text,\n    status :: Maybe Text\n  }\n  deriving (Show, Generic)\n\ninstance ToSchema RCExtractionOutput where\n  declareNamedSchema = genericDeclareNamedSchema $ fromAesonOptions stripPrefixUnderscoreIfAny\n\ninstance FromJSON RCExtractionOutput where\n  parseJSON = genericParseJSON stripPrefixUnderscoreIfAny\n\ninstance ToJSON RCExtractionOutput where\n  toJSON = genericToJSON stripPrefixUnderscoreIfAny\n\ndata PanExtractionOutput = PanExtractionOutput\n  { age :: Maybe Int,\n    date_of_birth :: Maybe Text,\n    date_of_issue :: Maybe Text,\n    fathers_name :: Maybe Text,\n    id_number :: Maybe Text,\n    is_scanned :: Maybe Bool,\n    minor :: Maybe Bool,\n    name_on_card :: Maybe Text,\n    pan_type :: Maybe Text\n  }\n  deriving (Show, Generic)\n\ninstance ToSchema PanExtractionOutput where\n  declareNamedSchema = genericDeclareNamedSchema $ fromAesonOptions stripPrefixUnderscoreIfAny\n\ninstance FromJSON PanExtractionOutput where\n  parseJSON = genericParseJSON stripPrefixUnderscoreIfAny\n\ninstance ToJSON PanExtractionOutput where\n  toJSON = genericToJSON stripPrefixUnderscoreIfAny\n\ndata GSTExtractionOutput = GSTExtractionOutput\n  { address :: Maybe Text,\n    constitution_of_business :: Maybe Text,\n    date_of_liability :: Maybe Text,\n    gstin :: Maybe Text,\n    is_provisional :: Maybe Bool,\n    legal_name :: Maybe Text,\n    pan_number :: Maybe Text,\n    trade_name :: Maybe Text,\n    type_of_registration :: Maybe Text,\n    valid_from :: Maybe Text,\n    valid_upto :: Maybe Text\n  }\n  deriving (Show, Generic)\n\ninstance ToSchema GSTExtractionOutput where\n  declareNamedSchema = genericDeclareNamedSchema $ fromAesonOptions stripPrefixUnderscoreIfAny\n\ninstance FromJSON GSTExtractionOutput where\n  parseJSON = genericParseJSON stripPrefixUnderscoreIfAny\n\ninstance ToJSON GSTExtractionOutput where\n  toJSON = genericToJSON stripPrefixUnderscoreIfAny\n\ndata AadhaarExtractionOutput = AadhaarExtractionOutput\n  { address :: Maybe Text,\n    date_of_birth :: Maybe Text,\n    district :: Maybe Text,\n    fathers_name :: Maybe Text,\n    gender :: Maybe Text,\n    house_number :: Maybe Text,\n    id_number :: Maybe Text,\n    is_scanned :: Maybe Bool,\n    name_on_card :: Maybe Text,\n    pincode :: Maybe Text,\n    state :: Maybe Text,\n    street_address :: Maybe Text,\n    year_of_birth :: Maybe Text\n  }\n  deriving (Show, Generic)\n\ninstance ToSchema AadhaarExtractionOutput where\n  declareNamedSchema = genericDeclareNamedSchema $ fromAesonOptions stripPrefixUnderscoreIfAny\n\ninstance FromJSON AadhaarExtractionOutput where\n  parseJSON = genericParseJSON stripPrefixUnderscoreIfAny\n\ninstance ToJSON AadhaarExtractionOutput where\n  toJSON = genericToJSON stripPrefixUnderscoreIfAny\n\ndata AadhaarQROutput = AadhaarQROutput\n  { address :: Maybe Text,\n    date_of_birth :: Maybe Text,\n    district :: Maybe Text,\n    gender :: Maybe Text,\n    house_number :: Maybe Text,\n    id_number :: Maybe Text,\n    name_on_card :: Maybe Text,\n    pincode :: Maybe Text,\n    state :: Maybe Text,\n    street_address :: Maybe Text,\n    year_of_birth :: Maybe Text\n  }\n  deriving (Show, Generic)\n\ninstance ToSchema AadhaarQROutput where\n  declareNamedSchema = genericDeclareNamedSchema $ fromAesonOptions stripPrefixUnderscoreIfAny\n\ninstance FromJSON AadhaarQROutput where\n  parseJSON = genericParseJSON stripPrefixUnderscoreIfAny\n\ninstance ToJSON AadhaarQROutput where\n  toJSON = genericToJSON stripPrefixUnderscoreIfAny\n\ndata AadhaarResult = AadhaarResult\n  { extraction_output :: AadhaarExtractionOutput,\n    qr_output :: AadhaarQROutput\n  }\n  deriving (Show, Generic)\n\ninstance ToSchema AadhaarResult where\n  declareNamedSchema = genericDeclareNamedSchema $ fromAesonOptions stripPrefixUnderscoreIfAny\n\ninstance FromJSON AadhaarResult where\n  parseJSON = genericParseJSON stripPrefixUnderscoreIfAny\n\ninstance ToJSON AadhaarResult where\n  toJSON = genericToJSON stripPrefixUnderscoreIfAny\n",
      "hash": "1db1eca8f85246649f5f5c4e5f445b372bb0382ab8adf4205478db9855300ac2",
      "size": 13035
    },
    "/lib/mobility-core/src/Kernel/External/Verification/Idfy/WebhookHandler.hs": {
      "type": "content",
      "content": "{-\n Copyright 2022-23, Juspay India Pvt Ltd\n\n This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program\n\n is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n\n or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of\n\n the GNU Affero General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n\nmodule Kernel.External.Verification.Idfy.WebhookHandler where\n\nimport Data.Aeson.Types as DAT\nimport Data.Maybe (listToMaybe)\nimport EulerHS.Prelude\nimport Kernel.External.Verification.Idfy.Auth\nimport Kernel.External.Verification.Idfy.Config\nimport Kernel.External.Verification.Idfy.Types.Response\nimport Kernel.Tools.Metrics.CoreMetrics.Types\nimport Kernel.Utils.Common\nimport Kernel.Utils.IOLogging\n\nwebhookHandler ::\n  ( EncFlow m r,\n    HasField \"isShuttingDown\" r (TMVar ()),\n    HasField \"coreMetrics\" r CoreMetricsContainer,\n    HasField \"loggerEnv\" r LoggerEnv\n  ) =>\n  IdfyCfg ->\n  (VerificationResponse -> Text -> m AckResponse) ->\n  Maybe Text ->\n  Value ->\n  m AckResponse\nwebhookHandler cfg verifyHandler secret val = do\n  withLogTag \"webhookIdfy\" $ do\n    let respDump = encodeToText val\n    let mResp = fromJSON val\n    case mResp of\n      DAT.Success (resp :: VerificationResponse) -> do\n        void $ verifyAuth cfg secret\n        void $ verifyHandler resp respDump\n        pure Ack\n      DAT.Error err1 -> do\n        logInfo $ \"Error 1: \" <> show err1\n        let mRespList = fromJSON val\n        case mRespList of\n          DAT.Success (respList :: VerificationResponseList) -> do\n            let mResp_ = listToMaybe respList\n            case mResp_ of\n              Just resp_ -> do\n                void $ verifyAuth cfg secret\n                void $ verifyHandler resp_ respDump\n                pure Ack\n              Nothing -> pure Ack\n          DAT.Error err -> do\n            logInfo $ \"Error 2: \" <> show err\n            pure Ack\n",
      "hash": "8273c663021831956499d6825407d9b2f361ce96d43606d4efa4c673c561aa29",
      "size": 2247
    },
    "/lib/mobility-core/src/Kernel/External/Verification/Interface.hs": {
      "type": "content",
      "content": "{-\n Copyright 2022-23, Juspay India Pvt Ltd\n\n This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program\n\n is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n\n or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of\n\n the GNU Affero General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n\nmodule Kernel.External.Verification.Interface\n  ( module Reexport,\n    verifyDLAsync,\n    verifyRC,\n    validateImage,\n    extractRCImage,\n    extractDLImage,\n    extractPanImage,\n    extractAadhaarImage,\n    extractGSTImage,\n    validateFaceImage,\n    searchAgent,\n    verifySdkResp,\n    getTask,\n  )\nwhere\n\nimport EulerHS.Prelude\nimport Kernel.Beam.Lib.UtilsTH\nimport qualified Kernel.External.Verification.GovtData.Client as GovtData\nimport Kernel.External.Verification.GovtData.Storage.Beam as BeamGRC\nimport Kernel.External.Verification.GovtData.Types as Reexport\nimport Kernel.External.Verification.HyperVerge.Types as Reexport\nimport Kernel.External.Verification.Idfy.Config as Reexport\nimport qualified Kernel.External.Verification.Interface.HyperVerge as HyperVerge\nimport qualified Kernel.External.Verification.Interface.Idfy as Idfy\nimport qualified Kernel.External.Verification.Interface.InternalScripts as IS\nimport qualified Kernel.External.Verification.Interface.SafetyPortal as SafetyPortal\nimport Kernel.External.Verification.Interface.Types as Reexport\nimport Kernel.External.Verification.InternalScripts.Types\nimport Kernel.External.Verification.SafetyPortal.Types\nimport Kernel.External.Verification.Types as Reexport\nimport Kernel.Tools.Metrics.CoreMetrics.Types\nimport Kernel.Types.Common\nimport Kernel.Types.Error\nimport Kernel.Utils.Common\n\nverifyDLAsync ::\n  ( EncFlow m r,\n    CoreMetrics m\n  ) =>\n  VerificationServiceConfig ->\n  VerifyDLAsyncReq ->\n  m VerifyDLAsyncResp\nverifyDLAsync serviceConfig req = case serviceConfig of\n  IdfyConfig cfg -> Idfy.verifyDLAsync cfg req\n  GovtDataConfig -> throwError $ InternalError \"Not Implemented!\"\n  FaceVerificationConfig _ -> throwError $ InternalError \"Not Implemented!\"\n  HyperVergeVerificationConfig _ -> throwError $ InternalError \"Not Implemented!\"\n  HyperVergeVerificationConfigRCDL cfg -> HyperVerge.verifyDLAsync cfg req\n\nverifyRC ::\n  ( EncFlow m r,\n    CoreMetrics m,\n    HasSchemaName BeamGRC.GovtDataRCT,\n    MonadFlow m,\n    EsqDBFlow m r,\n    CacheFlow m r\n  ) =>\n  (VerificationService -> m VerificationServiceConfig) ->\n  [VerificationService] ->\n  VerifyRCReq ->\n  m RCRespWithRemPriorityList\nverifyRC getServiceConfig verificationProvidersPriorityList req = do\n  when (null verificationProvidersPriorityList) $ throwError $ InternalError \"No verification service provider configured or exhausted all service providers !!!!\"\n  verifyRCWithFallback verificationProvidersPriorityList\n  where\n    verifyRCWithFallback [] = throwError $ InternalError \"Not able to verify the RC with all the configured providers !!!!!\"\n    verifyRCWithFallback (preferredProvider : restProviders) = do\n      logDebug $ \"Calling verifyRC for provider : \" <> show preferredProvider\n      result <- try @_ @SomeException $ getServiceConfig preferredProvider >>= flip verifyRC' req\n      case result of\n        Left _ -> verifyRCWithFallback restProviders\n        Right res -> return $ RCRespWithRemPriorityList res restProviders\n\nverifyRC' ::\n  ( EncFlow m r,\n    CoreMetrics m,\n    HasSchemaName BeamGRC.GovtDataRCT,\n    MonadFlow m,\n    EsqDBFlow m r,\n    CacheFlow m r\n  ) =>\n  VerificationServiceConfig ->\n  VerifyRCReq ->\n  m VerifyRCResp\nverifyRC' serviceConfig req = case serviceConfig of\n  IdfyConfig cfg -> Idfy.verifyRCAsync cfg req\n  GovtDataConfig -> GovtData.verifyRC req\n  FaceVerificationConfig _ -> throwError $ InternalError \"Not Implemented!\"\n  HyperVergeVerificationConfig _ -> throwError $ InternalError \"Not Implemented!\"\n  HyperVergeVerificationConfigRCDL cfg -> HyperVerge.verifyRCAsync cfg req\n\nvalidateImage ::\n  ( EncFlow m r,\n    CoreMetrics m\n  ) =>\n  VerificationServiceConfig ->\n  ValidateImageReq ->\n  m ValidateImageResp\nvalidateImage serviceConfig req = case serviceConfig of\n  IdfyConfig cfg -> Idfy.validateImage cfg req\n  GovtDataConfig -> throwError $ InternalError \"Not Implemented!\"\n  FaceVerificationConfig _ -> throwError $ InternalError \"Not Implemented!\"\n  HyperVergeVerificationConfig _ -> throwError $ InternalError \"Not Implemented!\"\n  HyperVergeVerificationConfigRCDL _ -> throwError $ InternalError \"Not Implemented!\"\n\nvalidateFaceImage ::\n  ( CoreMetrics m,\n    MonadFlow m\n  ) =>\n  VerificationServiceConfig ->\n  FaceValidationReq ->\n  m FaceValidationRes\nvalidateFaceImage serviceConfig req = case serviceConfig of\n  IdfyConfig _ -> throwError $ InternalError \"Not Implemented!\"\n  GovtDataConfig -> throwError $ InternalError \"Not Implemented!\"\n  FaceVerificationConfig cfg -> IS.validateFace cfg req\n  HyperVergeVerificationConfig _ -> throwError $ InternalError \"Not Implemented!\"\n  HyperVergeVerificationConfigRCDL _ -> throwError $ InternalError \"Not Implemented!\"\n\nextractRCImage ::\n  ( EncFlow m r,\n    CoreMetrics m\n  ) =>\n  VerificationServiceConfig ->\n  ExtractRCImageReq ->\n  m ExtractRCImageResp\nextractRCImage serviceConfig req = case serviceConfig of\n  IdfyConfig cfg -> Idfy.extractRCImage cfg req\n  GovtDataConfig -> throwError $ InternalError \"Not Implemented!\"\n  FaceVerificationConfig _ -> throwError $ InternalError \"Not Implemented!\"\n  HyperVergeVerificationConfig _ -> throwError $ InternalError \"Not Implemented!\"\n  HyperVergeVerificationConfigRCDL _ -> throwError $ InternalError \"Not Implemented!\"\n\nextractDLImage ::\n  ( EncFlow m r,\n    CoreMetrics m\n  ) =>\n  VerificationServiceConfig ->\n  ExtractDLImageReq ->\n  m ExtractDLImageResp\nextractDLImage serviceConfig req = case serviceConfig of\n  IdfyConfig cfg -> Idfy.extractDLImage cfg req\n  GovtDataConfig -> throwError $ InternalError \"Not Implemented!\"\n  FaceVerificationConfig _ -> throwError $ InternalError \"Not Implemented!\"\n  HyperVergeVerificationConfig _ -> throwError $ InternalError \"Not Implemented!\"\n  HyperVergeVerificationConfigRCDL _ -> throwError $ InternalError \"Not Implemented!\"\n\nextractPanImage ::\n  ( EncFlow m r,\n    CoreMetrics m\n  ) =>\n  VerificationServiceConfig ->\n  ExtractPanImage ->\n  m ExtractedPanImageResp\nextractPanImage serviceConfig req = case serviceConfig of\n  IdfyConfig cfg -> Idfy.extractPanImage cfg req\n  GovtDataConfig -> throwError $ InternalError \"Not Implemented!\"\n  FaceVerificationConfig _ -> throwError $ InternalError \"Not Implemented!\"\n  HyperVergeVerificationConfig _ -> throwError $ InternalError \"Not Implemented!\"\n  HyperVergeVerificationConfigRCDL _ -> throwError $ InternalError \"Not Implemented!\"\n\nextractGSTImage ::\n  ( EncFlow m r,\n    CoreMetrics m\n  ) =>\n  VerificationServiceConfig ->\n  ExtractGSTImage ->\n  m ExtractedGSTImageResp\nextractGSTImage serviceConfig req = case serviceConfig of\n  IdfyConfig cfg -> Idfy.extractGSTImage cfg req\n  GovtDataConfig -> throwError $ InternalError \"Not Implemented!\"\n  FaceVerificationConfig _ -> throwError $ InternalError \"Not Implemented!\"\n  HyperVergeVerificationConfig _ -> throwError $ InternalError \"Not Implemented!\"\n  HyperVergeVerificationConfigRCDL _ -> throwError $ InternalError \"Not Implemented!\"\n\nextractAadhaarImage ::\n  ( EncFlow m r,\n    CoreMetrics m\n  ) =>\n  VerificationServiceConfig ->\n  ExtractAadhaarImageReq ->\n  m ExtractAadhaarImageRes\nextractAadhaarImage serviceConfig req = case serviceConfig of\n  IdfyConfig cfg -> Idfy.extractAadhaarImage cfg req\n  GovtDataConfig -> throwError $ InternalError \"Not Implemented!\"\n  FaceVerificationConfig _ -> throwError $ InternalError \"Not Implemented!\"\n  HyperVergeVerificationConfig _ -> throwError $ InternalError \"Not Implemented!\"\n  HyperVergeVerificationConfigRCDL _ -> throwError $ InternalError \"Not Implemented!\"\n\nsearchAgent ::\n  ( EncFlow m r,\n    CoreMetrics m\n  ) =>\n  DriverBackgroundVerificationServiceConfig ->\n  Agent ->\n  m SearchAgentResponse\nsearchAgent serviceConfig req = case serviceConfig of\n  SafetyPortalConfig cfg -> SafetyPortal.searchAgent cfg req\n\nverifySdkResp ::\n  ( EncFlow m r,\n    CoreMetrics m\n  ) =>\n  VerificationServiceConfig ->\n  VerifySdkDataReq ->\n  m VerifySdkDataResp\nverifySdkResp serviceConfig req = case serviceConfig of\n  IdfyConfig _ -> throwError $ InternalError \"Not Implemented!\"\n  GovtDataConfig -> throwError $ InternalError \"Not Implemented!\"\n  FaceVerificationConfig _ -> throwError $ InternalError \"Not Implemented!\"\n  HyperVergeVerificationConfig cfg -> HyperVerge.verifySdkResp cfg req\n  HyperVergeVerificationConfigRCDL _ -> throwError $ InternalError \"Not Implemented!\"\n\ngetTask ::\n  ( EncFlow m r,\n    CoreMetrics m\n  ) =>\n  VerificationServiceConfig ->\n  GetTaskReq ->\n  (Text -> Maybe Text -> Text -> m ()) ->\n  m GetTaskResp\ngetTask serviceConfig req updateResp = case serviceConfig of\n  IdfyConfig cfg -> Idfy.getTask cfg req updateResp\n  GovtDataConfig -> throwError $ InternalError \"Not Implemented!\"\n  FaceVerificationConfig _ -> throwError $ InternalError \"Not Implemented!\"\n  HyperVergeVerificationConfig _ -> throwError $ InternalError \"Not Implemented!\"\n  HyperVergeVerificationConfigRCDL cfg -> HyperVerge.getVerificationStatus cfg req updateResp\n",
      "hash": "d73c18ca19ca2cf4d413e224ad108baa520cee63c8bc3b964ad6f7d275db07cd",
      "size": 9569
    },
    "/lib/mobility-core/src/Kernel/External/Verification/Interface/HyperVerge.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n\nmodule Kernel.External.Verification.Interface.HyperVerge where\n\nimport qualified Data.Text as T\nimport Data.Time\nimport qualified Data.Tuple.Extra as TE\nimport Kernel.External.Encryption as Common (EncFlow)\nimport Kernel.External.SharedLogic.HyperVerge.Error (HyperVergeError (..))\nimport qualified Kernel.External.Verification.HyperVerge.Flow as HyperVergeFlow\nimport qualified Kernel.External.Verification.HyperVerge.Types as HyperVergeTypes\nimport qualified Kernel.External.Verification.Idfy.Types.Response as IdfyTypes\nimport qualified Kernel.External.Verification.Interface.Types as InterfaceTypes\nimport qualified Kernel.External.Verification.Types as VT\nimport Kernel.Prelude hiding (error)\nimport Kernel.Tools.Metrics.CoreMetrics (CoreMetrics)\nimport Kernel.Types.Error (GenericError (InternalError))\nimport qualified Kernel.Types.MonadGuid as UID\nimport Kernel.Utils.Common (logError)\nimport Kernel.Utils.Error.Throwing (fromMaybeM, throwError)\nimport Kernel.Utils.Logging (Log)\n\nverifySdkResp ::\n  ( CoreMetrics m,\n    EncFlow m r\n  ) =>\n  HyperVergeTypes.HyperVergeVerificationCfg ->\n  InterfaceTypes.VerifySdkDataReq ->\n  m InterfaceTypes.VerifySdkDataResp\nverifySdkResp config req = do\n  let hvReq = convertVerifySdkRespToHyperVergeReq req\n  resp <- HyperVergeFlow.verifySdkResp config hvReq\n  return $ convertHvSdkVerificationRespToVerifySdkResp resp\n  where\n    convertVerifySdkRespToHyperVergeReq :: InterfaceTypes.VerifySdkDataReq -> HyperVergeTypes.HyperVergeSdkVerificationReq\n    convertVerifySdkRespToHyperVergeReq InterfaceTypes.VerifySdkDataReq {..} = HyperVergeTypes.HyperVergeSdkVerificationReq {..}\n\n    convertHvSdkVerificationRespToVerifySdkResp :: HyperVergeTypes.HyperVergeSdkVerificationRes -> InterfaceTypes.VerifySdkDataResp\n    convertHvSdkVerificationRespToVerifySdkResp HyperVergeTypes.HyperVergeSdkVerificationRes {..} =\n      InterfaceTypes.VerifySdkDataResp\n        { userDetails = join $ result <&> (.userDetails),\n          status = join $ result <&> (.status),\n          transactionId = join $ result <&> (.transactionId)\n        }\n\nverifyRCAsync ::\n  ( CoreMetrics m,\n    EncFlow m r,\n    MonadIO m\n  ) =>\n  HyperVergeTypes.HyperVergeRCDLVerificationConfig ->\n  InterfaceTypes.VerifyRCReq ->\n  m InterfaceTypes.VerifyRCResp\nverifyRCAsync cfg req = do\n  transactionId <- liftIO UID.generateGUIDTextIO\n  resp <- HyperVergeFlow.verifyRCAsync cfg transactionId $ makeHVRCAsyncReq req\n  makeRCResp resp\n  where\n    makeHVRCAsyncReq :: InterfaceTypes.VerifyRCReq -> HyperVergeTypes.VerifyRCAsyncReq\n    makeHVRCAsyncReq InterfaceTypes.VerifyRCReq {..} =\n      HyperVergeTypes.VerifyRCAsyncReq\n        { reg_no = rcNumber\n        }\n    makeRCResp :: (MonadThrow m, Log m) => HyperVergeTypes.VerifyRCAsyncResp -> m InterfaceTypes.VerifyRCResp\n    makeRCResp rsp@HyperVergeTypes.HyperVergeVerificationAsyncResp {..} = InterfaceTypes.AsyncResp <$> (InterfaceTypes.VerifyAsyncResp <$> fromMaybeM (HVError $ \"Could not find request id in a 200 response : \" <> show rsp) (join (metaData <&> (.requestId))) <*> return VT.HyperVergeRCDL <*> return (join (metaData <&> (.transactionId))))\n\nverifyDLAsync ::\n  ( CoreMetrics m,\n    EncFlow m r,\n    MonadIO m\n  ) =>\n  HyperVergeTypes.HyperVergeRCDLVerificationConfig ->\n  InterfaceTypes.VerifyDLAsyncReq ->\n  m InterfaceTypes.VerifyDLAsyncResp\nverifyDLAsync cfg req = do\n  transactionId <- liftIO UID.generateGUIDTextIO\n  resp <- HyperVergeFlow.verifyDLAsync cfg transactionId $ makeHVDLAsyncReq req\n  makeDLResp resp\n  where\n    makeHVDLAsyncReq :: InterfaceTypes.VerifyDLAsyncReq -> HyperVergeTypes.HyperVergeDLVerificationReq\n    makeHVDLAsyncReq InterfaceTypes.VerifyDLAsyncReq {..} =\n      HyperVergeTypes.HyperVergeDLVerificationReq\n        { returnState = fromMaybe False returnState,\n          dob = T.pack $ formatTime defaultTimeLocale \"%d-%m-%Y\" dateOfBirth,\n          ..\n        }\n    makeDLResp :: (MonadThrow m, Log m) => HyperVergeTypes.HyperVergeDLVerificationResp -> m InterfaceTypes.VerifyDLAsyncResp\n    makeDLResp rsp@HyperVergeTypes.HyperVergeVerificationAsyncResp {..} = InterfaceTypes.VerifyAsyncResp <$> fromMaybeM (HVError $ \"Could not find request id in a 200 response :\" <> show rsp) (join (metaData <&> (.requestId))) <*> return VT.HyperVergeRCDL <*> return (join (metaData <&> (.transactionId)))\n\ngetVerificationStatus ::\n  ( CoreMetrics m,\n    EncFlow m r\n  ) =>\n  HyperVergeTypes.HyperVergeRCDLVerificationConfig ->\n  InterfaceTypes.GetTaskReq ->\n  (Text -> Maybe Text -> Text -> m ()) ->\n  m InterfaceTypes.GetTaskResp\ngetVerificationStatus cfg rqst@InterfaceTypes.GetTaskReq {..} updateResp = do\n  (resp, respDump) <- fromMaybeM (HVBadInputError \"workflowId compulsory for hyperverge get status api not specified !!!!\") workflowId >>= flip (HyperVergeFlow.getVerificationStatus cfg) requestId\n  updateResp resp.status (Just respDump) requestId\n  convertToGetTaskResp resp\n  where\n    convertToGetTaskResp :: (MonadThrow m, Log m) => HyperVergeTypes.GetVerificationStatusResp -> m InterfaceTypes.GetTaskResp\n    convertToGetTaskResp statRsp@HyperVergeTypes.GetVerificationStatusResp {..} = do\n      let apiResp' = join $ result <&> (.result) . (.apiOutput)\n      case apiResp' of\n        Just (HyperVergeTypes.RCVerificationResultData apiResp) -> do\n          apiData <- fromMaybeM (HVMissingPayloadError $ show apiResp) apiResp.rcInfo\n          return $\n            InterfaceTypes.RCResp\n              VT.RCVerificationResponse\n                { registrationDate = apiData.reg_date,\n                  registrationNumber = apiData.reg_no,\n                  fitnessUpto = apiData.fit_upto,\n                  insuranceValidity = join $ apiData.vehicle_insurance_details <&> (.insurance_upto),\n                  vehicleClass = apiData.vehicle_catg,\n                  vehicleCategory = Nothing,\n                  seatingCapacity = toJSON <$> apiData.vehicle_seat_capacity,\n                  manufacturer = apiData.vehicle_manufacturer_name,\n                  permitValidityFrom = join $ apiData.permit_details <&> (.permit_valid_from),\n                  permitValidityUpto = join $ apiData.permit_details <&> (.permit_valid_upto),\n                  pucValidityUpto = join $ apiData.vehicle_pucc_details <&> (.pucc_upto),\n                  manufacturerModel = apiData.model,\n                  mYManufacturing = T.concat <$> sequence [(show <$> apiData.manufacturing_mon), Just \"-\", (show <$> apiData.manufacturing_yr)],\n                  color = apiData.color,\n                  fuelType = apiData.fuel_descr,\n                  bodyType = apiData.body_type,\n                  status = Just status,\n                  grossVehicleWeight = apiData.vehicle_gross_weight,\n                  unladdenWeight = apiData.unladen_weight\n                }\n        Just (HyperVergeTypes.DLVerificationResultData HyperVergeTypes.DLVerificationData {..}) -> do\n          let ((transporterValidFrom, transporterValidTo), (nonTransportValidFrom, nonTransportValidTo)) = flip (maybe ((Nothing, Nothing), (Nothing, Nothing))) validity $ (\\HyperVergeTypes.DLValidityInfo {..} -> TE.both (maybe (Nothing, Nothing) (\\d -> (listToMaybe d, listToMaybe $ reverse d)) . (T.splitOn \" \" <$>)) (transport, nonTransport))\n          return $\n            InterfaceTypes.DLResp\n              InterfaceTypes.DLVerificationOutputInterface\n                { driverName = name,\n                  licenseNumber = dl_number,\n                  nt_validity_from = formatValidityTimeFormat nonTransportValidFrom,\n                  nt_validity_to = formatValidityTimeFormat nonTransportValidTo,\n                  t_validity_from = formatValidityTimeFormat transporterValidFrom,\n                  t_validity_to = formatValidityTimeFormat transporterValidTo,\n                  covs = map (\\covDets -> IdfyTypes.CovDetail {category = Nothing, issue_date = covDets.issue_date, cov = covDets.cov}) <$> cov_details,\n                  status = result <&> (.status) . (.apiOutput),\n                  dateOfIssue = reverseDateFormat <$> issue_date,\n                  ..\n                }\n        _ -> if (result <&> ((.statusCode) &&& (.status)) . (.apiOutput)) == Just (\"422\", \"failure\") then makeInvalidRCDLResp else throwError $ HVError (\"Failed to parse getTask response data of Hyperverge properly. Resp : \" <> show statRsp)\n\n    formatValidityTimeFormat :: Maybe Text -> Maybe Text\n    formatValidityTimeFormat = (reverseDateFormat <$>) . (\\val -> bool val Nothing (val == Just \"\"))\n\n    reverseDateFormat :: Text -> Text\n    reverseDateFormat = T.intercalate \"-\" . reverse . T.splitOn \"-\"\n\n    makeInvalidRCDLResp :: (MonadThrow m, Log m) => m InterfaceTypes.GetTaskResp\n    makeInvalidRCDLResp = do\n      logError $ \"Invalid Document details in the request. Could not find in provider's database. Req : \" <> show rqst\n      case workflowId of\n        Just \"checkDL\" ->\n          return $\n            InterfaceTypes.DLResp\n              InterfaceTypes.DLVerificationOutputInterface\n                { driverName = Nothing,\n                  dob = Nothing,\n                  licenseNumber = Nothing,\n                  nt_validity_from = Nothing,\n                  nt_validity_to = Nothing,\n                  t_validity_from = Nothing,\n                  t_validity_to = Nothing,\n                  covs = Nothing,\n                  status = Just \"id_not_found\",\n                  dateOfIssue = Nothing,\n                  message = Nothing\n                }\n        Just \"RCVerification\" ->\n          return $\n            InterfaceTypes.RCResp\n              VT.RCVerificationResponse\n                { registrationDate = Nothing,\n                  registrationNumber = Nothing,\n                  fitnessUpto = Nothing,\n                  insuranceValidity = Nothing,\n                  vehicleClass = Nothing,\n                  vehicleCategory = Nothing,\n                  seatingCapacity = Nothing,\n                  manufacturer = Nothing,\n                  permitValidityFrom = Nothing,\n                  permitValidityUpto = Nothing,\n                  pucValidityUpto = Nothing,\n                  manufacturerModel = Nothing,\n                  mYManufacturing = Nothing,\n                  color = Nothing,\n                  fuelType = Nothing,\n                  bodyType = Nothing,\n                  status = Just \"failure\",\n                  grossVehicleWeight = Nothing,\n                  unladdenWeight = Nothing\n                }\n        _ -> throwError $ InternalError (\"Unknown Workflow!!!!!!!. workflowId : \" <> show workflowId)\n",
      "hash": "5337263ac20f06bf39d78eb0a588a0dc5a1d644fd3d2168efd2674c23c6eb0f7",
      "size": 11183
    },
    "/lib/mobility-core/src/Kernel/External/Verification/Interface/Idfy.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n\nmodule Kernel.External.Verification.Interface.Idfy\n  ( module Reexport,\n    verifyDLAsync,\n    verifyRCAsync,\n    validateImage,\n    extractRCImage,\n    extractDLImage,\n    extractPanImage,\n    extractGSTImage,\n    extractAadhaarImage,\n    getTask,\n    convertDLOutputToDLVerificationOutput,\n    convertRCOutputToRCVerificationResponse,\n  )\nwhere\n\nimport Control.Applicative ((<|>))\nimport qualified Data.Aeson as A\nimport qualified Data.Text as T\nimport Data.Time.Format\nimport Kernel.External.Encryption\nimport Kernel.External.Verification.Idfy.Auth as Reexport\nimport qualified Kernel.External.Verification.Idfy.Client as Idfy\nimport Kernel.External.Verification.Idfy.Config as Reexport\nimport Kernel.External.Verification.Idfy.Flow as Reexport\nimport Kernel.External.Verification.Idfy.Types as Reexport\nimport qualified Kernel.External.Verification.Idfy.Types.Request as Idfy\nimport qualified Kernel.External.Verification.Idfy.Types.Response as Idfy\nimport Kernel.External.Verification.Interface.Types\nimport qualified Kernel.External.Verification.Types as VT\nimport Kernel.Prelude\nimport Kernel.Tools.Metrics.CoreMetrics (CoreMetrics)\nimport Kernel.Types.Common\nimport Kernel.Types.Error (GenericError (InternalError))\nimport Kernel.Utils.Error.Throwing\n\nbuildIdfyRequest :: MonadGuid m => Text -> a -> m (Idfy.IdfyRequest a)\nbuildIdfyRequest driverId a = do\n  task_id <- generateGUID\n  let group_id = driverId\n  pure\n    Idfy.IdfyRequest\n      { _data = a,\n        ..\n      }\n\nverifyDLAsync ::\n  ( EncFlow m r,\n    CoreMetrics m\n  ) =>\n  IdfyCfg ->\n  VerifyDLAsyncReq ->\n  m VerifyDLAsyncResp\nverifyDLAsync cfg req = do\n  let url = cfg.url\n  apiKey <- decrypt cfg.apiKey\n  accountId <- decrypt cfg.accountId\n  let dobDay = T.pack $ formatTime defaultTimeLocale \"%F\" req.dateOfBirth\n  let reqData =\n        Idfy.DLVerificationData\n          { id_number = req.dlNumber,\n            date_of_birth = dobDay\n          }\n  idfyReq <- buildIdfyRequest req.driverId reqData\n  idfySuccess <- Idfy.verifyDLAsync apiKey accountId url idfyReq\n  pure $ VerifyAsyncResp {requestId = idfySuccess.request_id, requestor = VT.Idfy, transactionId = Nothing}\n\nverifyRCAsync ::\n  ( EncFlow m r,\n    CoreMetrics m\n  ) =>\n  IdfyCfg ->\n  VerifyRCReq ->\n  m VerifyRCResp\nverifyRCAsync cfg req = do\n  let url = cfg.url\n  apiKey <- decrypt cfg.apiKey\n  accountId <- decrypt cfg.accountId\n  let reqData =\n        Idfy.RCVerificationData\n          { rc_number = req.rcNumber,\n            _a = Nothing\n          }\n  idfyReq <- buildIdfyRequest req.driverId reqData\n  idfySuccess <- Idfy.verifyRCAsync apiKey accountId url idfyReq\n  pure $ AsyncResp VerifyAsyncResp {requestId = idfySuccess.request_id, requestor = VT.Idfy, transactionId = Nothing}\n\nvalidateImage ::\n  ( EncFlow m r,\n    CoreMetrics m\n  ) =>\n  IdfyCfg ->\n  ValidateImageReq ->\n  m ValidateImageResp\nvalidateImage cfg req = do\n  -- skipping validation for rc as validation not available in idfy\n  case req.imageType of\n    DriverLicense -> do\n      let url = cfg.url\n      apiKey <- decrypt cfg.apiKey\n      accountId <- decrypt cfg.accountId\n      let reqData =\n            Idfy.ValidateRequest\n              { document1 = req.image,\n                doc_type = getDocType req.imageType\n              }\n      idfyReq <- buildIdfyRequest req.driverId reqData\n      resp <- Idfy.validateImage apiKey accountId url idfyReq\n      pure $ mkValidateImageResp resp\n    VehicleRegistrationCertificate -> return validationNotAvailable\n    VehiclePUC -> return validationNotAvailable\n    VehiclePermit -> return validationNotAvailable\n    VehicleInsurance -> return validationNotAvailable\n    VehicleFitnessCertificate -> return validationNotAvailable\n    VehicleNOC -> return validationNotAvailable\n  where\n    validationNotAvailable =\n      ValidateImageResp\n        { validationAvailable = False,\n          detectedImage = Nothing\n        }\n\nmkValidateImageResp :: Idfy.IdfyResponse Idfy.ValidateResponse -> ValidateImageResp\nmkValidateImageResp resp = do\n  let detectedImage =\n        resp.result <&> \\result ->\n          DetectedImage\n            { imageType = getImageType result.detected_doc_type,\n              isReadable = result.is_readable,\n              confidence = result.readability.confidence\n            }\n  ValidateImageResp\n    { validationAvailable = True,\n      detectedImage\n    }\n\ngetDocType :: ImageType -> Text\ngetDocType DriverLicense = \"ind_driving_license\"\ngetDocType VehicleRegistrationCertificate = \"ind_rc\"\ngetDocType VehiclePUC = \"ind_puc\" -- fix these\ngetDocType VehiclePermit = \"ind_permit\"\ngetDocType VehicleInsurance = \"ind_insurance\"\ngetDocType VehicleFitnessCertificate = \"ind_fitness_certificate\"\ngetDocType VehicleNOC = \"ind_vehicle_noc\"\n\ngetImageType :: Text -> ImageType\ngetImageType \"ind_driving_license\" = DriverLicense\ngetImageType \"ind_rc\" = VehicleRegistrationCertificate\ngetImageType \"ind_puc\" = VehiclePUC\ngetImageType \"ind_permit\" = VehiclePermit\ngetImageType \"ind_insurance\" = VehicleInsurance\ngetImageType \"ind_fitness_certificate\" = VehicleFitnessCertificate\ngetImageType \"ind_vehicle_noc\" = VehicleNOC\ngetImageType _ = VehicleRegistrationCertificate\n\nextractRCImage ::\n  ( EncFlow m r,\n    CoreMetrics m\n  ) =>\n  IdfyCfg ->\n  ExtractRCImageReq ->\n  m ExtractRCImageResp\nextractRCImage cfg req = do\n  let url = cfg.url\n  apiKey <- decrypt cfg.apiKey\n  accountId <- decrypt cfg.accountId\n  let reqData =\n        Idfy.ExtractRequest\n          { document1 = req.image1,\n            document2 = req.image2\n          }\n  idfyReq <- buildIdfyRequest req.driverId reqData\n  resp <- Idfy.extractRCImage apiKey accountId url idfyReq\n  pure\n    ExtractRCImageResp\n      { extractedRC =\n          resp.result <&> \\result -> do\n            ExtractedRC {rcNumber = result.extraction_output.registration_number}\n      }\n\nextractDLImage ::\n  ( EncFlow m r,\n    CoreMetrics m\n  ) =>\n  IdfyCfg ->\n  ExtractDLImageReq ->\n  m ExtractDLImageResp\nextractDLImage cfg req = do\n  let url = cfg.url\n  apiKey <- decrypt cfg.apiKey\n  accountId <- decrypt cfg.accountId\n  let reqData =\n        Idfy.ExtractRequest\n          { document1 = req.image1,\n            document2 = req.image2\n          }\n  idfyReq <- buildIdfyRequest req.driverId reqData\n  resp <- Idfy.extractDLImage apiKey accountId url idfyReq\n  pure\n    ExtractDLImageResp\n      { extractedDL =\n          resp.result <&> \\result -> do\n            ExtractedDL\n              { dlNumber = result.extraction_output.id_number,\n                nameOnCard = result.extraction_output.name_on_card,\n                dateOfBirth = result.extraction_output.date_of_birth\n              }\n      }\n\nextractPanImage ::\n  ( EncFlow m r,\n    CoreMetrics m\n  ) =>\n  IdfyCfg ->\n  ExtractPanImage ->\n  m ExtractedPanImageResp\nextractPanImage cfg req = do\n  let url = cfg.url\n  apiKey <- decrypt cfg.apiKey\n  accountId <- decrypt cfg.accountId\n  let reqData =\n        Idfy.ExtractRequest\n          { document1 = req.image1,\n            document2 = req.image2\n          }\n  idfyReq <- buildIdfyRequest req.driverId reqData\n  resp <- Idfy.extractPanImage apiKey accountId url idfyReq\n  pure\n    ExtractedPanImageResp\n      { extractedPan = resp.result >>= (\\x -> pure x.extraction_output)\n      }\n\nextractGSTImage ::\n  ( EncFlow m r,\n    CoreMetrics m\n  ) =>\n  IdfyCfg ->\n  ExtractGSTImage ->\n  m ExtractedGSTImageResp\nextractGSTImage cfg req = do\n  let url = cfg.url\n  apiKey <- decrypt cfg.apiKey\n  accountId <- decrypt cfg.accountId\n  let reqData =\n        Idfy.ExtractRequest\n          { document1 = req.image1,\n            document2 = req.image2\n          }\n  idfyReq <- buildIdfyRequest req.driverId reqData\n  resp <- Idfy.extractGSTImage apiKey accountId url idfyReq\n  pure\n    ExtractedGSTImageResp\n      { extractedGST = resp.result >>= (\\x -> pure x.extraction_output)\n      }\n\nextractAadhaarImage ::\n  ( EncFlow m r,\n    CoreMetrics m\n  ) =>\n  IdfyCfg ->\n  ExtractAadhaarImageReq ->\n  m ExtractAadhaarImageRes\nextractAadhaarImage cfg req = do\n  let url = cfg.url\n  apiKey <- decrypt cfg.apiKey\n  accountId <- decrypt cfg.accountId\n  let reqData =\n        Idfy.AadharVerificationData\n          { document1 = req.image1,\n            document2 = req.image2,\n            consent = req.consent\n          }\n  idfyReq <- buildIdfyRequest req.driverId reqData\n  resp <- Idfy.extractAadhaarImage apiKey accountId url idfyReq\n  pure\n    ExtractAadhaarImageRes\n      { extractedAadhaar = resp.result\n      }\n\ngetTask ::\n  ( EncFlow m r,\n    CoreMetrics m\n  ) =>\n  IdfyCfg ->\n  GetTaskReq ->\n  (Text -> Maybe Text -> Text -> m ()) ->\n  m GetTaskResp\ngetTask cfg req updateResp = do\n  let url = cfg.url\n  apiKey <- decrypt cfg.apiKey\n  accountId <- decrypt cfg.accountId\n  (resp, respDump) <- Idfy.getTask apiKey accountId url req.requestId\n  updateResp resp.status (Just respDump) req.requestId\n  let dlOutput = join $ resp.result <&> (.source_output)\n      rcOutput = join $ resp.result <&> (.extraction_output)\n  case (dlOutput, rcOutput) of\n    (Just op, Nothing) -> return $ DLResp (convertDLOutputToDLVerificationOutput op)\n    (Nothing, Just op) -> return $ RCResp (convertRCOutputToRCVerificationResponse op)\n    _ -> throwError $ InternalError (\"Unrecognized response from getTesk api. Resp : \" <> show resp)\n\nconvertDLOutputToDLVerificationOutput :: DLVerificationOutput -> DLVerificationOutputInterface\nconvertDLOutputToDLVerificationOutput DLVerificationOutput {..} =\n  DLVerificationOutputInterface\n    { driverName = name,\n      licenseNumber = id_number,\n      covs = cov_details,\n      dateOfIssue = date_of_issue,\n      message = Nothing,\n      ..\n    }\n\nconvertRCOutputToRCVerificationResponse :: RCVerificationOutput -> VT.RCVerificationResponse\nconvertRCOutputToRCVerificationResponse RCVerificationOutput {..} =\n  VT.RCVerificationResponse\n    { registrationDate = registration_date,\n      registrationNumber = registration_number,\n      fitnessUpto = fitness_upto,\n      insuranceValidity = insurance_validity,\n      vehicleClass = vehicle_class,\n      vehicleCategory = vehicle_category,\n      seatingCapacity = seating_capacity,\n      manufacturer = manufacturer,\n      permitValidityFrom = permit_validity_from,\n      permitValidityUpto = permit_validity_upto,\n      pucValidityUpto = puc_validity_upto,\n      manufacturerModel = manufacturer_model,\n      mYManufacturing = m_y_manufacturing,\n      color = color <|> colour,\n      fuelType = fuel_type,\n      bodyType = body_type,\n      status = status,\n      grossVehicleWeight = gross_vehicle_weight >>= convertValueToFloat,\n      unladdenWeight = unladden_weight >>= convertValueToFloat\n    }\n\nconvertValueToFloat :: A.Value -> Maybe Float\nconvertValueToFloat (A.String val) = readMaybe (T.unpack val)\nconvertValueToFloat _ = Nothing\n",
      "hash": "e9c7ca17f7df6c005c4279d778f41b1b6af02478c116124eb3915ea68bab397a",
      "size": 11400
    },
    "/lib/mobility-core/src/Kernel/External/Verification/Interface/InternalScripts.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n\nmodule Kernel.External.Verification.Interface.InternalScripts\n  ( module Reexport,\n    validateFace,\n  )\nwhere\n\nimport Control.Monad\nimport Kernel.External.Verification.InternalScripts.Error\nimport qualified Kernel.External.Verification.InternalScripts.FaceVerification as FV\nimport Kernel.External.Verification.InternalScripts.Types as Reexport\nimport Kernel.Tools.Metrics.CoreMetrics (CoreMetrics)\nimport Kernel.Utils.Common\n\nvalidateFace :: (CoreMetrics m, MonadFlow m) => FaceVerificationCfg -> FaceValidationReq -> m FaceValidationRes\nvalidateFace fvCfg req = do\n  let url = fvCfg.url\n  res <- FV.validateFace url req\n  case res.faceType of\n    UNKNOWN -> throwError PoorImageQuality\n    FAKE_FACE -> throwError FakeFaceDetected\n    REAL_FACE -> return res\n",
      "hash": "aa88235949dee932f52ca992e583b5053278c1f44960a02a58112ea7fd0edae3",
      "size": 1456
    },
    "/lib/mobility-core/src/Kernel/External/Verification/Interface/SafetyPortal.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n\nmodule Kernel.External.Verification.Interface.SafetyPortal where\n\nimport Kernel.External.Encryption\nimport Kernel.External.Verification.Interface.Types\nimport qualified Kernel.External.Verification.SafetyPortal.Client as SafetyPortal\nimport Kernel.External.Verification.SafetyPortal.Config as Reexport\nimport Kernel.External.Verification.SafetyPortal.Types as Reexport\nimport qualified Kernel.External.Verification.SafetyPortal.Types as SafetyPortal\nimport Kernel.Prelude\nimport Kernel.Tools.Metrics.CoreMetrics (CoreMetrics)\n\nsearchAgent ::\n  ( EncFlow m r,\n    CoreMetrics m\n  ) =>\n  SafetyPortalCfg ->\n  SafetyPortal.Agent ->\n  m SearchAgentResponse\nsearchAgent cfg req = do\n  let url = cfg.url\n  token <- decrypt cfg.token\n  let reqData =\n        SafetyPortal.SearchAgentReq\n          { suspectReqList = [req]\n          }\n  safetyPortalResp <- SafetyPortal.searchAgent url token reqData\n  pure $ SearchAgentResponse {suspect = safetyPortalResp.suspects}\n",
      "hash": "06e79d593070572b4b105f82abe8ac02c78c78224cb8771e80abae69bfbe2d4a",
      "size": 1652
    },
    "/lib/mobility-core/src/Kernel/External/Verification/Interface/Types.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n{-# LANGUAGE DerivingStrategies #-}\n\nmodule Kernel.External.Verification.Interface.Types\n  ( module Kernel.External.Verification.Interface.Types,\n  )\nwhere\n\nimport Deriving.Aeson\nimport EulerHS.Prelude\nimport qualified Kernel.External.Verification.HyperVerge.Types as HyperVergeTypes\nimport qualified Kernel.External.Verification.Idfy.Config as Idfy\nimport qualified Kernel.External.Verification.Idfy.Types.Response as Idfy\nimport qualified Kernel.External.Verification.InternalScripts.Types as FV\nimport qualified Kernel.External.Verification.SafetyPortal.Config as SafetyPortal\nimport Kernel.External.Verification.SafetyPortal.Types\nimport qualified Kernel.External.Verification.Types as VT\nimport Kernel.Prelude\n\ndata VerificationServiceConfig = IdfyConfig Idfy.IdfyCfg | FaceVerificationConfig FV.FaceVerificationCfg | GovtDataConfig | HyperVergeVerificationConfig HyperVergeTypes.HyperVergeVerificationCfg | HyperVergeVerificationConfigRCDL HyperVergeTypes.HyperVergeRCDLVerificationConfig\n  deriving stock (Show, Eq, Generic)\n  deriving anyclass (FromJSON, ToJSON)\n\nnewtype DriverBackgroundVerificationServiceConfig = SafetyPortalConfig SafetyPortal.SafetyPortalCfg\n  deriving stock (Show, Eq, Generic)\n  deriving anyclass (FromJSON, ToJSON)\n\ndata VerifyDLAsyncReq = VerifyDLAsyncReq\n  { dlNumber :: Text,\n    driverId :: Text,\n    dateOfBirth :: UTCTime,\n    returnState :: Maybe Bool\n  }\n  deriving stock (Show, Generic)\n\ntype VerifyDLAsyncResp = VerifyAsyncResp\n\ndata VerifyRCReq = VerifyRCReq\n  { rcNumber :: Text,\n    driverId :: Text\n  }\n  deriving stock (Show, Generic)\n\ndata VerifyRCResp = AsyncResp VerifyAsyncResp | SyncResp VT.RCVerificationResponse\n  deriving (Show, Generic)\n\ninstance ToJSON VerifyRCResp where\n  toJSON (AsyncResp a) = toJSON a\n  toJSON (SyncResp s) = toJSON s\n\ninstance FromJSON VerifyRCResp where\n  parseJSON v = (AsyncResp <$> parseJSON v) <|> (SyncResp <$> parseJSON v)\n\ndata VerifyAsyncResp = VerifyAsyncResp\n  { requestId :: Text,\n    requestor :: VT.VerificationService,\n    transactionId :: Maybe Text\n  }\n  deriving stock (Show, Generic)\n  deriving anyclass (ToJSON, FromJSON, ToSchema)\n\ndata ValidateImageReq = ValidateImageReq\n  { image :: Text,\n    imageType :: ImageType,\n    driverId :: Text\n  }\n  deriving stock (Show, Generic)\n\ndata ImageType = DriverLicense | VehicleRegistrationCertificate | VehiclePUC | VehiclePermit | VehicleInsurance | VehicleFitnessCertificate | VehicleNOC\n  deriving stock (Show, Eq, Generic)\n  deriving anyclass (FromJSON, ToJSON, ToSchema)\n\ndata ValidateImageResp = ValidateImageResp\n  { validationAvailable :: Bool,\n    detectedImage :: Maybe DetectedImage\n  }\n  deriving stock (Show, Generic)\n\ndata DetectedImage = DetectedImage\n  { imageType :: ImageType,\n    isReadable :: Maybe Bool,\n    confidence :: Maybe Int\n  }\n  deriving stock (Show, Generic)\n\ntype ExtractRCImageReq = ExtractImageReq\n\ntype ExtractDLImageReq = ExtractImageReq\n\ntype ExtractPanImage = ExtractImageReq\n\ntype ExtractGSTImage = ExtractImageReq\n\ndata ExtractImageReq = ExtractImageReq\n  { image1 :: Text,\n    image2 :: Maybe Text,\n    driverId :: Text\n  }\n  deriving stock (Show, Generic)\n\ndata ExtractAadhaarImageReq = ExtractAadhaarImageReq\n  { image1 :: Text,\n    image2 :: Maybe Text,\n    consent :: Text,\n    driverId :: Text\n  }\n\nnewtype ExtractedPanImageResp = ExtractedPanImageResp\n  { extractedPan :: Maybe Idfy.PanExtractionOutput\n  }\n  deriving stock (Show, Generic)\n\nnewtype ExtractAadhaarImageRes = ExtractAadhaarImageRes\n  { extractedAadhaar :: Maybe Idfy.AadhaarResult\n  }\n\nnewtype ExtractedGSTImageResp = ExtractedGSTImageResp\n  { extractedGST :: Maybe Idfy.GSTExtractionOutput\n  }\n  deriving stock (Show, Generic)\n\nnewtype ExtractRCImageResp = ExtractRCImageResp\n  { extractedRC :: Maybe ExtractedRC\n  }\n  deriving stock (Show, Generic)\n\nnewtype ExtractedRC = ExtractedRC\n  { rcNumber :: Maybe Text\n  }\n  deriving stock (Show, Generic)\n\nnewtype ExtractDLImageResp = ExtractDLImageResp\n  { extractedDL :: Maybe ExtractedDL\n  }\n  deriving stock (Show, Generic)\n\ndata ExtractedDL = ExtractedDL\n  { dlNumber :: Maybe Text,\n    nameOnCard :: Maybe Text,\n    dateOfBirth :: Maybe Text\n  }\n  deriving stock (Show, Generic)\n\n-- not used in interface\n\ndata GetTaskReq = GetTaskReq\n  { workflowId :: Maybe Text,\n    requestId :: Text\n  }\n  deriving (Generic, FromJSON, ToJSON, Show)\n\ndata GetTaskResp = RCResp VT.RCVerificationResponse | DLResp DLVerificationOutputInterface\n  deriving (Generic, FromJSON, ToJSON, Show)\n\ndata DLVerificationOutputInterface = DLVerificationOutputInterface\n  { driverName :: Maybe Text,\n    dob :: Maybe Text,\n    licenseNumber :: Maybe Text,\n    nt_validity_from :: Maybe Text,\n    nt_validity_to :: Maybe Text,\n    t_validity_from :: Maybe Text,\n    t_validity_to :: Maybe Text,\n    covs :: Maybe [Idfy.CovDetail],\n    status :: Maybe Text,\n    dateOfIssue :: Maybe Text,\n    message :: Maybe Text\n  }\n  deriving (Show, FromJSON, ToJSON, Generic, ToSchema)\n\ndata SearchAgentReq = SearchAgentreq\n  { dl :: Maybe Text,\n    voterId :: Maybe Text\n  }\n  deriving (Generic, FromJSON, ToJSON, Show)\n\nnewtype SearchAgentResponse = SearchAgentResponse\n  { suspect :: [SearchAgent]\n  }\n  deriving (Generic, FromJSON, ToJSON, Show)\n\nnewtype VerifySdkDataReq = VerifySdkDataReq\n  { transactionId :: Text\n  }\n  deriving (Generic, FromJSON, ToJSON, Show)\n\ndata VerifySdkDataResp = VerifySdkDataResp\n  { userDetails :: Maybe HyperVergeTypes.UserDetails,\n    status :: Maybe Text,\n    transactionId :: Maybe Text\n  }\n  deriving (Generic, FromJSON, ToJSON, Show)\n\ndata RCRespWithRemPriorityList = RCRespWithRemPriorityList\n  { verifyRCResp :: VerifyRCResp,\n    remPriorityList :: [VT.VerificationService]\n  }\n  deriving (Show, Generic, FromJSON, ToJSON)\n",
      "hash": "f057823454ef7ff164e23426383065ae61bb783ad51f620fd0430d063077b16a",
      "size": 6422
    },
    "/lib/mobility-core/src/Kernel/External/Verification/InternalScripts/Error.hs": {
      "type": "content",
      "content": "{-\n Copyright 2022-23, Juspay India Pvt Ltd\n\n This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program\n\n is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n\n or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of\n\n the GNU Affero General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n{-# LANGUAGE DeriveAnyClass #-}\n{-# LANGUAGE TemplateHaskell #-}\n\nmodule Kernel.External.Verification.InternalScripts.Error where\n\nimport Kernel.Types.Error.BaseError\nimport Kernel.Types.Error.BaseError.HTTPError\nimport Kernel.Types.Error.BaseError.HTTPError.FromResponse (FromResponse (fromResponse))\nimport Network.HTTP.Types (Status (statusCode))\nimport Servant.Client (ResponseF (responseStatusCode))\nimport Prelude\n\ndata FaceVerificationError\n  = FakeFaceDetected\n  | FaceVerificationInternalServer\n  | PoorImageQuality\n  deriving (Eq, Show, IsBecknAPIError)\n\ninstanceExceptionWithParent 'HTTPException ''FaceVerificationError\n\ninstance FromResponse FaceVerificationError where\n  fromResponse resp = case statusCode $ responseStatusCode resp of\n    422 -> Just FakeFaceDetected\n    _ -> Just FaceVerificationInternalServer\n\ninstance IsBaseError FaceVerificationError where\n  toMessage = \\case\n    FakeFaceDetected -> Just \"Fake face detected. Please provide a valid image.\"\n    FaceVerificationInternalServer -> Just \"Could not verify face. Please try again.\"\n    PoorImageQuality -> Just \"Could not verify face due to poor image quality\"\n\ninstance IsHTTPError FaceVerificationError where\n  toErrorCode = \\case\n    FakeFaceDetected -> \"FAKE_FACE_DETECTED\"\n    FaceVerificationInternalServer -> \"INTERNAL_SERVER_ERROR\"\n    PoorImageQuality -> \"POOR_IMAGE_QUALITY\"\n\n  toHttpCode = \\case\n    FakeFaceDetected -> E422\n    FaceVerificationInternalServer -> E500\n    PoorImageQuality -> E422\n\ninstance IsAPIError FaceVerificationError\n",
      "hash": "7b6b77de7796e3c95cd6c0354ffc619056fc379ff7f6ad1528a79d4f56911107",
      "size": 2221
    },
    "/lib/mobility-core/src/Kernel/External/Verification/InternalScripts/FaceVerification.hs": {
      "type": "content",
      "content": "{-\n Copyright 2022-23, Juspay India Pvt Ltd\n\n This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program\n\n is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n\n or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of\n\n the GNU Affero General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n\nmodule Kernel.External.Verification.InternalScripts.FaceVerification where\n\nimport qualified Data.HashMap.Internal as HMap\nimport qualified Data.Text as DT\nimport EulerHS.Prelude\nimport EulerHS.Types (EulerClient, client)\nimport qualified EulerHS.Types as ET\nimport Kernel.External.Verification.InternalScripts.Error\nimport Kernel.External.Verification.InternalScripts.Types\nimport Kernel.Tools.Metrics.CoreMetrics (CoreMetrics)\nimport Kernel.Utils.Common\nimport qualified Network.HTTP.Client as Http\nimport Network.HTTP.Client.TLS as Http\nimport Servant (JSON, Post, ReqBody, type (:>))\n\ntype FaceValidationAPI =\n  \"upload\"\n    :> ReqBody '[JSON] FaceValidationReq\n    :> Post '[JSON] FaceValidationRes\n\nvalidateFace :: (CoreMetrics m, MonadFlow m) => BaseUrl -> FaceValidationReq -> m FaceValidationRes\nvalidateFace url req = callFaceVerificationApi url (translate req) \"upload\" faceValidationAPI\n\ntranslate :: FaceValidationReq -> EulerClient FaceValidationRes\ntranslate = client faceValidationAPI\n\nfaceValidationAPI :: Proxy FaceValidationAPI\nfaceValidationAPI = Proxy\n\nprepareInternalScriptsHttpManager :: Int -> HMap.HashMap DT.Text Http.ManagerSettings\nprepareInternalScriptsHttpManager timeout =\n  HMap.singleton (DT.pack internalScriptsManagerKey) $\n    Http.tlsManagerSettings {Http.managerResponseTimeout = Http.responseTimeoutMicro (timeout * 1000)}\n\ninternalScriptsManagerKey :: String\ninternalScriptsManagerKey = \"internal-scripts-http-manager\"\n\ncallFaceVerificationApi :: CallAPI env api res\ncallFaceVerificationApi = callApiUnwrappingApiError (identity @FaceVerificationError) (Just $ ET.ManagerSelector $ DT.pack internalScriptsManagerKey) (Just \"FACE_VERIFICATION_ERROR\") Nothing\n",
      "hash": "592e7278353e9da647ed701426a049354f4f4ec92575992b6e69d50ce40c70ef",
      "size": 2386
    },
    "/lib/mobility-core/src/Kernel/External/Verification/InternalScripts/Types.hs": {
      "type": "content",
      "content": "{-\n Copyright 2022-23, Juspay India Pvt Ltd\n\n This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program\n\n is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n\n or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of\n\n the GNU Affero General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n\nmodule Kernel.External.Verification.InternalScripts.Types where\n\nimport Data.Aeson\nimport EulerHS.Prelude\nimport Kernel.Prelude\n\nnewtype FaceVerificationCfg = FaceVerificationCfg\n  { url :: BaseUrl\n  }\n  deriving (Generic, ToJSON, FromJSON, Eq, Show)\n\ndata FaceType = REAL_FACE | FAKE_FACE | UNKNOWN\n  deriving (Generic, FromJSON, Show, ToJSON)\n\ndata FaceValidationReq = FaceValidationReq\n  { file :: Text,\n    brisqueFeatures :: [Double]\n  }\n  deriving (Generic, ToJSON)\n\ndata FaceValidationRes = FaceValidationRes\n  { faceType :: FaceType,\n    score :: Double,\n    predictionCost :: Double\n  }\n  deriving (Generic, FromJSON, Show, ToJSON)\n",
      "hash": "3f585dbc8e918ef0ee43616f844e24bf79321eeceaeebc2dd0a0f8bb684ac94e",
      "size": 1329
    },
    "/lib/mobility-core/src/Kernel/External/Verification/SafetyPortal/API.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n\nmodule Kernel.External.Verification.SafetyPortal.API where\n\nimport qualified EulerHS.Types as T\nimport qualified Kernel.External.Verification.SafetyPortal.Types as SafetyPortal\nimport Kernel.Prelude\nimport Servant (Header, JSON, Post, ReqBody, (:>))\n\ntype SearchAgentAPI =\n  \"partner\"\n    :> \"search\"\n    :> \"agent\"\n    :> Header \"token\" Text\n    :> ReqBody '[JSON] SafetyPortal.SearchAgentReq\n    :> Post '[JSON] SafetyPortal.SearchAgentResp\n\nsearchAgentAPI :: Proxy SearchAgentAPI\nsearchAgentAPI = Proxy\n\nsearchAgent ::\n  Maybe Text ->\n  SafetyPortal.SearchAgentReq ->\n  T.EulerClient SafetyPortal.SearchAgentResp\nsearchAgent = T.client searchAgentAPI\n",
      "hash": "29fca5ab90278fd2cf0d5a5e544ae5c5408db8092f61a601b9fd4277f3fb67b3",
      "size": 1348
    },
    "/lib/mobility-core/src/Kernel/External/Verification/SafetyPortal/Client.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n\nmodule Kernel.External.Verification.SafetyPortal.Client where\n\nimport qualified Data.Text as T\nimport qualified EulerHS.Types as ET\nimport Kernel.External.Verification.SafetyPortal.API as API\nimport Kernel.External.Verification.SafetyPortal.Config\nimport qualified Kernel.External.Verification.SafetyPortal.Error as SafetyPortal\nimport qualified Kernel.External.Verification.SafetyPortal.Types as SafetyPortal\nimport Kernel.Prelude\nimport Kernel.Tools.Metrics.CoreMetrics.Types\nimport Kernel.Types.Common\nimport Kernel.Utils.Common hiding (Error)\n\nsearchAgent ::\n  ( MonadFlow m,\n    CoreMetrics m\n  ) =>\n  BaseUrl ->\n  Text ->\n  SafetyPortal.SearchAgentReq ->\n  m SafetyPortal.SearchAgentResp\nsearchAgent url apiKey req = do\n  let client = API.searchAgent (Just apiKey) req\n  callSafetyPortalAPI url client \"searchAgent\" API.searchAgentAPI\n\ncallSafetyPortalAPI :: CallAPI env api res\ncallSafetyPortalAPI = callApiUnwrappingApiError (identity @SafetyPortal.SafetyPortalError) (Just $ ET.ManagerSelector $ T.pack safetyPortalHttpManagerKey) (Just \"SAFETY_PORTAL_ERROR\") Nothing\n",
      "hash": "16e7c79adb6be20608d49bf5cf5a7bec8c6cb4fe3722965a7c4a7b4abafa8d9e",
      "size": 1771
    },
    "/lib/mobility-core/src/Kernel/External/Verification/SafetyPortal/Config.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n{-# LANGUAGE DerivingStrategies #-}\n\nmodule Kernel.External.Verification.SafetyPortal.Config where\n\nimport qualified Data.HashMap.Internal as HMap\nimport qualified Data.Text as DT\nimport EulerHS.Prelude\nimport Kernel.External.Encryption\nimport Kernel.Prelude\nimport Network.HTTP.Client as Http\nimport Network.HTTP.Client.TLS as Http\n\ndata SafetyPortalCfg = SafetyPortalCfg\n  { token :: EncryptedField 'AsEncrypted Text,\n    url :: BaseUrl,\n    safetyWebhookAuthToken :: EncryptedField 'AsEncrypted Text\n  }\n  deriving stock (Show, Eq, Generic)\n  deriving anyclass (FromJSON, ToJSON)\n\nprepareSafetyPortalHttpManager :: Int -> HMap.HashMap DT.Text Http.ManagerSettings\nprepareSafetyPortalHttpManager timeout =\n  HMap.singleton (DT.pack safetyPortalHttpManagerKey) $\n    Http.tlsManagerSettings {Http.managerResponseTimeout = Http.responseTimeoutMicro (timeout * 1000)}\n\nsafetyPortalHttpManagerKey :: String\nsafetyPortalHttpManagerKey = \"safety-potal-http-manager\"\n",
      "hash": "587e3f027e6f2911c5888f6848d1aeb9793c71066351af2c7ca4734a40448fde",
      "size": 1655
    },
    "/lib/mobility-core/src/Kernel/External/Verification/SafetyPortal/Error.hs": {
      "type": "content",
      "content": "{-\n Copyright 2022-23, Juspay India Pvt Ltd\n\n This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program\n\n is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n\n or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of\n\n the GNU Affero General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n{-# LANGUAGE DeriveAnyClass #-}\n{-# LANGUAGE TemplateHaskell #-}\n\nmodule Kernel.External.Verification.SafetyPortal.Error where\n\nimport Kernel.Types.Error.BaseError\nimport Kernel.Types.Error.BaseError.HTTPError\nimport Kernel.Types.Error.BaseError.HTTPError.FromResponse (FromResponse (fromResponse))\nimport Network.HTTP.Types (Status (statusCode))\nimport Servant.Client (ResponseF (responseStatusCode))\nimport Prelude\n\ndata SafetyPortalError\n  = SafetyPortalBadRequest\n  deriving (Eq, Show, IsBecknAPIError)\n\ninstanceExceptionWithParent 'HTTPException ''SafetyPortalError\n\ninstance FromResponse SafetyPortalError where\n  fromResponse resp = case statusCode $ responseStatusCode resp of\n    400 -> Just SafetyPortalBadRequest\n    _ -> Nothing\n\ninstance IsBaseError SafetyPortalError where\n  toMessage = \\case\n    SafetyPortalBadRequest -> Just \"Bad request. Please check for the input.\"\n\ninstance IsHTTPError SafetyPortalError where\n  toErrorCode = \\case\n    SafetyPortalBadRequest -> \"BAD_REQUEST\"\n\n  toHttpCode = \\case\n    SafetyPortalBadRequest -> E400\n\ninstance IsAPIError SafetyPortalError\n",
      "hash": "2e7cd06b66dc4df88248e2cff86b366914e97a78395c374efd3881a707465d9b",
      "size": 1780
    },
    "/lib/mobility-core/src/Kernel/External/Verification/SafetyPortal/Types.hs": {
      "type": "content",
      "content": "{-\n Copyright 2022-23, Juspay India Pvt Ltd\n\n This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program\n\n is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n\n or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of\n\n the GNU Affero General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n{-# LANGUAGE DerivingStrategies #-}\n\nmodule Kernel.External.Verification.SafetyPortal.Types where\n\nimport Data.Aeson\nimport Data.Time (UTCTime)\nimport EulerHS.Prelude hiding (error, id, state)\n\nnewtype SearchAgentReq = SearchAgentReq\n  { suspectReqList :: [Agent]\n  }\n  deriving (Generic, FromJSON, ToJSON, Show)\n\ndata Agent = Agent\n  { dl :: Maybe Text,\n    voterId :: Maybe Text\n  }\n  deriving (Generic, FromJSON, ToJSON, Show)\n\ndata SearchAgentResp = SearchAgentResp\n  { suspects :: [SearchAgent],\n    summary :: Summary\n  }\n  deriving (Generic, FromJSON, ToJSON, Show)\n\ndata Summary = Summary\n  { totalCount :: Int,\n    count :: Int\n  }\n  deriving (Generic, FromJSON, ToJSON, Show)\n\ndata SearchAgent = SearchAgent\n  { createdAt :: UTCTime,\n    dl :: Maybe Text,\n    firstName :: Text,\n    flagUpdatedAt :: UTCTime,\n    flaggedBy :: Maybe [FlaggedBy],\n    flaggedCounter :: Int,\n    flaggedStatus :: FlaggedStatus,\n    id :: Text,\n    lastName :: Text,\n    statusChangedReason :: Maybe Text,\n    updatedAt :: UTCTime,\n    voterId :: Maybe Text\n  }\n  deriving (Generic, ToJSON, FromJSON, Show)\n\ndata FlaggedStatus = Flagged | Charged | Clean\n  deriving (Eq, Ord, Show, Read, Generic, ToJSON, FromJSON)\n\ndata FlaggedBy = FlaggedBy\n  { flaggedCategory :: Text,\n    partnerName :: Text\n  }\n  deriving (Generic, Show, ToJSON, FromJSON, Ord, Eq, Read)\n",
      "hash": "9938eb2680cab5f344f5595ba28baf7af5f29c5a14ff810f2226169febf71f7b",
      "size": 2036
    },
    "/lib/mobility-core/src/Kernel/External/Verification/Types.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n{-# LANGUAGE InstanceSigs #-}\n{-# LANGUAGE TemplateHaskell #-}\n\nmodule Kernel.External.Verification.Types\n  ( module Kernel.External.Verification.Types,\n  )\nwhere\n\nimport Data.Aeson as A\nimport Data.OpenApi\nimport qualified Data.Text as T\nimport EulerHS.Prelude\nimport Kernel.Beam.Lib.UtilsTH (mkBeamInstancesForEnumAndList)\nimport qualified Kernel.Prelude as KP\nimport Kernel.Storage.Esqueleto (derivePersistField)\n\ndata VerificationService = Idfy | InternalScripts | GovtData | HyperVerge | HyperVergeRCDL\n  deriving (Show, Read, Eq, Ord, Generic, ToJSON, FromJSON, ToSchema)\n\ndata DriverBackgroundVerificationService = SafetyPortal\n  deriving (Show, Read, Eq, Ord, Generic, ToJSON, ToSchema)\n\ninstance FromJSON DriverBackgroundVerificationService where -- remove this instance once you add more constructors to AadhaarVerificationService type.\n  parseJSON (A.String val) = maybe (fail (\"failed to parse String \" <> show val <> \" in DriverBackgroundVerificationService type\")) pure (KP.readMaybe $ T.unpack val)\n  parseJSON (A.Array _) = pure SafetyPortal\n  parseJSON e = fail $ \"unexpected type, expected String for AadhaarVerificationService\" <> show e\n\n$(mkBeamInstancesForEnumAndList ''VerificationService)\n$(mkBeamInstancesForEnumAndList ''DriverBackgroundVerificationService)\n\navailableVerificationServices :: [VerificationService]\navailableVerificationServices = [Idfy, InternalScripts]\n\navailableDriverBackgroundVerificationServices :: [DriverBackgroundVerificationService]\navailableDriverBackgroundVerificationServices = [SafetyPortal]\n\nderivePersistField \"VerificationService\"\nderivePersistField \"DriverBackgroundVerificationService\"\n\ndata RCVerificationResponse = RCVerificationResponse\n  { registrationDate :: Maybe Text,\n    registrationNumber :: Maybe Text,\n    fitnessUpto :: Maybe Text,\n    insuranceValidity :: Maybe Text,\n    vehicleClass :: Maybe Text,\n    vehicleCategory :: Maybe Text,\n    seatingCapacity :: Maybe A.Value,\n    manufacturer :: Maybe Text,\n    permitValidityFrom :: Maybe Text,\n    permitValidityUpto :: Maybe Text,\n    pucValidityUpto :: Maybe Text,\n    manufacturerModel :: Maybe Text,\n    mYManufacturing :: Maybe Text,\n    color :: Maybe Text,\n    fuelType :: Maybe Text,\n    bodyType :: Maybe Text,\n    status :: Maybe Text,\n    grossVehicleWeight :: Maybe Float,\n    unladdenWeight :: Maybe Float\n  }\n  deriving (Show, FromJSON, ToJSON, Generic, ToSchema)\n",
      "hash": "60370a1ef2e965d6cb0e13b0f51dc9d2d6e5db74745434b0bfcfa9518128bd70",
      "size": 3094
    },
    "/lib/mobility-core/src/Kernel/External/Whatsapp/GupShup/Config.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n\nmodule Kernel.External.Whatsapp.GupShup.Config where\n\nimport Kernel.External.Encryption\nimport Kernel.Prelude\nimport Kernel.Utils.JSON\n\ndata GupShupCfg = GupShupCfg\n  { userid :: EncryptedField 'AsEncrypted Text,\n    password :: EncryptedField 'AsEncrypted Text,\n    authScheme :: Text,\n    channel :: Text,\n    v :: Text,\n    url :: Text,\n    format :: Text,\n    otpCfg :: GupShupOTPCfg,\n    isTemplate :: Maybe Bool\n  }\n  deriving (Show, Eq, Generic)\n\ninstance FromJSON GupShupCfg where\n  parseJSON = genericParseJSON constructorsWithSnakeCase\n\ninstance ToJSON GupShupCfg where\n  toJSON = genericToJSON constructorsWithSnakeCase\n\ndata GupShupOTPCfg = GupShupOTPCfg\n  { msgType :: Text,\n    method :: Text,\n    templateId :: Text,\n    entityId :: Text\n  }\n  deriving (Show, Eq, Generic)\n\ninstance FromJSON GupShupOTPCfg where\n  parseJSON = genericParseJSON constructorsWithSnakeCase\n\ninstance ToJSON GupShupOTPCfg where\n  toJSON = genericToJSON constructorsWithSnakeCase\n",
      "hash": "0c38bb9cd36b75542f771d945107be83f0809be3bcf5702b89c7a73c5c9d3159",
      "size": 1666
    },
    "/lib/mobility-core/src/Kernel/External/Whatsapp/GupShup/Flow.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n\nmodule Kernel.External.Whatsapp.GupShup.Flow where\n\nimport qualified Data.Text as T\nimport EulerHS.Types (EulerClient, client)\nimport qualified Kernel.External.Whatsapp.Interface.Types as Whatsapp\nimport Kernel.Prelude\nimport Kernel.Tools.Metrics.CoreMetrics (CoreMetrics)\nimport Kernel.Types.Common\nimport Kernel.Types.Error\nimport Kernel.Utils.Common\nimport Servant hiding (throwError)\nimport Servant.Client.Core (ClientError)\n\ntype GupShupAPI =\n  GupShupOptAPI\n    :<|> GupShupSendOtpAPI\n    :<|> GupShupSendMessageWithTemplateIdAPI\n\ntype GupShupOptAPI =\n  MandatoryQueryParam \"userid\" Text\n    :> MandatoryQueryParam \"password\" Text\n    :> MandatoryQueryParam \"phone_number\" Text\n    :> MandatoryQueryParam \"method\" Text\n    :> MandatoryQueryParam \"auth_scheme\" Text\n    :> MandatoryQueryParam \"v\" Text\n    :> MandatoryQueryParam \"channel\" Text\n    :> MandatoryQueryParam \"format\" Text\n    :> Get '[JSON] Whatsapp.OptApiResp\n\ntype GupShupSendMessageWithTemplateIdAPI =\n  MandatoryQueryParam \"userid\" Text\n    :> MandatoryQueryParam \"password\" Text\n    :> MandatoryQueryParam \"send_to\" Text\n    :> MandatoryQueryParam \"method\" Text\n    :> MandatoryQueryParam \"auth_scheme\" Text\n    :> MandatoryQueryParam \"v\" Text\n    :> MandatoryQueryParam \"msg_type\" Text\n    :> MandatoryQueryParam \"format\" Text\n    :> QueryParam \"var1\" Text\n    :> QueryParam \"var2\" Text\n    :> QueryParam \"var3\" Text\n    :> QueryParam \"var4\" Text\n    :> QueryParam \"var5\" Text\n    :> QueryParam \"var6\" Text\n    :> QueryParam \"var7\" Text\n    :> QueryParam \"cta_button_url\" Text\n    :> QueryParam \"isTemplate\" Bool\n    :> MandatoryQueryParam \"template_id\" Text\n    :> Get '[JSON] Whatsapp.SendOtpApiResp\n\ntype GupShupSendOtpAPI =\n  MandatoryQueryParam \"userid\" Text\n    :> MandatoryQueryParam \"password\" Text\n    :> MandatoryQueryParam \"send_to\" Text\n    :> MandatoryQueryParam \"method\" Text\n    :> MandatoryQueryParam \"auth_scheme\" Text\n    :> MandatoryQueryParam \"v\" Text\n    :> MandatoryQueryParam \"msg_type\" Text\n    :> MandatoryQueryParam \"format\" Text\n    :> MandatoryQueryParam \"var1\" Text\n    :> MandatoryQueryParam \"template_id\" Text\n    :> QueryParam \"isTemplate\" Bool\n    :> Get '[JSON] Whatsapp.SendOtpApiResp\n\ngupShupOptAPIClient :: Text -> Text -> Text -> Text -> Text -> Text -> Text -> Text -> EulerClient Whatsapp.OptApiResp\ngupShupSendOtpAPIClient :: Text -> Text -> Text -> Text -> Text -> Text -> Text -> Text -> Text -> Text -> Maybe Bool -> EulerClient Whatsapp.SendOtpApiResp\ngupShupSendMessageWithTemplateIdAPIClient :: Text -> Text -> Text -> Text -> Text -> Text -> Text -> Text -> Maybe Text -> Maybe Text -> Maybe Text -> Maybe Text -> Maybe Text -> Maybe Text -> Maybe Text -> Maybe Text -> Maybe Bool -> Text -> EulerClient Whatsapp.SendOtpApiResp\ngupShupOptAPIClient :<|> gupShupSendOtpAPIClient :<|> gupShupSendMessageWithTemplateIdAPIClient = client (Proxy :: Proxy GupShupAPI)\n\nwhatsAppOptAPI ::\n  ( CoreMetrics m,\n    MonadFlow m\n  ) =>\n  BaseUrl ->\n  Text ->\n  Text ->\n  Text ->\n  Text ->\n  Text ->\n  Text ->\n  Text ->\n  Text ->\n  m Whatsapp.OptApiResp\nwhatsAppOptAPI url userid password phone_number method auth_scheme v channel format = do\n  callAPI url (gupShupOptAPIClient userid password phone_number method auth_scheme v channel format) \"GupShup Opt api\" (Proxy :: Proxy GupShupAPI)\n    >>= checkGupShupOptError url\n\ncheckGupShupOptError :: (MonadThrow m, Log m, HasField \"_response\" a Whatsapp.OptApiResponse) => BaseUrl -> Either ClientError a -> m a\ncheckGupShupOptError url res =\n  fromEitherM (gupShupOptError url) res >>= validateResponseStatus\n\ngupShupOptError :: BaseUrl -> ClientError -> ExternalAPICallError\ngupShupOptError = ExternalAPICallError (Just \"GUPSHUP_OPT_API_ERROR\")\n\nvalidateResponseStatus :: (MonadThrow m, Log m, HasField \"_response\" a Whatsapp.OptApiResponse) => a -> m a\nvalidateResponseStatus response = do\n  let resp = response._response\n  case T.toLower resp.status of\n    \"success\" -> pure response\n    _ -> do\n      case resp.id of\n        \"100\" -> throwError GupShupUnknownServerError\n        \"101\" -> throwError GupShupInvalidRequest\n        \"102\" -> throwError GupShupUnauthorized\n        \"103\" -> throwError GupShupUserIdNotFound\n        \"105\" -> throwError GupShupInvalidPhoneNumber\n        \"106\" -> throwError GupShupWrongMethodService\n        \"175\" -> throwError GupShupInterNationalPhoneNumber\n        \"322\" -> throwError GupShupTooManyRequests\n        _ -> throwError GupShupUnknownServerError\n\nwhatsAppSendOtpAPI ::\n  ( CoreMetrics m,\n    MonadFlow m\n  ) =>\n  BaseUrl ->\n  Text ->\n  Text ->\n  Text ->\n  Text ->\n  Text ->\n  Text ->\n  Text ->\n  Text ->\n  Text ->\n  Text ->\n  Maybe Bool ->\n  m Whatsapp.SendOtpApiResp\nwhatsAppSendOtpAPI url userid password sendTo method auth_scheme v msgType format var1 templateId isTemplate = do\n  callAPI url (gupShupSendOtpAPIClient userid password sendTo method auth_scheme v msgType format var1 templateId isTemplate) \"GupShup Otp api\" (Proxy :: Proxy GupShupAPI)\n    >>= checkGupShupOptError url\n\nwhatsAppSendMessageWithTemplateIdAPI ::\n  ( CoreMetrics m,\n    MonadFlow m\n  ) =>\n  BaseUrl ->\n  Text ->\n  Text ->\n  Text ->\n  Text ->\n  Text ->\n  Text ->\n  Text ->\n  Text ->\n  Maybe Text ->\n  Maybe Text ->\n  Maybe Text ->\n  Maybe Text ->\n  Maybe Text ->\n  Maybe Text ->\n  Maybe Text ->\n  Maybe Text ->\n  Maybe Bool ->\n  Text ->\n  m Whatsapp.SendWhatsAppMessageApiResp\nwhatsAppSendMessageWithTemplateIdAPI url userid password sendTo method auth_scheme v msgType format var1 var2 var3 var4 var5 var6 var7 ctaButtonUrl containsUrlButton templateId = do\n  callAPI url (gupShupSendMessageWithTemplateIdAPIClient userid password sendTo method auth_scheme v msgType format var1 var2 var3 var4 var5 var6 var7 ctaButtonUrl containsUrlButton templateId) \"GupShup WhatsApp Message with TemplateId API\" (Proxy :: Proxy GupShupAPI)\n    >>= checkGupShupOptError url\n",
      "hash": "03ce4790a5116c1fc3cda6f6d9c29b592977721a54360cb4c121fe4f42c13f8a",
      "size": 6537
    },
    "/lib/mobility-core/src/Kernel/External/Whatsapp/GupShup/Types.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n{-# LANGUAGE DerivingVia #-}\n{-# LANGUAGE StandaloneDeriving #-}\n{-# LANGUAGE TemplateHaskell #-}\n\nmodule Kernel.External.Whatsapp.GupShup.Types\n  ( module Kernel.External.Whatsapp.GupShup.Types,\n  )\nwhere\n\nimport Deriving.Aeson\nimport qualified Kernel.External.Whatsapp.Interface.Types as IT\nimport Kernel.Prelude\nimport Kernel.Utils.JSON\n\ndata OptApiReq = OptApiReq\n  { phoneNumber :: Text,\n    method :: IT.OptApiMethods\n  }\n  deriving (Generic, Show)\n\ninstance FromJSON OptApiReq where\n  parseJSON = genericParseJSON constructorsWithSnakeCase\n\ninstance ToJSON OptApiReq where\n  toJSON = genericToJSON constructorsWithSnakeCase\n\ndata SendOtpApiReq = SendOtpApiReq\n  { sendTo :: Text,\n    var1 :: Text\n  }\n  deriving (Generic, Eq, Show, ToSchema)\n\ninstance FromJSON SendOtpApiReq where\n  parseJSON = genericParseJSON constructorsWithSnakeCase\n\ninstance ToJSON SendOtpApiReq where\n  toJSON = genericToJSON constructorsWithSnakeCase\n\ntype SendOtpApiResp = OptApiResp\n\ntype SendWhatsAppMessageApiResp = OptApiResp\n\ndata SendWhatsAppMessageWithTemplateIdApIReq = SendWhatsAppMessageWithTemplateIdApIReq\n  { sendTo :: Text,\n    templateId :: Text,\n    var1 :: Maybe Text,\n    var2 :: Maybe Text,\n    var3 :: Maybe Text,\n    var4 :: Maybe Text,\n    var5 :: Maybe Text,\n    var6 :: Maybe Text,\n    var7 :: Maybe Text,\n    ctaButtonUrl :: Maybe Text,\n    containsUrlButton :: Maybe Bool\n  }\n  deriving (Generic, Eq, Show, ToSchema)\n\ninstance FromJSON SendWhatsAppMessageWithTemplateIdApIReq where\n  parseJSON = genericParseJSON constructorsWithSnakeCase\n\ninstance ToJSON SendWhatsAppMessageWithTemplateIdApIReq where\n  toJSON = genericToJSON constructorsWithSnakeCase\n\ndata OptApiResp = OptApiResp\n  { _response :: OptApiResponse,\n    _data :: Maybe OptApiRespData\n  }\n  deriving (Generic, Eq, Show, ToSchema)\n\ninstance FromJSON OptApiResp where\n  parseJSON = genericParseJSON stripPrefixUnderscoreIfAny\n\ninstance ToJSON OptApiResp where\n  toJSON = genericToJSON stripPrefixUnderscoreIfAny\n\nnewtype OptApiRespData = OptApiRespData\n  { responseMessages :: [OptApiResponse]\n  }\n  deriving (Generic, Eq, Show, ToSchema)\n\ninstance FromJSON OptApiRespData where\n  parseJSON = genericParseJSON constructorsWithSnakeCase\n\ninstance ToJSON OptApiRespData where\n  toJSON = genericToJSON constructorsWithSnakeCase\n\ndata OptApiResponse = OptApiResponse\n  { id :: Text,\n    phone :: Text,\n    details :: Text,\n    status :: Text\n  }\n  deriving (Generic, Eq, Show, ToSchema, FromJSON, ToJSON)\n",
      "hash": "ee1206289439ef1f723392b4a30f9ddad6b1f50e008299ee36087606a34f86e0",
      "size": 3166
    },
    "/lib/mobility-core/src/Kernel/External/Whatsapp/Interface.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n\nmodule Kernel.External.Whatsapp.Interface\n  ( module Reexport,\n    whatsAppOptApi,\n    whatsAppOtpApi,\n    whatsAppSendMessageWithTemplateIdAPI,\n  )\nwhere\n\nimport EulerHS.Prelude\nimport Kernel.External.Whatsapp.GupShup.Config as Reexport\nimport qualified Kernel.External.Whatsapp.Interface.GupShup as GupShup\nimport qualified Kernel.External.Whatsapp.Interface.TataCommunications as TataCommunications\nimport Kernel.External.Whatsapp.Interface.Types as Reexport\nimport Kernel.External.Whatsapp.TataCommunications.Config as Reexport\nimport Kernel.External.Whatsapp.Types as Reexport\nimport Kernel.Tools.Metrics.CoreMetrics (CoreMetrics)\nimport Kernel.Types.Common\nimport Kernel.Types.Error\nimport Kernel.Utils.Common\n\nwhatsAppOptApi :: (EncFlow m r, EsqDBFlow m r, CoreMetrics m) => WhatsappHandler m -> OptApiReq -> m (Maybe OptApiResp)\nwhatsAppOptApi WhatsappHandler {..} req = do\n  prividersPriorityList <- getProvidersPriorityList\n  when (null prividersPriorityList) $ throwError $ InternalError \"No whatsapp serive provider configured\"\n  callWithFallback prividersPriorityList\n  where\n    callWithFallback [] = throwError $ InternalError \"Not able to opt whatsapp with all the configured providers\"\n    callWithFallback (preferredProvider : restProviders) = do\n      whatsappConfig <- getProviderConfig preferredProvider\n      result <- try @_ @SomeException $ whatsAppOptApi' whatsappConfig req\n      case result of\n        Left _ -> callWithFallback restProviders\n        Right res -> pure res\n\nwhatsAppOptApi' ::\n  ( EncFlow m r,\n    CoreMetrics m\n  ) =>\n  WhatsappServiceConfig ->\n  OptApiReq ->\n  m (Maybe OptApiResp)\nwhatsAppOptApi' serviceConfig req = case serviceConfig of\n  GupShupConfig cfg -> do\n    res <- GupShup.whatsAppOptApi cfg req\n    pure $ Just res\n  TataCommunicationsConfig _ -> do\n    logDebug $ \"Skipping WhatsApp opt-in API call for Tata Communications as it is not required.\"\n    pure Nothing\n\nwhatsAppOtpApi :: (EncFlow m r, EsqDBFlow m r, CoreMetrics m) => WhatsappHandler m -> SendOtpApiReq -> m SendOtpApiResp\nwhatsAppOtpApi WhatsappHandler {..} req = do\n  prividersPriorityList <- getProvidersPriorityList\n  when (null prividersPriorityList) $ throwError $ InternalError \"No whatsapp serive provider configured\"\n  callWithFallback prividersPriorityList\n  where\n    callWithFallback [] = throwError $ InternalError \"Not able to opt whatsapp with all the configured providers\"\n    callWithFallback (preferredProvider : restProviders) = do\n      whatsappConfig <- getProviderConfig preferredProvider\n      result <- try @_ @SomeException $ whatsAppOtpApi' whatsappConfig req\n      case result of\n        Left _ -> callWithFallback restProviders\n        Right res -> pure res\n\nwhatsAppOtpApi' ::\n  ( EncFlow m r,\n    CoreMetrics m\n  ) =>\n  WhatsappServiceConfig ->\n  SendOtpApiReq ->\n  m SendOtpApiResp\nwhatsAppOtpApi' serviceConfig req = case serviceConfig of\n  GupShupConfig cfg -> GupShup.whatsAppOTPApi cfg req\n  TataCommunicationsConfig cfg -> TataCommunications.whatsAppOTPApi cfg req\n\nwhatsAppSendMessageWithTemplateIdAPI :: (EncFlow m r, EsqDBFlow m r, CoreMetrics m) => WhatsappHandler m -> SendWhatsAppMessageWithTemplateIdApIReq -> m SendOtpApiResp\nwhatsAppSendMessageWithTemplateIdAPI WhatsappHandler {..} req = do\n  logDebug $ \"whatsAppSendMessageWithTemplateIdAPI: \" <> show req\n  prividersPriorityList <- getProvidersPriorityList\n  when (null prividersPriorityList) $ throwError $ InternalError \"No whatsapp serive provider configured\"\n  callWithFallback prividersPriorityList\n  where\n    callWithFallback [] = throwError $ InternalError \"Not able to opt whatsapp with all the configured providers\"\n    callWithFallback (preferredProvider : restProviders) = do\n      whatsappConfig <- getProviderConfig preferredProvider\n      result <- try @_ @SomeException $ whatsAppSendMessageWithTemplateIdAPI' whatsappConfig req\n      case result of\n        Left err -> do\n          logError $ \"Error while sending whatsapp message with template id: \" <> show err\n          callWithFallback restProviders\n        Right res -> pure res\n\nwhatsAppSendMessageWithTemplateIdAPI' ::\n  ( EncFlow m r,\n    CoreMetrics m\n  ) =>\n  WhatsappServiceConfig ->\n  SendWhatsAppMessageWithTemplateIdApIReq ->\n  m SendOtpApiResp\nwhatsAppSendMessageWithTemplateIdAPI' serviceConfig req = case serviceConfig of\n  GupShupConfig cfg -> GupShup.whatsAppSendMessageWithTemplateIdAPI cfg req\n  TataCommunicationsConfig cfg -> TataCommunications.whatsAppSendMessageWithTemplateIdAPI cfg req\n",
      "hash": "2a4096afc28edb330235655f4a9408dc6c6e09aa6f76f48ffa547b0259b8d4d5",
      "size": 5193
    },
    "/lib/mobility-core/src/Kernel/External/Whatsapp/Interface/GupShup.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n\nmodule Kernel.External.Whatsapp.Interface.GupShup\n  ( module Reexport,\n    whatsAppOptApi,\n    whatsAppOTPApi,\n    whatsAppSendMessageWithTemplateIdAPI,\n  )\nwhere\n\nimport EulerHS.Prelude\nimport Kernel.External.Encryption\nimport Kernel.External.Whatsapp.GupShup.Config\nimport qualified Kernel.External.Whatsapp.GupShup.Flow as Ex\nimport Kernel.External.Whatsapp.Interface.Types as IT\nimport Kernel.External.Whatsapp.Types as Reexport\nimport Kernel.Prelude hiding (length, map)\nimport Kernel.Tools.Metrics.CoreMetrics (CoreMetrics)\nimport Kernel.Types.Common\nimport Kernel.Types.Error\nimport Kernel.Utils.Common\n\nwhatsAppOptApi ::\n  ( CoreMetrics m,\n    MonadFlow m,\n    EncFlow m r,\n    Log m\n  ) =>\n  GupShupCfg ->\n  IT.OptApiReq ->\n  m IT.OptApiResp\nwhatsAppOptApi GupShupCfg {..} OptApiReq {..} = do\n  userId <- decrypt userid\n  password' <- decrypt password\n  gupShupUrl <- parseBaseUrl url\n  Ex.whatsAppOptAPI gupShupUrl userId password' phoneNumber (show method) authScheme v channel format\n\nwhatsAppOTPApi ::\n  ( CoreMetrics m,\n    MonadFlow m,\n    EncFlow m r,\n    Log m\n  ) =>\n  GupShupCfg ->\n  IT.SendOtpApiReq ->\n  m IT.SendOtpApiResp\nwhatsAppOTPApi GupShupCfg {..} SendOtpApiReq {..} = do\n  userId <- decrypt userid\n  password' <- decrypt password\n  gupShupUrl <- parseBaseUrl url\n  Ex.whatsAppSendOtpAPI gupShupUrl userId password' sendTo otpCfg.method authScheme v otpCfg.msgType format var1 otpCfg.templateId isTemplate\n\nwhatsAppSendMessageWithTemplateIdAPI ::\n  ( CoreMetrics m,\n    MonadFlow m,\n    EncFlow m r,\n    Log m\n  ) =>\n  GupShupCfg ->\n  IT.SendWhatsAppMessageWithTemplateIdApIReq ->\n  m IT.SendWhatsAppMessageApiResp\nwhatsAppSendMessageWithTemplateIdAPI GupShupCfg {..} SendWhatsAppMessageWithTemplateIdApIReq {..} = do\n  userId <- decrypt userid\n  password' <- decrypt password\n  gupShupUrl <- parseBaseUrl url\n\n  when (length variables > 7) $\n    throwError (InvalidRequest \"Too many variables, maximum allowed is 7\")\n\n  let padded = variables ++ replicate (7 - min 7 (length variables)) Nothing\n  (var1, var2, var3, var4, var5, var6, var7) <- case padded of\n    [v1, v2, v3, v4, v5, v6, v7] -> pure (v1, v2, v3, v4, v5, v6, v7)\n    _ -> throwError (InvalidRequest \"Invalid request\")\n  Ex.whatsAppSendMessageWithTemplateIdAPI\n    gupShupUrl\n    userId\n    password'\n    sendTo\n    otpCfg.method authScheme v otpCfg.msgType\n    format\n    var1\n    var2\n    var3\n    var4\n    var5\n    var6\n    var7\n    ctaButtonUrl\n    containsUrlButton\n    templateId\n",
      "hash": "5b03beabae5119d2b7fd8af6cd31ffb225c59c2ffb720586098b749810baf50e",
      "size": 3173
    },
    "/lib/mobility-core/src/Kernel/External/Whatsapp/Interface/TataCommunications.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n\nmodule Kernel.External.Whatsapp.Interface.TataCommunications\n  ( whatsAppOTPApi,\n    whatsAppSendMessageWithTemplateIdAPI,\n  )\nwhere\n\nimport EulerHS.Prelude\nimport Kernel.External.Whatsapp.Interface.Types as IT\nimport Kernel.External.Whatsapp.TataCommunications.Config (TataCommunicationsCfg (..))\nimport Kernel.External.Whatsapp.TataCommunications.Flow as Flow\nimport qualified Kernel.External.Whatsapp.TataCommunications.Types as TC\nimport Kernel.Tools.Metrics.CoreMetrics (CoreMetrics)\nimport Kernel.Types.Common\n\nwhatsAppSendMessageWithTemplateIdAPI ::\n  ( CoreMetrics m,\n    MonadFlow m,\n    EncFlow m r\n  ) =>\n  TataCommunicationsCfg ->\n  IT.SendWhatsAppMessageWithTemplateIdApIReq ->\n  m SendOtpApiResp\nwhatsAppSendMessageWithTemplateIdAPI tataCommunicationsCfg req = do\n  let convertReq =\n        TC.WhatsAppMessageReq\n          { recipient = req.sendTo,\n            from = tataCommunicationsCfg.from,\n            type_ = tataCommunicationsCfg.type_,\n            template =\n              TC.Template\n                { name = tataCommunicationsCfg.template.name,\n                  language = TC.Language {code = tataCommunicationsCfg.template.language.code},\n                  components =\n                    [ TC.Component\n                        { type_ = \"body\",\n                          parameters = map (\\v -> TC.Parameter {type_ = \"text\", text = v}) req.variables\n                        }\n                    ]\n                }\n          }\n\n  res <- Flow.sendMessageApi tataCommunicationsCfg convertReq\n  return $ toOptApiResp req.sendTo res\n\nwhatsAppOTPApi ::\n  ( CoreMetrics m,\n    MonadFlow m,\n    EncFlow m r\n  ) =>\n  TataCommunicationsCfg ->\n  IT.SendOtpApiReq ->\n  m SendOtpApiResp\nwhatsAppOTPApi tataCommunicationsCfg req = do\n  let convertReq =\n        TC.WhatsAppMessageReq\n          { recipient = req.sendTo,\n            from = tataCommunicationsCfg.from,\n            type_ = tataCommunicationsCfg.type_,\n            template =\n              TC.Template\n                { name = tataCommunicationsCfg.template.name,\n                  language = TC.Language {code = tataCommunicationsCfg.template.language.code},\n                  components =\n                    [ TC.Component\n                        { type_ = \"body\",\n                          parameters = [TC.Parameter {type_ = \"text\", text = Just req.var1}]\n                        }\n                    ]\n                }\n          }\n\n  res <- Flow.sendMessageApi tataCommunicationsCfg convertReq\n  return $ toOptApiResp req.sendTo res\n\ntoOptApiResp :: Text -> TC.WhatsappSubmitRes -> IT.SendOtpApiResp\ntoOptApiResp phone (TC.WhatsappSuccess (TC.WhatsAppResponse wid)) =\n  let resp =\n        IT.OptApiResponse\n          { IT.id = wid,\n            IT.phone = phone,\n            IT.details = \"Success\",\n            IT.status = \"sent\"\n          }\n   in IT.OptApiResp\n        { IT._response = resp,\n          IT._data = Just $ IT.OptApiRespData [resp]\n        }\ntoOptApiResp phone (TC.WhatsAppError (TC.WhatsAppErrorResponse (TC.WhatsAppErrorDetails _code msg typ))) =\n  let resp =\n        IT.OptApiResponse\n          { IT.id = \"\",\n            IT.phone = phone,\n            IT.details = msg,\n            IT.status = typ\n          }\n   in IT.OptApiResp\n        { IT._response = resp,\n          IT._data = Nothing\n        }\n",
      "hash": "3aa22fd83ed1a3e311750cdcf7028dc7c58c5db67ac53989b55aa49596565591",
      "size": 3996
    },
    "/lib/mobility-core/src/Kernel/External/Whatsapp/Interface/Types.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n{-# LANGUAGE DerivingVia #-}\n{-# LANGUAGE StandaloneDeriving #-}\n{-# LANGUAGE TemplateHaskell #-}\n\nmodule Kernel.External.Whatsapp.Interface.Types\n  ( module Kernel.External.Whatsapp.Interface.Types,\n  )\nwhere\n\nimport Deriving.Aeson\nimport Kernel.Beam.Lib.UtilsTH (mkBeamInstancesForEnum)\nimport qualified Kernel.External.Whatsapp.GupShup.Config as GupShup\nimport qualified Kernel.External.Whatsapp.TataCommunications.Config as TataCommunications\nimport qualified Kernel.External.Whatsapp.Types as T\nimport Kernel.Prelude\nimport Kernel.Utils.JSON\n\ndata WhatsappServiceConfig = GupShupConfig GupShup.GupShupCfg | TataCommunicationsConfig TataCommunications.TataCommunicationsCfg\n  deriving stock (Show, Eq, Generic)\n  deriving (FromJSON, ToJSON) via CustomJSON '[SumTaggedObject \"tag\" \"content\"] WhatsappServiceConfig\n\ndata OptApiMethods = OPT_IN | OPT_OUT\n  deriving (Show, Eq, Read, Ord, Generic, ToSchema, FromJSON, ToJSON, Enum)\n\n$(mkBeamInstancesForEnum ''OptApiMethods)\n\ndata WhatsappHandler m = WhatsappHandler\n  { getProvidersPriorityList :: m [T.WhatsappService],\n    getProviderConfig :: T.WhatsappService -> m WhatsappServiceConfig\n  }\n\ndata OptApiReq = OptApiReq\n  { phoneNumber :: Text,\n    method :: OptApiMethods\n  }\n  deriving (Generic, Show)\n\ninstance FromJSON OptApiReq where\n  parseJSON = genericParseJSON constructorsWithSnakeCase\n\ninstance ToJSON OptApiReq where\n  toJSON = genericToJSON constructorsWithSnakeCase\n\ndata SendOtpApiReq = SendOtpApiReq\n  { sendTo :: Text,\n    var1 :: Text\n  }\n  deriving (Generic, Eq, Show, ToSchema)\n\ninstance FromJSON SendOtpApiReq where\n  parseJSON = genericParseJSON constructorsWithSnakeCase\n\ninstance ToJSON SendOtpApiReq where\n  toJSON = genericToJSON constructorsWithSnakeCase\n\ntype SendOtpApiResp = OptApiResp\n\ntype SendWhatsAppMessageApiResp = OptApiResp\n\ndata SendWhatsAppMessageWithTemplateIdApIReq = SendWhatsAppMessageWithTemplateIdApIReq\n  { sendTo :: Text,\n    templateId :: Text,\n    variables :: [Maybe Text],\n    ctaButtonUrl :: Maybe Text,\n    containsUrlButton :: Maybe Bool\n  }\n  deriving (Generic, Eq, Show, ToSchema)\n\ninstance FromJSON SendWhatsAppMessageWithTemplateIdApIReq where\n  parseJSON = genericParseJSON constructorsWithSnakeCase\n\ninstance ToJSON SendWhatsAppMessageWithTemplateIdApIReq where\n  toJSON = genericToJSON constructorsWithSnakeCase\n\ndata OptApiResp = OptApiResp\n  { _response :: OptApiResponse,\n    _data :: Maybe OptApiRespData\n  }\n  deriving (Generic, Eq, Show, ToSchema)\n\ninstance FromJSON OptApiResp where\n  parseJSON = genericParseJSON stripPrefixUnderscoreIfAny\n\ninstance ToJSON OptApiResp where\n  toJSON = genericToJSON stripPrefixUnderscoreIfAny\n\nnewtype OptApiRespData = OptApiRespData\n  { responseMessages :: [OptApiResponse]\n  }\n  deriving (Generic, Eq, Show, ToSchema)\n\ninstance FromJSON OptApiRespData where\n  parseJSON = genericParseJSON constructorsWithSnakeCase\n\ninstance ToJSON OptApiRespData where\n  toJSON = genericToJSON constructorsWithSnakeCase\n\ndata OptApiResponse = OptApiResponse\n  { id :: Text,\n    phone :: Text,\n    details :: Text,\n    status :: Text\n  }\n  deriving (Generic, Eq, Show, ToSchema, FromJSON, ToJSON)\n",
      "hash": "05a5173650056180a528d9cf8c389a36cfec2c48a7b73cdde592dc43262edef9",
      "size": 3832
    },
    "/lib/mobility-core/src/Kernel/External/Whatsapp/TataCommunications/Config.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n\nmodule Kernel.External.Whatsapp.TataCommunications.Config where\n\nimport Data.Aeson (object, withObject, (.:), (.=))\nimport Kernel.External.Encryption\nimport Kernel.Prelude\n\n-- Language sub-structure for templates\ndata Language = Language\n  { code :: Text\n  }\n  deriving (Show, Eq, Generic, ToJSON, FromJSON)\n\n-- Template structure containing name and language\ndata Template = Template\n  { name :: Text,\n    language :: Language\n  }\n  deriving (Show, Eq, Generic, ToJSON, FromJSON)\n\n-- Main config structure\ndata TataCommunicationsCfg = TataCommunicationsCfg\n  { apiToken :: EncryptedField 'AsEncrypted Text,\n    url :: BaseUrl,\n    from :: Text,\n    type_ :: Text,\n    template :: Template\n  }\n  deriving (Show, Eq, Generic)\n\n-- Manual JSON decoding with custom field name mapping\ninstance FromJSON TataCommunicationsCfg where\n  parseJSON = withObject \"TataCommunicationsCfg\" $ \\v ->\n    TataCommunicationsCfg\n      <$> v .: \"apiToken\"\n      <*> v .: \"url\"\n      <*> v .: \"from\"\n      <*> v .: \"type\"\n      <*> v .: \"template\"\n\n-- Manual JSON encoding with custom field name mapping\ninstance ToJSON TataCommunicationsCfg where\n  toJSON TataCommunicationsCfg {..} =\n    object\n      [ \"apiToken\" .= apiToken,\n        \"url\" .= url,\n        \"from\" .= from,\n        \"type\" .= type_,\n        \"template\" .= template\n      ]\n",
      "hash": "cd1600b846666914a95ddbf8465aba6091d47e80d6b6a4836d56a11b71d478ba",
      "size": 2012
    },
    "/lib/mobility-core/src/Kernel/External/Whatsapp/TataCommunications/Flow.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n\nmodule Kernel.External.Whatsapp.TataCommunications.Flow where\n\nimport EulerHS.Prelude\nimport EulerHS.Types as ET\nimport Kernel.External.Encryption (decrypt)\nimport Kernel.External.Whatsapp.TataCommunications.Config\nimport Kernel.External.Whatsapp.TataCommunications.Types\nimport Kernel.Tools.Metrics.CoreMetrics (CoreMetrics)\nimport Kernel.Types.Common\nimport Kernel.Types.Error\nimport Kernel.Utils.Common as B\nimport Servant hiding (throwError)\nimport Servant.Client\n\ntype TataCommunicationsWhatsappAPI =\n  \"v1\" :> \"whatsapp\"\n    :> \"messages\"\n    :> Header \"Authorization\" Text\n    :> ReqBody '[JSON] WhatsAppMessageReq\n    :> Post '[JSON] WhatsappSubmitRes\n\nsendMessageApi ::\n  ( CoreMetrics m,\n    MonadFlow m,\n    EncFlow m r\n  ) =>\n  TataCommunicationsCfg ->\n  WhatsAppMessageReq ->\n  m WhatsappSubmitRes\nsendMessageApi tataCommunicationsCfg req = do\n  apiKey_ <- decrypt tataCommunicationsCfg.apiToken\n  let authHeader = Just apiKey_\n  let eulerClient = ET.client (Proxy @TataCommunicationsWhatsappAPI)\n  res <-\n    callAPI\n      tataCommunicationsCfg.url\n      (eulerClient authHeader req)\n      \"sendMessageApi\"\n      (Proxy @TataCommunicationsWhatsappAPI)\n      >>= checkTataCommunicationsWhatsappError tataCommunicationsCfg.url\n  logDebug $ \"TataCommunicationsWhatsappAPI response: \" <> show res\n  return res\n\ncheckTataCommunicationsWhatsappError :: (MonadThrow m, B.Log m) => BaseUrl -> Either ClientError WhatsappSubmitRes -> m WhatsappSubmitRes\ncheckTataCommunicationsWhatsappError url res =\n  fromEitherM (tataCommunicationsWhatsappError url) res >>= validateResponseStatus\n\nvalidateResponseStatus :: (MonadThrow m, B.Log m) => WhatsappSubmitRes -> m WhatsappSubmitRes\nvalidateResponseStatus (WhatsappSuccess res) = pure (WhatsappSuccess res)\nvalidateResponseStatus (WhatsAppError errResponse) =\n  let err = errDetails errResponse\n   in case err.code of\n        400 -> do\n          logDebug $ \"Tata WhatsApp API Validation Error: \" <> err.message\n          throwError TataCommunicationsWhatsappInvalidRequest\n        401 -> do\n          logDebug $ \"Tata WhatsApp API Authentication Error: \" <> err.message\n          throwError TataCommunicationsWhatsappUnauthorized\n        403 -> do\n          logDebug $ \"Tata WhatsApp API Permission Denied: \" <> err.message\n          throwError TataCommunicationsWhatsapPermissionDenied\n        404 -> do\n          logDebug $ \"Tata WhatsApp API User Not Found: \" <> err.message\n          throwError TataCommunicationsWhatsappUserIdNotFound\n        429 -> do\n          logDebug $ \"Tata WhatsApp API Too Many Requests: \" <> err.message\n          throwError TataCommunicationsWhatsappTooManyRequests\n        500 -> do\n          logDebug $ \"Tata WhatsApp API Internal Server Error: \" <> err.message\n          throwError TataCommunicationsWhatsappUnknownServerError\n        503 -> do\n          logDebug $ \"Tata WhatsApp API Temporary downtime or overload: \" <> err.message\n          throwError TataCommunicationsWhatsapServiceUnavailable\n        _ -> do\n          logDebug $ \"Tata WhatsApp API Unknown Error: \" <> err.message\n          throwError $ TataCommunicationsWhatsappGenericError err.message\n\ntataCommunicationsWhatsappError :: BaseUrl -> ClientError -> ExternalAPICallError\ntataCommunicationsWhatsappError = ExternalAPICallError (Just \"TataCommunicationsWhatsapp_API_Error\")\n",
      "hash": "3bd23b78ebdf7afa23d3b86f461c2d06aac5c9a370bc65b4adb663d7bc7ca548",
      "size": 4024
    },
    "/lib/mobility-core/src/Kernel/External/Whatsapp/TataCommunications/Types.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n\nmodule Kernel.External.Whatsapp.TataCommunications.Types where\n\nimport Control.Applicative ((<|>))\nimport Data.Aeson\nimport GHC.Generics hiding (from, to)\nimport Kernel.Prelude hiding (error)\n\n-- Top-level request type\ndata WhatsAppMessageReq = WhatsAppMessageReq\n  { recipient :: Text,\n    from :: Text,\n    type_ :: Text,\n    template :: Template\n  }\n  deriving (Show, Generic)\n\ninstance ToJSON WhatsAppMessageReq where\n  toJSON = genericToJSON defaultOptions {fieldLabelModifier = renameFields}\n\ninstance FromJSON WhatsAppMessageReq where\n  parseJSON = genericParseJSON defaultOptions {fieldLabelModifier = renameFields}\n\n-- Template structure\ndata Template = Template\n  { name :: Text,\n    language :: Language,\n    components :: [Component]\n  }\n  deriving (Show, Generic)\n\ninstance ToJSON Template\n\ninstance FromJSON Template\n\n-- Language structure\ndata Language = Language\n  { code :: Text\n  }\n  deriving (Show, Generic)\n\ninstance ToJSON Language\n\ninstance FromJSON Language\n\n-- Components structure\ndata Component = Component\n  { type_ :: Text,\n    parameters :: [Parameter]\n  }\n  deriving (Show, Generic)\n\ninstance ToJSON Component where\n  toJSON = genericToJSON defaultOptions {fieldLabelModifier = renameFields}\n\ninstance FromJSON Component where\n  parseJSON = genericParseJSON defaultOptions {fieldLabelModifier = renameFields}\n\n-- Parameters structure\ndata Parameter = Parameter\n  { type_ :: Text,\n    text :: Maybe Text\n  }\n  deriving (Show, Generic)\n\ninstance ToJSON Parameter where\n  toJSON = genericToJSON defaultOptions {fieldLabelModifier = renameFields}\n\ninstance FromJSON Parameter where\n  parseJSON = genericParseJSON defaultOptions {fieldLabelModifier = renameFields}\n\ndata WhatsappSubmitRes\n  = WhatsappSuccess WhatsAppResponse\n  | WhatsAppError WhatsAppErrorResponse\n  deriving (Show, Generic)\n\ninstance FromJSON WhatsappSubmitRes where\n  parseJSON v =\n    (WhatsappSuccess <$> parseJSON v) <|> (WhatsAppError <$> parseJSON v)\n\ninstance ToJSON WhatsappSubmitRes where\n  toJSON (WhatsappSuccess res) = toJSON res\n  toJSON (WhatsAppError err) = toJSON err\n\ndata WhatsAppResponse = WhatsAppResponse\n  { id :: Text\n  }\n  deriving (Show, Generic)\n\ninstance ToJSON WhatsAppResponse\n\ninstance FromJSON WhatsAppResponse\n\ndata WhatsAppErrorResponse = WhatsAppErrorResponse\n  { errDetails :: WhatsAppErrorDetails\n  }\n  deriving (Show, Generic)\n\ninstance ToJSON WhatsAppErrorResponse where\n  toJSON = genericToJSON defaultOptions {fieldLabelModifier = renameFields}\n\ninstance FromJSON WhatsAppErrorResponse where\n  parseJSON = genericParseJSON defaultOptions {fieldLabelModifier = renameFields}\n\ndata WhatsAppErrorDetails = WhatsAppErrorDetails\n  { code :: Int,\n    message :: Text,\n    type_ :: Text\n  }\n  deriving (Show, Generic)\n\ninstance ToJSON WhatsAppErrorDetails where\n  toJSON = genericToJSON defaultOptions {fieldLabelModifier = renameFields}\n\ninstance FromJSON WhatsAppErrorDetails where\n  parseJSON = genericParseJSON defaultOptions {fieldLabelModifier = renameFields}\n\n-- Helper function to rename fields\nrenameFields :: String -> String\nrenameFields \"recipient\" = \"to\"\nrenameFields \"errDetails\" = \"error\"\nrenameFields \"type_\" = \"type\"\nrenameFields other = other\n",
      "hash": "10144de079851f176ebfdb1a83c3bf7794f84fc428bb8d76b14ef47e899a8daf",
      "size": 3882
    },
    "/lib/mobility-core/src/Kernel/External/Whatsapp/Types.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n{-# LANGUAGE InstanceSigs #-}\n{-# LANGUAGE TemplateHaskell #-}\n\nmodule Kernel.External.Whatsapp.Types\n  ( module Kernel.External.Whatsapp.Types,\n  )\nwhere\n\nimport Data.Aeson as A\nimport Data.OpenApi\nimport qualified Data.Text as T\nimport Database.Beam.Backend\nimport EulerHS.Prelude\nimport Kernel.Beam.Lib.UtilsTH (mkBeamInstancesForList)\nimport qualified Kernel.Prelude as KP\nimport Kernel.Storage.Esqueleto (derivePersistField)\n\ndata WhatsappService = GupShup | TataCommunications\n  deriving (Show, Read, Eq, Ord, Generic, ToSchema)\n\ninstance HasSqlValueSyntax be String => HasSqlValueSyntax be WhatsappService where\n  sqlValueSyntax = autoSqlValueSyntax\n\ninstance FromJSON WhatsappService where -- remove this instance once you add more constructors to WhatsappService type.\n  parseJSON (A.String val) = maybe (fail (\"failed to parse String \" <> show val <> \" in WhatsappService type\")) pure (KP.readMaybe $ T.unpack val)\n  parseJSON (A.Array _) = pure GupShup\n  parseJSON e = fail $ \"unexpected type, expected String for WhatsappService \" <> show e\n\ninstance ToJSON WhatsappService where\n  toJSON GupShup = A.String (show GupShup)\n  toJSON TataCommunications = A.String (show TataCommunications)\n\navailableWhatsappServices :: [WhatsappService]\navailableWhatsappServices = [GupShup, TataCommunications]\n\n$(mkBeamInstancesForList ''WhatsappService)\n\nderivePersistField \"WhatsappService\"\n",
      "hash": "8ad181bb43780ad9adf6c4aa73cce8463d3280e33866de2ff54826b443621b74",
      "size": 2082
    },
    "/lib/mobility-core/src/Kernel/InternalAPI/Auth/API.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n\nmodule Kernel.InternalAPI.Auth.API where\n\nimport Kernel.Prelude\nimport Servant\n\ntype API =\n  \"internal\"\n    :> \"auth\"\n    :> Capture \"token\" Token\n    :> Get '[JSON] PersonId\n\ntype Token = Text\n\ntype PersonId = Text\n",
      "hash": "44290fb57ae1ba086296c576157fc9cef6813c0b7e57dac59754cc59b05beef4",
      "size": 910
    },
    "/lib/mobility-core/src/Kernel/InternalAPI/Auth/Client.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n{-# OPTIONS_GHC -Wno-incomplete-patterns #-}\n\nmodule Kernel.InternalAPI.Auth.Client where\n\nimport qualified EulerHS.Types as E\nimport Kernel.InternalAPI.Auth.API\nimport Kernel.Prelude\nimport Kernel.Tools.Metrics.CoreMetrics (CoreMetrics)\nimport Kernel.Types.Common\nimport Kernel.Types.Error\nimport Kernel.Utils.Error.BaseError.HTTPError.APIError\nimport Kernel.Utils.Error.Throwing\n\nauthAPI :: Text -> E.EulerClient PersonId\nauthAPI = E.client (Proxy @API)\n\nauth ::\n  ( HasField \"authServiceUrl\" r BaseUrl,\n    CoreMetrics m,\n    MonadFlow m,\n    MonadReader r m\n  ) =>\n  Text ->\n  m PersonId\nauth token = do\n  url <- asks (.authServiceUrl)\n  callOwnAPI Nothing (Just \"AUTH_FAILED\") Nothing url (authAPI token) \"auth\" (Proxy @API)\n    `catchOwnAPI` throwError . \\case\n      \"INVALID_TOKEN\" -> InvalidToken token\n      \"TOKEN_IS_NOT_VERIFIED\" -> TokenIsNotVerified\n      \"TOKEN_EXPIRED\" -> TokenExpired\n",
      "hash": "7582826dcbe3f5602016685251e6bde76784ee68882fd00864c54cf5912128de",
      "size": 1594
    },
    "/lib/mobility-core/src/Kernel/Mock/App.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n{-# LANGUAGE DerivingStrategies #-}\n{-# LANGUAGE GeneralizedNewtypeDeriving #-}\n{-# LANGUAGE TypeApplications #-}\n\nmodule Kernel.Mock.App where\n\nimport qualified Control.Concurrent.MVar as M\nimport qualified Control.Monad.Catch as C\nimport Control.Monad.IO.Unlift\nimport qualified EulerHS.Types as ET\nimport Kernel.Tools.Metrics.CoreMetrics\nimport Kernel.Types.Common\nimport Kernel.Utils.IOLogging\nimport Servant\nimport Universum\nimport UnliftIO.Concurrent\n\ntype HealthCheckAPI = Get '[JSON] Text\n\nhealthCheckServer :: MockM e Text\nhealthCheckServer = do\n  pure \"Mock is up!\"\n\nrun :: forall e api. HasServer api '[] => Proxy (api :: Type) -> ServerT api (MockM e) -> e -> Application\nrun _ server env = serve proxyApi $ hoistServer proxyApi f (healthCheckServer :<|> server)\n  where\n    proxyApi = Proxy @(HealthCheckAPI :<|> api)\n    f :: MockM e a -> Handler a\n    f action = do\n      eithRes <- liftIO . C.try $ runReaderT (runMockM action) env\n      case eithRes of\n        Left err ->\n          liftIO $ print @String (\"exception thrown: \" <> show err) *> throwError err\n        Right res -> pure res\n\nnewtype MockM e a = MockM {runMockM :: ReaderT e IO a}\n  deriving newtype (Functor, Applicative, Monad, MonadReader e, MonadIO, MonadUnliftIO, C.MonadThrow, C.MonadCatch, C.MonadMask)\n\nrunMock :: e -> MockM e a -> IO a\nrunMock env action = runReaderT (runMockM action) env\n\ninstance CoreMetrics (MockM e) where\n  addRequestLatency _ _ _ _ = return ()\n  addDatastoreLatency _ _ _ = return ()\n  incrementErrorCounter _ _ = return ()\n  addUrlCallRetries _ _ = return ()\n  addUrlCallRetryFailures _ = return ()\n  incrementSortedSetCounter _ = return ()\n  incrementStreamCounter _ = return ()\n  addGenericLatency _ _ = return ()\n  incrementSchedulerFailureCounter _ = return ()\n  incrementGenericMetrics _ = return ()\n  incrementSystemConfigsFailedCounter _ = return ()\n  addGenericLatencyMetrics _ _ = return ()\n\ninstance MonadTime (MockM e) where\n  getCurrentTime = liftIO getCurrentTime\n\ninstance MonadClock (MockM e) where\n  getClockTime = liftIO getClockTime\n\ninstance (HasLog e) => Log (MockM e) where\n  logOutput = logOutputImplementation\n  withLogTag = withLogTagImplementation\n\ninstance (HasLog e) => Forkable (MockM e) where\n  fork = mockFork\n  forkMultiple tagAndFunction = forM_ tagAndFunction $ \\(tag, f) -> mockFork tag f -- it works with multiple threads unlike forkMultiple @(FlowR r), which creates only one thread\n  awaitableFork = mockAwaitableFork\n\ninstance MonadGuid (MockM e) where\n  generateGUIDText = liftIO generateGUIDTextIO\n\nmockFork :: (HasLog e) => Text -> MockM e a -> MockM e ()\nmockFork tag action = void $\n  withLogTag tag $\n    forkFinally action $ \\case\n      Left se -> logOutput ERROR $ show se\n      Right _ -> pure ()\n\nmockAwaitableFork :: (HasLog e) => Text -> MockM e a -> MockM e (ET.Awaitable (Either Text a))\nmockAwaitableFork tag action = do\n  awaitableMVar <- liftIO M.newEmptyMVar\n  void . withLogTag tag $\n    forkFinally action $ \\case\n      Left se -> do\n        logOutput ERROR $ show se\n        liftIO $ M.putMVar awaitableMVar $ Left $ show se\n      Right res -> do\n        liftIO $ M.putMVar awaitableMVar $ Right res\n  pure $ ET.Awaitable awaitableMVar\n",
      "hash": "f0769ccdfe3bf46c6b518d583b23c52e6f07cfd053ca10f1912605c79894ea58",
      "size": 3903
    },
    "/lib/mobility-core/src/Kernel/Mock/Exceptions.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n{-# LANGUAGE TemplateHaskell #-}\n\nmodule Kernel.Mock.Exceptions where\n\nimport Kernel.Prelude\nimport Kernel.Types.Error.BaseError\nimport Kernel.Types.Error.BaseError.HTTPError\n\nnewtype OrderError = OrderNotFound Text\n  deriving (Show, IsBecknAPIError, Typeable)\n\ninstanceExceptionWithParent 'HTTPException ''OrderError\n\ninstance IsBaseError OrderError where\n  toMessage = \\case\n    OrderNotFound orderId -> Just $ \"Order not found:\" <> show orderId\n\ninstance IsHTTPError OrderError where\n  toErrorCode = \\case\n    OrderNotFound _ -> \"ORDER_NOT_FOUND\"\n  toHttpCode _ = E500\n\ninstance IsAPIError OrderError\n",
      "hash": "61df9b2a3914b2f5b87c0912dab08a26f94034c3b5e20dd6ecc6d55b18067bc2",
      "size": 1297
    },
    "/lib/mobility-core/src/Kernel/Mock/ExternalAPI.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n{-# LANGUAGE AllowAmbiguousTypes #-}\n{-# LANGUAGE TypeApplications #-}\n\nmodule Kernel.Mock.ExternalAPI where\n\nimport Control.Monad\nimport qualified Control.Monad.Catch as C\nimport qualified Data.CaseInsensitive as CI\nimport Data.String.Conversions\nimport Data.Time.Clock.POSIX (getPOSIXTime)\nimport Fmt\nimport GHC.Records.Extra\nimport Kernel.Mock.App\nimport Kernel.Prelude (lookup)\nimport Kernel.Types.Beckn.ReqTypes\nimport Kernel.Types.Common\nimport Kernel.Types.Error (GenericError (InternalError))\nimport Kernel.Utils.IOLogging\nimport Kernel.Utils.Servant.SignatureAuth (AuthenticatingEntity (getSignatureExpiry, getSigningKey))\nimport qualified Kernel.Utils.SignatureAuth as HttpSig\nimport Network.HTTP.Client hiding (Proxy)\nimport qualified Network.HTTP.Client as Http\nimport qualified Network.HTTP.Client.TLS as Http\nimport Servant.Client\nimport Universum\n\ncallBapAPI ::\n  forall api a b e.\n  ( Show a,\n    HasField \"selfId\" e Text,\n    HasField \"uniqueKeyId\" e Text,\n    HasClient ClientM api,\n    Client ClientM api ~ (BecknCallbackReq a -> ClientM b),\n    HasLog e,\n    HasField \"authManager\" e Manager\n  ) =>\n  BecknCallbackReq a ->\n  MockM e ()\ncallBapAPI req = do\n  let bapUrl = req.context.bap_uri\n  logOutput INFO \"calling BAP\"\n  callAPI @api bapUrl req\n\ncallAPI ::\n  forall api a b e.\n  ( Show a,\n    HasField \"selfId\" e Text,\n    HasField \"uniqueKeyId\" e Text,\n    HasClient ClientM api,\n    Client ClientM api ~ (BecknCallbackReq a -> ClientM b),\n    HasLog e,\n    HasField \"authManager\" e Manager\n  ) =>\n  BaseUrl ->\n  BecknCallbackReq a ->\n  MockM e ()\ncallAPI url req = do\n  let clientFunc = client @api Proxy\n      clientAction = clientFunc req\n  logOutput INFO $ mconcat [\"calling \", show req.context.action, \"; url=\", show url]\n  logOutput DEBUG $ show req\n  _ <- callClientM url clientAction\n  pure ()\n\ncallClientM ::\n  ( HasField \"selfId\" e Text,\n    HasField \"uniqueKeyId\" e Text,\n    HasField \"authManager\" e Manager\n  ) =>\n  BaseUrl ->\n  ClientM a ->\n  MockM e a\ncallClientM url clientAction = do\n  manager <- asks (.authManager)\n  res <- liftIO $ runClientM clientAction $ mkClientEnv manager url\n  either C.throwM pure res\n\nprepareAuthManager ::\n  AuthenticatingEntity cfg =>\n  cfg ->\n  [Text] ->\n  Text ->\n  Text ->\n  (LogLevel -> Text -> IO ()) ->\n  Http.ManagerSettings\nprepareAuthManager appCfg signHeaders subscriberId uniqueKeyId logger =\n  Http.tlsManagerSettings {Http.managerModifyRequest = doSignature}\n  where\n    doSignature :: Request -> IO Request\n    doSignature req = do\n      now <- getPOSIXTime\n      let params = HttpSig.mkSignatureParams subscriberId uniqueKeyId now signatureExpiry HttpSig.Ed25519\n      let body = getBody $ Http.requestBody req\n      let bodyHash = HttpSig.becknSignatureHash body\n      let headers = Http.requestHeaders req\n      let signatureMsg = HttpSig.makeSignatureString params bodyHash headers\n      logger DEBUG $ \"Request body for signing: \" +|| body ||+ \"\"\n      logger DEBUG $ \"Signature Message: \" +|| signatureMsg ||+ \"\"\n      let mbRes = foldM (addSignature bodyHash params headers) req signHeaders\n      maybe (C.throwM $ InternalError $ \"Could not add signature: \" <> show params) pure mbRes\n    getBody (Http.RequestBodyLBS body) = cs body\n    getBody (Http.RequestBodyBS body) = body\n    getBody _ = \"<MISSING_BODY>\"\n    signPrivKey = getSigningKey appCfg\n    signatureExpiry = getSignatureExpiry appCfg\n\n    -- FIXME: we don't currently deal with Content-Length not being there (this is\n    -- filled later, so we might need to have some special handling)\n    addSignature bodyHash params headers req signHeader =\n      let ciHeader = CI.mk $ encodeUtf8 signHeader\n       in -- We check if the signHeader exists because `managerModifyRequest` might be\n          -- called multiple times, so we already added it once, let's skip right over\n          if isJust $ lookup ciHeader headers\n            then Just req\n            else do\n              signature <- HttpSig.sign signPrivKey params bodyHash headers\n              let headerVal = HttpSig.encode $ HttpSig.SignaturePayload signature params\n              Just $ req {Http.requestHeaders = (ciHeader, headerVal) : headers}\n",
      "hash": "02a76614e6659b63e4414b97bd7fbbf033ce233ecced1121db8b33709980d096",
      "size": 4859
    },
    "/lib/mobility-core/src/Kernel/Mock/Utils.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n\nmodule Kernel.Mock.Utils (module Kernel.Mock.Utils) where\n\nimport Data.Aeson hiding (Error)\nimport qualified Data.Aeson as Ae\nimport qualified Data.Aeson.Types as Ae\nimport qualified Data.ByteString as BS\nimport qualified Data.ByteString.Lazy as BSL\nimport Data.Text as Text\nimport Data.Text.Encoding as Text\nimport Kernel.Randomizer (getRandomInRange)\nimport Kernel.Types.Beckn.Error\nimport Universum\n\ntextToError :: Text -> Error\ntextToError desc =\n  Error\n    { _type = CORE_ERROR,\n      code = \"400\",\n      path = Nothing,\n      message = Just desc\n    }\n\ngenerateOrderId :: (MonadIO m) => m Text\ngenerateOrderId = show <$> getRandomInRange (1000000, 9999999 :: Int)\n\ndecodeJSON :: (FromJSON a) => BS.ByteString -> Maybe a\ndecodeJSON bs = Ae.decode (BSL.fromStrict bs) >>= Ae.parseMaybe parseJSON\n\ndecodeJSONText :: (FromJSON a) => Text.Text -> Maybe a\ndecodeJSONText = Ae.decode . BSL.fromStrict . Text.encodeUtf8\n",
      "hash": "978772b083eac9fe42dac9223ea5778413c8fe3f0beb2e2566ab52285651fa23",
      "size": 1613
    },
    "/lib/mobility-core/src/Kernel/Prelude.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n\nmodule Kernel.Prelude (module E, module Kernel.Prelude) where\n\nimport Control.Arrow as E\nimport qualified Control.Concurrent as Conc\nimport Control.Concurrent.STM.TMVar as E (TMVar)\nimport Control.Exception.Safe as E hiding (assert)\nimport Control.Monad.Reader as E\nimport Control.Monad.Trans.Maybe as E\nimport Data.Aeson as E (FromJSON (..), ToJSON (..), genericParseJSON, genericToJSON)\nimport Data.Bool as E (bool)\nimport Data.Fixed\nimport Data.Foldable as E\nimport Data.Function as E hiding (id)\nimport Data.Functor as E\nimport Data.Functor.Identity as E\nimport Data.Kind as E (Type)\nimport Data.List.NonEmpty as E (NonEmpty (..))\nimport Data.Maybe as E\nimport Data.OpenApi as E (ToParamSchema, ToSchema)\nimport Data.Proxy as E (Proxy (..))\nimport Data.String as E (IsString (..))\nimport Data.Text as E (Text)\nimport qualified Data.Text as T\nimport Data.Time as E (LocalTime, TimeOfDay)\nimport Data.Time.Clock (secondsToNominalDiffTime)\nimport Data.Time.Clock as E (NominalDiffTime, UTCTime)\nimport Data.Traversable as E\nimport GHC.Generics as E (Generic, Generic1)\nimport GHC.Int as E (Int64)\nimport GHC.Records.Compat as E\nimport GHC.Stack as E (HasCallStack)\nimport Kernel.Prelude.OrphanInstances ()\nimport Safe as E\nimport Servant.Client as E (BaseUrl (..))\nimport qualified Servant.Client as Servant\nimport Text.Read as E (readMaybe)\nimport Universum.Debug as E\nimport Universum.Print as E\nimport Universum.String.Conversion as E hiding (readMaybe)\nimport Prelude as E hiding (error, id, log, print, putStr, putStrLn, show, undefined)\n\nfoldWIndex :: (Integer -> acc -> a -> acc) -> acc -> [a] -> acc\nfoldWIndex f acc p = snd $ foldl' (\\(i, acc') c -> (i + 1, f i acc' c)) (0, acc) p\n\nidentity :: p -> p\nidentity a = a\n\neveryPossibleVariant :: (Enum a, Bounded a) => [a]\neveryPossibleVariant = [minBound .. maxBound]\n\nwhenJust :: Applicative m => Maybe a -> (a -> m ()) -> m ()\nwhenJust mg f = maybe (pure ()) f mg\n\nwhenM :: Monad m => m Bool -> m () -> m ()\nwhenM mb thing = do\n  b <- mb\n  when b thing\n\nunlessM :: Monad m => m Bool -> m () -> m ()\nunlessM mb = whenM (not <$> mb)\n\nshowBaseUrl :: BaseUrl -> Text\nshowBaseUrl = T.pack . Servant.showBaseUrl\n\nparseBaseUrl :: MonadThrow m => Text -> m BaseUrl\nparseBaseUrl = Servant.parseBaseUrl . T.unpack\n\nwhileM :: Monad m => m Bool -> m () -> m ()\nwhileM b f = whenM b $ f >> whileM b f\n\nthreadDelay :: MonadIO m => Int -> m ()\nthreadDelay = liftIO . Conc.threadDelay\n\nrightToMaybe :: Either e a -> Maybe a\nrightToMaybe = either (const Nothing) Just\n\nintToNominalDiffTime :: Int -> NominalDiffTime\nintToNominalDiffTime = secondsToNominalDiffTime . MkFixed . (* 1000000000000) . toInteger\n\n-- fixme: test this function\nroundToPowerOfTen :: RealFrac a => Int -> a -> a\nroundToPowerOfTen tenExp a = do\n  let f = 10 ^^ negate tenExp\n      lifted = a * f\n      eps = 1e-8\n      roundVia func = fromIntegral @Integer (func lifted) / f\n  if abs (abs (lifted - fromIntegral @Integer (floor lifted)) - 0.5) < eps\n    then if a >= 0 then roundVia ceiling else roundVia floor\n    else roundVia round\n\nroundToUnits :: (RealFrac a) => a -> a\nroundToUnits = roundToPowerOfTen 0\n\nroundToIntegral :: (RealFrac a, Integral b) => a -> b\nroundToIntegral = round . roundToUnits\n\nshowRounded :: RealFrac a => a -> Text\nshowRounded = show @_ @Int . roundToIntegral\n\ninfixl 1 >>=/\n\n(>>=/) :: Monad m => m a -> (a -> m b) -> m a\n(>>=/) a b = do\n  a' <- a\n  _ <- b a'\n  return a'\n\ninfixl 1 /=<<\n\n(/=<<) :: Monad m => (a -> m b) -> m a -> m a\n(/=<<) a b = b >>=/ a\n\ninfixl 1 >>>=\n\n(>>>=) :: (Traversable n, Monad m, Monad n) => m (n a) -> (a -> m (n b)) -> m (n b)\n(>>>=) a b = do\n  a >>= \\a1 -> sequenceA (a1 <&> b) <&> join\n\ninfixl 1 =<<<\n\n(=<<<) :: (Traversable n, Monad m, Monad n) => (a -> m (n b)) -> m (n a) -> m (n b)\n(=<<<) a b = b >>>= a\n\nhoistMaybe :: Applicative m => Maybe b -> MaybeT m b\nhoistMaybe = MaybeT . pure\n\n(|<|>|) :: Monad m => m (Maybe a) -> m (Maybe a) -> m (Maybe a)\n(|<|>|) funcA funcB = do\n  maybeA <- funcA\n  case maybeA of\n    Just _ -> return maybeA\n    Nothing -> funcB\n\nsafeInit :: [a] -> [a]\nsafeInit [] = []\nsafeInit xs = init xs\n",
      "hash": "765f18b1abfef1dc28daea02b71d88e9af12312fb07672ed00fc4719e9fc21d3",
      "size": 4794
    },
    "/lib/mobility-core/src/Kernel/Prelude/OrphanInstances.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n{-# LANGUAGE StandaloneDeriving #-}\n{-# OPTIONS_GHC -Wno-orphans #-}\n\nmodule Kernel.Prelude.OrphanInstances where\n\nimport Control.Lens (At, Index, IxValue, Ixed, Lens', at, coerced, ix)\nimport qualified Data.OpenApi as DS\nimport Data.Text (Text)\nimport EulerHS.Language ()\nimport EulerHS.Prelude ((.))\nimport GHC.Generics ()\n\n-- deriving instance Generic (a,b,c,d,e,f,g,h) -- uncomment this when remove EulerHS\n-- deriving instance Generic (a, b, c, d, e, f, g, h, i)\n\n{-\n\n-- deriving instance Generic (a, b, c, d, e, f, g, h, i, j)\n\n-- deriving instance Generic (a, b, c, d, e, f, g, h, i, j, k)\n\n-- deriving instance Generic (a, b, c, d, e, f, g, h, i, j, k, l)\n\n-- deriving instance Generic (a, b, c, d, e, f, g, h, i, j, k, l, m)\n\n-- deriving instance Generic (a, b, c, d, e, f, g, h, i, j, k, l, m, n)\n\n-- deriving instance Generic (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o)\n\nderiving instance Generic (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p)\n\nderiving instance Generic (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q)\n\nderiving instance Generic (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r)\n\nderiving instance Generic (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s)\n\nderiving instance Generic (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t)\n\nderiving instance Generic (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u)\n\nderiving instance Generic (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v)\n\nderiving instance Generic (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w)\n\nderiving instance Generic (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x)\n\nderiving instance Generic (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y)\n\nderiving instance Generic (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z)\n\n-}\n\n-- Index and IxValue Type Family instances for SecurityDefinitions\ntype instance Index DS.SecurityDefinitions = Text\n\ntype instance IxValue DS.SecurityDefinitions = DS.SecurityScheme\n\n-- Ixed and At Type-Class instances for SecurityDefinitions\ninstance Ixed DS.SecurityDefinitions where ix n = (coerced :: Lens' DS.SecurityDefinitions (DS.Definitions DS.SecurityScheme)) . ix n\n\ninstance At DS.SecurityDefinitions where at n = (coerced :: Lens' DS.SecurityDefinitions (DS.Definitions DS.SecurityScheme)) . at n\n",
      "hash": "e14e7402c3cef447ac268eb99d17c1c204537ae3760cdee5c77c11221a935ce0",
      "size": 3093
    },
    "/lib/mobility-core/src/Kernel/Product/Validation/Context.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n\nmodule Kernel.Product.Validation.Context where\n\nimport Control.Lens (view)\nimport qualified EulerHS.Language as L\nimport EulerHS.Prelude hiding (view)\nimport qualified Kernel.Types.Beckn.Context as CoreContext\nimport Kernel.Types.Common\nimport Kernel.Types.Error\nimport Kernel.Types.Field\nimport Kernel.Utils.Common\n\nvalidateContext :: (HasFlowEnv m r '[\"coreVersion\" ::: Text]) => CoreContext.Action -> CoreContext.Context -> m ()\nvalidateContext action context = do\n  validateDomain CoreContext.MOBILITY context\n  validateContextCommons action context\n\nvalidateMetroContext :: (HasFlowEnv m r '[\"coreVersion\" ::: Text]) => CoreContext.Action -> CoreContext.Context -> m ()\nvalidateMetroContext action context = do\n  validateDomain CoreContext.METRO context\n  validateContextCommons action context\n\nvalidateDomain :: (L.MonadFlow m, Log m) => CoreContext.Domain -> CoreContext.Context -> m ()\nvalidateDomain expectedDomain context =\n  unless (context.domain == expectedDomain) $\n    throwError InvalidDomain\n\nvalidateAction :: (L.MonadFlow m, Log m) => CoreContext.Action -> CoreContext.Context -> m ()\nvalidateAction expectedAction context =\n  unless (context.action == expectedAction) $\n    throwError InvalidAction\n\nvalidateCoreVersion ::\n  ( HasFlowEnv m r '[\"coreVersion\" ::: Text],\n    Log m\n  ) =>\n  CoreContext.Context ->\n  m ()\nvalidateCoreVersion context = do\n  supportedVersion <- view #coreVersion\n  unless (context.core_version == supportedVersion) $\n    throwError UnsupportedCoreVer\n\nvalidateContextCommons ::\n  ( HasFlowEnv m r '[\"coreVersion\" ::: Text],\n    Log m\n  ) =>\n  CoreContext.Action ->\n  CoreContext.Context ->\n  m ()\nvalidateContextCommons expectedAction context = do\n  -- TODO: City validation\n  validateAction expectedAction context\n  validateCoreVersion context\n",
      "hash": "2ce174312994d44d18e38b61f1694beda6a33b8a5732b9303cdca68fb9a60a0f",
      "size": 2487
    },
    "/lib/mobility-core/src/Kernel/Randomizer.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n{-# OPTIONS_GHC -Wwarn=incomplete-uni-patterns #-}\n\nmodule Kernel.Randomizer where\n\nimport Safe (at)\nimport System.Random\nimport Universum\n\ngetRandomInRange :: (MonadIO m, Random a) => (a, a) -> m a\ngetRandomInRange = liftIO . randomRIO\n\nrandomizeList ::\n  forall m arr1 arr2 a.\n  ( Element (arr1 a) ~ a,\n    MonadIO m,\n    Applicative arr2,\n    Monoid (arr2 a),\n    Container (arr1 a)\n  ) =>\n  arr1 a ->\n  m (arr2 a)\nrandomizeList = randomizeList' . toList\n  where\n    randomizeList' [] = return mempty\n    randomizeList' l = do\n      let len = length l\n      randNum <- getRandomInRange (0, len - 1)\n      let (leftPart, el : rightPart) = splitAt randNum l\n      (pure el <>) <$> randomizeList' (leftPart <> rightPart)\n\ngetRandomElement :: (Element (arr a) ~ a, MonadIO m, Container (arr a)) => arr a -> m a\ngetRandomElement arr = do\n  let len = length arr\n  randNum <- getRandomInRange (0, len - 1)\n  return $ toList arr `at` randNum\n",
      "hash": "2e3637c2e34a8f328f8d44ee8d5fe561b8582f9d6d1e9bd2a4ecb0a35234d539",
      "size": 1630
    },
    "/lib/mobility-core/src/Kernel/ServantMultipart.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n{-# OPTIONS_GHC -fno-warn-orphans #-}\n\nmodule Kernel.ServantMultipart\n  ( module Servant.Multipart,\n    module Servant.Multipart.API,\n    module Servant.Multipart.Client,\n  )\nwhere\n\nimport Kernel.Prelude\nimport Kernel.Utils.Monitoring.Prometheus.Servant\nimport Servant hiding (ResponseHeader (..))\nimport Servant.Multipart\nimport Servant.Multipart.API\nimport Servant.Multipart.Client\nimport qualified Servant.OpenApi as S\n\ninstance\n  ( S.HasOpenApi api\n  ) =>\n  S.HasOpenApi (MultipartForm tag a :> api)\n  where\n  toOpenApi _ = S.toOpenApi (Proxy @api) -- TODO: implementing OpenAPI interpretation for Multipart.\n\ninstance\n  SanitizedUrl (sub :: Type) =>\n  SanitizedUrl (MultipartForm tag a :> sub)\n  where\n  getSanitizedUrl _ = getSanitizedUrl (Proxy :: Proxy sub)\n",
      "hash": "91af66c271fcc7a0cc0e6c6aad0671fe7737498322d7847f2e99fe4aaec4497a",
      "size": 1459
    },
    "/lib/mobility-core/src/Kernel/Serviceability.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n\nmodule Kernel.Serviceability where\n\n-- import Kernel.Storage.Esqueleto.Config\n-- import Kernel.Storage.Esqueleto.SqlDB\n-- import Kernel.Storage.Esqueleto.Transactionable\n\nimport qualified EulerHS.Language as L\nimport Kernel.External.Maps.Types\nimport Kernel.Prelude\nimport Kernel.Types.Geofencing\n\n-- rideServiceable ::\n--   ( EsqDBFlow m r,\n--     EsqDBReplicaFlow m r\n--   ) =>\n--   GeofencingConfig ->\n--   (LatLong -> [Text] -> SelectSqlDB Bool) ->\n--   LatLong ->\n--   Maybe LatLong ->\n--   m Bool\n-- rideServiceable geofencingConfig someGeometriesContain origin mbDestination = do\n--   originServiceable <-\n--     case geofencingConfig.origin of\n--       Unrestricted -> pure True\n--       Regions regions -> runInReplica $ someGeometriesContain origin regions\n--   destinationServiceable <-\n--     case geofencingConfig.destination of\n--       Unrestricted -> pure True\n--       Regions regions -> do\n--         maybe (pure True) (runInReplica . (flip someGeometriesContain) regions) mbDestination\n--   pure $ originServiceable && destinationServiceable\n\nrideServiceable ::\n  L.MonadFlow m =>\n  GeofencingConfig ->\n  (LatLong -> [Text] -> m Bool) ->\n  LatLong ->\n  Maybe LatLong ->\n  m Bool\nrideServiceable geofencingConfig someGeometriesContain origin mbDestination = do\n  originServiceable <-\n    case geofencingConfig.origin of\n      Unrestricted -> pure True\n      Regions regions -> someGeometriesContain origin regions\n  destinationServiceable <-\n    case geofencingConfig.destination of\n      Unrestricted -> pure True\n      Regions regions -> do\n        maybe (pure True) (`someGeometriesContain` regions) mbDestination\n  pure $ originServiceable && destinationServiceable\n",
      "hash": "0650e1ddaeafd2908073367a79c091d2e6ee7c2dfe5b5a778bdcd1a1d066aa57",
      "size": 2382
    },
    "/lib/mobility-core/src/Kernel/Sms/Config.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n\nmodule Kernel.Sms.Config where\n\nimport EulerHS.Prelude\nimport Kernel.Prelude\nimport Kernel.Utils.Dhall (FromDhall)\n\ndata SmsSessionConfig = SmsSessionConfig\n  { attempts :: Int,\n    authExpiry :: Int,\n    tokenExpiry :: Int\n  }\n  deriving (Generic, FromDhall, Show, FromJSON, ToJSON, ToSchema)\n\ndata SmsCredConfig = SmsCredConfig\n  { username :: Text, -- FIXME? Do we need to reuse Servant's one?\n    password :: Text, -- idem\n    otpHash :: Text,\n    token :: Maybe Text\n  }\n  deriving (Generic, FromDhall)\n\ndata SmsConfig = SmsConfig\n  { sessionConfig :: SmsSessionConfig,\n    credConfig :: SmsCredConfig,\n    useFakeSms :: Maybe Word16, -- 4 digit\n    url :: BaseUrl,\n    sender :: Text\n  }\n  deriving (Generic, FromDhall)\n",
      "hash": "92e19c34cb6500caa9f43c189be05b2ef2dafbf09bbc7fd35a88ea911916ccd1",
      "size": 1420
    },
    "/lib/mobility-core/src/Kernel/Storage/.DS_Store": {
      "type": "binary",
      "hash": "b689eab28f81c1093cd40eeb0ac22886baf77d6c5a61b5d520442c31a82dd3e9",
      "size": 6148,
      "url": "https://raw.githubusercontent.com/nammayatri/shared-kernel/b19b62ccc9511b2ecf8c74a7948725e979e990a2/lib/mobility-core/src/Kernel/Storage/.DS_Store"
    },
    "/lib/mobility-core/src/Kernel/Storage/Beam/BecknRequest.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program\n\n  is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n\n  or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of\n\n  the GNU Affero General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n{-# LANGUAGE DerivingStrategies #-}\n{-# LANGUAGE StandaloneDeriving #-}\n{-# LANGUAGE TemplateHaskell #-}\n\nmodule Kernel.Storage.Beam.BecknRequest where\n\nimport qualified Data.Aeson as A\nimport qualified Data.Time as Time\nimport qualified Database.Beam as B\nimport Kernel.Beam.Lib.UtilsTH\nimport Kernel.Prelude\n\ndata BecknRequestT f = BecknRequestT\n  { id :: B.C f Text,\n    becknRequest :: B.C f Text,\n    signatureHeader :: B.C f Text,\n    timeStamp :: B.C f UTCTime\n  }\n  deriving (Generic, B.Beamable)\n\ninstance B.Table BecknRequestT where\n  data PrimaryKey BecknRequestT f\n    = Id (B.C f Text)\n    deriving (Generic, B.Beamable)\n  primaryKey = Id . id\n\ntype BecknRequest = BecknRequestT Identity\n\n$(enableKVPG ''BecknRequestT ['id] [])\n\n$(mkTableInstancesGenericSchema ''BecknRequestT \"beckn_request\")\n\n-- How it works inside of template:\n-- instance HasSchemaName BecknRequestT => Sequelize.ModelMeta BecknRequestT where\n--   modelFieldModification = becknRequestTMod\n--   modelTableName = \"booking\"\n--   modelSchemaName = Just (schemaName (Proxy @BecknRequestT))\n\n-- How it works inside of template:\n-- becknRequestTable :: HasSchemaName BecknRequestT => B.EntityModification (B.DatabaseEntity be db) be (B.TableEntity BecknRequestT)\n-- becknRequestTable = B.setEntitySchema (Just (schemaName (Proxy @BecknRequestT))) <> (B.setEntityName \"beckn_request\" <> B.modifyTableFields becknRequestTMod)\n\n--- KAFKA ---\n\n-- BecknRequestKafka type should not be changed because kafka consumer will not work\n-- Any field of BecknRequestT type can be safely changed\ndata BecknRequestKafka = BecknRequestKafka\n  { timestamp :: UTCTime,\n    becknRequest :: A.Value -- encoded BecknRequest\n  }\n  deriving (ToJSON, FromJSON, Generic)\n\nmkBecknRequestKafka :: BecknRequest -> BecknRequestKafka\nmkBecknRequestKafka becknRequestT = do\n  let timestamp = timeStamp becknRequestT\n  let becknRequest = toJSON becknRequestT\n  BecknRequestKafka {..}\n\n-- FIXME use 24 partitions instead of 24 topics\ncountTopicNumber :: UTCTime -> Int\ncountTopicNumber timeStamp = do\n  let timeOfDay = Time.timeToTimeOfDay . Time.utctDayTime $ timeStamp\n  Time.todHour timeOfDay\n",
      "hash": "63b3fb4779b9b6a9102e0b8314b36ad9466d7c0c7bf70cee9cd42c06a96878a6",
      "size": 2834
    },
    "/lib/mobility-core/src/Kernel/Storage/Beam/SystemConfigs.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program\n\n  is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n\n  or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of\n\n  the GNU Affero General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n{-# LANGUAGE DerivingStrategies #-}\n{-# LANGUAGE StandaloneDeriving #-}\n{-# LANGUAGE TemplateHaskell #-}\n\nmodule Kernel.Storage.Beam.SystemConfigs where\n\nimport qualified Database.Beam as B\nimport Kernel.Beam.Lib.UtilsTH\nimport Kernel.Prelude\n\ndata SystemConfigsT f = SystemConfigsT\n  { id :: B.C f Text,\n    configValue :: B.C f Text\n  }\n  deriving (Generic, B.Beamable)\n\ninstance B.Table SystemConfigsT where\n  data PrimaryKey SystemConfigsT f\n    = Id (B.C f Text)\n    deriving (Generic, B.Beamable)\n  primaryKey = Id . id\n\ntype SystemConfigs = SystemConfigsT Identity\n\n$(enableKVPG ''SystemConfigsT ['id] [])\n\n$(mkTableInstancesGenericSchema ''SystemConfigsT \"system_configs\")\n",
      "hash": "4e986f3cd92a48fbd6e6f4cf116a5fc6034cb6c4b5a4f76d201ea36bc57aa387",
      "size": 1374
    },
    "/lib/mobility-core/src/Kernel/Storage/Clickhouse/Config.hs": {
      "type": "content",
      "content": "module Kernel.Storage.Clickhouse.Config where\n\nimport qualified Control.Concurrent.MVar as M\nimport qualified Control.Monad.Catch as C\nimport Data.String.Conversions\nimport Data.Text as T\nimport Data.Time.Clock hiding (getCurrentTime)\nimport qualified Data.Vector as V\nimport Data.Word (Word16)\nimport qualified Database.ClickHouseDriver.HTTP as CH\nimport Kernel.Prelude\nimport Kernel.Types.Common\nimport Kernel.Utils.Dhall (FromDhall)\n\ntype ClickhouseFlow m env =\n  ( MonadReader env m,\n    HasField \"kafkaClickhouseEnv\" env ClickhouseEnv,\n    HasField \"serviceClickhouseEnv\" env ClickhouseEnv,\n    HasField \"dashboardClickhouseEnv\" env ClickhouseEnv,\n    MonadIO m,\n    C.MonadThrow m,\n    Log m,\n    HasField \"serviceClickhouseCfg\" env ClickhouseCfg,\n    HasField \"kafkaClickhouseCfg\" env ClickhouseCfg,\n    HasField \"dashboardClickhouseCfg\" env ClickhouseCfg\n  )\n\ndata ClickhouseCfg = ClickhouseCfg\n  { username :: Text,\n    host :: Text,\n    port :: Word16,\n    password :: Text,\n    database :: Text,\n    tls :: Bool,\n    retryInterval :: V.Vector Int\n  }\n  deriving (Generic, FromDhall)\n\ndata ClickhouseDb = APP_SERVICE_CLICKHOUSE | ATLAS_KAFKA\n\ndata ClickhouseData = ClickhouseData\n  { connection :: CH.HttpConnection,\n    retryInterval :: V.Vector Int,\n    lastTryIndex :: Int,\n    lastTryTime :: UTCTime,\n    status :: Bool\n  }\n\nnewtype ClickhouseEnv = ClickhouseEnv\n  { connectionData :: M.MVar ClickhouseData\n  }\n\ncreateConn :: ClickhouseCfg -> IO ClickhouseEnv\ncreateConn ClickhouseCfg {..} = do\n  conn <-\n    CH.httpConnectDb\n      (if T.null database then Nothing else Just (cs database))\n      (cs username)\n      (cs password)\n      (fromIntegral port)\n      (cs host)\n      tls\n  time <- getCurrentTime\n  ClickhouseEnv <$> M.newMVar (ClickhouseData {connection = conn, lastTryIndex = -1, lastTryTime = time, status = False, ..})\n\ngetLock :: ClickhouseEnv -> IO Bool\ngetLock env = do\n  envData <- M.takeMVar env.connectionData\n  let status = envData.status\n  M.putMVar env.connectionData envData {status = True}\n  return status\n\nreleaseLock :: ClickhouseEnv -> IO ()\nreleaseLock env = do\n  envData <- M.readMVar env.connectionData\n  M.modifyMVar_ env.connectionData (\\_ -> pure $ envData {status = False})\n\nconnectionHelper :: ClickhouseCfg -> ClickhouseEnv -> IO ()\nconnectionHelper cfg env = do\n  lock <- getLock env\n  when (not lock) $ do\n    envData <- M.readMVar env.connectionData\n    when (V.length envData.retryInterval /= 0) do\n      let retryIndex = min (envData.lastTryIndex + 1) ((V.length envData.retryInterval) -1)\n      let retryTime = envData.retryInterval V.! retryIndex\n      time <- liftIO getCurrentTime\n      if diffUTCTime time (lastTryTime envData) > fromIntegral retryTime\n        then do\n          con <- liftIO $ createCkhConn cfg\n          M.modifyMVar_ env.connectionData (\\_ -> pure $ envData {connection = con, lastTryIndex = retryIndex, lastTryTime = time})\n        else pure ()\n    releaseLock env\n\nretryClickhouseConnection :: (MonadFlow m, ClickhouseFlow m env) => ClickhouseDb -> m ()\nretryClickhouseConnection db = do\n  case db of\n    APP_SERVICE_CLICKHOUSE -> do\n      clickhouseEnv <- asks (.serviceClickhouseEnv)\n      ckhCfg <- asks (.serviceClickhouseCfg)\n      liftIO $ connectionHelper ckhCfg clickhouseEnv\n    ATLAS_KAFKA -> do\n      clickhouseEnv <- asks (.kafkaClickhouseEnv)\n      ckhCfg <- asks (.kafkaClickhouseCfg)\n      liftIO $ connectionHelper ckhCfg clickhouseEnv\n\ncreateCkhConn :: ClickhouseCfg -> IO CH.HttpConnection\ncreateCkhConn ClickhouseCfg {..} =\n  CH.httpConnectDb\n    (if T.null database then Nothing else Just (cs database))\n    (cs username)\n    (cs password)\n    (fromIntegral port)\n    (cs host)\n    tls\n",
      "hash": "e8109209fa01816efe082673bb0abd7e7a78ba1af3e60b5e2932a32b1b661f79",
      "size": 3689
    },
    "/lib/mobility-core/src/Kernel/Storage/Clickhouse/Operators.hs": {
      "type": "content",
      "content": "{-# OPTIONS_GHC -Wno-orphans #-}\n\nmodule Kernel.Storage.Clickhouse.Operators where\n\nimport Data.List (intercalate)\nimport Kernel.Prelude\nimport Kernel.Storage.Clickhouse.Types\n\ntype ValueToExprStr = String -> String -> ClickhouseExpr\n\n(=.=) :: ValueToExprStr -- equal to operator :: usage (\"columnName\" =.= \"expectedValue\")\n(=!=) :: ValueToExprStr -- not equal to operator :: usage (\"columnName\" =!= \"unexpectedValue\")\n(<<.) :: ValueToExprStr -- less than operator :: usage (\"columnName\" <<. \"highestValue\")\n(>>.) :: ValueToExprStr -- greater than operator :: usage (\"columnName\" >>. \"lowestValue\")\n(>>==.) :: ValueToExprStr -- greater than equal to operator :: usage (\"columnName\" >>==. \"lowestValue\")\n(<<==.) :: ValueToExprStr -- less than equal to operator :: usage (\"columnName\" <<==. \"highestValue\")\n\ninfixl 6 <<., >>., =.=, =!=, >>==., <<==.\n\n(=.=) col val = ExprStr (col <> \"=\" <> \"'\" <> val <> \"'\")\n\n(=!=) col val = ExprStr (col <> \"!\" <> val)\n\n(<<.) col val = ExprStr (col <> \"<\" <> val)\n\n(>>.) col val = ExprStr (col <> \">\" <> val)\n\n(>>==.) col val = ExprStr (col <> \">=\" <> \"'\" <> val <> \"'\")\n\n(<<==.) col val = ExprStr (col <> \"<=\" <> \"'\" <> val <> \"'\")\n\n__like :: ValueToExprStr\n__like col val = ExprStr (col <> \" LIKE \" <> val)\n\ninstance ToClickhouseQuery [String] where\n  toClickhouseQuery ls = \"(\" <> intercalate \",\" ls <> \")\"\n\n__in :: String -> [String] -> ClickhouseExpr\n__in col valList = ExprStr (col <> \" IN \" <> toClickhouseQuery valList)\n\ntype ExprsToExprStr = ClickhouseExpr -> ClickhouseExpr -> ClickhouseExpr\n\n(|.|) :: ExprsToExprStr\n(&.&) :: ExprsToExprStr\n\ninfixr 8 |.|, &.&\n\n(|.|) a b = ExprStr (toClickhouseQuery a <> \" OR \" <> toClickhouseQuery b)\n\n(&.&) a b = ExprStr (toClickhouseQuery a <> \" AND \" <> toClickhouseQuery b)\n",
      "hash": "d1c3a52c8b98dc2cdd859f3a07e210cb2ce609d86c6a864770111c6f3504a232",
      "size": 1756
    },
    "/lib/mobility-core/src/Kernel/Storage/Clickhouse/Queries.hs": {
      "type": "content",
      "content": "-- support only read operation for now\nmodule Kernel.Storage.Clickhouse.Queries\n  ( findAll,\n    findOne,\n    runRawQuery',\n    findOneWithOrder,\n    retryClickhouseConnection,\n  )\nwhere\n\nimport qualified Control.Concurrent.MVar as M\nimport Data.Text as T hiding (null)\nimport Data.Typeable (typeRep)\nimport Database.ClickHouseDriver.HTTP\nimport qualified EulerHS.Language as L\nimport Kernel.Prelude\nimport Kernel.Storage.Clickhouse.Config\nimport Kernel.Storage.Clickhouse.Types\nimport Kernel.Types.Error\nimport Kernel.Utils.Common hiding (Limit, Offset)\nimport Kernel.Utils.JSON\n\nappendExpr :: ClickhouseExpr -> String -> String\nappendExpr expr prefix =\n  prefix\n    <> if expr /= Nil\n      then \" WHERE \" <> toClickhouseQuery expr\n      else \"\"\n\nappendGroupBy :: Maybe String -> String -> String\nappendGroupBy maybeGroupBy query = do\n  let groupBy_ = case maybeGroupBy of\n        Just gb -> \" GROUP BY \" <> gb\n        Nothing -> \"\"\n  query <> groupBy_\n\n__select :: forall a. Typeable a => Proxy a -> [Text] -> Maybe String -> ClickhouseExpr -> String\n__select proxyTableType cols maybeGroupBy expr = do\n  let tableName = dropBeforeDot $ camelToSnakeCase . show $ typeRep proxyTableType\n  let selectClause = if null cols then \"SELECT *\" else T.unpack $ \"SELECT \" <> intercalate \", \" cols\n  appendGroupBy maybeGroupBy $ appendExpr expr $ selectClause <> \" FROM \" <> tableName\n\naddClause :: ToClickhouseQuery a => String -> a -> String\naddClause query clause = query <> toClickhouseQuery clause\n\n__limit :: String -> Limit -> String\n__limit = addClause\n\n__orderBy :: String -> Order -> String\n__orderBy = addClause\n\n__offset :: String -> Offset -> String\n__offset = addClause\n\nrunClickhouse :: (MonadFlow m, ClickhouseFlow m env, FromJSON a) => (HttpConnection -> IO (Either String a)) -> ClickhouseDb -> m (Either String a)\nrunClickhouse action db = do\n  con <- case db of\n    APP_SERVICE_CLICKHOUSE -> do\n      conn' <- asks (.serviceClickhouseEnv)\n      conn <- liftIO $ M.readMVar $ conn'.connectionData\n      return conn.connection\n    ATLAS_KAFKA -> do\n      conn' <- asks (.kafkaClickhouseEnv)\n      conn <- liftIO $ M.readMVar $ conn'.connectionData\n      return conn.connection\n  res <- L.runIO $ action con\n  case res of\n    Left err -> do\n      if ((T.pack \"ConnectionFailure\") `T.isInfixOf` (T.pack err))\n        then do\n          logError $ \"Clickhouse error: \" <> T.pack err\n          retryClickhouseConnection db\n          L.runIO $ action con\n        else pure $ Left err\n    Right val -> pure $ Right val\n\nrunRawQuery :: (MonadFlow m, ClickhouseFlow m env, FromJSON a) => String -> ClickhouseDb -> m (Either String a)\nrunRawQuery query db = do\n  logDebug $ \"clickhouse raw query v1: \" <> T.pack query\n  runClickhouse (`runQuery` getJSON query) db\n\nrunRawQuery' :: (MonadFlow m, ClickhouseFlow m env, FromJSON a) => ClickhouseExpr -> ClickhouseDb -> m (Either String a)\nrunRawQuery' (ExprStr query) db = runRawQuery query db\nrunRawQuery' _ _ = throwError $ InternalError \"can't call this function with unresolved clickhouseExpr\"\n\nconstructQuery :: Typeable a => Proxy a -> [Text] -> Maybe String -> ClickhouseExpr -> Maybe Limit -> Maybe Offset -> Maybe Order -> String\nconstructQuery proxyTable columns maybeGroupBy expr mbLimit mbOffset mbOrder = do\n  addOffset . addLimit . addOrder $ __select proxyTable columns maybeGroupBy expr\n  where\n    addLimit q = maybe q (__limit q) mbLimit\n    addOrder q = maybe q (__orderBy q) mbOrder\n    addOffset q = maybe q (__offset q) mbOffset\n\nfindAll :: (MonadFlow m, ClickhouseFlow m env, Typeable a, FromJSON a) => ClickhouseDb -> Proxy a -> [Text] -> Maybe String -> ClickhouseExpr -> Maybe Limit -> Maybe Offset -> Maybe Order -> m (Either String [a])\nfindAll db proxyTable columns maybeGroupBy expr mbLimit mbOffset mbOrder = runRawQuery (constructQuery proxyTable columns maybeGroupBy expr mbLimit mbOffset mbOrder) db\n\nfindOne' :: (MonadFlow m, ClickhouseFlow m env, Typeable a, FromJSON a) => ClickhouseDb -> Proxy a -> [Text] -> Maybe String -> ClickhouseExpr -> Maybe Offset -> Maybe Order -> m (Maybe a)\nfindOne' db proxyTable columns maybeGroupBy expr mbOffset mbOrder = either (\\err -> logInfo (T.pack err) $> Nothing) (pure . listToMaybe) =<< runRawQuery (constructQuery proxyTable columns maybeGroupBy expr (Just $ Limit 1) mbOffset mbOrder) db\n\nfindOne :: (MonadFlow m, ClickhouseFlow m env, Typeable a, FromJSON a) => ClickhouseDb -> Proxy a -> [Text] -> Maybe String -> ClickhouseExpr -> m (Maybe a)\nfindOne db proxyTable columns maybeGroupBy expr = findOne' db proxyTable columns maybeGroupBy expr Nothing Nothing\n\nfindOneWithOrder :: (MonadFlow m, ClickhouseFlow m env, Typeable a, FromJSON a) => ClickhouseDb -> Proxy a -> [Text] -> Maybe String -> ClickhouseExpr -> Order -> m (Maybe a)\nfindOneWithOrder db proxyTable columns maybeGroupBy expr order = findOne' db proxyTable columns maybeGroupBy expr Nothing (Just order)\n\n-- USAGE EXAPLE\n-- res1 :: Either String [Test] <- CH.runRawQuery' $ CH.ExprStr \"SELECT * FROM test\"\n-- res2 :: (Maybe Test) <- CH.findOne (Proxy @Test) (\"x\" =.= \"1\")\n-- res3 :: (Maybe Test) <- CH.findOneWithOrder (Proxy @Test) (\"x\" =.= \"1\") (CH.Desc \"x\")\n-- res4 :: Either String [Test] <- CH.findAll (Proxy @Test) (\"x\" =.= \"1\") (Just $ CH.Limit 10) Nothing (Just $ CH.Desc \"x\")\n",
      "hash": "73c37b7baea0e2a0a85a71761c5dfa9e48d3b0d34a6619d2fbe1a2960a2b2cc2",
      "size": 5280
    },
    "/lib/mobility-core/src/Kernel/Storage/Clickhouse/Types.hs": {
      "type": "content",
      "content": "module Kernel.Storage.Clickhouse.Types where\n\nimport Kernel.Prelude\n\ntype ChCol a b = a -> b\n\ndata CHExpr a = CHExpr a (a -> a -> String) a\n\ninstance Eq (CHExpr a) where\n  (==) (CHExpr a fn b) (CHExpr c fn2 d) = fn a b == fn2 c d\n\ndata ClickhouseExpr = Nil | ExprStr String deriving (Eq)\n\nclass ToClickhouseQuery a where\n  toClickhouseQuery :: a -> String\n\n-- why extra brackets?\ninstance ToClickhouseQuery ClickhouseExpr where\n  toClickhouseQuery expr = \"(\" <> go expr\n    where\n      go :: ClickhouseExpr -> String\n      go e =\n        case e of\n          Nil -> \")\"\n          ExprStr str -> str <> \")\"\n\ndata Order = Asc String | Desc String\n\ninstance ToClickhouseQuery Order where\n  toClickhouseQuery (Asc colName) = \" ORDER BY \" <> colName <> \" ASC\"\n  toClickhouseQuery (Desc colName) = \" ORDER BY \" <> colName <> \" DESC\"\n\nnewtype Offset = Offset Int\n\ninstance ToClickhouseQuery Offset where\n  toClickhouseQuery (Offset val) = \" OFFSET \" <> show val\n\nnewtype Limit = Limit Int\n\ninstance ToClickhouseQuery Limit where\n  toClickhouseQuery (Limit val) = \" LIMIT \" <> show val\n\ndropBeforeDot :: String -> String\ndropBeforeDot str = case dropWhile (/= '.') str of\n  [] -> str\n  (_ : rest) -> rest\n",
      "hash": "934f4ccf032852404367f744eb148e26b45101bd1988dc94aa7daf8be54ad16d",
      "size": 1196
    },
    "/lib/mobility-core/src/Kernel/Storage/ClickhouseV2.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n\nmodule Kernel.Storage.ClickhouseV2 (module Reexport) where\n\nimport Kernel.Storage.ClickhouseV2.ClickhouseDb as Reexport\nimport Kernel.Storage.ClickhouseV2.ClickhouseTable as Reexport\nimport Kernel.Storage.ClickhouseV2.ClickhouseValue as Reexport\nimport Kernel.Storage.ClickhouseV2.Internal.ClickhouseColumns ()\nimport Kernel.Storage.ClickhouseV2.Operators as Reexport\nimport Kernel.Storage.ClickhouseV2.Queries as Reexport\n",
      "hash": "4be68871c2daffd184c65859534f33786ca7104ed0f0b90633375f354417ec67",
      "size": 1117
    },
    "/lib/mobility-core/src/Kernel/Storage/ClickhouseV2/ClickhouseDb.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n\nmodule Kernel.Storage.ClickhouseV2.ClickhouseDb (module Kernel.Storage.ClickhouseV2.ClickhouseDb, module Reexport) where\n\n-- import Data.String.Conversions\n-- import Data.Text as T\n-- import Data.Word (Word16)\n-- import qualified Database.ClickHouseDriver.HTTP as CH\nimport Kernel.Prelude\n-- import Kernel.Utils.Dhall (FromDhall)\nimport Kernel.Storage.Clickhouse.Config as Reexport (ClickhouseCfg (..), ClickhouseEnv (..), createConn)\nimport Kernel.Types.Common\n\nclass ClickhouseDb db\n\nclass (ClickhouseDb db, MonadFlow m) => HasClickhouseEnv db m where\n  getClickhouseEnv :: Proxy db -> m ClickhouseEnv\n  getClickhouseCfg :: Proxy db -> m ClickhouseCfg\n\ndata APP_SERVICE_CLICKHOUSE\n\ninstance ClickhouseDb APP_SERVICE_CLICKHOUSE\n\ninstance (MonadFlow m, MonadReader r m, HasField \"serviceClickhouseEnv\" r ClickhouseEnv, HasField \"serviceClickhouseCfg\" r ClickhouseCfg) => HasClickhouseEnv APP_SERVICE_CLICKHOUSE m where\n  getClickhouseEnv _ = asks (.serviceClickhouseEnv)\n  getClickhouseCfg _ = asks (.serviceClickhouseCfg)\n\ndata ATLAS_KAFKA\n\ninstance ClickhouseDb ATLAS_KAFKA\n\ninstance (MonadFlow m, MonadReader r m, HasField \"kafkaClickhouseEnv\" r ClickhouseEnv, HasField \"kafkaClickhouseCfg\" r ClickhouseCfg) => HasClickhouseEnv ATLAS_KAFKA m where\n  getClickhouseEnv _ = asks (.kafkaClickhouseEnv)\n  getClickhouseCfg _ = asks (.kafkaClickhouseCfg)\n\n-- data ClickhouseCfg = ClickhouseCfg\n--   { username :: Text,\n--     host :: Text,\n--     port :: Word16,\n--     password :: Text,\n--     database :: Text,\n--     tls :: Bool\n--   }\n--   deriving (Generic, FromDhall)\n\n-- newtype ClickhouseEnv = ClickhouseEnv\n--   { connection :: CH.HttpConnection\n--   }\n\n-- createConn :: ClickhouseCfg -> IO ClickhouseEnv\n-- createConn ClickhouseCfg {..} =\n--   ClickhouseEnv\n--     <$> CH.httpConnectDb\n--       (if T.null database then Nothing else Just (cs database))\n--       (cs username)\n--       (cs password)\n--       (fromIntegral port)\n--       (cs host)\n--       tls\n",
      "hash": "0669472c7f8a9ead46d3890e4cbdd2d1ce417ad563532acb324043e95892e494",
      "size": 2660
    },
    "/lib/mobility-core/src/Kernel/Storage/ClickhouseV2/ClickhouseTable.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n{-# LANGUAGE DerivingStrategies #-}\n{-# LANGUAGE GeneralizedNewtypeDeriving #-}\n\nmodule Kernel.Storage.ClickhouseV2.ClickhouseTable where\n\nimport Kernel.Prelude\n\nclass (Typeable t, FromJSON (t Identity)) => ClickhouseTable (t :: (Type -> Type) -> Type) where\n  tableModification :: FieldModifications t\n  mapTable :: forall f g. (forall a. C f a -> C g a) -> t f -> t g\n  getSelectModifier :: Proxy t -> SelectModifier\n\ndata SelectModifier = SELECT_FINAL_MODIFIER | NO_SELECT_MODIFIER\n\n-- | A type family that we use to \"tag\" columns in our table datatypes.\ntype family Columnar (f :: Type -> Type) x where\n  Columnar Identity x = x\n  Columnar f x = f x\n\n-- | A short type-alias for 'Columnar'. May shorten your schema definitions\ntype C f a = Columnar f a\n\nnewtype FieldModification table value = FieldModification String\n\ninstance IsString (FieldModification table value) where\n  fromString = FieldModification\n\n-- record field did not work with TH\ngetFieldModification :: FieldModification table value -> String\ngetFieldModification (FieldModification str) = str\n\ntype FieldModifications table = table (FieldModification table)\n",
      "hash": "79b788332a06d8177013f790739a4b7b08f37c8516ff36a966d5a8e542a1573c",
      "size": 1824
    },
    "/lib/mobility-core/src/Kernel/Storage/ClickhouseV2/ClickhouseValue.hs": {
      "type": "content",
      "content": "{-# LANGUAGE DerivingStrategies #-}\n{-# LANGUAGE GeneralizedNewtypeDeriving #-}\n{-# LANGUAGE InstanceSigs #-}\n\n{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n\nmodule Kernel.Storage.ClickhouseV2.ClickhouseValue where\n\nimport qualified Data.Aeson as A\nimport Data.ByteString as BS\nimport Data.Coerce (coerce)\nimport qualified Data.Scientific as Sci\nimport qualified Data.Text as T\nimport qualified Data.Text.Encoding as TE\nimport qualified Data.Time as Time\nimport Kernel.Prelude\nimport Kernel.Types.Common (Centesimal, Currency, HighPrecMeters, HighPrecMoney)\nimport Kernel.Types.Id\nimport qualified Text.Read as T\n\ndata Value a = Null | String String | Number Sci.Scientific\n\n-- FIXME\n-- data Value a where\n--   Null :: Value a\n--   String :: constraint => a -> Value a\n--   Number :: constraint => a -> Value a\n\ninstance FromJSON (Value a) where\n  parseJSON val@(A.String _) = String <$> parseJSON @String val\n  parseJSON val@(A.Number _) = Number <$> parseJSON @Sci.Scientific val\n  parseJSON A.Null = pure Null\n  parseJSON _ = fail \"Expected String or Null for clickhouse value\"\n\nclass (Show a, Read a) => ClickhouseValue a where\n  toClickhouseValue :: a -> Value a\n  fromClickhouseValue :: Value a -> Except a\n  toClickhouseValue = String . show\n  fromClickhouseValue (String str) = parseAsString @a str\n  fromClickhouseValue (Number _) = fail \"Unexpected Number\"\n  fromClickhouseValue Null = fail \"Unexpected Null\"\n\n-- For ATLAS_KAFKA env we store numbers as String, for APP_SERVICE_CLICKHOUSE env we store as Number. So we should be able to parse both\ninstance ClickhouseValue HighPrecMoney where\n  fromClickhouseValue = parseAsStringOrNumber @HighPrecMoney\n\ninstance ClickhouseValue Currency where\n  fromClickhouseValue = parseAsEnum @Currency\n\ninstance ClickhouseValue HighPrecMeters where\n  fromClickhouseValue = parseAsStringOrNumber @HighPrecMeters\n\ninstance ClickhouseValue Double where\n  fromClickhouseValue = parseAsStringOrNumber @Double\n\ninstance ClickhouseValue Centesimal where\n  fromClickhouseValue = parseAsStringOrNumber @Centesimal\n\n-- TODO create type safe wrapper CString Int in case of we have string on clickhouse side\ninstance ClickhouseValue Int where\n  fromClickhouseValue = parseAsStringOrNumber @Int\n  toClickhouseValue = Number . fromIntegral\n\nparseAsStringOrNumber :: forall a. (Read a, Num a, FromJSON a) => Value a -> Except a\nparseAsStringOrNumber (String str) = parseAsString @a str\nparseAsStringOrNumber (Number num) = parseAsNumber @a num\nparseAsStringOrNumber Null = fail \"Unexpected Null\"\n\nparseAsEnum :: forall a. Read a => Value a -> Except a\nparseAsEnum (String str) = parseAsString @a str\nparseAsEnum (Number _) = fail \"Unexpected Number\"\nparseAsEnum Null = fail \"Unexpected Null\"\n\nparseAsString :: forall a. Read a => String -> Except a\nparseAsString = Except . T.readEither @a\n\nparseAsNumber :: forall a. (Num a, FromJSON a) => Sci.Scientific -> Except a\nparseAsNumber = Except . eitherResult . A.fromJSON @a . A.Number\n\ninstance ClickhouseValue Bool where\n  fromClickhouseValue (String \"1\") = pure True\n  fromClickhouseValue (String \"0\") = pure False\n  fromClickhouseValue (String \"True\") = pure True\n  fromClickhouseValue (String \"False\") = pure False\n  fromClickhouseValue (String \"TRUE\") = pure True\n  fromClickhouseValue (String \"FALSE\") = pure False\n  fromClickhouseValue (String \"true\") = pure True\n  fromClickhouseValue (String \"false\") = pure False\n  fromClickhouseValue (String str) = fail $ \"Could not parse Bool value: \" <> str <> \"; Supported format for Bool: 0, 1, false, true, False, True, TRUE, FALSE\"\n  fromClickhouseValue _ = fail \"Unexpected Null\"\n\ninstance ClickhouseValue Time.Day\n\ninstance ClickhouseValue UTCTime where\n  toClickhouseValue = String . Time.formatTime Time.defaultTimeLocale \"%Y-%m-%d %H:%M:%S\"\n  fromClickhouseValue (String str) = Time.parseTimeM @Except True Time.defaultTimeLocale \"%Y-%m-%d %H:%M:%S%Q\" str\n  fromClickhouseValue (Number _) = fail \"Unexpected Number\"\n  fromClickhouseValue Null = fail \"Unexpected Null\"\n\nnewtype DateTime = DateTime {getDateTime :: UTCTime}\n  deriving newtype (Show, Read)\n\ninstance ClickhouseValue DateTime where\n  toClickhouseValue = String . Time.formatTime Time.defaultTimeLocale \"%Y-%m-%d %H:%M:%S\" . getDateTime\n  fromClickhouseValue (String str) = DateTime <$> Time.parseTimeM @Except True Time.defaultTimeLocale \"%Y-%m-%d %H:%M:%S\" str\n  fromClickhouseValue (Number _) = fail \"Unexpected Number\"\n  fromClickhouseValue Null = fail \"Unexpected Null\"\n\n-- No instance for (MonadFail (Either String))\nnewtype Except a = Except {getExcept :: Either String a}\n  deriving newtype (Monad, Applicative, Functor)\n\ninstance MonadFail Except where\n  fail = Except . Left\n\ninstance ClickhouseValue (Id a) where\n  toClickhouseValue = String . T.unpack . getId\n  fromClickhouseValue (String str) = pure . Id . T.pack $ str\n  fromClickhouseValue (Number _) = fail \"Unexpected Number\"\n  fromClickhouseValue Null = fail \"Unexpected Null\"\n\ninstance ClickhouseValue (ShortId a) where\n  toClickhouseValue = String . T.unpack . getShortId\n  fromClickhouseValue (String str) = pure . ShortId . T.pack $ str\n  fromClickhouseValue (Number _) = fail \"Unexpected Number\"\n  fromClickhouseValue Null = fail \"Unexpected Null\"\n\ninstance ClickhouseValue Text where\n  toClickhouseValue = String . T.unpack\n  fromClickhouseValue (String str) = pure . T.pack $ str\n  fromClickhouseValue (Number _) = fail \"Unexpected Number\"\n  fromClickhouseValue Null = fail \"Unexpected Null\"\n\ninstance ClickhouseValue A.Value where\n  fromClickhouseValue (String str) = Except . A.eitherDecode . BS.fromStrict . TE.encodeUtf8 . T.pack $ str\n  fromClickhouseValue _ = fail \"String expected\"\n  toClickhouseValue = String . T.unpack . TE.decodeUtf8 . BS.toStrict . A.encode\n\ninstance ClickhouseValue a => ClickhouseValue (Maybe a) where\n  toClickhouseValue (Just a) = coerce @(Value a) @(Value (Maybe a)) (toClickhouseValue a)\n  toClickhouseValue Nothing = Null\n  fromClickhouseValue :: ClickhouseValue a => Value (Maybe a) -> Except (Maybe a)\n  fromClickhouseValue Null = pure Nothing\n  fromClickhouseValue str = Just <$> fromClickhouseValue @a (coerce @(Value (Maybe a)) @(Value a) str)\n\neitherResult :: A.Result a -> Either String a\neitherResult (A.Error err) = Left err\neitherResult (A.Success a) = Right a\n\nvalToString :: Value value -> String\nvalToString (String str) = addQuotes $ str\nvalToString (Number num) = show num\nvalToString Null = \"null\"\n\naddQuotes :: String -> String\naddQuotes rq = \"'\" <> rq <> \"'\"\n",
      "hash": "dbd3da776944323152c1b637cccd578e00de6b3d9cb437c5eecdbedb6b5645ce",
      "size": 7135
    },
    "/lib/mobility-core/src/Kernel/Storage/ClickhouseV2/Internal/ClickhouseColumns.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n{-# OPTIONS_GHC -Wno-orphans #-}\n\nmodule Kernel.Storage.ClickhouseV2.Internal.ClickhouseColumns where\n\nimport qualified Data.Aeson.KeyMap as A\nimport qualified Data.Aeson.Types as A\nimport Data.Coerce (coerce)\nimport qualified Data.List as List\nimport Kernel.Prelude\nimport Kernel.Storage.ClickhouseV2.ClickhouseTable\nimport Kernel.Storage.ClickhouseV2.ClickhouseValue\nimport Kernel.Storage.ClickhouseV2.Internal.Types\n\ninstance (FromJSON (ColumnsType 'NOT_AGG (Columns 'NOT_AGG t)), ClickhouseTable t) => ClickhouseColumns 'NOT_AGG (Columns 'NOT_AGG t) where\n  type ColumnsType 'NOT_AGG (Columns 'NOT_AGG t) = t Identity\n  showClickhouseColumns _ _ _ = \"*\"\n  parseColumns _ _ val _ = eitherResult . A.fromJSON $ val\n\n-- should be all AGG columns or all NOT_AGG columns\ninstance (ClickhouseValue v) => ClickhouseColumns a (Column a t v) where\n  type ColumnsType a (Column a t v) = v\n  showClickhouseColumns _ = zipColumnsWithSynonyms1\n  parseColumns _ = parseColumns1\n\ninstance (C2 ClickhouseValue v1 v2) => ClickhouseColumns a (T2 (Column a t) v1 v2) where\n  type ColumnsType a (T2 (Column a t) v1 v2) = (v1, v2)\n  showClickhouseColumns _ = zipColumnsWithSynonyms2\n  parseColumns _ = parseColumns2\n\ninstance (C3 ClickhouseValue v1 v2 v3) => ClickhouseColumns a (T3 (Column a t) v1 v2 v3) where\n  type ColumnsType a (T3 (Column a t) v1 v2 v3) = (v1, v2, v3)\n  showClickhouseColumns _ = zipColumnsWithSynonyms3\n  parseColumns _ = parseColumns3\n\ninstance (C4 ClickhouseValue v1 v2 v3 v4) => ClickhouseColumns a (T4 (Column a t) v1 v2 v3 v4) where\n  type ColumnsType a (T4 (Column a t) v1 v2 v3 v4) = (v1, v2, v3, v4)\n  showClickhouseColumns _ = zipColumnsWithSynonyms4\n  parseColumns _ = parseColumns4\n\ninstance (C5 ClickhouseValue v1 v2 v3 v4 v5) => ClickhouseColumns a (T5 (Column a t) v1 v2 v3 v4 v5) where\n  type ColumnsType a (T5 (Column a t) v1 v2 v3 v4 v5) = (v1, v2, v3, v4, v5)\n  showClickhouseColumns _ = zipColumnsWithSynonyms5\n  parseColumns _ = parseColumns5\n\ninstance (C6 ClickhouseValue v1 v2 v3 v4 v5 v6) => ClickhouseColumns a (T6 (Column a t) v1 v2 v3 v4 v5 v6) where\n  type ColumnsType a (T6 (Column a t) v1 v2 v3 v4 v5 v6) = (v1, v2, v3, v4, v5, v6)\n  showClickhouseColumns _ = zipColumnsWithSynonyms6\n  parseColumns _ = parseColumns6\n\ninstance (C7 ClickhouseValue v1 v2 v3 v4 v5 v6 v7) => ClickhouseColumns a (T7 (Column a t) v1 v2 v3 v4 v5 v6 v7) where\n  type ColumnsType a (T7 (Column a t) v1 v2 v3 v4 v5 v6 v7) = (v1, v2, v3, v4, v5, v6, v7)\n  showClickhouseColumns _ = zipColumnsWithSynonyms7\n  parseColumns _ = parseColumns7\n\n-- we need to create map of values with different types\ndata NotSpecified\n\nparseColumns1 ::\n  forall a t v1.\n  ClickhouseValue v1 =>\n  Column a t v1 ->\n  A.Value ->\n  SubQueryLevel ->\n  Either String v1\nparseColumns1 c1 json l = do\n  mapResult <- eitherResult . A.fromJSON @(A.KeyMap (Value NotSpecified)) $ json\n  parseValueFromMap @a @t @v1 1 c1 mapResult l\n\nparseColumns2 ::\n  forall a t v1 v2.\n  (C2 ClickhouseValue v1 v2) =>\n  T2 (Column a t) v1 v2 ->\n  A.Value ->\n  SubQueryLevel ->\n  Either String (v1, v2)\nparseColumns2 (c1, c2) json l = do\n  mapResult <- eitherResult . A.fromJSON @(A.KeyMap (Value NotSpecified)) $ json\n  v1 <- parseValueFromMap @a @t @v1 1 c1 mapResult l\n  v2 <- parseValueFromMap @a @t @v2 2 c2 mapResult l\n  pure (v1, v2)\n\nparseColumns3 ::\n  forall a t v1 v2 v3.\n  (C3 ClickhouseValue v1 v2 v3) =>\n  T3 (Column a t) v1 v2 v3 ->\n  A.Value ->\n  SubQueryLevel ->\n  Either String (v1, v2, v3)\nparseColumns3 (c1, c2, c3) json l = do\n  mapResult <- eitherResult . A.fromJSON @(A.KeyMap (Value NotSpecified)) $ json\n  v1 <- parseValueFromMap @a @t @v1 1 c1 mapResult l\n  v2 <- parseValueFromMap @a @t @v2 2 c2 mapResult l\n  v3 <- parseValueFromMap @a @t @v3 3 c3 mapResult l\n  pure (v1, v2, v3)\n\nparseColumns4 ::\n  forall a t v1 v2 v3 v4.\n  (C4 ClickhouseValue v1 v2 v3 v4) =>\n  T4 (Column a t) v1 v2 v3 v4 ->\n  A.Value ->\n  SubQueryLevel ->\n  Either String (v1, v2, v3, v4)\nparseColumns4 (c1, c2, c3, c4) json l = do\n  mapResult <- eitherResult . A.fromJSON @(A.KeyMap (Value NotSpecified)) $ json\n  v1 <- parseValueFromMap @a @t @v1 1 c1 mapResult l\n  v2 <- parseValueFromMap @a @t @v2 2 c2 mapResult l\n  v3 <- parseValueFromMap @a @t @v3 3 c3 mapResult l\n  v4 <- parseValueFromMap @a @t @v4 4 c4 mapResult l\n  pure (v1, v2, v3, v4)\n\nparseColumns5 ::\n  forall a t v1 v2 v3 v4 v5.\n  (C5 ClickhouseValue v1 v2 v3 v4 v5) =>\n  T5 (Column a t) v1 v2 v3 v4 v5 ->\n  A.Value ->\n  SubQueryLevel ->\n  Either String (v1, v2, v3, v4, v5)\nparseColumns5 (c1, c2, c3, c4, c5) json l = do\n  mapResult <- eitherResult . A.fromJSON @(A.KeyMap (Value NotSpecified)) $ json\n  v1 <- parseValueFromMap @a @t @v1 1 c1 mapResult l\n  v2 <- parseValueFromMap @a @t @v2 2 c2 mapResult l\n  v3 <- parseValueFromMap @a @t @v3 3 c3 mapResult l\n  v4 <- parseValueFromMap @a @t @v4 4 c4 mapResult l\n  v5 <- parseValueFromMap @a @t @v5 5 c5 mapResult l\n  pure (v1, v2, v3, v4, v5)\n\nparseColumns6 ::\n  forall a t v1 v2 v3 v4 v5 v6.\n  (C6 ClickhouseValue v1 v2 v3 v4 v5 v6) =>\n  T6 (Column a t) v1 v2 v3 v4 v5 v6 ->\n  A.Value ->\n  SubQueryLevel ->\n  Either String (v1, v2, v3, v4, v5, v6)\nparseColumns6 (c1, c2, c3, c4, c5, c6) json l = do\n  mapResult <- eitherResult . A.fromJSON @(A.KeyMap (Value NotSpecified)) $ json\n  v1 <- parseValueFromMap @a @t @v1 1 c1 mapResult l\n  v2 <- parseValueFromMap @a @t @v2 2 c2 mapResult l\n  v3 <- parseValueFromMap @a @t @v3 3 c3 mapResult l\n  v4 <- parseValueFromMap @a @t @v4 4 c4 mapResult l\n  v5 <- parseValueFromMap @a @t @v5 5 c5 mapResult l\n  v6 <- parseValueFromMap @a @t @v6 6 c6 mapResult l\n  pure (v1, v2, v3, v4, v5, v6)\n\nparseColumns7 ::\n  forall a t v1 v2 v3 v4 v5 v6 v7.\n  (C7 ClickhouseValue v1 v2 v3 v4 v5 v6 v7) =>\n  T7 (Column a t) v1 v2 v3 v4 v5 v6 v7 ->\n  A.Value ->\n  SubQueryLevel ->\n  Either String (v1, v2, v3, v4, v5, v6, v7)\nparseColumns7 (c1, c2, c3, c4, c5, c6, c7) json l = do\n  mapResult <- eitherResult . A.fromJSON @(A.KeyMap (Value NotSpecified)) $ json\n  v1 <- parseValueFromMap @a @t @v1 1 c1 mapResult l\n  v2 <- parseValueFromMap @a @t @v2 2 c2 mapResult l\n  v3 <- parseValueFromMap @a @t @v3 3 c3 mapResult l\n  v4 <- parseValueFromMap @a @t @v4 4 c4 mapResult l\n  v5 <- parseValueFromMap @a @t @v5 5 c5 mapResult l\n  v6 <- parseValueFromMap @a @t @v6 6 c6 mapResult l\n  v7 <- parseValueFromMap @a @t @v7 7 c7 mapResult l\n  pure (v1, v2, v3, v4, v5, v6, v7)\n\n-- FIXME should parse Numbers also\nparseValueFromMap ::\n  forall a t v.\n  (ClickhouseValue v) =>\n  ColumnNumber ->\n  Column a t v ->\n  A.KeyMap (Value NotSpecified) ->\n  SubQueryLevel ->\n  Either String v\nparseValueFromMap n column mapResult l = do\n  let columnName = showColumn column\n  val <- case A.lookup (fromString $ getColumnSynonym n l) mapResult of\n    Nothing -> Left $ \"Key \\\"\" <> getColumnSynonym n l <> \"\\\" for column \\\"\" <> columnName <> \"\\\" did not found\"\n    Just val -> pure $ coerce @(Value NotSpecified) @(Value v) val\n  either (\\err -> Left $ \"Failed to parse key \\\"\" <> getColumnSynonym n l <> \"\\\" for column \\\"\" <> columnName <> \"\\\": \" <> err) pure $\n    getExcept $ fromClickhouseValue @v val\n\nzipColumnsWithSynonyms1 :: Column a t v1 -> SubQueryLevel -> String\nzipColumnsWithSynonyms1 c1 = zipColumns [showColumn c1]\n\nzipColumnsWithSynonyms2 :: T2 (Column a t) v1 v2 -> SubQueryLevel -> String\nzipColumnsWithSynonyms2 (c1, c2) = zipColumns [showColumn c1, showColumn c2]\n\nzipColumnsWithSynonyms3 :: T3 (Column a t) v1 v2 v3 -> SubQueryLevel -> String\nzipColumnsWithSynonyms3 (c1, c2, c3) = zipColumns [showColumn c1, showColumn c2, showColumn c3]\n\nzipColumnsWithSynonyms4 :: T4 (Column a t) v1 v2 v3 v4 -> SubQueryLevel -> String\nzipColumnsWithSynonyms4 (c1, c2, c3, c4) = zipColumns [showColumn c1, showColumn c2, showColumn c3, showColumn c4]\n\nzipColumnsWithSynonyms5 :: T5 (Column a t) v1 v2 v3 v4 v5 -> SubQueryLevel -> String\nzipColumnsWithSynonyms5 (c1, c2, c3, c4, c5) = zipColumns [showColumn c1, showColumn c2, showColumn c3, showColumn c4, showColumn c5]\n\nzipColumnsWithSynonyms6 :: T6 (Column a t) v1 v2 v3 v4 v5 v6 -> SubQueryLevel -> String\nzipColumnsWithSynonyms6 (c1, c2, c3, c4, c5, c6) = zipColumns [showColumn c1, showColumn c2, showColumn c3, showColumn c4, showColumn c5, showColumn c6]\n\nzipColumnsWithSynonyms7 :: T7 (Column a t) v1 v2 v3 v4 v5 v6 v7 -> SubQueryLevel -> String\nzipColumnsWithSynonyms7 (c1, c2, c3, c4, c5, c6, c7) = zipColumns [showColumn c1, showColumn c2, showColumn c3, showColumn c4, showColumn c5, showColumn c6, showColumn c7]\n\nzipColumns :: [String] -> SubQueryLevel -> String\nzipColumns columns l = List.intercalate \", \" $ zipWith (\\n column -> column <> \" as \" <> getColumnSynonym n l) [1 ..] columns\n",
      "hash": "0613a844e4ec74a7cc87df79541df2d502da76c7b042b59d4f72e90e4a219853",
      "size": 9338
    },
    "/lib/mobility-core/src/Kernel/Storage/ClickhouseV2/Internal/ClickhouseQuery.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n{-# OPTIONS_GHC -Wno-orphans #-}\n\nmodule Kernel.Storage.ClickhouseV2.Internal.ClickhouseQuery\n  ( ClickhouseQuery (toClickhouseQuery),\n    RawQuery (..),\n  )\nwhere\n\nimport qualified Data.Char as C\nimport qualified Data.List as List\nimport Data.Typeable (typeRep)\nimport Kernel.Prelude\nimport Kernel.Storage.ClickhouseV2.ClickhouseDb\nimport Kernel.Storage.ClickhouseV2.ClickhouseTable\nimport Kernel.Storage.ClickhouseV2.ClickhouseValue\nimport Kernel.Storage.ClickhouseV2.Internal.Types\nimport Kernel.Utils.JSON (camelToSnakeCase)\n\ninstance\n  ( ClickhouseDb db,\n    ClickhouseTable t,\n    ClickhouseColumns a cols,\n    ClickhouseQuery gr,\n    ClickhouseQuery ord,\n    ClickhouseQuery (AvailableColumns db t acols)\n  ) =>\n  ClickhouseQuery (Select a db t cols gr ord acols)\n  where\n  toClickhouseQuery (Select cols groupBy q) = do\n    let selectModifier = case fromMaybe (getSelectModifier (Proxy @t)) q.selectModifierOverrideQ of\n          NO_SELECT_MODIFIER -> \"\"\n          SELECT_FINAL_MODIFIER -> \" FINAL \"\n    \"SELECT \"\n      <> RawQuery (showClickhouseColumns @a @cols (Proxy @a) cols q.subQueryLevelQ)\n      <> \" FROM \"\n      <> toClickhouseQuery @(AvailableColumns db t acols) q.tableQ\n      <> selectModifier\n      <> mkMaybeClause @(Where t) (q.whereQ <&> ($ cols))\n      <> toClickhouseQuery @(GroupBy a gr) groupBy\n      <> mkMaybeClause @(OrderBy ord) (q.orderByQ <&> ($ cols))\n      <> mkMaybeClause @Limit q.limitQ\n      <> mkMaybeClause @Offset q.offsetQ\n\nmkMaybeClause :: forall expr. ClickhouseQuery expr => Maybe expr -> RawQuery\nmkMaybeClause = maybe mempty (toClickhouseQuery @expr)\n\ndropBeforeDot :: String -> String\ndropBeforeDot str = case dropWhile (/= '.') str of\n  [] -> str\n  (_ : rest) -> rest\n\ninstance ClickhouseTable t => ClickhouseQuery (Where t) where\n  toClickhouseQuery (Where clause) = \" WHERE \" <> addBrackets (toClickhouseQuery @(Clause t) clause)\n\ninstance (ClickhouseTable t) => ClickhouseQuery (Clause t) where\n  toClickhouseQuery (And clause1 clause2) = addBrackets (toClickhouseQuery @(Clause t) clause1) <> \" AND \" <> addBrackets (toClickhouseQuery @(Clause t) clause2)\n  toClickhouseQuery (Or clause1 clause2) = addBrackets (toClickhouseQuery @(Clause t) clause1) <> \" OR \" <> addBrackets (toClickhouseQuery @(Clause t) clause2)\n  toClickhouseQuery (Not clause) = \"NOT \" <> addBrackets (toClickhouseQuery @(Clause t) clause)\n  toClickhouseQuery (Is column term) = toClickhouseQuery @(Column _ t _) column <> toClickhouseQuery @(Term _) term\n  toClickhouseQuery (Val b) = RawQuery $ C.toLower <$> show @String @Bool b\n\ninstance ClickhouseValue value => ClickhouseQuery (Term value) where\n  toClickhouseQuery (In valList) = \" IN \" <> (addBrackets . intercalate \",\" . (valToClickhouseQuery @value <$>) $ toList valList)\n  toClickhouseQuery (Eq term) = \"=\" <> valToClickhouseQuery @value term\n  toClickhouseQuery NullTerm = \" IS NULL\"\n  toClickhouseQuery NotNullTerm = \" IS NOT NULL\"\n  toClickhouseQuery (NotEq term) = \"!=\" <> valToClickhouseQuery @value term\n  toClickhouseQuery (GreaterThan term) = \">\" <> valToClickhouseQuery @value term\n  toClickhouseQuery (GreaterOrEqualThan term) = \">=\" <> valToClickhouseQuery @value term\n  toClickhouseQuery (LessThan term) = \"<\" <> valToClickhouseQuery @value term\n  toClickhouseQuery (LessOrEqualThan term) = \"<=\" <> valToClickhouseQuery @value term\n  toClickhouseQuery (Like term) = \" LIKE \" <> valToClickhouseQuery @value term\n\n-- do we need quotes for each datatype?\nvalToClickhouseQuery :: forall value. ClickhouseValue value => value -> RawQuery\nvalToClickhouseQuery = toClickhouseQuery @(Value value) . toClickhouseValue @value\n\ninstance ClickhouseValue value => ClickhouseQuery (Value value) where\n  toClickhouseQuery = RawQuery . valToString\n\nintercalate :: RawQuery -> [RawQuery] -> RawQuery\nintercalate x = RawQuery . List.intercalate (getRawQuery x) . (getRawQuery <$>)\n\naddBrackets :: RawQuery -> RawQuery\naddBrackets rq = \"(\" <> rq <> \")\"\n\ninstance ClickhouseQuery Limit where\n  toClickhouseQuery (Limit val) = \" LIMIT \" <> show val\n\ninstance ClickhouseQuery Offset where\n  toClickhouseQuery (Offset val) = \" OFFSET \" <> show val\n\ninstance ClickhouseQuery NotOrdered where\n  toClickhouseQuery _ = mempty\n\ninstance ClickhouseQuery ord => ClickhouseQuery (OrderBy ord) where\n  toClickhouseQuery (OrderBy Asc column) = \" ORDER BY \" <> toClickhouseQuery @ord column <> \" ASC\"\n  toClickhouseQuery (OrderBy Desc column) = \" ORDER BY \" <> toClickhouseQuery @ord column <> \" DESC\"\n\ninstance ClickhouseQuery NotGrouped where\n  toClickhouseQuery _ = mempty\n\ninstance ClickhouseQuery NoColumns where\n  toClickhouseQuery _ = mempty\n\ninstance ClickhouseQuery gr => ClickhouseQuery (GroupBy a gr) where\n  toClickhouseQuery (GroupBy gr) = \" GROUP BY \" <> toClickhouseQuery gr\n  toClickhouseQuery Aggregate = mempty\n  toClickhouseQuery NotGrouped = mempty\n\ninstance ClickhouseTable t => ClickhouseQuery (Column a t value) where\n  toClickhouseQuery = fromString . showColumn\n\ninstance ClickhouseTable t => ClickhouseQuery (T2 (Column a t) v1 v2) where\n  toClickhouseQuery (c1, c2) = intercalate \", \" [toClickhouseQuery c1, toClickhouseQuery c2]\n\ninstance ClickhouseTable t => ClickhouseQuery (T3 (Column a t) v1 v2 v3) where\n  toClickhouseQuery (c1, c2, c3) = intercalate \", \" [toClickhouseQuery c1, toClickhouseQuery c2, toClickhouseQuery c3]\n\ninstance ClickhouseTable t => ClickhouseQuery (T4 (Column a t) v1 v2 v3 v4) where\n  toClickhouseQuery (c1, c2, c3, c4) = intercalate \", \" [toClickhouseQuery c1, toClickhouseQuery c2, toClickhouseQuery c3, toClickhouseQuery c4]\n\ninstance ClickhouseTable t => ClickhouseQuery (T5 (Column a t) v1 v2 v3 v4 v5) where\n  toClickhouseQuery (c1, c2, c3, c4, c5) = intercalate \", \" [toClickhouseQuery c1, toClickhouseQuery c2, toClickhouseQuery c3, toClickhouseQuery c4, toClickhouseQuery c5]\n\ninstance ClickhouseTable t => ClickhouseQuery (T6 (Column a t) v1 v2 v3 v4 v5 v6) where\n  toClickhouseQuery (c1, c2, c3, c4, c5, c6) = intercalate \", \" [toClickhouseQuery c1, toClickhouseQuery c2, toClickhouseQuery c3, toClickhouseQuery c4, toClickhouseQuery c5, toClickhouseQuery c6]\n\ninstance ClickhouseTable t => ClickhouseQuery (AvailableAllColumns db t) where\n  toClickhouseQuery _ = do\n    let tableName = dropBeforeDot $ camelToSnakeCase . dropTSuffix . show $ typeRep (Proxy @t)\n    fromString tableName\n    where\n      dropTSuffix str = take (length str - 1) str\n\ninstance ClickhouseQuery (AvailableSubSelectColumns db t subcols) where\n  toClickhouseQuery (AvailableColumns (SubSelectColumns subSelect)) = addBrackets . toClickhouseQuery $ subSelect\n",
      "hash": "4f173ca50f777be34748756c4767044b099e42fb5dd632b4d45cb9eac0acca45",
      "size": 7261
    },
    "/lib/mobility-core/src/Kernel/Storage/ClickhouseV2/Internal/Types.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n{-# LANGUAGE DerivingStrategies #-}\n{-# LANGUAGE GeneralizedNewtypeDeriving #-}\n\nmodule Kernel.Storage.ClickhouseV2.Internal.Types where\n\nimport qualified Data.Aeson.Types as A\nimport Data.Kind (Constraint)\nimport qualified Data.Time as Time\nimport Kernel.Prelude\nimport Kernel.Storage.ClickhouseV2.ClickhouseDb\nimport Kernel.Storage.ClickhouseV2.ClickhouseTable\nimport Kernel.Storage.ClickhouseV2.ClickhouseValue\n\ndata Select a db table cols gr ord acols where\n  Select :: (ClickhouseTable table, ClickhouseColumns a cols) => cols -> GroupBy a gr -> Q db table cols ord acols -> Select a db table cols gr ord acols\n\nclass ClickhouseColumns (a :: IsAggregated) cols where\n  type ColumnsType a cols\n  showClickhouseColumns :: Proxy a -> cols -> SubQueryLevel -> String\n  parseColumns :: Proxy a -> cols -> A.Value -> SubQueryLevel -> Either String (ColumnsType a cols)\n\nnewtype RawQuery = RawQuery {getRawQuery :: String}\n  deriving newtype (IsString, Semigroup, Monoid)\n\nclass ClickhouseQuery expr where\n  toClickhouseQuery :: expr -> RawQuery\n\ndata IsAggregated = AGG | NOT_AGG\n\nclass ClickhouseValue v => ClickhouseNum v\n\ninstance (ClickhouseValue v, Num v) => ClickhouseNum v\n\ninstance {-# OVERLAPPING #-} (ClickhouseValue v, Num v) => ClickhouseNum (Maybe v)\n\ndata Column (a :: IsAggregated) t v where\n  Column :: (ClickhouseTable t) => FieldModification t v -> Column 'NOT_AGG t v -- initial column\n  Group :: (ClickhouseTable t, ClickhouseValue v) => Column 'NOT_AGG t v -> Column 'AGG t v -- column from groupBy clause\n  SubColumn :: (ClickhouseTable t, ClickhouseValue v) => Column a t v -> ColumnNumber -> SubQueryLevel -> Column 'NOT_AGG t v -- column synonym will be generated based on these two guys SubQueryLevel and ColumnNumber\n  Sum :: (ClickhouseTable t, ClickhouseNum v) => Column 'NOT_AGG t v -> Column 'AGG t v\n  Avg :: (ClickhouseTable t, ClickhouseNum v) => Column 'NOT_AGG t v -> Column 'AGG t v\n  Count :: (ClickhouseTable t, ClickhouseValue v, ClickhouseValue Int) => Column 'NOT_AGG t v -> Column 'AGG t Int\n  Distinct :: (ClickhouseTable t, ClickhouseValue v) => Column a t v -> Column a t v -- should not be used in where clause\n  Max :: (ClickhouseTable t, ClickhouseValue v) => Column a t v -> Column a t v\n  Add :: (ClickhouseTable t, ClickhouseNum v) => Column a t v -> Column a t v -> Column a t v\n  CoerceNum :: (ClickhouseTable t, ClickhouseNum v1, ClickhouseNum v2) => Column a t v1 -> Column a t v2\n  ToDate :: (ClickhouseTable t, ClickhouseValue DateTime, ClickhouseValue Time.Day) => Column a t DateTime -> Column a t Time.Day -- FIXME create some generic constructor for different clickhouse functions\n  ToHour :: (ClickhouseTable t, ClickhouseValue DateTime, ClickhouseValue Int) => Column a t DateTime -> Column a t Int\n  TimeDiff :: (ClickhouseTable t, ClickhouseValue UTCTime, ClickhouseValue UTCTime, ClickhouseValue Int) => Column a t UTCTime -> Column a t UTCTime -> Column a t Int\n  ToStartOfWeek :: (ClickhouseTable t, ClickhouseValue Time.Day, ClickhouseValue Int) => Column a t Time.Day -> Column a t Int -> Column a t Time.Day\n  ToStartOfMonth :: (ClickhouseTable t, ClickhouseValue Time.Day) => Column a t Time.Day -> Column a t Time.Day\n  ValColumn :: (ClickhouseTable t, ClickhouseValue v) => v -> Column a t v\n  If :: (ClickhouseTable t, ClickhouseValue v) => Column a t Bool -> Column a t v -> Column a t v -> Column a t v\n  Case :: (ClickhouseTable t, ClickhouseValue v) => NonEmpty (Column a t Bool, Column a t v) -> Column a t v -> Column a t v -- only boolean conditions available for now\n  EqColumn :: (ClickhouseTable t, ClickhouseValue v) => Column a t v -> Column a t v -> Column a t Bool\n  ArgMax :: (ClickhouseTable t, ClickhouseValue v1, ClickhouseValue v2) => Column 'NOT_AGG t v1 -> Column 'NOT_AGG t v2 -> Column 'AGG t v1\n  AndColumn :: (ClickhouseTable t, ClickhouseValue Bool) => Column a t Bool -> Column a t Bool -> Column a t Bool\n  OrColumn :: (ClickhouseTable t, ClickhouseValue Bool) => Column a t Bool -> Column a t Bool -> Column a t Bool\n  GreaterOrEqual :: (ClickhouseTable t, ClickhouseValue v) => Column a t v -> Column a t v -> Column a t Bool\n  LessOrEqual :: (ClickhouseTable t, ClickhouseValue v) => Column a t v -> Column a t v -> Column a t Bool\n  Greater :: (ClickhouseTable t, ClickhouseValue v) => Column a t v -> Column a t v -> Column a t Bool\n  Less :: (ClickhouseTable t, ClickhouseValue v) => Column a t v -> Column a t v -> Column a t Bool\n\nmkTableColumns :: ClickhouseTable t => FieldModifications t -> Columns 'NOT_AGG t\nmkTableColumns = mapTable Column\n\ntype Columns a table = table (Column a table)\n\ndata Clause table where\n  And :: ClickhouseTable table => Clause table -> Clause table -> Clause table\n  Or :: ClickhouseTable table => Clause table -> Clause table -> Clause table\n  Not :: ClickhouseTable table => Clause table -> Clause table\n  Is :: (ClickhouseTable table, ClickhouseValue value) => Column a table value -> Term value -> Clause table\n  Val :: (ClickhouseTable table, ClickhouseValue Bool) => Bool -> Clause table\n\ndata Term value where\n  In :: ClickhouseValue value => NonEmpty value -> Term value\n  NullTerm :: ClickhouseValue value => Term (Maybe value)\n  NotNullTerm :: ClickhouseValue value => Term (Maybe value)\n  Eq :: ClickhouseValue value => value -> Term value\n  NotEq :: ClickhouseValue value => value -> Term value\n  GreaterThan :: ClickhouseValue value => value -> Term value\n  GreaterOrEqualThan :: ClickhouseValue value => value -> Term value\n  LessThan :: ClickhouseValue value => value -> Term value\n  LessOrEqualThan :: ClickhouseValue value => value -> Term value\n  Like :: Text -> Term Text\n\nnewtype Where table = Where (Clause table)\n\nclass IsGroupColumns cols where\n  type GroupColumnsType cols\n  groupColumns :: cols -> GroupColumnsType cols\n\ninstance (ClickhouseTable t, ClickhouseValue v) => IsGroupColumns (Column 'NOT_AGG t v) where\n  type GroupColumnsType (Column 'NOT_AGG t v) = Column 'AGG t v\n  groupColumns = Group @t @v\n\ninstance (ClickhouseTable t, C2 ClickhouseValue v1 v2) => IsGroupColumns (T2 (Column 'NOT_AGG t) v1 v2) where\n  type GroupColumnsType (T2 (Column 'NOT_AGG t) v1 v2) = (T2 (Column 'AGG t) v1 v2)\n  groupColumns (c1, c2) = (Group @t @v1 c1, Group @t @v2 c2)\n\ninstance (ClickhouseTable t, C3 ClickhouseValue v1 v2 v3) => IsGroupColumns (T3 (Column 'NOT_AGG t) v1 v2 v3) where\n  type GroupColumnsType (T3 (Column 'NOT_AGG t) v1 v2 v3) = (T3 (Column 'AGG t) v1 v2 v3)\n  groupColumns (c1, c2, c3) = (Group @t @v1 c1, Group @t @v2 c2, Group @t @v3 c3)\n\ninstance (ClickhouseTable t, C4 ClickhouseValue v1 v2 v3 v4) => IsGroupColumns (T4 (Column 'NOT_AGG t) v1 v2 v3 v4) where\n  type GroupColumnsType (T4 (Column 'NOT_AGG t) v1 v2 v3 v4) = (T4 (Column 'AGG t) v1 v2 v3 v4)\n  groupColumns (c1, c2, c3, c4) = (Group @t @v1 c1, Group @t @v2 c2, Group @t @v3 c3, Group @t @v4 c4)\n\ninstance (ClickhouseTable t, C5 ClickhouseValue v1 v2 v3 v4 v5) => IsGroupColumns (T5 (Column 'NOT_AGG t) v1 v2 v3 v4 v5) where\n  type GroupColumnsType (T5 (Column 'NOT_AGG t) v1 v2 v3 v4 v5) = (T5 (Column 'AGG t) v1 v2 v3 v4 v5)\n  groupColumns (c1, c2, c3, c4, c5) = (Group @t @v1 c1, Group @t @v2 c2, Group @t @v3 c3, Group @t @v4 c4, Group @t @v5 c5)\n\ninstance (ClickhouseTable t, C6 ClickhouseValue v1 v2 v3 v4 v5 v6) => IsGroupColumns (T6 (Column 'NOT_AGG t) v1 v2 v3 v4 v5 v6) where\n  type GroupColumnsType (T6 (Column 'NOT_AGG t) v1 v2 v3 v4 v5 v6) = (T6 (Column 'AGG t) v1 v2 v3 v4 v5 v6)\n  groupColumns (c1, c2, c3, c4, c5, c6) = (Group @t @v1 c1, Group @t @v2 c2, Group @t @v3 c3, Group @t @v4 c4, Group @t @v5 c5, Group @t @v6 c6)\n\n-- we need to reset group columns for subqueries, thus we can group twice, first time in subquery, second time in main query\nclass MkSubColumns cols where\n  type SubColumnsType cols\n  subColumnsValue :: cols -> SubQueryLevel -> SubColumnsType cols\n\ninstance (ClickhouseTable t, ClickhouseValue v) => MkSubColumns (Column a t v) where\n  type SubColumnsType (Column a t v) = Column 'NOT_AGG t v\n  subColumnsValue c l = SubColumn @t @v c 1 l\n\ninstance (ClickhouseTable t, C2 ClickhouseValue v1 v2) => MkSubColumns (T2 (Column a t) v1 v2) where\n  type SubColumnsType (T2 (Column a t) v1 v2) = (T2 (Column 'NOT_AGG t) v1 v2)\n  subColumnsValue (c1, c2) l = (SubColumn @t @v1 c1 1 l, SubColumn @t @v2 c2 2 l)\n\ninstance (ClickhouseTable t, C3 ClickhouseValue v1 v2 v3) => MkSubColumns (T3 (Column a t) v1 v2 v3) where\n  type SubColumnsType (T3 (Column a t) v1 v2 v3) = (T3 (Column 'NOT_AGG t) v1 v2 v3)\n  subColumnsValue (c1, c2, c3) l = (SubColumn @t @v1 c1 1 l, SubColumn @t @v2 c2 2 l, SubColumn @t @v3 c3 3 l)\n\ninstance (ClickhouseTable t, C4 ClickhouseValue v1 v2 v3 v4) => MkSubColumns (T4 (Column a t) v1 v2 v3 v4) where\n  type SubColumnsType (T4 (Column a t) v1 v2 v3 v4) = (T4 (Column 'NOT_AGG t) v1 v2 v3 v4)\n  subColumnsValue (c1, c2, c3, c4) l = (SubColumn @t @v1 c1 1 l, SubColumn @t @v2 c2 2 l, SubColumn @t @v3 c3 3 l, SubColumn @t @v4 c4 4 l)\n\ninstance (ClickhouseTable t, C5 ClickhouseValue v1 v2 v3 v4 v5) => MkSubColumns (T5 (Column a t) v1 v2 v3 v4 v5) where\n  type SubColumnsType (T5 (Column a t) v1 v2 v3 v4 v5) = (T5 (Column 'NOT_AGG t) v1 v2 v3 v4 v5)\n  subColumnsValue (c1, c2, c3, c4, c5) l = (SubColumn @t @v1 c1 1 l, SubColumn @t @v2 c2 2 l, SubColumn @t @v3 c3 3 l, SubColumn @t @v4 c4 4 l, SubColumn @t @v5 c5 5 l)\n\ninstance (ClickhouseTable t, C6 ClickhouseValue v1 v2 v3 v4 v5 v6) => MkSubColumns (T6 (Column a t) v1 v2 v3 v4 v5 v6) where\n  type SubColumnsType (T6 (Column a t) v1 v2 v3 v4 v5 v6) = (T6 (Column 'NOT_AGG t) v1 v2 v3 v4 v5 v6)\n  subColumnsValue (c1, c2, c3, c4, c5, c6) l = (SubColumn @t @v1 c1 1 l, SubColumn @t @v2 c2 2 l, SubColumn @t @v3 c3 3 l, SubColumn @t @v4 c4 4 l, SubColumn @t @v5 c5 5 l, SubColumn @t @v6 c6 6 l)\n\ndata NotGrouped\n\ndata NoColumns\n\ndata GroupBy (a :: IsAggregated) gr where\n  GroupBy :: IsGroupColumns gr => gr -> GroupBy 'AGG gr\n  Aggregate :: GroupBy 'AGG NoColumns\n  NotGrouped :: GroupBy 'NOT_AGG NotGrouped\n\ndata OrderBy ord where\n  OrderBy :: IsOrderColumns ord => Order -> ord -> OrderBy ord\n\ndata NotOrdered\n\nclass IsOrderColumns cols\n\ninstance IsOrderColumns NotOrdered\n\ninstance (ClickhouseTable t, ClickhouseValue v) => IsOrderColumns (Column a t v)\n\ninstance (ClickhouseTable t, C2 ClickhouseValue v1 v2) => IsOrderColumns (T2 (Column a t) v1 v2)\n\ninstance (ClickhouseTable t, C3 ClickhouseValue v1 v2 v3) => IsOrderColumns (T3 (Column a t) v1 v2 v3)\n\ninstance (ClickhouseTable t, C4 ClickhouseValue v1 v2 v3 v4) => IsOrderColumns (T4 (Column a t) v1 v2 v3 v4)\n\ninstance (ClickhouseTable t, C5 ClickhouseValue v1 v2 v3 v4 v5) => IsOrderColumns (T5 (Column a t) v1 v2 v3 v4 v5)\n\ninstance (ClickhouseTable t, C6 ClickhouseValue v1 v2 v3 v4 v5 v6) => IsOrderColumns (T6 (Column a t) v1 v2 v3 v4 v5 v6)\n\ndata Q db table cols ord acols = (ClickhouseDb db) =>\n  Q\n  { tableQ :: AvailableColumns db table acols,\n    subQueryLevelQ :: SubQueryLevel,\n    whereQ :: Maybe (cols -> Where table),\n    limitQ :: Maybe Limit,\n    offsetQ :: Maybe Offset,\n    orderByQ :: Maybe (cols -> OrderBy ord),\n    selectModifierOverrideQ :: Maybe SelectModifier\n  }\n\nnewtype Offset = Offset Int\n\nnewtype Limit = Limit Int\n\ndata Order = Asc | Desc\n\nclass HasAvailableColumns (cols :: Type) where\n  type AvailableColumnsType cols\n  availableColumnsValue :: cols -> AvailableColumnsType cols\n\ninstance HasAvailableColumns (AllColumns db table) where\n  type AvailableColumnsType (AllColumns db table) = Columns 'NOT_AGG table\n  availableColumnsValue (AllColumns cols) = cols\n\ninstance HasAvailableColumns (SubSelectColumns db table subcols) where\n  type AvailableColumnsType (SubSelectColumns db table subcols) = SubColumnsType subcols\n  availableColumnsValue (SubSelectColumns (Select subcols _ q)) = subColumnsValue subcols q.subQueryLevelQ\n\ngetAvailableColumnsValue ::\n  AvailableColumns db table acols ->\n  AvailableColumnsType acols\ngetAvailableColumnsValue (AvailableColumns acols) = availableColumnsValue acols\n\ndata AvailableColumns db table acols where\n  AvailableColumns :: (ClickhouseDb db, ClickhouseTable table, HasAvailableColumns acols) => acols -> AvailableColumns db table acols\n\ndata AllColumns db table where\n  AllColumns :: (ClickhouseDb db, ClickhouseTable table) => Columns 'NOT_AGG table -> AllColumns db table\n\ndata SubSelectColumns db table subcols where\n  SubSelectColumns :: (ClickhouseDb db, ClickhouseTable table, ClickhouseQuery (Select a db table subcols gr ord acols), MkSubColumns subcols) => Select a db table subcols gr ord acols -> SubSelectColumns db table subcols\n\ntype AvailableAllColumns db table = AvailableColumns db table (AllColumns db table)\n\ntype AvailableSubSelectColumns db table subcols = AvailableColumns db table (SubSelectColumns db table subcols)\n\nshowColumn :: Column a t v -> String\nshowColumn (Column column) = getFieldModification column\nshowColumn (Group column) = showColumn column\nshowColumn (SubColumn _column n l) = getColumnSynonym n l\nshowColumn (Sum column) = \"SUM\" <> addBrackets' (showColumn column)\nshowColumn (Count column) = \"COUNT\" <> addBrackets' (showColumn column)\nshowColumn (Avg column) = \"AVG\" <> addBrackets' (showColumn column)\nshowColumn (Distinct column) = \"DISTINCT\" <> addBrackets' (showColumn column)\nshowColumn (Max column) = \"MAX\" <> addBrackets' (showColumn column)\nshowColumn (Add column1 column2) = addBrackets' (showColumn column1 <> \"+\" <> showColumn column2)\nshowColumn (CoerceNum column) = showColumn column\nshowColumn (ToDate column) = \"toDate\" <> addBrackets' (showColumn column)\nshowColumn (ToHour column) = \"toHour\" <> addBrackets' (showColumn column)\nshowColumn (ToStartOfWeek column1 column2) = \"toStartOfWeek\" <> addBrackets' (showColumn column1 <> \", \" <> showColumn column2)\nshowColumn (ToStartOfMonth column) = \"toStartOfMonth\" <> addBrackets' (showColumn column)\nshowColumn (TimeDiff column1 column2) = \"timeDiff\" <> addBrackets' (showColumn column1 <> \", \" <> showColumn column2)\nshowColumn (ValColumn v) = valToString . toClickhouseValue $ v\nshowColumn (If cond v1 v2) = \"if\" <> addBrackets' (showColumn cond <> \", \" <> showColumn v1 <> \", \" <> showColumn v2)\nshowColumn (Case whenThen else_) = addBrackets' $ \"CASE \" <> concat (fmap (\\(when_, then_) -> \"WHEN \" <> showColumn when_ <> \" THEN \" <> showColumn then_ <> \" \") whenThen) <> \"ELSE \" <> showColumn else_ <> \" END\"\nshowColumn (EqColumn column1 column2) = addBrackets' $ showColumn column1 <> \"=\" <> showColumn column2\nshowColumn (ArgMax arg value) = \"argMax\" <> addBrackets' (showColumn arg <> \", \" <> showColumn value)\nshowColumn (AndColumn column1 column2) = addBrackets' $ showColumn column1 <> \" AND \" <> showColumn column2\nshowColumn (OrColumn column1 column2) = addBrackets' $ showColumn column1 <> \" OR \" <> showColumn column2\nshowColumn (GreaterOrEqual column1 column2) = addBrackets' $ showColumn column1 <> \">=\" <> showColumn column2\nshowColumn (LessOrEqual column1 column2) = addBrackets' $ showColumn column1 <> \"<=\" <> showColumn column2\nshowColumn (Greater column1 column2) = addBrackets' $ showColumn column1 <> \">\" <> showColumn column2\nshowColumn (Less column1 column2) = addBrackets' $ showColumn column1 <> \"<\" <> showColumn column2\n\naddBrackets' :: String -> String\naddBrackets' rq = \"(\" <> rq <> \")\"\n\ntype T2 (c :: Type -> Type) x1 x2 = (c x1, c x2)\n\ntype T3 (c :: Type -> Type) x1 x2 x3 = (c x1, c x2, c x3)\n\ntype T4 (c :: Type -> Type) x1 x2 x3 x4 = (c x1, c x2, c x3, c x4)\n\ntype T5 (c :: Type -> Type) x1 x2 x3 x4 x5 = (c x1, c x2, c x3, c x4, c x5)\n\ntype T6 (c :: Type -> Type) x1 x2 x3 x4 x5 x6 = (c x1, c x2, c x3, c x4, c x5, c x6)\n\ntype T7 (c :: Type -> Type) x1 x2 x3 x4 x5 x6 x7 = (c x1, c x2, c x3, c x4, c x5, c x6, c x7)\n\ntype C2 (c :: Type -> Constraint) x1 x2 = (c x1, c x2)\n\ntype C3 (c :: Type -> Constraint) x1 x2 x3 = (c x1, c x2, c x3)\n\ntype C4 (c :: Type -> Constraint) x1 x2 x3 x4 = (c x1, c x2, c x3, c x4)\n\ntype C5 (c :: Type -> Constraint) x1 x2 x3 x4 x5 = (c x1, c x2, c x3, c x4, c x5)\n\ntype C6 (c :: Type -> Constraint) x1 x2 x3 x4 x5 x6 = (c x1, c x2, c x3, c x4, c x5, c x6)\n\ntype C7 (c :: Type -> Constraint) x1 x2 x3 x4 x5 x6 x7 = (c x1, c x2, c x3, c x4, c x5, c x6, c x7)\n\nnewtype SubQueryLevel = SubQueryLevel {getSubQueryLevel :: Int}\n  deriving newtype (Show, Num, Eq)\n\nnewtype ColumnNumber = ColumnNumber {getColumnNumber :: Int}\n  deriving newtype (Show, Num, Enum, Eq)\n\ngetColumnSynonym :: ColumnNumber -> SubQueryLevel -> String\ngetColumnSynonym n 0 = \"res\" <> show n\ngetColumnSynonym n l = \"res\" <> show n <> \"_sub\" <> show l\n",
      "hash": "42a27225307e76408e1ad92b1f73b1d03790110654a7a186c70575f6dbb9dada",
      "size": 17183
    },
    "/lib/mobility-core/src/Kernel/Storage/ClickhouseV2/Operators.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n\nmodule Kernel.Storage.ClickhouseV2.Operators where\n\nimport qualified Data.List.NonEmpty as NE\nimport qualified Data.Time as Time\nimport Kernel.Prelude\nimport Kernel.Storage.ClickhouseV2.ClickhouseDb\nimport Kernel.Storage.ClickhouseV2.ClickhouseTable\nimport Kernel.Storage.ClickhouseV2.ClickhouseValue\nimport Kernel.Storage.ClickhouseV2.Internal.ClickhouseColumns ()\nimport Kernel.Storage.ClickhouseV2.Internal.Types\n\n(==.) :: forall a table value. (ClickhouseTable table, ClickhouseValue value) => Column a table value -> value -> Clause table\n(==.) column value = column `Is` Eq value\n\n(!=.) :: forall a table value. (ClickhouseTable table, ClickhouseValue value) => Column a table value -> value -> Clause table\n(!=.) column value = column `Is` NotEq value\n\n(>.) :: forall a table value. (ClickhouseTable table, ClickhouseValue value) => Column a table value -> value -> Clause table\n(>.) column value = column `Is` GreaterThan value\n\n(<.) :: forall a table value. (ClickhouseTable table, ClickhouseValue value) => Column a table value -> value -> Clause table\n(<.) column value = column `Is` LessThan value\n\n(>=.) :: forall a table value. (ClickhouseTable table, ClickhouseValue value) => Column a table value -> value -> Clause table\n(>=.) column value = column `Is` GreaterOrEqualThan value\n\n(<=.) :: forall a table value. (ClickhouseTable table, ClickhouseValue value) => Column a table value -> value -> Clause table\n(<=.) column value = column `Is` LessOrEqualThan value\n\ninfix 4 ==., >., <., >=., <=.\n\n(&&.) :: forall table. ClickhouseTable table => Clause table -> Clause table -> Clause table\n(&&.) = And\n\ninfixr 3 &&.\n\n(||.) :: forall table. ClickhouseTable table => Clause table -> Clause table -> Clause table\n(||.) = Or\n\ninfixr 2 ||.\n\nnot_ :: forall table. ClickhouseTable table => Clause table -> Clause table\nnot_ = Not\n\nval_ :: forall table. (ClickhouseTable table, ClickhouseValue Bool) => Bool -> Clause table\nval_ = Val\n\nvalColumn :: forall a t v. (ClickhouseTable t, ClickhouseValue v) => v -> Column a t v\nvalColumn = ValColumn\n\nin_ :: forall a table value. (ClickhouseTable table, ClickhouseValue value) => Column a table value -> [value] -> Clause table\nin_ _column [] = val_ False\nin_ column (value1 : values) = column `Is` In (value1 NE.:| values)\n\nisNull :: forall a table value. (ClickhouseTable table, ClickhouseValue value) => Column a table (Maybe value) -> Clause table\nisNull column = Is column NullTerm\n\nisNotNull :: forall a table value. (ClickhouseTable table, ClickhouseValue value) => Column a table (Maybe value) -> Clause table\nisNotNull column = Is column NotNullTerm\n\nselect ::\n  forall db table ord.\n  ClickhouseTable table =>\n  Q db table (Columns 'NOT_AGG table) ord (AllColumns db table) ->\n  Select 'NOT_AGG db table (Columns 'NOT_AGG table) NotGrouped ord (AllColumns db table)\nselect q = Select (getAvailableColumnsValue q.tableQ) NotGrouped q\n\nselect_ ::\n  forall a db table cols gr ord acols.\n  (ClickhouseTable table, ClickhouseColumns a cols) =>\n  (AvailableColumnsType acols -> (cols, GroupBy a gr)) ->\n  Q db table cols ord acols ->\n  Select a db table cols gr ord acols\nselect_ colsClause q = do\n  let (cols, gr) = colsClause (getAvailableColumnsValue q.tableQ)\n  Select cols gr q\n\n-- FIXME Integer\nlimit_ :: Int -> Q db table cols ord subsel -> Q db table cols ord subsel\nlimit_ limitVal q = q {limitQ = Just $ Limit limitVal}\n\noffset_ :: Int -> Q db table cols ord subsel -> Q db table cols ord subsel\noffset_ offsetVal q = q {offsetQ = Just $ Offset offsetVal}\n\nselectModifierOverride :: SelectModifier -> Q db table cols ord subsel -> Q db table cols ord subsel\nselectModifierOverride selectModifier q = q {selectModifierOverrideQ = Just selectModifier}\n\norderBy_ ::\n  forall db table cols ord acols.\n  ClickhouseTable table =>\n  (AvailableColumnsType acols -> cols -> OrderBy ord) ->\n  Q db table cols NotOrdered acols ->\n  Q db table cols ord acols\norderBy_ orderByClause q = q {orderByQ = Just $ orderByClause $ getAvailableColumnsValue (tableQ q)}\n\nasc :: forall ord. IsOrderColumns ord => ord -> OrderBy ord\nasc = OrderBy Asc\n\ndesc :: forall ord. IsOrderColumns ord => ord -> OrderBy ord\ndesc = OrderBy Desc\n\ngroupBy :: forall cols gr. IsGroupColumns gr => gr -> (GroupColumnsType gr -> cols) -> (cols, GroupBy 'AGG gr)\ngroupBy gr mkCols = (mkCols (groupColumns gr), GroupBy gr)\n\naggregate :: forall cols. cols -> (cols, GroupBy 'AGG NoColumns)\naggregate cols = (cols, Aggregate)\n\nnotGrouped :: cols -> (cols, GroupBy 'NOT_AGG NotGrouped)\nnotGrouped cols = (cols, NotGrouped)\n\nall_ ::\n  forall db table.\n  (ClickhouseDb db, ClickhouseTable table) =>\n  FieldModifications table ->\n  (AvailableAllColumns db table, SubQueryLevel)\nall_ tableMod = (AvailableColumns $ AllColumns (mkTableColumns @table tableMod), 0)\n\nsubSelect_ ::\n  forall a db table subcols gr ord acols.\n  ( ClickhouseDb db,\n    ClickhouseTable table,\n    ClickhouseQuery (Select a db table subcols gr ord acols),\n    MkSubColumns subcols\n  ) =>\n  Select a db table subcols gr ord acols ->\n  (AvailableSubSelectColumns db table subcols, SubQueryLevel)\nsubSelect_ s@(Select _cols _gr q) = (AvailableColumns . SubSelectColumns $ s, q.subQueryLevelQ + 1)\n\nfilter_ ::\n  ClickhouseDb db =>\n  (AvailableColumnsType acols -> cols -> Clause table) ->\n  (AvailableColumns db table acols, SubQueryLevel) ->\n  Q db table cols NotOrdered acols\nfilter_ filterClause (table, level) =\n  Q\n    { tableQ = table,\n      subQueryLevelQ = level,\n      whereQ = Just $ Where . filterClause (getAvailableColumnsValue table),\n      limitQ = Nothing,\n      offsetQ = Nothing,\n      orderByQ = Nothing,\n      selectModifierOverrideQ = Nothing\n    }\n\nemptyFilter ::\n  ClickhouseDb db =>\n  (AvailableColumns db table acols, SubQueryLevel) ->\n  Q db table cols NotOrdered acols\nemptyFilter (table, level) =\n  Q\n    { tableQ = table,\n      subQueryLevelQ = level,\n      whereQ = Nothing,\n      limitQ = Nothing,\n      offsetQ = Nothing,\n      orderByQ = Nothing,\n      selectModifierOverrideQ = Nothing\n    }\n\nsum_ :: (ClickhouseTable table, ClickhouseNum value) => Column 'NOT_AGG table value -> Column 'AGG table value\nsum_ = Sum\n\navg_ :: (ClickhouseTable table, ClickhouseNum value) => Column 'NOT_AGG table value -> Column 'AGG table value\navg_ = Avg\n\ncount_ :: (ClickhouseTable table, ClickhouseValue value, ClickhouseValue Int) => Column 'NOT_AGG table value -> Column 'AGG table Int\ncount_ = Count\n\ndistinct :: (ClickhouseTable t, ClickhouseValue v) => Column a t v -> Column a t v\ndistinct = Distinct\n\nmax :: (ClickhouseTable t, ClickhouseValue v) => Column a t v -> Column a t v\nmax = Max\n\n(+.) :: (ClickhouseTable t, ClickhouseNum v) => Column a t v -> Column a t v -> Column a t v\n(+.) = Add\n\ninfixl 6 +.\n\n-- for example we can use for columns sum with different types\nunsafeCoerceNum :: forall v1 v2 a t. (ClickhouseTable t, ClickhouseNum v1, ClickhouseNum v2) => Column a t v1 -> Column a t v2\nunsafeCoerceNum = CoerceNum\n\nwhenJust_ :: ClickhouseTable t => Maybe a -> (a -> Clause t) -> Clause t\nwhenJust_ (Just a) mkClause = mkClause a\nwhenJust_ Nothing _ = val_ True\n\ntoDate :: (ClickhouseTable t, ClickhouseValue DateTime, ClickhouseValue Time.Day) => Column a t DateTime -> Column a t Time.Day\ntoDate = ToDate\n\ntoHour :: (ClickhouseTable t, ClickhouseValue DateTime, ClickhouseValue Int) => Column a t DateTime -> Column a t Int\ntoHour = ToHour\n\ntoStartOfWeek :: (ClickhouseTable t, ClickhouseValue Time.Day, ClickhouseValue Int) => Column a t Time.Day -> Column a t Int -> Column a t Time.Day\ntoStartOfWeek = ToStartOfWeek\n\ntoStartOfMonth :: (ClickhouseTable t, ClickhouseValue Time.Day) => Column a t Time.Day -> Column a t Time.Day\ntoStartOfMonth = ToStartOfMonth\n\ntimeDiff :: (ClickhouseTable t, ClickhouseValue UTCTime, ClickhouseValue UTCTime, ClickhouseValue Int) => Column a t UTCTime -> Column a t UTCTime -> Column a t Int\ntimeDiff = TimeDiff\n\nif_ :: (ClickhouseTable t, ClickhouseValue v) => Column a t Bool -> Column a t v -> Column a t v -> Column a t v\nif_ = If\n\ncase_ :: (ClickhouseTable t, ClickhouseValue v) => NonEmpty (Column a t Bool, Column a t v) -> Column a t v -> Column a t v\ncase_ = Case\n\n(==..) :: (ClickhouseTable t, ClickhouseValue v) => Column a t v -> Column a t v -> Column a t Bool\n(==..) = EqColumn\n\n(&&..) :: ClickhouseTable t => Column a t Bool -> Column a t Bool -> Column a t Bool\n(&&..) = AndColumn\n\n(||..) :: ClickhouseTable t => Column a t Bool -> Column a t Bool -> Column a t Bool\n(||..) = OrColumn\n\n(>..) :: (ClickhouseTable t, ClickhouseValue v) => Column a t v -> Column a t v -> Column a t Bool\n(>..) = Greater\n\n(<..) :: (ClickhouseTable t, ClickhouseValue v) => Column a t v -> Column a t v -> Column a t Bool\n(<..) = Less\n\n(>=..) :: (ClickhouseTable t, ClickhouseValue v) => Column a t v -> Column a t v -> Column a t Bool\n(>=..) = GreaterOrEqual\n\n(<=..) :: (ClickhouseTable t, ClickhouseValue v) => Column a t v -> Column a t v -> Column a t Bool\n(<=..) = LessOrEqual\n\ninfix 4 ==.., >.., <.., >=.., <=..\n\ninfixr 3 &&..\n\ninfixr 2 ||..\n\n-- | Calculates the 'arg' value for a maximum 'val' value.\n-- If there are multiple rows with equal 'val' being the maximum, which of the associated 'arg' is returned is not deterministic\nargMax ::\n  (ClickhouseTable t, ClickhouseValue v1, ClickhouseValue v2) =>\n  Column 'NOT_AGG t v1 -> -- 'arg'\n  Column 'NOT_AGG t v2 -> -- 'val'\n  Column 'AGG t v1\nargMax = ArgMax\n",
      "hash": "c1bf1a9fd69aac3cd52049867be5ac150cb824872509ed2efca0896f10a6bbc7",
      "size": 10066
    },
    "/lib/mobility-core/src/Kernel/Storage/ClickhouseV2/Queries.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n\nmodule Kernel.Storage.ClickhouseV2.Queries\n  ( findAll,\n    -- findOne,\n    runRawQuery,\n    RawQuery (..),\n  )\nwhere\n\nimport qualified Control.Concurrent.MVar as M\nimport qualified Data.Aeson as A\nimport qualified Data.Text as T\nimport qualified Data.Vector as V\nimport Database.ClickHouseDriver.HTTP\nimport qualified EulerHS.Language as L\nimport Kernel.Prelude\nimport Kernel.Storage.Clickhouse.Config\nimport Kernel.Storage.ClickhouseV2.ClickhouseDb\nimport Kernel.Storage.ClickhouseV2.Internal.ClickhouseQuery\nimport Kernel.Storage.ClickhouseV2.Internal.Types\nimport Kernel.Utils.Common hiding (Limit, Offset)\n\nfindAll ::\n  forall a db t m cols gr ord acols.\n  (HasClickhouseEnv db m, ClickhouseQuery (Select a db t cols gr ord acols)) =>\n  Select a db t cols gr ord acols ->\n  m [ColumnsType a cols]\nfindAll selectClause@(Select cols _ q) = do\n  let rawQuery = toClickhouseQuery @(Select a db t cols gr ord acols) selectClause\n  logDebug $ \"clickhouse raw query v2: \" <> T.pack rawQuery.getRawQuery\n  resJSON <- runRawQuery @db @A.Value @m (Proxy @db) rawQuery\n  case resJSON of\n    Left err -> do\n      logError $ \"Clickhouse error: \" <> T.pack err\n      pure []\n    Right val@(A.Array xs) -> do\n      logDebug $ \"clickhouse raw query v2 json result: \" <> show val\n      case mapM (\\val' -> parseColumns @a @cols (Proxy @a) cols val' q.subQueryLevelQ) xs of\n        Left err -> do\n          logError $ \"Clickhouse parsing result error: \" <> T.pack err\n          pure []\n        Right ys -> pure (V.toList ys)\n    Right val -> do\n      logDebug $ \"clickhouse raw query v2 json result: \" <> show val\n      logError \"Expected Array\"\n      pure []\n\nrunRawQuery :: forall db a m. (HasClickhouseEnv db m, FromJSON a) => Proxy db -> RawQuery -> m (Either String a)\nrunRawQuery db query = runClickhouse @db @a @m db (`runQuery` getJSON query.getRawQuery)\n\nrunClickhouse :: forall db a m. (MonadFlow m, HasClickhouseEnv db m, FromJSON a) => Proxy db -> (HttpConnection -> IO (Either String a)) -> m (Either String a)\nrunClickhouse db action = do\n  con' <- getClickhouseEnv db\n  con <- liftIO $ M.readMVar $ con'.connectionData\n  res <- L.runIO $ action con.connection\n  case res of\n    Left err -> do\n      if ((T.pack \"ConnectionFailure\") `T.isInfixOf` (T.pack err))\n        then do\n          logError $ \"Clickhouse error: \" <> T.pack err\n          ckhCfg <- getClickhouseCfg db\n          liftIO $ connectionHelper ckhCfg con'\n          con'' <- getClickhouseEnv db\n          con''' <- liftIO $ M.readMVar $ con''.connectionData\n          L.runIO $ action con'''.connection\n        else pure $ Left err\n    Right val -> pure $ Right val\n",
      "hash": "82603a8f2331f881fcef3a5f08d1740978a3e3d13752d1a2331f79933661d819",
      "size": 3326
    },
    "/lib/mobility-core/src/Kernel/Storage/ClickhouseV2/UtilsTH.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n{-# LANGUAGE TemplateHaskell #-}\n\nmodule Kernel.Storage.ClickhouseV2.UtilsTH (mkClickhouseInstances, mkClickhouseInstancesDebug) where\n\nimport qualified Data.Aeson as A\nimport Data.Char (toLower)\nimport Data.List (head, tail)\nimport EulerHS.Prelude hiding (Type, words)\nimport qualified Kernel.Storage.ClickhouseV2.ClickhouseTable as CH\nimport qualified Kernel.Storage.ClickhouseV2.ClickhouseValue as CH\nimport Kernel.Types.Common ()\nimport Language.Haskell.TH\n\nmkClickhouseInstances :: Name -> Name -> Q [Dec]\nmkClickhouseInstances name selectModifier = do\n  fields <- reifyFields name\n  let fieldNames = fst <$> fields\n  fromJSONValue <- mkFromJSONValue name fieldNames\n  fromJSON <- mkFromJSON name fieldNames\n  isClickhouseTableInstance <- mkClickhouseTableInstance name fields selectModifier\n  pure [fromJSONValue, fromJSON, isClickhouseTableInstance]\n\n-- | Will generate string for simple testing in repl. Using: putStrLn testSplice\nmkClickhouseInstancesDebug :: Name -> Name -> Q [Dec]\nmkClickhouseInstancesDebug name selectModifier = do\n  decs <- mkClickhouseInstances name selectModifier\n  testFunc <- mkTestSplice decs\n  pure $ decs <> testFunc\n\nreifyFields :: Name -> Q [(Name, Type)]\nreifyFields name = do\n  let nameStr = nameBase name\n  mbTypeName <- lookupTypeName nameStr\n  typeName <- case mbTypeName of\n    Nothing -> fail $ nameStr <> \" should be type name\"\n    Just n -> pure n\n  tableTypeInfo <- reify typeName\n  case tableTypeInfo of\n    TyConI dec -> do\n      case dec of\n        DataD _ _ _ _ [constructor] _ -> do\n          case constructor of\n            RecC _ records -> forM records $ \\(fieldName, _, fieldType) -> do\n              case fieldType of\n                AppT (AppT _c _f) a -> pure (fieldName, a)\n                _ -> fail \"field should have type C f a\"\n            _ -> fail $ nameStr <> \" should contain records\"\n        _ -> fail $ nameStr <> \" should be data type with one constructor\"\n    _ -> fail $ nameStr <> \" should be type name\"\n\nmkClickhouseTableInstance :: Name -> [(Name, Type)] -> Name -> Q Dec\nmkClickhouseTableInstance name fieldNames selectModifier = do\n  let camelName = toLower (head $ nameBase name) : tail (nameBase name)\n      fnN = mkName $ camelName <> \"Table\"\n      fN = mkName \"f\"\n      tN = mkName \"t\"\n      fieldExpressions =\n        fieldNames <&> \\(fieldName, fieldType) -> do\n          (fieldName, VarE fN `AppTypeE` fieldType `AppE` (VarE fieldName `AppE` VarE tN))\n      nameC = mkName $ nameBase name\n      bodyExpr = RecConE nameC fieldExpressions\n      tableModificationFunc = FunD 'CH.tableModification [Clause [] (NormalB $ VarE fnN) []]\n      mapTableFunc = FunD 'CH.mapTable [Clause [VarP fN, VarP tN] (NormalB bodyExpr) []]\n      selectModifierFunc = FunD 'CH.getSelectModifier [Clause [WildP] (NormalB $ ConE selectModifier) []]\n  return $ InstanceD Nothing [] (ConT ''CH.ClickhouseTable `AppT` ConT name) [tableModificationFunc, mapTableFunc, selectModifierFunc]\n\n-- SPLICE:\n-- instance ClickhouseTable FooT where\n--   tableModification = fooTTable\n--   mapTable f t = FooT {\n--       bar1 = f @Bar1Type (bar1 t),\n--       bar2 = f @Bar2Type (bar2 t),\n--       bar3 = f @Bar3Type (bar3 t)\n--     }\n\nmkfieldModifierFunction :: Name -> Name -> [Name] -> [Dec]\nmkfieldModifierFunction fnN name fieldNames = do\n  let camelName = toLower (head $ nameBase name) : tail (nameBase name)\n      --     fnN = mkName $ camelName <> \"FieldModifier\"\n      caseExpressions =\n        fieldNames <&> \\fieldName -> do\n          let matchBody = NormalB (VarE 'CH.getFieldModification `AppE` (VarE fieldName `AppE` VarE (mkName $ camelName <> \"Table\")))\n          Match (LitP . StringL $ nameBase fieldName) matchBody []\n      defaultCase = Match (VarP $ mkName \"a\") (NormalB . VarE $ mkName \"a\") []\n      fieldExpression =\n        ('A.fieldLabelModifier, LamCaseE $ caseExpressions <> [defaultCase])\n      bodyExpr = RecUpdE (VarE 'A.defaultOptions) [fieldExpression]\n      fnTypeBody = ConT ''A.Options\n      fnSig = SigD fnN fnTypeBody\n      fnBody = FunD fnN [Clause [] (NormalB bodyExpr) []]\n  [fnSig, fnBody]\n\nmkFromJSON :: Name -> [Name] -> Q Dec\nmkFromJSON name fieldNames = do\n  let fnN = 'A.parseJSON\n      valN = mkName \"val\"\n      tN = mkName \"t\"\n      nameE = LitE (StringL $ nameBase name)\n      paseJSONStmt = BindS (VarP tN) $ VarE 'A.parseJSON `AppTypeE` (ConT name `AppT` ConT ''CH.Value) `AppE` VarE valN\n      fieldBinds =\n        fieldNames <&> \\fieldName -> do\n          (fieldName, mkName (nameBase fieldName <> \"'\"))\n      fieldStmts =\n        fieldBinds <&> \\(fieldName, fieldBind) -> do\n          BindS (VarP fieldBind) (VarE 'parseField `AppE` nameE `AppE` LitE (StringL $ nameBase fieldName) `AppE` (VarE fieldName `AppE` VarE tN))\n      recStmt = NoBindS $ VarE 'pure `AppE` RecConE (mkName $ nameBase name) (fieldBinds <&> second VarE)\n      bodyExpr = DoE Nothing $ paseJSONStmt : fieldStmts <> [recStmt]\n      fromJSONInstance = FunD fnN [Clause [VarP valN] (NormalB bodyExpr) []]\n  return $ InstanceD Nothing [] (AppT (ConT ''FromJSON) (AppT (ConT name) (ConT ''Identity))) [fromJSONInstance]\n\nparseField :: (MonadFail m, CH.ClickhouseValue a) => String -> String -> CH.Value a -> m a\nparseField tableName fieldName val = do\n  either (\\err -> fail $ \"Could not parse clickhouse field \" <> tableName <> \".\" <> fieldName <> \": \" <> err) pure $ CH.getExcept (CH.fromClickhouseValue val)\n\n-- SPLICE\n-- instance FromJSON (FooT Identity) where\n--   parseJSON val = do\n--     t <- parseJSON @(FooT CH.Value) val\n--     bar1' <- parseField \"FooT\" \"bar1\" (bar1 t)\n--     bar2' <- parseField \"FooT\" \"bar2\" (bar2 t)\n--     bar3' <- parseField \"FooT\" \"bar3\" (bar3 t)\n--     pure FooT\n--       { bar1 = bar1',\n--         bar2 = bar2',\n--         bar3 = bar3'\n--       }\n\nmkFromJSONValue :: Name -> [Name] -> Q Dec\nmkFromJSONValue name fieldNames = do\n  let fieldModifierN = mkName \"fieldModifier\"\n  let fnN = 'A.parseJSON\n      fromJSONInstance = FunD fnN [Clause [] (NormalB (AppE (VarE 'A.genericParseJSON) (VarE fieldModifierN))) (mkfieldModifierFunction fieldModifierN name fieldNames)]\n  return $ InstanceD Nothing [] (AppT (ConT ''FromJSON) (AppT (ConT name) (ConT ''CH.Value))) [fromJSONInstance]\n\n-- SPLICE:\n-- instance FromJSON (FooT CH.Value)\n--   where parseJSON = genericParseJSON fieldModifier\n--           where fieldModifier :: A.Options\n--                 fieldModifier = A.defaultOptions{A.fieldLabelModifier = \\case\n--                   \"bar1\" -> getFieldModification (bar1 driverEdaKafkaTTable)\n--                   \"bar2\" -> getFieldModification (bar1 driverEdaKafkaTTable)\n--                   \"bar3\" -> getFieldModification (bar1 driverEdaKafkaTTable)\n--                   a -> a}\n\nmkTestSplice :: [Dec] -> Q [Dec]\nmkTestSplice decs = do\n  let fnName = mkName \"testSplice\"\n  let fnSig = SigD fnName (ConT ''String)\n  let fnBody = FunD fnName [Clause [] (NormalB . LitE . StringL $ pprint decs) []]\n  return [fnSig, fnBody]\n\n-- SPLICE:\n-- testSplice :: String\n-- testSplice = \"<all code from declarations splice here>\"\n",
      "hash": "7a09bc6eed93b94a3a8af58eb581fc944ae10304daf6d8a777e2c8e93adbad93",
      "size": 7717
    },
    "/lib/mobility-core/src/Kernel/Storage/Esqueleto.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n\nmodule Kernel.Storage.Esqueleto\n  ( module Types,\n    module Functions,\n    module Queries,\n    module Logger,\n    module Config,\n    module SqlDB,\n    module Class,\n    module Reexport,\n    module Transactionable,\n    module DTypeBuilder,\n    defaultQQ,\n    defaultSqlSettings,\n  )\nwhere\n\nimport qualified Data.Text as T\nimport Database.Persist.Quasi.Internal\nimport Database.Persist.TH as Reexport\nimport EulerHS.Prelude hiding (Key)\nimport Kernel.Storage.Esqueleto.Class as Class (FromTType (..), SolidType, TEntityKey (..), ToTType (..), extractSolidType)\nimport Kernel.Storage.Esqueleto.Config as Config (EsqDBFlow, EsqDBReplicaFlow)\nimport Kernel.Storage.Esqueleto.DTypeBuilder as DTypeBuilder (DTypeBuilder, buildDType)\nimport Kernel.Storage.Esqueleto.Functions as Functions\nimport Kernel.Storage.Esqueleto.Logger as Logger (LoggerIO)\nimport Kernel.Storage.Esqueleto.Queries as Queries\nimport Kernel.Storage.Esqueleto.SqlDB as SqlDB\nimport Kernel.Storage.Esqueleto.Transactionable as Transactionable\nimport Kernel.Storage.Esqueleto.Types as Types\nimport Kernel.Utils.Text\nimport Language.Haskell.TH.Quote\n\ndefaultQQ :: QuasiQuoter\ndefaultQQ =\n  persistWith $\n    upperCaseSettings\n      { psToDBName = camelCaseToSnakeCase\n      }\n\ndefaultSqlSettings :: MkPersistSettings\ndefaultSqlSettings =\n  sqlSettings\n    { mpsConstraintLabelModifier = \\tableName fieldName ->\n        if T.last tableName /= 'T'\n          then \"Table_name_must_end_with_T\"\n          else T.init tableName <> fieldName,\n      mpsFieldLabelModifier = \\_ fieldName -> fieldName\n    }\n",
      "hash": "ead6bbe3952e6463d00f0d4340654f7d242fd5f3470cfb13640293f7a848137b",
      "size": 2254
    },
    "/lib/mobility-core/src/Kernel/Storage/Esqueleto/Class.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n{-# LANGUAGE AllowAmbiguousTypes #-}\n{-# LANGUAGE FunctionalDependencies #-}\n{-# OPTIONS_GHC -Wno-orphans #-}\n\nmodule Kernel.Storage.Esqueleto.Class\n  ( FromTType (..),\n    ToTType (..),\n    TEntityKey (..),\n    extractSolidType,\n    QEntity (..),\n    TEntity (..),\n    SolidType,\n  )\nwhere\n\nimport Database.Esqueleto.Experimental\nimport qualified Database.Esqueleto.Internal.Internal as EsqInt\nimport EulerHS.Prelude hiding (Key)\nimport qualified GHC.Generics as Gen\nimport Kernel.Types.Logging (Log)\n\nclass\n  FromTType t a\n    | a -> t\n  where\n  fromTType :: (MonadThrow m, Log m) => t -> m a\n\nclass\n  ToTType t a\n    | a -> t\n  where\n  toTType :: a -> t\n\nclass\n  ( PersistEntity t,\n    PersistEntityBackend t ~ SqlBackend\n  ) =>\n  TEntityKey t\n  where\n  type DomainKey t\n  fromKey :: Key t -> DomainKey t\n  toKey :: DomainKey t -> Key t\n\n-- Use this type to bind returns of different tables/values.\n-- It will allow to build combined type of them (i.e. (Entity a1, Entity a2) -> b )\nextractSolidType :: forall solidt a. FromTType a solidt => a -> SolidType a\nextractSolidType = SolidType\n\n--------------------------------------------------------------------------------\n--------------------Internal classes and instnces-------------------------------\n--------------------------------------------------------------------------------\n\nnewtype SolidType a = SolidType {unSolidType :: a}\n\ninstance (EsqInt.SqlSelect a b) => EsqInt.SqlSelect (SolidType a) (SolidType b) where\n  sqlSelectCols a (SolidType b) = EsqInt.sqlSelectCols a b\n  sqlSelectColCount _ = EsqInt.sqlSelectColCount (Proxy @a)\n  sqlSelectProcessRow a = SolidType <$> EsqInt.sqlSelectProcessRow a\n\nclass QEntity t a where\n  toResult :: (MonadThrow m, Log m) => t -> m a\n\ninstance {-# OVERLAPPABLE #-} (Generic t, Generic a, GQEntity (Gen.Rep t) (Gen.Rep a)) => QEntity t a where\n  toResult t = Gen.to <$> toResultGen (Gen.from t)\n\ninstance {-# OVERLAPPING #-} FromTType a b => QEntity (Entity a) b where\n  toResult = fromTType . extractTType\n\ninstance {-# OVERLAPPING #-} QEntity a b => QEntity [a] [b] where\n  toResult = traverse toResult\n\ninstance {-# OVERLAPPING #-} QEntity a b => QEntity (Maybe a) (Maybe b) where\n  toResult = mapM toResult\n\ninstance {-# OVERLAPPING #-} ((b ~ DomainKey a), TEntityKey a) => QEntity (Value (Key a)) b where\n  toResult = return . fromKey . unValue\n\ninstance {-# OVERLAPPING #-} ((b ~ DomainKey a), TEntityKey a) => QEntity (Value (Maybe (Key a))) (Maybe b) where\n  toResult = return . fmap fromKey . unValue\n\ninstance {-# OVERLAPPING #-} QEntity (Value a) a where\n  toResult = return . unValue\n\ninstance {-# OVERLAPPING #-} (FromTType a b) => QEntity (SolidType a) b where\n  toResult = fromTType . unSolidType\n\nclass GQEntity gt ga where\n  toResultGen :: (MonadThrow m, Log m) => gt p -> m (ga p)\n\ninstance\n  (GQEntity a1 a2, GQEntity b1 b2) =>\n  GQEntity ((Gen.:*:) a1 b1) ((Gen.:*:) a2 b2)\n  where\n  toResultGen (a1 Gen.:*: b1) = do\n    a2 <- toResultGen a1\n    b2 <- toResultGen b1\n    return (a2 Gen.:*: b2)\n\ninstance\n  (GQEntity a1 a2, GQEntity b1 b2) =>\n  GQEntity ((Gen.:+:) a1 b1) ((Gen.:+:) a2 b2)\n  where\n  toResultGen (Gen.L1 a1) = Gen.L1 <$> toResultGen a1\n  toResultGen (Gen.R1 b1) = Gen.R1 <$> toResultGen b1\n\ninstance\n  (GQEntity a1 a2) =>\n  GQEntity (Gen.M1 i t a1) (Gen.M1 i t a2)\n  where\n  toResultGen (Gen.M1 a1) = Gen.M1 <$> toResultGen a1\n\ninstance\n  (QEntity a1 a2) =>\n  GQEntity (Gen.K1 i a1) (Gen.K1 i a2)\n  where\n  toResultGen (Gen.K1 a1) = Gen.K1 <$> toResult a1\n\nclass TEntity te a where\n  extractTType :: te -> a\n\ninstance {-# OVERLAPPABLE #-} (Generic te, Generic a, GTEntity (Gen.Rep te) (Gen.Rep a)) => TEntity te a where\n  extractTType = Gen.to . extractTTypeGen . Gen.from\n\ninstance {-# OVERLAPPING #-} TEntity (Entity a) a where\n  extractTType = entityVal\n\ninstance {-# OVERLAPPING #-} TEntity (Value a) a where\n  extractTType = unValue\n\ninstance {-# OVERLAPPING #-} TEntity a b => TEntity [a] [b] where\n  extractTType = fmap extractTType\n\ninstance {-# OVERLAPPING #-} TEntity a b => TEntity (Maybe a) (Maybe b) where\n  extractTType = fmap extractTType\n\nclass GTEntity gt ga where\n  extractTTypeGen :: gt p -> ga p\n\ninstance\n  (GTEntity a1 a2, GTEntity b1 b2) =>\n  GTEntity ((Gen.:*:) a1 b1) ((Gen.:*:) a2 b2)\n  where\n  extractTTypeGen (a1 Gen.:*: b1) = do\n    let a2 = extractTTypeGen a1\n        b2 = extractTTypeGen b1\n    a2 Gen.:*: b2\n\ninstance\n  (GTEntity a1 a2, GTEntity b1 b2) =>\n  GTEntity ((Gen.:+:) a1 b1) ((Gen.:+:) a2 b2)\n  where\n  extractTTypeGen (Gen.L1 a1) = Gen.L1 $ extractTTypeGen a1\n  extractTTypeGen (Gen.R1 b1) = Gen.R1 $ extractTTypeGen b1\n\ninstance\n  (GTEntity a1 a2) =>\n  GTEntity (Gen.M1 i t a1) (Gen.M1 i t a2)\n  where\n  extractTTypeGen (Gen.M1 a1) = Gen.M1 $ extractTTypeGen a1\n\ninstance\n  (TEntity a1 a2) =>\n  GTEntity (Gen.K1 i a1) (Gen.K1 i a2)\n  where\n  extractTTypeGen (Gen.K1 a1) = Gen.K1 $ extractTType a1\n",
      "hash": "8e91462195ba4da7c335b7ec678a34af9df624736544622ca66e264ac718ff9c",
      "size": 5569
    },
    "/lib/mobility-core/src/Kernel/Storage/Esqueleto/Config.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n\nmodule Kernel.Storage.Esqueleto.Config where\n\nimport Data.Pool (Pool)\nimport Database.Persist.Postgresql\nimport Database.PostgreSQL.Simple (execute_)\nimport Database.PostgreSQL.Simple.Types (Query (Query))\nimport EulerHS.Prelude\nimport GHC.Records.Extra\nimport Kernel.Storage.Esqueleto.Logger (runLoggerIO)\nimport Kernel.Types.App (MonadFlow)\nimport Kernel.Types.Time (MonadTime)\nimport Kernel.Utils.Dhall (FromDhall)\nimport Kernel.Utils.IOLogging\n\ndata EsqDBConfig = EsqDBConfig\n  { connectHost :: Text,\n    connectPort :: Word16,\n    connectUser :: Text,\n    connectPassword :: Text,\n    connectDatabase :: Text,\n    connectSchemaName :: Text,\n    connectionPoolCount :: Int\n  }\n  deriving (Generic, Show, ToJSON, FromJSON, FromDhall)\n\nnewtype EsqDBEnv = EsqDBEnv\n  { connPool :: Pool SqlBackend\n  }\n  deriving (Generic)\n\nprepareEsqDBEnv :: EsqDBConfig -> LoggerEnv -> IO EsqDBEnv\nprepareEsqDBEnv cfg logEnv = do\n  let connStr = makeConnString cfg\n      modifyConnString = encodeUtf8 cfg.connectSchemaName\n  let checkedLogEnv =\n        if logEnv.logRawSql\n          then logEnv\n          else logEnv {fileLogger = Nothing, consoleLogger = Nothing}\n  pool <- liftIO . runLoggerIO checkedLogEnv $ createPostgresqlPoolModified (modifyConn modifyConnString) connStr cfg.connectionPoolCount\n  return $ EsqDBEnv pool\n  where\n    makeConnString dbConfig =\n      encodeUtf8 $\n        \"host=\" <> dbConfig.connectHost\n          <> \" dbname=\"\n          <> dbConfig.connectDatabase\n          <> \" user=\"\n          <> dbConfig.connectUser\n          <> \" password=\"\n          <> dbConfig.connectPassword\n          <> \" port=\"\n          <> show dbConfig.connectPort\n    modifyConn schemaName conn =\n      void . execute_ conn . Query $ \"set search_path to \" <> schemaName <> \", public; \"\n\ntype HasEsq m r = (MonadReader r m, HasLog r, MonadTime m, MonadIO m)\n\ntype HasEsqEnv m r = (HasEsq m r, HasField \"esqDBEnv\" r EsqDBEnv, HasField \"requestId\" r (Maybe Text), HasField \"shouldLogRequestId\" r Bool)\n\ntype HasEsqReplica m r = (HasEsq m r, HasField \"esqDBReplicaEnv\" r EsqDBEnv)\n\ntype EsqDBFlow m r = (HasEsqEnv m r, MonadFlow m)\n\ntype EsqDBReplicaFlow m r = (HasEsqReplica m r, MonadFlow m)\n",
      "hash": "10791e77a14ee886e91ad1db392dc47e7924a4fd5a3a3530c944267868913e19",
      "size": 2873
    },
    "/lib/mobility-core/src/Kernel/Storage/Esqueleto/DTypeBuilder.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n{-# LANGUAGE DerivingStrategies #-}\n{-# LANGUAGE GeneralizedNewtypeDeriving #-}\n\nmodule Kernel.Storage.Esqueleto.DTypeBuilder\n  ( DTypeBuilder,\n    liftToBuilder,\n    buildDType,\n  )\nwhere\n\nimport Kernel.Prelude\nimport Kernel.Storage.Esqueleto.Class\nimport Kernel.Types.Logging\n\nnewtype DTypeBuilder m t = DTypeBuilder\n  { getTType :: m t\n  }\n  deriving newtype (Functor, Applicative, Monad, Log, MonadThrow)\n\nliftToBuilder :: m t -> DTypeBuilder m t\nliftToBuilder = DTypeBuilder\n\nbuildDType :: (MonadThrow m, Log m, QEntity t a) => DTypeBuilder m t -> m a\nbuildDType b = toResult =<< getTType b\n",
      "hash": "b9b20269e3b54698485cafe3233af462b3c69d95d1c039a8cff36f1a86600a13",
      "size": 1289
    },
    "/lib/mobility-core/src/Kernel/Storage/Esqueleto/Functions.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n{-# OPTIONS_GHC -Wno-deprecations #-}\n\nmodule Kernel.Storage.Esqueleto.Functions\n  ( (<->.),\n    getPoint,\n    containsPoint,\n    getGeomGeoJSON,\n    mbGetGeomGeoJSON,\n    IntervalVal (..),\n    interval,\n    rand,\n    unnest,\n    buildRadiusWithin,\n    buildRegionWithin,\n    containsRegion,\n    getTextFromGeoJSON,\n    geojsonToBin,\n    containsPointGeom,\n    pointCloseByOrWithin,\n  )\nwhere\n\nimport qualified Data.Text.Lazy as TL\nimport qualified Data.Text.Lazy.Builder as TL\nimport qualified Database.Esqueleto.Experimental as Esq\nimport Database.Esqueleto.Internal.Internal hiding (rand)\nimport Kernel.Prelude\nimport Kernel.Storage.Esqueleto.Types\n\n(<->.) :: SqlExpr (Value Point) -> SqlExpr (Value Point) -> SqlExpr (Value Double)\n(<->.) = unsafeSqlBinOp \" <-> \"\n\ngetPoint :: (SqlExpr (Value Double), SqlExpr (Value Double)) -> SqlExpr (Value Point)\ngetPoint (lat, long) = unsafeSqlFunction \"ST_SetSRID\" (buildSTPoint (long, lat), val (4326 :: Int))\n\nbuildSTPoint :: (SqlExpr (Value Double), SqlExpr (Value Double)) -> SqlExpr (Value b)\nbuildSTPoint = unsafeSqlFunction \"ST_Point\"\n\ngetGeomGeoJSON :: SqlExpr (Value Text)\ngetGeomGeoJSON = unsafeSqlFunction \"ST_AsGeoJSON\" args\n  where\n    args = unsafeSqlValue \"geom\"\n\nmbGetGeomGeoJSON :: SqlExpr (Value (Maybe Text))\nmbGetGeomGeoJSON = unsafeSqlFunction \"ST_AsGeoJSON\" args\n  where\n    args = unsafeSqlValue \"geom\"\n\ngetTextFromGeoJSON :: SqlExpr (Value Text) -> SqlExpr (Value Text)\ngetTextFromGeoJSON geoJson = unsafeSqlFunction \"ST_SetSRID\" args\n  where\n    args = (unsafeSqlFunction \"ST_GeomFromGeoJSON\" geoJson, val (4326 :: Int))\n\ngeojsonToBin :: SqlExpr (Value Text) -> SqlExpr (Value Geom)\ngeojsonToBin = unsafeSqlFunction \"geojson_to_bin\"\n\nbuildRadiusWithin :: SqlExpr (Value Point) -> (Double, Double) -> SqlExpr (Value Int) -> SqlExpr (Value b)\nbuildRadiusWithin pnt (lat, lon) radius = unsafeSqlFunction \"ST_DWithin\" args\n  where\n    args = (pnt, getPoint', radius)\n    getPoint' = val (\"SRID=4326;POINT(\" <> show lon <> \" \" <> show lat <> \")\") :: SqlExpr (Value Text)\n\npointCloseByOrWithin :: (Double, Double) -> SqlExpr (Value Int) -> SqlExpr (Value b)\npointCloseByOrWithin (lon, lat) radius = unsafeSqlFunction \"st_Dwithin\" args\n  where\n    args = (transform (setSrid (unsafeSqlValue \"geom\", val (4326 :: Int)), val (3557 :: Int)), transform2 (val (\"SRID=4326;POINT(\" <> show lon <> \" \" <> show lat <> \")\" :: Text), val (3557 :: Int)), radius)\n    setSrid setSridArgs = unsafeSqlFunction \"ST_SetSRID\" setSridArgs\n    transform argsTransform = unsafeSqlFunction \"ST_Transform\" argsTransform\n    transform2 argsTransform = unsafeSqlFunction \"ST_Transform\" argsTransform\n\ncontainsPoint :: (Double, Double) -> SqlExpr (Value b)\ncontainsPoint (lon, lat) = unsafeSqlFunction \"st_contains\" args\n  where\n    args = (unsafeSqlValue \"geom\", geomFromText pointText)\n    geomFromText = unsafeSqlFunction \"ST_GeomFromText\"\n    pointText = val (\"POINT (\" <> show lon <> \" \" <> show lat <> \")\") :: SqlExpr (Value Text)\n\ncontainsPointGeom :: (Double, Double) -> SqlExpr (Value b)\ncontainsPointGeom (lon, lat) = unsafeSqlFunction \"st_contains\" args\n  where\n    args = (unsafeSqlValue \"geom\", geomFromText gftArgs)\n    geomFromText = unsafeSqlFunction \"ST_GeomFromText\"\n    gftArgs = (pointText, val (4326 :: Int))\n    pointText = val (\"POINT (\" <> show lon <> \" \" <> show lat <> \")\") :: SqlExpr (Value Text)\n\ncontainsRegion :: (Double, Double) -> (Double, Double) -> SqlExpr (Value b)\ncontainsRegion (minLon, minLat) (maxLon, maxLat) = unsafeSqlFunction \"st_intersects\" args\n  where\n    args = (unsafeSqlValue \"geom\", unsafeSqlFunction \"ST_MakeEnvelope\" points)\n    points = (val minLon, val minLat, val maxLon, val maxLat, val (4326 :: Int))\n\nbuildRegionWithin :: (Double, Double) -> (Double, Double) -> SqlExpr (Value b)\nbuildRegionWithin (minLat, minLon) (maxLat, maxLon) = unsafeSqlFunction \"ST_MakeEnvelope\" args\n  where\n    args = (val minLon, val minLat, val maxLon, val maxLat)\n\ndata IntervalVal = YEAR Int | MONTH Int | DAY Int | HOUR Int | MINUTE Int | SECOND Int deriving (Show)\n\ninterval :: [IntervalVal] -> SqlExpr (Value UTCTime)\ninterval intervalVals = unsafeSqlValue valueString\n  where\n    valueString = \"interval '\" <> intervalArg <> \"'\"\n    intervalArg = TL.fromLazyText $ TL.unwords (intervalValToString <$> intervalVals)\n    intervalValToString = \\case\n      YEAR i -> show i <> \" YEAR\"\n      MONTH i -> show i <> \" MONTH\"\n      DAY i -> show i <> \" DAY\"\n      HOUR i -> show i <> \" HOUR\"\n      MINUTE i -> show i <> \" MINUTE\"\n      SECOND i -> show i <> \" SECOND\"\n\nrand :: SqlExpr OrderBy\nrand = Esq.rand\n\nunnest :: PostgresListField a => SqlExpr (Value a) -> SqlExpr (Value b)\nunnest = unsafeSqlFunction \"unnest\"\n",
      "hash": "5750bd2cf4707f7dd885b93fe4727b0052d818689c5270424f07fa012d8c98d6",
      "size": 5381
    },
    "/lib/mobility-core/src/Kernel/Storage/Esqueleto/Logger.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n{-# LANGUAGE DerivingStrategies #-}\n{-# LANGUAGE GeneralizedNewtypeDeriving #-}\n\nmodule Kernel.Storage.Esqueleto.Logger (LoggerIO (..), runLoggerIO) where\n\nimport Control.Monad.IO.Unlift (MonadUnliftIO)\nimport Control.Monad.Logger as CMLogger\n  ( LogLevel (..),\n    MonadLogger (..),\n    MonadLoggerIO (..),\n    ToLogStr (toLogStr),\n    fromLogStr,\n  )\nimport qualified Data.UUID as UUID\nimport qualified Data.UUID.V4 as UUID\nimport EulerHS.Prelude hiding (Key)\nimport Kernel.Types.Logging as BLogging (Log (..), LogLevel (..))\nimport Kernel.Types.MonadGuid\nimport Kernel.Types.Time (MonadTime (..))\nimport Kernel.Utils.IOLogging (LoggerEnv, appendLogTag, logOutputIO)\n\n--TODO: Remove this when we remove EulerHS\nnewtype LoggerIO a = LoggerIO (ReaderT LoggerEnv IO a)\n  deriving stock (Generic)\n  deriving newtype (Functor, Applicative, Monad, MonadIO, MonadUnliftIO, MonadThrow, MonadCatch, MonadMask)\n\ninstance MonadTime LoggerIO where\n  getCurrentTime = liftIO getCurrentTime\n\nrunLoggerIO :: LoggerEnv -> LoggerIO a -> IO a\nrunLoggerIO logEnv (LoggerIO rdr) = runReaderT rdr logEnv\n\nlogFunc :: ToLogStr msg => LoggerEnv -> BLogging.LogLevel -> msg -> IO ()\nlogFunc logEnv logLevel msg =\n  logOutputIO logEnv logLevel . decodeUtf8 . fromLogStr $ toLogStr msg\n\nlogLevelCMtoB :: CMLogger.LogLevel -> BLogging.LogLevel\nlogLevelCMtoB cmLogLevel = case cmLogLevel of\n  LevelError -> ERROR\n  LevelWarn -> WARNING\n  LevelDebug -> DEBUG\n  _ -> INFO\n\ninstance MonadLogger LoggerIO where\n  monadLoggerLog _ _ logLevel msg = LoggerIO $ do\n    loggerEnv <- ask\n    liftIO $ logFunc loggerEnv (logLevelCMtoB logLevel) msg\n\ninstance MonadLoggerIO LoggerIO where\n  askLoggerIO =\n    LoggerIO $\n      (\\logEnv _ _ logLvl msg -> logFunc logEnv (logLevelCMtoB logLvl) msg) <$> ask\n\ninstance Log LoggerIO where\n  logOutput logLevel msg = LoggerIO $ do\n    loggerEnv <- ask\n    liftIO $ logFunc loggerEnv logLevel msg\n\n  withLogTag tag (LoggerIO logger) = LoggerIO $ local modifyEnv logger\n    where\n      modifyEnv logEnv = appendLogTag tag logEnv\n\ninstance MonadGuid LoggerIO where\n  generateGUIDText = liftIO (UUID.toText <$> UUID.nextRandom)\n",
      "hash": "196a25bcc0ef8b55d020709d3edd5d88b5482acae11b620ac4299d158ab76e01",
      "size": 2821
    },
    "/lib/mobility-core/src/Kernel/Storage/Esqueleto/Migration.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n\nmodule Kernel.Storage.Esqueleto.Migration\n  ( migrateIfNeeded,\n    migrateIfNeeded',\n  )\nwhere\n\nimport Data.ByteString hiding (map)\nimport qualified Data.Text as T\nimport qualified Database.PostgreSQL.Simple as PS\nimport Database.PostgreSQL.Simple.Migration\nimport Kernel.Prelude\nimport Kernel.Storage.Esqueleto.Config\nimport Kernel.Types.Common\nimport Kernel.Utils.Common\n\nfromEsqDBConfig :: EsqDBConfig -> PS.ConnectInfo\nfromEsqDBConfig EsqDBConfig {..} =\n  PS.ConnectInfo\n    { connectHost = T.unpack connectHost,\n      connectPort,\n      connectUser = T.unpack connectUser,\n      connectPassword = T.unpack connectPassword,\n      connectDatabase = T.unpack connectDatabase\n    }\n\nmigrateIfNeeded :: (MonadMask m, MonadIO m, Log m) => [FilePath] -> Bool -> EsqDBConfig -> m (Either String ())\nmigrateIfNeeded mPaths autoMigrate esqDbConfig =\n  migrateIfNeeded' mPaths autoMigrate schemaName connectInfo\n  where\n    schemaName = encodeUtf8 esqDbConfig.connectSchemaName\n    connectInfo = fromEsqDBConfig esqDbConfig\n\nmigrateIfNeeded' :: (MonadMask m, MonadIO m, Log m) => [FilePath] -> Bool -> ByteString -> PS.ConnectInfo -> m (Either String ())\nmigrateIfNeeded' mPaths autoMigrate schemaName connectInfo =\n  if autoMigrate\n    then\n      bracket\n        (liftIO (PS.connect connectInfo))\n        (liftIO . PS.close)\n        (migrate mPaths)\n    else pure $ Right ()\n  where\n    options =\n      defaultOptions\n        { optTableName = schemaName <> \".\" <> \"schema_migrations\",\n          optVerbose = Verbose\n        }\n    resultToEither MigrationSuccess = Right ()\n    resultToEither (MigrationError a) = Left a\n    migrate paths conn =\n      fmap resultToEither $ do\n        logInfo $ \"Running migrations (\" <> show paths <> \") ...\"\n        liftIO $\n          runMigrations\n            conn\n            options\n            ([MigrationInitialization] <> map MigrationDirectory paths)\n",
      "hash": "7618e63214382c05ef1112b1d07ab57cd75d4b789d9e502974d854a5df80d788",
      "size": 2581
    },
    "/lib/mobility-core/src/Kernel/Storage/Esqueleto/Queries.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n{-# LANGUAGE AllowAmbiguousTypes #-}\n{-# LANGUAGE TypeApplications #-}\n\nmodule Kernel.Storage.Esqueleto.Queries\n  ( findOne,\n    findOne',\n    findOneM,\n    findById,\n    findById',\n    findByIdM,\n    findAll,\n    findAll',\n    create,\n    create',\n    update,\n    update',\n    createMany,\n    createMany',\n    createUnique,\n    createUnique',\n    updateReturningCount,\n    updateReturningCount',\n    deleteByKey,\n    deleteByKey',\n    delete,\n    delete',\n    deleteReturningCount,\n    deleteReturningCount',\n    repsert,\n    repsert',\n    upsert,\n    upsert',\n    upsertBy,\n    upsertBy',\n    insertSelect,\n    insertSelect',\n    insertSelectCount,\n    insertSelectCount',\n    (<#>),\n    whenJust_,\n    whenTrue_,\n    updateWhenJust_,\n    maybe_,\n    module EsqExport,\n  )\nwhere\n\nimport Data.Text (pack)\nimport Data.Typeable\nimport Database.Esqueleto.Experimental as EsqExport hiding\n  ( Table,\n    delete,\n    deleteCount,\n    deleteKey,\n    insert,\n    insertSelect,\n    insertSelectCount,\n    rand,\n    repsert,\n    selectOne,\n    update,\n    updateCount,\n    upsert,\n    upsertBy,\n    (<&>),\n  )\nimport qualified Database.Esqueleto.Experimental as Esq\nimport qualified Database.Esqueleto.Internal.Internal as Esq\nimport Kernel.Prelude\nimport Kernel.Storage.Esqueleto.Class\nimport Kernel.Storage.Esqueleto.DTypeBuilder\nimport Kernel.Storage.Esqueleto.SqlDB\nimport Kernel.Storage.Esqueleto.Transactionable\nimport Kernel.Types.Logging (Log)\n\nfindOne :: (Typeable t, Transactionable m, Esq.SqlSelect b t, QEntity t a) => Esq.SqlQuery b -> m (Maybe a)\nfindOne = buildDType . findOneInternal\n\nfindOne' :: (Typeable t, Transactionable m, TEntity t a, Esq.SqlSelect b t) => Esq.SqlQuery b -> DTypeBuilder m (Maybe a)\nfindOne' q = extractTType <$> findOneInternal q\n\nfindOneM :: (Typeable t, Transactionable m, TEntity t a, Esq.SqlSelect b t) => Esq.SqlQuery b -> MaybeT (DTypeBuilder m) a\nfindOneM = MaybeT . findOne'\n\nfindOneInternal :: forall m t b. (Typeable t, Transactionable m, Esq.SqlSelect b t) => Esq.SqlQuery b -> DTypeBuilder m (Maybe t)\nfindOneInternal q = liftToBuilder . runTransaction . SelectSqlDB . SqlDB $ selectOnlyOne\n  where\n    selectOnlyOne = do\n      list <- lift $ Esq.select q\n      case list of\n        [res] -> return $ Just res\n        [] -> return Nothing\n        _ -> do\n          let errType = pack . show . typeRep $ (Proxy @t)\n          throw $ PersistError $ \"Multiple results of \" <> errType\n\nfindById :: forall a t m. (Typeable t, Transactionable m, QEntity (Entity t) a, TEntityKey t) => DomainKey t -> m (Maybe a)\nfindById = buildDType . findByIdInternal @t . toKey @t\n\nfindById' :: forall t m. (Typeable t, Transactionable m, TEntityKey t, TEntity (Entity t) t) => Key t -> DTypeBuilder m (Maybe t)\nfindById' key = extractTType <$> findByIdInternal @t key\n\nfindByIdM :: forall t m. (Typeable t, Transactionable m, TEntityKey t, TEntity (Entity t) t) => Key t -> MaybeT (DTypeBuilder m) t\nfindByIdM = MaybeT . findById'\n\nfindByIdInternal :: forall t m. (Typeable t, Transactionable m, TEntityKey t, Log m) => Key t -> DTypeBuilder m (Maybe (Entity t))\nfindByIdInternal key = findOneInternal $ do\n  res <- from $ table @t\n  where_ $ res Esq.^. persistIdField Esq.==. val key\n  return res\n\nfindAll :: (Transactionable m, Esq.SqlSelect b t, QEntity [t] [a]) => Esq.SqlQuery b -> m [a]\nfindAll q = buildDType $ findAllInternal q\n\nfindAll' :: (Transactionable m, Esq.SqlSelect b t, TEntity [t] [a]) => Esq.SqlQuery b -> DTypeBuilder m [a]\nfindAll' q = extractTType <$> findAllInternal q\n\nfindAllInternal :: (Transactionable m, Esq.SqlSelect b t) => Esq.SqlQuery b -> DTypeBuilder m [t]\nfindAllInternal q = liftToBuilder . runTransaction . SelectSqlDB . SqlDB $ lift (Esq.select q)\n\ncreate ::\n  ( PersistEntity t,\n    PersistEntityBackend t ~ SqlBackend,\n    SafeToInsert t,\n    ToTType t a\n  ) =>\n  a ->\n  SqlDB ()\ncreate q = do\n  let ttypes = toTType q\n  SqlDB . lift $ Esq.insert_ ttypes\n\ncreate' ::\n  ( PersistEntity t,\n    PersistEntityBackend t ~ SqlBackend,\n    SafeToInsert t\n  ) =>\n  t ->\n  FullEntitySqlDB ()\ncreate' q = do\n  liftToFullEntitySqlDB . SqlDB . lift $ Esq.insert_ q\n\ncreateMany ::\n  ( PersistEntity t,\n    PersistEntityBackend t ~ SqlBackend,\n    SafeToInsert t,\n    ToTType t a\n  ) =>\n  [a] ->\n  SqlDB ()\ncreateMany q = do\n  let ttypes = toTType `fmap` q\n  SqlDB . lift $ Esq.insertMany_ ttypes\n\ncreateMany' ::\n  ( PersistEntity t,\n    PersistEntityBackend t ~ SqlBackend,\n    SafeToInsert t\n  ) =>\n  [t] ->\n  FullEntitySqlDB ()\ncreateMany' q = do\n  liftToFullEntitySqlDB . SqlDB . lift $ Esq.insertMany_ q\n\ncreateUnique ::\n  ( PersistEntity t,\n    PersistEntityBackend t ~ SqlBackend,\n    SafeToInsert t,\n    ToTType t a\n  ) =>\n  a ->\n  SqlDB (Maybe (Key t))\ncreateUnique q = do\n  let ttypes = toTType q\n  SqlDB . lift $ Esq.insertUnique ttypes\n\ncreateUnique' ::\n  ( PersistEntity t,\n    PersistEntityBackend t ~ SqlBackend,\n    SafeToInsert t\n  ) =>\n  t ->\n  FullEntitySqlDB (Maybe (Key t))\ncreateUnique' q = do\n  liftToFullEntitySqlDB . SqlDB . lift $ Esq.insertUnique q\n\nupdate ::\n  ( PersistEntity a,\n    BackendCompatible SqlBackend (PersistEntityBackend a)\n  ) =>\n  (Esq.SqlExpr (Entity a) -> Esq.SqlQuery ()) ->\n  SqlDB ()\nupdate = SqlDB . lift . Esq.update\n\nupdate' ::\n  ( PersistEntity a,\n    BackendCompatible SqlBackend (PersistEntityBackend a)\n  ) =>\n  (Esq.SqlExpr (Entity a) -> Esq.SqlQuery ()) ->\n  FullEntitySqlDB ()\nupdate' = liftToFullEntitySqlDB . SqlDB . lift . Esq.update\n\nupdateReturningCount ::\n  ( PersistEntity a,\n    BackendCompatible SqlBackend (PersistEntityBackend a)\n  ) =>\n  (Esq.SqlExpr (Entity a) -> Esq.SqlQuery ()) ->\n  SqlDB Int64\nupdateReturningCount = SqlDB . lift . Esq.updateCount\n\nupdateReturningCount' ::\n  ( PersistEntity a,\n    BackendCompatible SqlBackend (PersistEntityBackend a)\n  ) =>\n  (Esq.SqlExpr (Entity a) -> Esq.SqlQuery ()) ->\n  FullEntitySqlDB Int64\nupdateReturningCount' = liftToFullEntitySqlDB . SqlDB . lift . Esq.updateCount\n\ndeleteByKey ::\n  forall t.\n  ( TEntityKey t\n  ) =>\n  DomainKey t ->\n  SqlDB ()\ndeleteByKey = SqlDB . lift . Esq.deleteKey . toKey @t\n\ndeleteByKey' ::\n  ( PersistEntity t,\n    PersistEntityBackend t ~ SqlBackend\n  ) =>\n  Key t ->\n  FullEntitySqlDB ()\ndeleteByKey' = liftToFullEntitySqlDB . SqlDB . lift . Esq.deleteKey\n\ndelete ::\n  Esq.SqlQuery () ->\n  SqlDB ()\ndelete = SqlDB . lift . Esq.delete\n\ndelete' ::\n  Esq.SqlQuery () ->\n  FullEntitySqlDB ()\ndelete' = liftToFullEntitySqlDB . SqlDB . lift . Esq.delete\n\ndeleteReturningCount ::\n  Esq.SqlQuery () ->\n  SqlDB Int64\ndeleteReturningCount = SqlDB . lift . Esq.deleteCount\n\ndeleteReturningCount' ::\n  Esq.SqlQuery () ->\n  FullEntitySqlDB Int64\ndeleteReturningCount' = liftToFullEntitySqlDB . SqlDB . lift . Esq.deleteCount\n\nrepsert ::\n  ( PersistEntityBackend t ~ SqlBackend,\n    ToTType t a,\n    TEntityKey t\n  ) =>\n  DomainKey t ->\n  a ->\n  SqlDB ()\nrepsert k v = do\n  let ttype = toTType v\n  SqlDB . lift $ Esq.repsert (toKey k) ttype\n\nrepsert' ::\n  ( PersistEntity t,\n    PersistEntityBackend t ~ SqlBackend\n  ) =>\n  Key t ->\n  t ->\n  FullEntitySqlDB ()\nrepsert' k v = do\n  liftToFullEntitySqlDB . SqlDB . lift $ Esq.repsert k v\n\nupsert ::\n  ( OnlyOneUniqueKey t,\n    PersistEntityBackend t ~ SqlBackend,\n    SafeToInsert t,\n    ToTType t a\n  ) =>\n  a ->\n  [SqlExpr (Entity t) -> SqlExpr Esq.Update] ->\n  SqlDB ()\nupsert r u = do\n  let uniqueKey = onlyUniqueP $ toTType r\n  upsertBy uniqueKey r u\n\nupsert' ::\n  ( OnlyOneUniqueKey t,\n    PersistEntityBackend t ~ SqlBackend,\n    SafeToInsert t\n  ) =>\n  t ->\n  [SqlExpr (Entity t) -> SqlExpr Esq.Update] ->\n  FullEntitySqlDB ()\nupsert' r u = do\n  let uniqueKey = onlyUniqueP r\n  upsertBy' uniqueKey r u\n\nupsertBy ::\n  ( PersistEntity t,\n    PersistEntityBackend t ~ SqlBackend,\n    SafeToInsert t,\n    ToTType t a\n  ) =>\n  Unique t ->\n  a ->\n  [SqlExpr (Entity t) -> SqlExpr Esq.Update] ->\n  SqlDB ()\nupsertBy k r u = do\n  mbEntity <- SqlDB . lift $ getBy k\n  case mbEntity of\n    Nothing -> create r\n    Just ent -> update $ \\tbl -> do\n      Esq.set\n        tbl\n        u\n      where_ $ tbl Esq.^. persistIdField Esq.==. val (entityKey ent)\n\nupsertBy' ::\n  ( PersistEntity t,\n    PersistEntityBackend t ~ SqlBackend,\n    SafeToInsert t\n  ) =>\n  Unique t ->\n  t ->\n  [SqlExpr (Entity t) -> SqlExpr Esq.Update] ->\n  FullEntitySqlDB ()\nupsertBy' k r u = do\n  mbEntity <- liftToFullEntitySqlDB . SqlDB . lift $ getBy k\n  case mbEntity of\n    Nothing -> create' r\n    Just ent -> update' $ \\tbl -> do\n      Esq.set\n        tbl\n        u\n      where_ $ tbl Esq.^. persistIdField Esq.==. val (entityKey ent)\n\ninsertSelect ::\n  ( PersistEntity t\n  ) =>\n  SqlQuery (SqlExpr (Esq.Insertion t)) ->\n  SqlDB ()\ninsertSelect = SqlDB . lift . Esq.insertSelect\n\ninsertSelect' ::\n  ( PersistEntity t\n  ) =>\n  SqlQuery (SqlExpr (Esq.Insertion t)) ->\n  FullEntitySqlDB ()\ninsertSelect' = liftToFullEntitySqlDB . SqlDB . lift . Esq.insertSelect\n\ninsertSelectCount ::\n  ( PersistEntity t\n  ) =>\n  SqlQuery (SqlExpr (Esq.Insertion t)) ->\n  SqlDB Int64\ninsertSelectCount = SqlDB . lift . Esq.insertSelectCount\n\ninsertSelectCount' ::\n  ( PersistEntity t\n  ) =>\n  SqlQuery (SqlExpr (Esq.Insertion t)) ->\n  FullEntitySqlDB Int64\ninsertSelectCount' = liftToFullEntitySqlDB . SqlDB . lift . Esq.insertSelectCount\n\n(<#>) :: SqlExpr (Esq.Insertion (a -> b)) -> SqlExpr (Value a) -> SqlExpr (Esq.Insertion b)\n(<#>) = (Esq.<&>)\n\nwhenJust_ :: Maybe a -> (a -> SqlExpr (Value Bool)) -> SqlExpr (Value Bool)\nwhenJust_ mbVal func = maybe (Esq.val True) func mbVal\n\nwhenTrue_ :: Bool -> SqlExpr (Value Bool) -> SqlExpr (Value Bool)\nwhenTrue_ bl func = bool (Esq.val True) func bl\n\nupdateWhenJust_ :: (a -> SqlExpr (Entity e) -> SqlExpr Esq.Update) -> Maybe a -> [SqlExpr (Entity e) -> SqlExpr Esq.Update]\nupdateWhenJust_ f = maybe [] (\\value -> [f value])\n\nmaybe_ ::\n  forall a b.\n  (PersistField a, PersistField b) =>\n  SqlExpr (Value b) ->\n  (SqlExpr (Value a) -> SqlExpr (Value b)) ->\n  SqlExpr (Value (Maybe a)) ->\n  SqlExpr (Value b)\nmaybe_ def f mbVal =\n  case_\n    [when_ (Esq.isNothing mbVal) then_ def]\n    ( else_ $ f $ Esq.veryUnsafeCoerceSqlExprValue mbVal\n    )\n",
      "hash": "f78d70d2ec65d0f84dfa15bca5086233b52b9b8683f52b0b8d703af40f588be7",
      "size": 10777
    },
    "/lib/mobility-core/src/Kernel/Storage/Esqueleto/SqlDB.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n{-# LANGUAGE DerivingStrategies #-}\n{-# LANGUAGE GeneralizedNewtypeDeriving #-}\n\nmodule Kernel.Storage.Esqueleto.SqlDB\n  ( SqlDBEnv (..),\n    SqlDB (..),\n    SelectSqlDB (..),\n    FullEntitySqlDB,\n    liftToFullEntitySqlDB,\n    withFullEntity,\n    withFullEntities,\n  )\nwhere\n\nimport Data.Time (UTCTime)\nimport Database.Esqueleto.Experimental (SqlBackend)\nimport EulerHS.Prelude\nimport Kernel.Storage.Esqueleto.Class\nimport Kernel.Storage.Esqueleto.Logger (LoggerIO)\nimport Kernel.Types.GuidLike\nimport Kernel.Types.MonadGuid\nimport Kernel.Types.Time (MonadTime (..))\nimport Kernel.Utils.Logging\n\nnewtype SqlDBEnv = SqlDBEnv\n  { currentTime :: UTCTime\n  }\n\nnewtype SqlDB a = SqlDB {unSqlDB :: ReaderT SqlDBEnv (ReaderT SqlBackend LoggerIO) a}\n  deriving newtype (Functor, Applicative, Monad, MonadTime, MonadGuid, Log, MonadThrow)\n\ninstance Monad m => MonadTime (ReaderT SqlDBEnv m) where\n  getCurrentTime = asks (.currentTime)\n\ninstance MonadGuid (ReaderT SqlDBEnv (ReaderT SqlBackend LoggerIO)) where\n  generateGUIDText = lift $ lift generateGUID\n\ninstance Log (ReaderT SqlDBEnv (ReaderT SqlBackend LoggerIO)) where\n  logOutput a b = lift . lift $ logOutput a b\n  withLogTag a (ReaderT f1) = ReaderT $ \\env1 -> do\n    let (ReaderT f2) = f1 env1\n    ReaderT $ \\env2 ->\n      withLogTag a $ f2 env2\n\nnewtype SelectSqlDB a = SelectSqlDB {unSelectSqlDB :: SqlDB a}\n  deriving newtype (Functor, Applicative, Monad, MonadTime, MonadGuid, Log, MonadThrow)\n\nnewtype FullEntitySqlDB t = FullEntitySqlDB\n  { getSqlDB :: SqlDB t\n  }\n  deriving newtype (Functor, Applicative, Monad, MonadTime, MonadGuid)\n\nliftToFullEntitySqlDB :: SqlDB t -> FullEntitySqlDB t\nliftToFullEntitySqlDB = FullEntitySqlDB\n\nwithFullEntity' :: ToTType t a => a -> (t -> b) -> b\nwithFullEntity' dtype func = func $ toTType dtype\n\nwithFullEntity :: ToTType t a => a -> (t -> FullEntitySqlDB b) -> SqlDB b\nwithFullEntity dtype func = getSqlDB $ withFullEntity' dtype func\n\nwithFullEntities' :: ToTType t a => [a] -> ([t] -> b) -> b\nwithFullEntities' [] f = f []\nwithFullEntities' (x : xs) f =\n  withFullEntity' x $ \\y ->\n    withFullEntities' xs \\ys -> f (y : ys)\n\nwithFullEntities :: ToTType t a => [a] -> ([t] -> FullEntitySqlDB b) -> SqlDB b\nwithFullEntities dtypes func = getSqlDB $ withFullEntities' dtypes func\n",
      "hash": "2b906181d30d0d1cfd53001c90bf23bff694a0a515ffd16298caa15fcff3c61b",
      "size": 2973
    },
    "/lib/mobility-core/src/Kernel/Storage/Esqueleto/Transactionable.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n\nmodule Kernel.Storage.Esqueleto.Transactionable where\n\nimport qualified Data.Pool as DP\nimport Database.Esqueleto.Experimental (runSqlPool)\nimport Database.Persist.Postgresql (runSqlPoolNoTransaction)\nimport qualified EulerHS.Types as ET\nimport Kernel.Prelude hiding (either)\nimport Kernel.Storage.Esqueleto.Config\nimport Kernel.Storage.Esqueleto.DTypeBuilder\nimport Kernel.Storage.Esqueleto.Logger\nimport Kernel.Storage.Esqueleto.SqlDB\nimport Kernel.Types.Logging\nimport Kernel.Types.Time (getCurrentTime)\nimport Kernel.Utils.IOLogging (LoggerEnv)\nimport Kernel.Utils.Logging (logError)\n\ntype Transactionable m = Transactionable' SelectSqlDB m\n\nclass (MonadThrow m, Log m) => Transactionable' m1 m where\n  runTransaction :: m1 a -> m a\n\ninstance {-# OVERLAPPING #-} Transactionable' SqlDB SqlDB where\n  runTransaction = identity\n\ninstance {-# OVERLAPPING #-} Transactionable' SelectSqlDB SqlDB where\n  runTransaction = unSelectSqlDB\n\ninstance {-# OVERLAPPING #-} Transactionable' SelectSqlDB SelectSqlDB where\n  runTransaction = identity\n\ninstance {-# INCOHERENT #-} (HasEsqEnv m r, MonadThrow m, Log m) => Transactionable' SelectSqlDB m where\n  runTransaction (SelectSqlDB m) = do\n    dbEnv <- asks (.esqDBEnv)\n    runNoTransactionImpl dbEnv m\n\ninstance {-# OVERLAPPING #-} Transactionable' SqlDB m => Transactionable' SqlDB (DTypeBuilder m) where\n  runTransaction f = liftToBuilder $ runTransaction f\n\n-- We need INCOHERENT here because in next case:\n-- create :: a -> m ()\n-- create = runTransaction  . create'\n-- compiler cannot figure out which instance to use since in some cases it might be SqlDB\n-- and in another it might be not.\n-- But with INCOHERENT it will always use Transactionable' m instance.\n-- It's fine since Transactionable' SqlDB instance should be used only in find... functions,\n-- which have proper Transactionable' instance.\ninstance {-# INCOHERENT #-} (HasEsqEnv m r, MonadThrow m, Log m) => Transactionable' SqlDB m where\n  runTransaction m = do\n    dbEnv <- asks (.esqDBEnv)\n    runTransactionImpl dbEnv m\n\nrunTransactionImpl ::\n  (HasEsq m r) =>\n  EsqDBEnv ->\n  SqlDB a ->\n  m a\nrunTransactionImpl dbEnv run = do\n  logEnv <- asks (.loggerEnv)\n  liftIO $ runTransactionIO logEnv dbEnv run\n\nrunTransactionIO :: LoggerEnv -> EsqDBEnv -> SqlDB a -> IO a\nrunTransactionIO logEnv dbEnv (SqlDB run) = do\n  now <- getCurrentTime\n  let sqlDBEnv =\n        SqlDBEnv\n          { currentTime = now\n          }\n  runLoggerIO logEnv\n    . withLogTag \"DB QUERY\"\n    . destroyAllConnAndRetryIfExpired dbEnv\n    $ runSqlPool (runReaderT run sqlDBEnv) dbEnv.connPool\n\nrunInReplica :: (EsqDBReplicaFlow m r, MonadThrow m, Log m) => SelectSqlDB a -> m a\nrunInReplica (SelectSqlDB m) = do\n  dbEnv <- asks (.esqDBReplicaEnv)\n  runNoTransactionImpl dbEnv m\n\nrunNoTransaction :: (EsqDBFlow m r, MonadThrow m, Log m) => SqlDB a -> m a\nrunNoTransaction m = do\n  dbEnv <- asks (.esqDBEnv)\n  runNoTransactionImpl dbEnv m\n\nrunNoTransactionImpl ::\n  (HasEsq m r) =>\n  EsqDBEnv ->\n  SqlDB a ->\n  m a\nrunNoTransactionImpl dbEnv run = do\n  logEnv <- asks (.loggerEnv)\n  liftIO $ runNoTransactionIO logEnv dbEnv run\n\nrunNoTransactionIO :: LoggerEnv -> EsqDBEnv -> SqlDB a -> IO a\nrunNoTransactionIO logEnv dbEnv (SqlDB run) = do\n  now <- getCurrentTime\n  let sqlDBEnv =\n        SqlDBEnv\n          { currentTime = now\n          }\n  runLoggerIO logEnv\n    . withLogTag \"DB QUERY NO TRANSACTION\"\n    . destroyAllConnAndRetryIfExpired dbEnv\n    $ runSqlPoolNoTransaction (runReaderT run sqlDBEnv) dbEnv.connPool Nothing\n\ndestroyAllConnAndRetryIfExpired :: EsqDBEnv -> LoggerIO a -> LoggerIO a\ndestroyAllConnAndRetryIfExpired dbEnv action =\n  catch @_ @SomeException action $ \\e -> do\n    let res = transformException e\n    logError $ \"Transformed ERROR response: \" <> show res\n    case res of\n      ET.DBError (ET.SQLError (ET.PostgresError (ET.PostgresSqlError \"\" ET.PostgresFatalError \"\" \"\" \"\"))) _ -> do\n        liftIO $ DP.destroyAllResources dbEnv.connPool\n        action\n      _ -> throwIO e\n\ntransformException :: SomeException -> ET.DBError\ntransformException e =\n  maybe\n    (ET.DBError ET.UnrecognizedError $ show e)\n    (ET.postgresErrorToDbError (show e))\n    $ fromException e\n",
      "hash": "70a0bc4a0ca48da3b101b29831e9c424d96e6d8efc5c509b25e1156d141d5aea",
      "size": 4876
    },
    "/lib/mobility-core/src/Kernel/Storage/Esqueleto/Types.hs": {
      "type": "content",
      "content": "{-# LANGUAGE DerivingStrategies #-}\n{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n{-# LANGUAGE StandaloneDeriving #-}\n\nmodule Kernel.Storage.Esqueleto.Types\n  ( Point (..),\n    Geom (..),\n    PostgresList (..),\n    PostgresNonEmptyList (..),\n    Table,\n    MbTable,\n    PostgresListField,\n  )\nwhere\n\nimport Data.ByteString (ByteString)\nimport qualified Database.Beam as B\nimport Database.Beam.Backend\nimport Database.Beam.Postgres\nimport Database.Esqueleto.Experimental hiding (Table)\nimport Database.PostgreSQL.Simple.FromField (FromField (fromField))\nimport qualified Database.PostgreSQL.Simple.FromField as DPSF\nimport Kernel.Prelude\n\ndata Point = Point\n  deriving stock (Show, Eq, Read, Ord, Generic)\n  deriving anyclass (FromJSON, ToJSON, ToSchema)\n\nfromFieldPoint ::\n  DPSF.Field ->\n  Maybe ByteString ->\n  DPSF.Conversion Point\nfromFieldPoint f mbValue = case mbValue of\n  Nothing -> DPSF.returnError DPSF.UnexpectedNull f mempty\n  Just _ -> pure Point\n\ninstance FromField Point where\n  fromField = fromFieldPoint\n\ninstance HasSqlValueSyntax be String => HasSqlValueSyntax be Point where\n  sqlValueSyntax = autoSqlValueSyntax\n\ninstance BeamSqlBackend be => B.HasSqlEqualityCheck be Point\n\ninstance FromBackendRow Postgres Point\n\ninstance PersistField Point where\n  toPersistValue _ = error \"This value should not be used in queries directly.\"\n  fromPersistValue _ = return Point\n\ninstance PersistFieldSql Point where\n  sqlType _ = SqlOther \"geography\"\n\ndata Geom = Geom\n  deriving (Generic, Show, Read, Eq, ToSchema)\n\ninstance PersistField Geom where\n  toPersistValue _ = error \"This value should not be used in queries directly.\"\n  fromPersistValue _ = return Geom\n\ninstance PersistFieldSql Geom where\n  sqlType _ = SqlOther \"geometry\"\n\nclass PostgresListField a\n\ninstance PostgresListField (PostgresList a)\n\ninstance PostgresListField (PostgresNonEmptyList a)\n\n--\nnewtype PostgresList a = PostgresList {unPostgresList :: [a]}\n\n-- It works, but what the hell is going on here?\n-- toPersistValue -- [a] -> PersistArray\n-- fromPersistValue -- PersistList -> [a]\n-- we use different PersistValue constructors for marshaling there and back\n--\n-- This instance isn't currently properly tested, but it works at least for a list of doubles.\ninstance (PersistField a) => PersistField (PostgresList a) where\n  toPersistValue (PostgresList xs) = PersistArray $ map toPersistValue xs\n  fromPersistValue (PersistList xs) = PostgresList <$> mapM fromPersistValue xs\n  fromPersistValue x = Left $ \"Cannot convert \" <> show x <> \" to PostgresList\"\n\ninstance (PersistField a) => PersistFieldSql (PostgresList a) where\n  sqlType _ = SqlString\n\n--\nnewtype PostgresNonEmptyList a = PostgresNonEmptyList {unPostgresNonEmptyList :: NonEmpty a}\n\ninstance (PersistField a) => PersistField (PostgresNonEmptyList a) where\n  toPersistValue (PostgresNonEmptyList xs) = PersistArray $ map toPersistValue $ toList xs\n  fromPersistValue (PersistList (s : xs)) = PostgresNonEmptyList <$> mapM fromPersistValue (s :| xs)\n  fromPersistValue x = Left $ \"Cannot convert \" <> show x <> \" to PostgresNonEmptyList\"\n\ninstance (PersistField a) => PersistFieldSql (PostgresNonEmptyList a) where\n  sqlType _ = SqlString\n\ntype Table a = SqlExpr (Entity a)\n\ntype MbTable a = SqlExpr (Maybe (Entity a))\n",
      "hash": "b0dfda2d5e109e7e67763f362f8b6e1ace7fc91764497eaf6e06c7b8e5b45444",
      "size": 3913
    },
    "/lib/mobility-core/src/Kernel/Storage/Hedis.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n\nmodule Kernel.Storage.Hedis (module Reexport) where\n\nimport Kernel.Storage.Hedis.Config as Reexport\nimport Kernel.Storage.Hedis.Error as Reexport\nimport Kernel.Storage.Hedis.Queries as Reexport\n",
      "hash": "13fb01eb9a05b39b8c517b7faa961664e85a50b671792d2b66a62808d4dc1558",
      "size": 888
    },
    "/lib/mobility-core/src/Kernel/Storage/Hedis/AppPrefixes.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n\nmodule Kernel.Storage.Hedis.AppPrefixes where\n\nimport Kernel.Prelude\nimport Kernel.Storage.Hedis.Config\n\nriderAppPrefix :: KeyModifierFunc\nriderAppPrefix = (\"app-backend:\" <>)\n\nstaticOfferDriverAppPrefix :: KeyModifierFunc\nstaticOfferDriverAppPrefix = (\"static-offer-driver-app:\" <>)\n\npublicTransportBapPrefix :: KeyModifierFunc\npublicTransportBapPrefix = (\"public-transport-bap:\" <>)\n",
      "hash": "3635f0487d8a0d127540f3bda78fa237d0a53916b119e0b0e3de9dd7c970784b",
      "size": 1079
    },
    "/lib/mobility-core/src/Kernel/Storage/Hedis/Config.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n\nmodule Kernel.Storage.Hedis.Config where\n\nimport qualified Control.Monad.Catch as C\nimport Data.Word (Word16)\nimport Database.Redis\nimport GHC.Records.Extra\nimport Kernel.Prelude\nimport Kernel.Tools.Metrics.CoreMetrics\nimport Kernel.Types.Logging\nimport Kernel.Types.Time\nimport Kernel.Utils.Dhall (FromDhall)\nimport Network.Socket (HostName)\n\ntype HedisFlow m env =\n  (MonadTime m, MonadClock m, CoreMetrics m, MonadCatch m, MonadReader env m, HedisFlowEnv env, MonadIO m, C.MonadThrow m, Log m)\n\ntype HedisFlowEnv env = (HasField \"hedisMigrationStage\" env Bool, HasField \"hedisClusterEnv\" env HedisEnv, HasField \"hedisNonCriticalClusterEnv\" env HedisEnv, HasField \"hedisEnv\" env HedisEnv, HasField \"hedisNonCriticalEnv\" env HedisEnv, HasField \"enablePrometheusMetricLogging\" env Bool, HasField \"enableRedisLatencyLogging\" env Bool)\n\ntype KeyModifierFunc = (Text -> Text)\n\ndata HedisCfg = HedisCfg\n  { connectHost :: HostName,\n    connectPort :: Word16,\n    connectAuth :: Maybe Text,\n    connectDatabase :: Integer,\n    connectMaxConnections :: Int,\n    connectMaxIdleTime :: NominalDiffTime,\n    connectTimeout :: Maybe NominalDiffTime,\n    connectReadOnly :: Bool\n  }\n  deriving (Generic, Show, FromDhall)\n\ndata HedisEnv = HedisEnv\n  { hedisConnection :: Connection,\n    keyModifier :: KeyModifierFunc\n  }\n  deriving (Generic)\n\ndefaultHedisCfg :: HedisCfg\ndefaultHedisCfg =\n  HedisCfg\n    { connectHost = \"localhost\",\n      connectPort = 6379,\n      connectAuth = Nothing,\n      connectDatabase = 0,\n      connectMaxConnections = 50,\n      connectMaxIdleTime = 30,\n      connectTimeout = Nothing,\n      connectReadOnly = False\n    }\n\nwithHedisEnv :: HedisCfg -> KeyModifierFunc -> (HedisEnv -> IO a) -> IO a\nwithHedisEnv cfg keyModifier = C.bracket (connectHedis cfg keyModifier) disconnectHedis\n\nconnectHedisCluster :: HedisCfg -> KeyModifierFunc -> IO HedisEnv\nconnectHedisCluster cfg keyModifier = do\n  conn <- connectCluster connectInfo\n  return $\n    HedisEnv\n      { hedisConnection = conn,\n        keyModifier = keyModifier\n      }\n  where\n    connectInfo :: ConnectInfo\n    connectInfo =\n      defaultConnectInfo\n        { connectHost = cfg.connectHost,\n          connectPort = PortNumber $ toEnum $ fromEnum cfg.connectPort,\n          connectAuth = encodeUtf8 <$> cfg.connectAuth,\n          connectDatabase = cfg.connectDatabase,\n          connectMaxConnections = cfg.connectMaxConnections,\n          connectMaxIdleTime = cfg.connectMaxIdleTime,\n          connectTimeout = cfg.connectTimeout,\n          connectReadOnly = cfg.connectReadOnly\n        }\n\nconnectHedis :: HedisCfg -> KeyModifierFunc -> IO HedisEnv\nconnectHedis cfg keyModifier = do\n  conn <- checkedConnect connectInfo\n  return $\n    HedisEnv\n      { hedisConnection = conn,\n        keyModifier = keyModifier\n      }\n  where\n    connectInfo :: ConnectInfo\n    connectInfo =\n      defaultConnectInfo\n        { connectHost = cfg.connectHost,\n          connectPort = PortNumber $ toEnum $ fromEnum cfg.connectPort,\n          connectAuth = encodeUtf8 <$> cfg.connectAuth,\n          connectDatabase = cfg.connectDatabase,\n          connectMaxConnections = cfg.connectMaxConnections,\n          connectMaxIdleTime = cfg.connectMaxIdleTime,\n          connectTimeout = cfg.connectTimeout\n        }\n\ndisconnectHedis :: HedisEnv -> IO ()\ndisconnectHedis HedisEnv {..} =\n  disconnect hedisConnection\n",
      "hash": "2f9a23e5016934c4e56059c62518e376ca2b8204853e2c87c57b1fd6d5a29911",
      "size": 4058
    },
    "/lib/mobility-core/src/Kernel/Storage/Hedis/Error.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n{-# LANGUAGE DeriveAnyClass #-}\n{-# LANGUAGE TemplateHaskell #-}\n\nmodule Kernel.Storage.Hedis.Error where\n\nimport Kernel.Prelude\nimport Kernel.Types.Error.BaseError\nimport Kernel.Types.Error.BaseError.HTTPError\n\ndata HedisError\n  = HedisReplyError String\n  | HedisDecodeError Text\n  | HedisTransactionAborted\n  deriving (Show, Typeable, IsBecknAPIError)\n\ninstanceExceptionWithParent 'HTTPException ''HedisError\n\ninstance IsBaseError HedisError where\n  toMessage = \\case\n    HedisReplyError err -> Just $ show err\n    HedisDecodeError err -> Just err\n    HedisTransactionAborted -> Nothing\n\ninstance IsHTTPError HedisError where\n  toErrorCode = \\case\n    HedisReplyError _ -> \"REDIS_REPLY_ERROR\"\n    HedisDecodeError _ -> \"REDIS_DECODE_ERROR\"\n    HedisTransactionAborted -> \"REDIS_TRANSACTION_ABORTED\"\n  toHttpCode _ = E500\n\ninstance IsAPIError HedisError\n",
      "hash": "991f74eb93f6b96dd5a772443c7a70c92d8cdcbc5e3ca4ea9533d60e5dd47f99",
      "size": 1548
    },
    "/lib/mobility-core/src/Kernel/Storage/Hedis/Queries.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n\nmodule Kernel.Storage.Hedis.Queries (module Reexport, module Kernel.Storage.Hedis.Queries) where\n\nimport qualified Data.Aeson as Ae\nimport qualified Data.ByteString as BS\nimport qualified Data.ByteString.Lazy as BSL\nimport Data.String.Conversions\nimport Data.Text hiding (concatMap, map, null)\nimport qualified Data.Text as T\nimport qualified Data.Text as Text\nimport Database.Redis as Reexport (GeoBy (..), GeoFrom (..), Queued, Redis, RedisTx, Reply, TxResult (..))\nimport qualified Database.Redis as Hedis\nimport qualified Database.Redis.Cluster as Cluster\nimport EulerHS.Prelude (whenLeft)\nimport GHC.Records.Extra\nimport Kernel.Prelude\nimport Kernel.Storage.Hedis.Config\nimport Kernel.Storage.Hedis.Error\nimport Kernel.Utils.DatastoreLatencyCalculator\nimport qualified Kernel.Utils.Error.Throwing as Error\nimport Kernel.Utils.Logging\nimport qualified Test.RandomStrings as RS\n\ntype ExpirationTime = Int\n\ndata XReadResponse = XReadResponse\n  { stream :: BS.ByteString,\n    records :: [StreamsRecord]\n  }\n  deriving (Show)\n\ndata StreamsRecord = StreamsRecord\n  { recordId :: BS.ByteString,\n    keyValues :: [(BS.ByteString, BS.ByteString)]\n  }\n  deriving (Show)\n\nconvertFromHedisResponse :: Hedis.XReadResponse -> XReadResponse\nconvertFromHedisResponse hedisResponse =\n  XReadResponse\n    { stream = Hedis.stream hedisResponse,\n      records = map convertFromHedisRecord (Hedis.records hedisResponse)\n    }\n\nconvertFromHedisRecord :: Hedis.StreamsRecord -> StreamsRecord\nconvertFromHedisRecord hedisRecord =\n  StreamsRecord\n    { recordId = Hedis.recordId hedisRecord,\n      keyValues = Hedis.keyValues hedisRecord\n    }\n\nrunHedis ::\n  HedisFlow m env => Redis (Either Reply a) -> m a\nrunHedis action = do\n  eithRes <- runHedisEither action\n  Error.fromEitherM (HedisReplyError . show) eithRes\n\nrunHedisEither ::\n  HedisFlow m env => Redis (Either Reply a) -> m (Either Reply a)\nrunHedisEither action = do\n  con <- asks (.hedisClusterEnv.hedisConnection)\n  liftIO $ Hedis.runRedis con action\n\nrunHedisTransaction ::\n  HedisFlow m env => RedisTx (Queued a) -> m a\nrunHedisTransaction action = do\n  con <- asks (.hedisClusterEnv.hedisConnection)\n  res <- liftIO . Hedis.runRedis con $ Hedis.multiExec action\n  case res of\n    TxError err -> Error.throwError $ HedisReplyError err\n    TxAborted -> Error.throwError HedisTransactionAborted\n    TxSuccess a -> return a\n\n----------------------------------------------------\n\nmodifyMasterOnlyConnection :: Hedis.Connection -> Hedis.Connection\nmodifyMasterOnlyConnection (Hedis.ClusteredConnection connInfo (Cluster.Connection mvar infoMap clusterCfg)) =\n  Hedis.ClusteredConnection connInfo (Cluster.Connection mvar infoMap (clusterCfg {Cluster.useMasterOnly = Just True}))\nmodifyMasterOnlyConnection nonClustered = nonClustered -- If it's NonClusteredConnection, return it unchanged\n\nwithMasterRedis ::\n  (HedisFlow m env) => m f -> m f\nwithMasterRedis f = do\n  local\n    ( \\env ->\n        env{hedisEnv =\n              (env.hedisEnv)\n                { hedisConnection = modifyMasterOnlyConnection (hedisConnection (env.hedisEnv))\n                },\n            hedisClusterEnv =\n              (env.hedisClusterEnv)\n                { hedisConnection = modifyMasterOnlyConnection (hedisConnection (env.hedisClusterEnv))\n                },\n            hedisNonCriticalEnv =\n              (env.hedisNonCriticalEnv)\n                { hedisConnection = modifyMasterOnlyConnection (hedisConnection (env.hedisNonCriticalEnv))\n                },\n            hedisNonCriticalClusterEnv =\n              (env.hedisNonCriticalClusterEnv)\n                { hedisConnection = modifyMasterOnlyConnection (hedisConnection (env.hedisNonCriticalClusterEnv))\n                }\n           }\n    )\n    f\n\n-- Just remove key modifier, so it won't modify the key with app prefixes\nwithCrossAppRedis ::\n  (HedisFlow m env) => m f -> m f\nwithCrossAppRedis f = do\n  local (\\env -> env{hedisEnv = env.hedisEnv{keyModifier = identity}, hedisClusterEnv = env.hedisClusterEnv{keyModifier = identity}}) f\n\nwithNonCriticalCrossAppRedis ::\n  (HedisFlow m env) => m f -> m f\nwithNonCriticalCrossAppRedis f = do\n  local (\\env -> env{hedisEnv = env.hedisNonCriticalEnv{keyModifier = identity}, hedisClusterEnv = env.hedisNonCriticalClusterEnv{keyModifier = identity}}) f\n\nwithNonCriticalRedis ::\n  (HedisFlow m env) => m f -> m f\nwithNonCriticalRedis f = do\n  local (\\env -> env{hedisEnv = env.hedisNonCriticalEnv, hedisClusterEnv = env.hedisNonCriticalClusterEnv}) f\n\nbuildKey :: HedisFlow m env => Text -> m BS.ByteString\nbuildKey key = do\n  keyModifier <- asks (.hedisEnv.keyModifier)\n  return . cs $ keyModifier key\n\nrunWithPrefixEither :: (HedisFlow m env) => Text -> (BS.ByteString -> Redis (Either Reply a)) -> m (Either Reply a)\nrunWithPrefixEither key action = do\n  prefKey <- buildKey key\n  runHedisEither $ action prefKey\n\nrunWithPrefix :: (HedisFlow m env) => Text -> (BS.ByteString -> Redis (Either Reply a)) -> m a\nrunWithPrefix key action = do\n  prefKey <- buildKey key\n  runHedis $ action prefKey\n\nrunWithPrefix_ :: (HedisFlow m env) => Text -> (BS.ByteString -> Redis (Either Reply a)) -> m ()\nrunWithPrefix_ key action = void $ runWithPrefix key action\n\nrunWithPrefix'_ :: (HedisFlow m env) => Text -> (BS.ByteString -> Redis (Either Reply a)) -> m ()\nrunWithPrefix'_ key action = void $ runWithPrefix' key action\n\nrunWithPrefix' :: (HedisFlow m env) => Text -> (BS.ByteString -> Redis (Either Reply a)) -> m a\nrunWithPrefix' key action = do\n  prefKey <- buildKey key\n  runHedis' $ action prefKey\n\nrunHedisTransaction' ::\n  HedisFlow m env => RedisTx (Queued a) -> m a\nrunHedisTransaction' action = do\n  con <- asks (.hedisEnv.hedisConnection)\n  res <- liftIO . Hedis.runRedis con $ Hedis.multiExec action\n  case res of\n    TxError err -> Error.throwError $ HedisReplyError err\n    TxAborted -> Error.throwError HedisTransactionAborted\n    TxSuccess a -> return a\n\nrunHedis' ::\n  HedisFlow m env => Redis (Either Reply a) -> m a\nrunHedis' action = do\n  eithRes <- runHedisEither' action\n  Error.fromEitherM (HedisReplyError . show) eithRes\n\nrunHedisEither' ::\n  HedisFlow m env => Redis (Either Reply a) -> m (Either Reply a)\nrunHedisEither' action = do\n  con <- asks (.hedisEnv.hedisConnection)\n  liftIO $ Hedis.runRedis con action\n\ntryGetFromStandalone :: HedisFlow m env => Text -> m (Maybe BS.ByteString)\ntryGetFromStandalone key = withLogTag \"STANDALONE\" $ do\n  eitherMaybeBS <- withTimeRedis \"RedisStandalone\" \"get\" $ try @_ @SomeException (runWithPrefix' key Hedis.get)\n  case eitherMaybeBS of\n    Left err -> logTagInfo \"ERROR_WHILE_GET\" (show err) $> Nothing\n    Right maybeBS -> pure maybeBS\n\ntryGetFromCluster :: HedisFlow m env => Text -> m (Maybe BS.ByteString)\ntryGetFromCluster key = withLogTag \"CLUSTER\" $ do\n  eitherMaybeBS <- withTimeRedis \"RedisCluster\" \"get\" $ try @_ @SomeException (runWithPrefix key Hedis.get)\n  case eitherMaybeBS of\n    Left err -> logTagInfo \"ERROR_WHILE_GET\" (show err) $> Nothing\n    Right maybeBS -> pure maybeBS\n\ngetImpl :: (FromJSON a, HedisFlow m env) => (BS.ByteString -> m (Maybe a)) -> Text -> m (Maybe a)\ngetImpl decodeResult key = withLogTag \"Redis\" $ do\n  res <- tryGetFromCluster key\n  case res of\n    Nothing -> do\n      migrating <- asks (.hedisMigrationStage)\n      if migrating\n        then do\n          res' <- tryGetFromStandalone key\n          maybe (pure Nothing) decodeResult res'\n        else pure Nothing\n    Just res' -> decodeResult res'\n\nget :: (FromJSON a, HedisFlow m env) => Text -> m (Maybe a)\nget = getImpl decodeResult\n  where\n    decodeResult bs = Error.fromMaybeM (HedisDecodeError $ cs bs) $ Ae.decode $ BSL.fromStrict bs\n\nget' ::\n  (FromJSON a, HedisFlow m env) => Text -> m () -> m (Maybe a)\nget' key decodeErrHandler = getImpl decodeResult key\n  where\n    decodeResult bs =\n      case Ae.decode $ BSL.fromStrict bs of\n        Just a -> return $ Just a\n        Nothing -> do\n          logTagError \"REDIS\" $ \"Decode Failure for key:\" <> key <> \", with value:\" <> cs bs\n          decodeErrHandler\n          return Nothing\n\nsafeGet ::\n  (FromJSON a, HedisFlow m env) => Text -> m (Maybe a)\nsafeGet key = get' key (del key)\n\nset ::\n  (ToJSON a, HedisFlow m env) => Text -> a -> m ()\nset key val = withLogTag \"Redis\" $ do\n  migrating <- asks (.hedisMigrationStage)\n  if migrating\n    then do\n      res <- withTimeRedis \"RedisStandalone\" \"set\" $ try @_ @SomeException (runWithPrefix'_ key $ \\prefKey -> Hedis.set prefKey $ BSL.toStrict $ Ae.encode val)\n      whenLeft res (\\err -> withLogTag \"STANDALONE\" $ logTagInfo \"FAILED_TO_SET\" $ show err)\n    else pure ()\n  res <- withTimeRedis \"RedisCluster\" \"set\" $ try @_ @SomeException (runWithPrefix_ key $ \\prefKey -> Hedis.set prefKey $ BSL.toStrict $ Ae.encode val)\n  whenLeft res (\\err -> withLogTag \"CLUSTER\" $ logTagInfo \"FAILED_TO_SET\" $ show err)\n\nsetExp ::\n  (ToJSON a, HedisFlow m env) => Text -> a -> ExpirationTime -> m ()\nsetExp key val expirationTime = withTimeRedis \"Redis\" \"setExp\" . withLogTag \"Redis\" $ do\n  prefKey <- buildKey key\n  migrating <- asks (.hedisMigrationStage)\n  if migrating\n    then do\n      standaloneRes <-\n        withTimeRedis \"RedisStandalone\" \"setExp\" $\n          try @_ @SomeException $ do\n            void . runHedisTransaction' $ do\n              void . Hedis.set prefKey $ BSL.toStrict $ Ae.encode val\n              Hedis.expire prefKey (toInteger expirationTime)\n      whenLeft standaloneRes (\\err -> withLogTag \"STANDALONE\" $ logTagInfo \"FAILED_TO_SETEXP\" $ show err)\n    else pure ()\n  clusterRes <-\n    withTimeRedis \"RedisCluster\" \"setExp\" $\n      try @_ @SomeException $ do\n        void . runHedisTransaction $ do\n          void . Hedis.set prefKey $ BSL.toStrict $ Ae.encode val\n          Hedis.expire prefKey (toInteger expirationTime)\n  whenLeft clusterRes (\\err -> withLogTag \"CLUSTER\" $ logTagInfo \"FAILED_TO_SETEXP\" $ show err)\n\nsetNx ::\n  (ToJSON a, HedisFlow m env) => Text -> a -> m Bool\nsetNx key val = withLogTag \"Redis\" $ do\n  migrating <- asks (.hedisMigrationStage)\n  writtenInStandalone <-\n    if migrating\n      then do\n        standaloneRes <- withTimeRedis \"RedisStandalone\" \"setNx\" $ try @_ @SomeException $ runWithPrefix' key $ \\prefKey -> Hedis.setnx prefKey $ BSL.toStrict $ Ae.encode val\n        case standaloneRes of\n          Left err -> withLogTag \"STANDALONE\" (logTagInfo \"FAILED_TO_SETNX\" $ show err) $> False\n          Right res -> pure res\n      else pure False\n  clusterRes <- withTimeRedis \"RedisCluster\" \"setNx\" $ try @_ @SomeException $ runWithPrefix key $ \\prefKey -> Hedis.setnx prefKey $ BSL.toStrict $ Ae.encode val\n  case clusterRes of\n    Left err -> withLogTag \"CLUSTER\" (logTagInfo \"FAILED_TO_SETNX\" $ show err) $> (writtenInStandalone || False)\n    Right res -> pure $ writtenInStandalone || res\n\ndel :: (HedisFlow m env) => Text -> m ()\ndel key = withLogTag \"Redis\" do\n  migrating <- asks (.hedisMigrationStage)\n  if migrating\n    then do\n      res <- withTimeRedis \"RedisStandalone\" \"del\" $ try @_ @SomeException (runWithPrefix'_ key $ \\prefKey -> Hedis.del [prefKey])\n      whenLeft res (\\err -> withLogTag \"STANDALONE\" $ logTagInfo \"FAILED_TO_DELETE\" $ show err)\n    else pure ()\n  res <- withTimeRedis \"RedisCluster\" \"del\" $ try @_ @SomeException (runWithPrefix_ key $ \\prefKey -> Hedis.del [prefKey])\n  whenLeft res (\\err -> withLogTag \"CLUSTER\" $ logTagInfo \"FAILED_TO_DELETE\" $ show err)\n\nrPushExp :: (HedisFlow m env, ToJSON a) => Text -> [a] -> ExpirationTime -> m ()\nrPushExp key list ex = withLogTag \"Redis\" $ do\n  prefKey <- buildKey key\n  unless (null list) $ do\n    migrating <- asks (.hedisMigrationStage)\n    if migrating\n      then do\n        standaloneRes <-\n          withTimeRedis \"RedisStandalone\" \"rPushExp\" $ do\n            try @_ @SomeException $ do\n              void . runHedisTransaction' $ do\n                void . Hedis.rpush prefKey $ map (BSL.toStrict . Ae.encode) list\n                Hedis.expire prefKey (toInteger ex)\n        whenLeft standaloneRes (\\err -> withLogTag \"STANDALONE\" $ logTagInfo \"FAILED_TO_PUSHEXP\" $ show err)\n      else pure ()\n    clusterRes <-\n      withTimeRedis \"RedisCluster\" \"rPushExp\" $ do\n        try @_ @SomeException $ do\n          void . runHedisTransaction $ do\n            void . Hedis.rpush prefKey $ map (BSL.toStrict . Ae.encode) list\n            Hedis.expire prefKey (toInteger ex)\n    whenLeft clusterRes (\\err -> withLogTag \"CLUSTER\" $ logTagInfo \"FAILED_TO_PUSHEXP\" $ show err)\n\nlPush :: (HedisFlow m env, ToJSON a) => Text -> NonEmpty a -> m ()\nlPush key list = withTimeRedis \"RedisCluster\" \"lPush\" . runWithPrefix_ key $ \\prefKey ->\n  Hedis.lpush prefKey $ map (BSL.toStrict . Ae.encode) (toList list)\n\nrPush :: (HedisFlow m env, ToJSON a) => Text -> NonEmpty a -> m ()\nrPush key list = withTimeRedis \"RedisCluster\" \"rPush\" . runWithPrefix_ key $ \\prefKey ->\n  Hedis.rpush prefKey $ map (BSL.toStrict . Ae.encode) (toList list)\n\nrPop :: (HedisFlow m env, FromJSON a) => Text -> m (Maybe a)\nrPop key = withTimeRedis \"RedisCluster\" \"rPop\" $ do\n  res <- runWithPrefix key $ \\prefKey -> Hedis.rpop prefKey\n  pure $ Ae.decode . BSL.fromStrict =<< res\n\nlTrim :: (HedisFlow m env) => Text -> Integer -> Integer -> m ()\nlTrim key start stop = withTimeRedis \"RedisCluster\" \"lTrim\" . runWithPrefix_ key $ \\prefKey ->\n  Hedis.ltrim prefKey start stop\n\nclearList :: (HedisFlow m env) => Text -> m ()\nclearList key = lTrim key 2 1\n\nlLen :: (HedisFlow m env) => Text -> m Integer\nlLen key = withTimeRedis \"RedisCluster\" \"lLen\" $ runWithPrefix key Hedis.llen\n\nlRange :: (HedisFlow m env, FromJSON a) => Text -> Integer -> Integer -> m [a]\nlRange key start stop = withTimeRedis \"RedisCluster\" \"lRange\" $ do\n  res <- runWithPrefix key $ \\prefKey ->\n    Hedis.lrange prefKey start stop\n  mapM (\\a -> Error.fromMaybeM (HedisDecodeError $ cs a) . Ae.decode $ cs a) res\n\ngetList :: (HedisFlow m env, FromJSON a) => Text -> m [a]\ngetList key = lRange key 0 (-1)\n\nincr :: (HedisFlow m env) => Text -> m Integer\nincr key = withTimeRedis \"RedisCluster\" \"incr\" $ runWithPrefix key Hedis.incr\n\nincrby :: (HedisFlow m env) => Text -> Integer -> m Integer\nincrby key val = withTimeRedis \"RedisCluster\" \"incrBy\" $ runWithPrefix key $ flip Hedis.incrby val\n\ndecr :: (HedisFlow m env) => Text -> m Integer\ndecr key = withTimeRedis \"RedisCluster\" \"decr\" $ runWithPrefix key Hedis.decr\n\ndecrby :: (HedisFlow m env) => Text -> Integer -> m Integer\ndecrby key val = withTimeRedis \"RedisCluster\" \"decrBy\" $ runWithPrefix key $ flip Hedis.decrby val\n\nincrByFloat :: (HedisFlow m env) => Text -> Double -> m Double\nincrByFloat key toAdd = withTimeRedis \"RedisCluster\" \"incrByFloat\" . runWithPrefix key $ \\prefKey ->\n  Hedis.incrbyfloat prefKey toAdd\n\nexpire :: (HedisFlow m env) => Text -> ExpirationTime -> m ()\nexpire key expirationTime = do\n  migrating <- asks (.hedisMigrationStage)\n  when migrating . withTimeRedis \"RedisStandalone\" \"expire\" . runWithPrefix'_ key $ \\prefKey -> Hedis.expire prefKey (toInteger expirationTime)\n  withTimeRedis \"RedisCluster\" \"expire\" . runWithPrefix_ key $ \\prefKey -> Hedis.expire prefKey (toInteger expirationTime)\n\nsetNxExpire :: (ToJSON a, HedisFlow m env) => Text -> ExpirationTime -> a -> m Bool\nsetNxExpire key expirationTime val = withTimeRedis \"RedisCluster\" \"setNxExpire\" $ do\n  eithRes <- runWithPrefixEither key $ \\prefKey ->\n    Hedis.setOpts prefKey (cs $ Ae.encode val) $\n      Hedis.SetOpts (Just $ toInteger expirationTime) Nothing (Just Hedis.Nx)\n  pure $ case eithRes of\n    Right Hedis.Ok -> True\n    _ -> False\n\ndecrIfExist :: HedisFlow m env => Text -> m Integer\ndecrIfExist key = do\n  res <- withTimeRedis \"RedisCluster\" \"decrIfExist\" $\n    runWithPrefix key $ \\prefKey ->\n      Hedis.eval\n        \"if tonumber(redis.call('GET', KEYS[1]) or '0') > 0 then return redis.call('DECR', KEYS[1]) else return nil end\"\n        [prefKey]\n        []\n  case res of\n    Just (Hedis.Integer i) -> pure i\n    _ -> pure (-1)\n\nzAddIfPossible :: HedisFlow m env => Text -> (Text, Double) -> Int -> Double -> m Integer\nzAddIfPossible key (member, score) maxSize fromScore = do\n  let script =\n        \"if redis.call('ZCOUNT', KEYS[1], ARGV[1], ARGV[2]) < tonumber(ARGV[3]) then \"\n          ++ \"redis.call('ZADD', KEYS[1], ARGV[2], ARGV[4]); return 1 \"\n          ++ \"else return 0 end\"\n  result <- withTimeRedis \"RedisCluster\" \"zAddIfPossible\" $\n    runWithPrefix key $ \\prefKey ->\n      Hedis.eval (cs script) [prefKey] [cs (show fromScore :: String), cs (show score :: String), cs (show maxSize :: String), cs member]\n\n  case result of\n    Just (Hedis.Integer i) -> pure i\n    _ -> pure (-1)\n\ntryLockRedis :: HedisFlow m env => Text -> ExpirationTime -> m Bool\ntryLockRedis key timeout = setNxExpire (buildLockResourceName key) timeout ()\n\nunlockRedis :: HedisFlow m env => Text -> m ()\nunlockRedis key = void . del $ buildLockResourceName key\n\nwhenWithLockRedis :: (HedisFlow m env, MonadMask m) => Text -> ExpirationTime -> m () -> m ()\nwhenWithLockRedis key timeout func = do\n  whenM (tryLockRedis key timeout) $ do\n    finally func $ unlockRedis key\n\nwhenWithLockRedisAndReturnValue :: (HedisFlow m env, MonadMask m) => Text -> ExpirationTime -> m a -> m (Either () a)\nwhenWithLockRedisAndReturnValue key timeout func = do\n  locked <- tryLockRedis key timeout\n  if locked\n    then do\n      res <- finally func $ unlockRedis key\n      return $ Right res\n    else return $ Left ()\n\nwithWaitAndLockRedis :: (HedisFlow m env, MonadMask m) => Text -> ExpirationTime -> Int -> m a -> m a\nwithWaitAndLockRedis key timeout delay func = do\n  getLock\n  finally func (unlockRedis key)\n  where\n    getLock = do\n      lockAvailable <- tryLockRedis key timeout\n      threadDelay delay\n      unless lockAvailable getLock\n\nwithLockRedis :: (HedisFlow m env, MonadMask m) => Text -> ExpirationTime -> m () -> m ()\nwithLockRedis key timeout func = do\n  getLock\n  finally func (unlockRedis key)\n  where\n    getLock = do\n      lockAvailable <- tryLockRedis key timeout\n      unless lockAvailable getLock\n\nwithLockRedisAndReturnValue :: (HedisFlow m env, MonadMask m) => Text -> ExpirationTime -> m a -> m a\nwithLockRedisAndReturnValue key timeout func = do\n  getLock\n  finally func (unlockRedis key)\n  where\n    getLock = do\n      lockAvailable <- tryLockRedis key timeout\n      unless lockAvailable getLock\n\nwithWaitOnLockRedisWithExpiry :: (HedisFlow m env, MonadMask m) => Text -> ExpirationTime -> ExpirationTime -> m () -> m ()\nwithWaitOnLockRedisWithExpiry key timeout recursionTimeOut func = do\n  uuid <- T.pack <$> liftIO (RS.randomString (RS.onlyAlphaNum RS.randomASCII) 10)\n  let keyE = \"recursion timeout for:\" <> uuid\n  setExp keyE True recursionTimeOut\n  withMasterRedis $ withWaitOnLockRedisWithExpiry' keyE key timeout func\n\nwithWaitOnLockRedisWithExpiry' :: (HedisFlow m env, MonadMask m) => Text -> Text -> ExpirationTime -> m () -> m ()\nwithWaitOnLockRedisWithExpiry' recursionTimedOutKey key timeout func = do\n  toExecute <- getLock recursionTimedOutKey\n  when toExecute $ do\n    finally func $ do\n      unlockRedis key\n      del recursionTimedOutKey\n  where\n    getLock recurrsionTimedOutKey' = do\n      get recurrsionTimedOutKey' >>= \\case\n        Just a -> do\n          lockAvailable <- tryLockRedis key timeout\n          if not lockAvailable && a\n            then getLock recurrsionTimedOutKey'\n            else return True\n        Nothing -> do\n          tryLockRedis key timeout\n\nbuildLockResourceName :: (IsString a) => Text -> a\nbuildLockResourceName key = fromString $ \"mobility:locker:\" <> Text.unpack key\n\nhSetExp :: (ToJSON a, HedisFlow m env) => Text -> Text -> a -> ExpirationTime -> m ()\nhSetExp key field value expirationTime = withLogTag \"Redis\" $ do\n  prefKey <- buildKey key\n  migrating <- asks (.hedisMigrationStage)\n  if migrating\n    then do\n      standaloneRes <-\n        withTimeRedis \"RedisStandalone\" \"hSetExp\" $ do\n          try @_ @SomeException $ do\n            void . runHedisTransaction' $ do\n              void . Hedis.hset prefKey (cs field) $ BSL.toStrict $ Ae.encode value\n              Hedis.expire prefKey (toInteger expirationTime)\n      whenLeft standaloneRes (\\err -> withLogTag \"STANDALONE\" $ logTagInfo \"FAILED_TO_HSETEXP\" $ show err)\n    else pure ()\n  clusterRes <-\n    withTimeRedis \"RedisCluster\" \"hSetExp\" $ do\n      try @_ @SomeException $ do\n        void . runHedisTransaction $ do\n          void . Hedis.hset prefKey (cs field) $ BSL.toStrict $ Ae.encode value\n          Hedis.expire prefKey (toInteger expirationTime)\n  whenLeft clusterRes (\\err -> withLogTag \"CLUSTER\" $ logTagInfo \"FAILED_TO_HSETEXP\" $ show err)\n\nsafeHGet :: (FromJSON a, HedisFlow m env) => Text -> Text -> m (Maybe a)\nsafeHGet key field =\n  withTimeRedis \"RedisCluster\" \"safeHGet\" $ do\n    maybeBS <- runWithPrefix key (`Hedis.hget` cs field)\n    case maybeBS of\n      Nothing -> pure Nothing\n      Just bs -> case Ae.decode $ BSL.fromStrict bs of\n        Just a -> return $ Just a\n        Nothing -> do\n          logTagError \"REDIS\" $ \"Decode Failure for hash key:\" <> key <> \", field:\" <> field <> \", with value:\" <> cs bs\n          hDel key [field]\n          return Nothing\n\nhGet :: (FromJSON a, HedisFlow m env) => Text -> Text -> m (Maybe a)\nhGet key field =\n  withTimeRedis \"RedisCluster\" \"hGet\" $ do\n    maybeBS <- runWithPrefix key (`Hedis.hget` cs field)\n    case maybeBS of\n      Nothing -> pure Nothing\n      Just bs -> Error.fromMaybeM (HedisDecodeError $ cs bs) $ Ae.decode $ BSL.fromStrict bs\n\nhmGet :: (FromJSON a, HedisFlow m env) => Text -> [Text] -> m [Maybe a]\nhmGet key fields =\n  withTimeRedis \"RedisCluster\" \"hmGet\" $ do\n    listBS <- runWithPrefix key (`Hedis.hmget` map cs fields)\n    mapM decodeBS listBS\n  where\n    decodeBS :: (FromJSON a, HedisFlow m env) => Maybe BS.ByteString -> m (Maybe a)\n    decodeBS Nothing = pure Nothing\n    decodeBS (Just bs) = Error.fromMaybeM (HedisDecodeError $ cs bs) $ Ae.decode $ BSL.fromStrict bs\n\nhDel :: HedisFlow m env => Text -> [Text] -> m ()\nhDel key fields = withTimeRedis \"RedisCluster\" \"hDel\" $ runWithPrefix_ key (`Hedis.hdel` map cs fields)\n\nhGetAll :: (FromJSON a, HedisFlow m env) => Text -> m [(Text, a)]\nhGetAll key = withTimeRedis \"RedisCluster\" \"hGetAll\" $ do\n  hMap <- runWithPrefix key Hedis.hgetall\n  pure $ mapMaybe (\\(k, val) -> (cs k,) <$> Ae.decode (BSL.fromStrict val)) hMap\n\nzAddExp :: (ToJSON Integer, HedisFlow m env) => Text -> Text -> Integer -> ExpirationTime -> m ()\nzAddExp key field value expirationTime = withLogTag \"Redis\" $ do\n  prefKey <- buildKey key\n  migrating <- asks (.hedisMigrationStage)\n  if migrating\n    then do\n      standaloneRes <-\n        try @_ @SomeException $ do\n          void . runHedisTransaction' $ do\n            void . Hedis.zadd prefKey $ [(fromIntegral value, cs field)]\n            Hedis.expire prefKey (toInteger expirationTime)\n      whenLeft standaloneRes (\\err -> withLogTag \"STANDALONE\" $ logTagInfo \"FAILED_TO_ZADDEXP\" $ show err)\n    else pure ()\n  clusterRes <-\n    try @_ @SomeException $ do\n      void . runHedisTransaction $ do\n        void . Hedis.zadd prefKey $ [(fromIntegral value, cs field)]\n        Hedis.expire prefKey (toInteger expirationTime)\n  whenLeft clusterRes (\\err -> withLogTag \"CLUSTER\" $ logTagInfo \"FAILED_TO_ZADDEXP\" $ show err)\n\nzrevrangeWithscores :: (HedisFlow m env) => Text -> Integer -> Integer -> m [(Text, Double)]\nzrevrangeWithscores key start stop = do\n  res <- runWithPrefix key $ \\prefKey ->\n    Hedis.zrevrangeWithscores prefKey start stop\n  pure $ map (\\(k, score) -> (cs' k, score)) res\n  where\n    cs' :: BS.ByteString -> Text\n    cs' = cs\n\nzScore :: (FromJSON Double, HedisFlow m env) => Text -> Text -> m (Maybe Double)\nzScore key member = do\n  maybeZS <- runWithPrefix key (`Hedis.zscore` cs member)\n  pure maybeZS\n\nzRevRank :: (FromJSON Integer, HedisFlow m env) => Text -> Text -> m (Maybe Integer)\nzRevRank key member = do\n  maybeZr <- runWithPrefix key (`Hedis.zrevrank` cs member)\n  pure maybeZr\n\nzCard :: (HedisFlow m env) => Text -> m Integer\nzCard key = runWithPrefix key Hedis.zcard\n\nzAdd ::\n  (ToJSON member, HedisFlow m env) =>\n  Text ->\n  [(Double, member)] ->\n  m ()\nzAdd key members = withLogTag \"Redis\" $ do\n  migrating <- asks (.hedisMigrationStage)\n  if migrating\n    then do\n      res <- withTimeRedis \"RedisStandalone\" \"zAdd\" $ try @_ @SomeException (runWithPrefix'_ key $ \\prefKey -> Hedis.zadd prefKey $ map (\\(score, member) -> (score, BSL.toStrict $ Ae.encode member)) members)\n      whenLeft res (\\err -> withLogTag \"STANDALONE\" $ logTagInfo \"FAILED_TO_ZADD\" $ show err)\n    else pure ()\n  res <- withTimeRedis \"RedisCluster\" \"zAdd\" $ try @_ @SomeException (runWithPrefix_ key $ \\prefKey -> Hedis.zadd prefKey $ map (\\(score, member) -> (score, BSL.toStrict $ Ae.encode member)) members)\n  whenLeft res (\\err -> withLogTag \"CLUSTER\" $ logTagInfo \"FAILED_TO_ZADD\" $ show err)\n\nzCount :: (HedisFlow m env) => Text -> Double -> Double -> m Integer\nzCount key mn mx = withTimeRedis \"RedisStandalone\" \"zCount\" $ runWithPrefix key $ \\prefKey -> Hedis.zcount prefKey mn mx\n\nzIncrBy ::\n  (ToJSON member, HedisFlow m env) =>\n  Text ->\n  Integer ->\n  member ->\n  m ()\nzIncrBy key increment member = withLogTag \"Redis\" $ do\n  migrating <- asks (.hedisMigrationStage)\n  if migrating\n    then do\n      res <- withTimeRedis \"RedisStandalone\" \"zIncrBy\" $ try @_ @SomeException (runWithPrefix'_ key $ \\prefKey -> Hedis.zincrby prefKey increment (BSL.toStrict $ Ae.encode member))\n      whenLeft res (\\err -> withLogTag \"STANDALONE\" $ logTagInfo \"FAILED_TO_ZINCRBY\" $ show err)\n    else pure ()\n  res <- withTimeRedis \"RedisCluster\" \"zIncrBy\" $ try @_ @SomeException (runWithPrefix_ key $ \\prefKey -> Hedis.zincrby prefKey increment (BSL.toStrict $ Ae.encode member))\n  whenLeft res (\\err -> withLogTag \"CLUSTER\" $ logTagInfo \"FAILED_TO_ZINCRBY\" $ show err)\n\nxInfoGroups ::\n  (HedisFlow m env) =>\n  Text -> -- Stream key\n  m Bool\nxInfoGroups key = do\n  migrating <- asks (.hedisMigrationStage)\n  eitherMaybeBS <-\n    if migrating\n      then withTimeRedis \"RedisStandalone\" \"xInfoGroups\" $ try @_ @SomeException (runWithPrefix' key Hedis.xinfoGroups)\n      else withTimeRedis \"RedisCluster\" \"xInfoGroups\" $ try @_ @SomeException (runWithPrefix key Hedis.xinfoGroups)\n  ls <-\n    case eitherMaybeBS of\n      Left err -> logTagInfo \"ERROR_WHILE_GET_XInfoGroups\" (show err) $> []\n      Right maybeBS -> pure maybeBS\n  return $ not (null ls)\n\n-- Function to create a new consumer group for a stream\nxGroupCreate ::\n  (HedisFlow m env) =>\n  Text -> -- Stream key\n  Text -> -- Group name\n  Text -> -- Start ID\n  m ()\nxGroupCreate key groupName startId = withLogTag \"Redis\" $ do\n  migrating <- asks (.hedisMigrationStage)\n  when migrating $ do\n    res <- withTimeRedis \"RedisStandalone\" \"xGroupCreate\" $ try @_ @SomeException (runWithPrefix'_ key $ \\prefKey -> Hedis.xgroupCreate prefKey (cs groupName) (cs startId))\n    whenLeft res (withLogTag \"STANDALONE\" . logTagInfo \"FAILED_TO_xGroupCreate\" . show)\n  res <- withTimeRedis \"RedisCluster\" \"xGroupCreate\" $ try @_ @SomeException (runWithPrefix_ key $ \\prefKey -> Hedis.xgroupCreate prefKey (cs groupName) (cs startId))\n  whenLeft res (withLogTag \"CLUSTER\" . logTagInfo \"FAILED_TO_xGroupCreate\" . show)\n\nextractKeyValuePairs :: [StreamsRecord] -> [(Text, Text)]\nextractKeyValuePairs = concatMap (\\(StreamsRecord _ keyVals) -> map (\\(k, v) -> (cs k, cs v)) keyVals)\n\nextractRecordIds :: [StreamsRecord] -> [BS.ByteString]\nextractRecordIds = map (\\(StreamsRecord recordId _) -> recordId)\n\nxReadGroup ::\n  (HedisFlow m env) =>\n  Text -> -- group name\n  Text -> -- consumer name\n  [(Text, Text)] -> -- (stream, id) pairs\n  m (Maybe [XReadResponse])\nxReadGroup groupName consumerName pairsList = do\n  let bsPairsList = map (\\(stream, id) -> (cs stream, cs id)) pairsList\n  let mbKeyVal = listToMaybe bsPairsList\n  case mbKeyVal of\n    Just keyVal -> do\n      migrating <- asks (.hedisMigrationStage)\n      eitherMaybeBS <-\n        if migrating\n          then withTimeRedis \"RedisStandalone\" \"XReadGroup\" $ try @_ @SomeException (runWithPrefix' (cs $ fst keyVal) $ \\_ -> Hedis.xreadGroup (cs groupName) (cs consumerName) bsPairsList)\n          else withTimeRedis \"RedisCluster\" \"XReadGroup\" $ try @_ @SomeException (runWithPrefix (cs $ fst keyVal) $ \\_ -> Hedis.xreadGroup (cs groupName) (cs consumerName) bsPairsList)\n      mbRes <-\n        case eitherMaybeBS of\n          Left err -> logTagInfo \"ERROR_WHILE_GET_XReadGroup\" (show err) $> Nothing\n          Right maybeBS -> pure maybeBS\n      case mbRes of\n        Just res -> return $ Just (map convertFromHedisResponse res)\n        Nothing -> pure Nothing\n    Nothing -> pure Nothing\n\nxReadGroupOpts ::\n  (HedisFlow m env) =>\n  Text -> -- group name\n  Text -> -- consumer name\n  [(Text, Text)] -> -- (stream, id) pairs\n  Maybe Integer ->\n  Maybe Integer ->\n  m (Maybe [XReadResponse])\nxReadGroupOpts groupName consumerName pairsList block_ recordCount_ = do\n  let opts = Hedis.XReadOpts {block = block_, recordCount = recordCount_, noack = False}\n  let bsPairsList = map (\\(stream, id) -> (cs stream, cs id)) pairsList\n  let mbKeyVal = listToMaybe bsPairsList\n  case mbKeyVal of\n    Just keyVal -> do\n      migrating <- asks (.hedisMigrationStage)\n      eitherMaybeBS <-\n        if migrating\n          then withTimeRedis \"RedisStandalone\" \"xReadGroupOpts\" $ try @_ @SomeException (runWithPrefix' (cs $ fst keyVal) $ \\_ -> Hedis.xreadGroupOpts (cs groupName) (cs consumerName) bsPairsList opts)\n          else withTimeRedis \"RedisCluster\" \"xReadGroupOpts\" $ try @_ @SomeException (runWithPrefix (cs $ fst keyVal) $ \\_ -> Hedis.xreadGroupOpts (cs groupName) (cs consumerName) bsPairsList opts)\n      mbRes <-\n        case eitherMaybeBS of\n          Left err -> logTagInfo \"ERROR_WHILE_GET_XReadGroupOpts\" (show err) $> Nothing\n          Right maybeBS -> pure maybeBS\n      case mbRes of\n        Just res -> return $ Just (map convertFromHedisResponse res)\n        Nothing -> pure Nothing\n    Nothing -> pure Nothing\n\nxAdd :: (HedisFlow m env) => Text -> Text -> [(BS.ByteString, BS.ByteString)] -> m BS.ByteString\nxAdd key entryId fieldValues = withLogTag \"Redis\" $ do\n  migrating <- asks (.hedisMigrationStage)\n  when migrating $ do\n    res <- withTimeRedis \"RedisStandalone\" \"xadd\" $ try @_ @SomeException (runWithPrefix'_ key $ \\prefKey -> Hedis.xadd prefKey (cs entryId) fieldValues)\n    whenLeft res (withLogTag \"STANDALONE\" . logTagInfo \"FAILED_TO_xadd\" . show)\n  res <- withTimeRedis \"RedisCluster\" \"xadd\" $ try @_ @SomeException (runWithPrefix key $ \\prefKey -> Hedis.xadd prefKey (cs entryId) fieldValues)\n  case res of\n    Left err -> do\n      withLogTag \"CLUSTER\" $ logTagInfo \"xadd\" $ show err\n      pure \"\"\n    Right items -> pure items\n\nxAddExp :: (HedisFlow m env) => Text -> Text -> [(BS.ByteString, BS.ByteString)] -> ExpirationTime -> m ()\nxAddExp key entryId fieldValues expirationTime = withLogTag \"Redis\" $ do\n  prefKey <- buildKey key\n  migrating <- asks (.hedisMigrationStage)\n  when migrating $ do\n    res <-\n      withTimeRedis \"RedisStandalone\" \"xaddExp\" $\n        try @_ @SomeException $ do\n          void $\n            runHedisTransaction' $ do\n              void $ Hedis.xadd prefKey (cs entryId) fieldValues\n              Hedis.expire prefKey (toInteger expirationTime)\n    whenLeft res (withLogTag \"STANDALONE\" . logTagInfo \"FAILED_TO_xaddExp\" . show)\n  clusterRes <-\n    withTimeRedis \"RedisCluster\" \"xaddExp\" $\n      try @_ @SomeException $ do\n        void $\n          runHedisTransaction $ do\n            void $ Hedis.xadd prefKey (cs entryId) fieldValues\n            Hedis.expire prefKey (toInteger expirationTime)\n  whenLeft clusterRes (withLogTag \"CLUSTER\" . logTagInfo \"FAILED_TO_XADDEXP\" . show)\n\nzRangeByScoreByCount :: (HedisFlow m env) => Text -> Double -> Double -> Integer -> Integer -> m [BS.ByteString]\nzRangeByScoreByCount key start end offset limit = withLogTag \"Redis\" $ do\n  migrating <- asks (.hedisMigrationStage)\n  when migrating $ do\n    res <- withTimeRedis \"RedisStandalone\" \"zRangeByScoreByCount\" $ try @_ @SomeException (runWithPrefix'_ key $ \\prefKey -> Hedis.zrangebyscoreLimit prefKey start end offset limit)\n    whenLeft res (withLogTag \"STANDALONE\" . logTagInfo \"FAILED_TO_ZRANGEBYSCOREBYCOUNT\" . show)\n  res <- withTimeRedis \"RedisCluster\" \"zRangeByScoreByCount\" $ try @_ @SomeException (runWithPrefix key $ \\prefKey -> Hedis.zrangebyscoreLimit prefKey start end offset limit)\n  case res of\n    Left err -> do\n      withLogTag \"CLUSTER\" $ logTagInfo \"FAILED_TO_ZRANGEBYSCOREBYCOUNT\" $ show err\n      pure [] -- Return an empty list if there was an error\n    Right items -> pure items\n\nzRangeByScore :: (HedisFlow m env) => Text -> Double -> Double -> m [BS.ByteString]\nzRangeByScore key start end = withLogTag \"Redis\" $ do\n  migrating <- asks (.hedisMigrationStage)\n  when migrating $ do\n    res <- withTimeRedis \"RedisStandalone\" \"zRangeByScore\" $ try @_ @SomeException (runWithPrefix'_ key $ \\prefKey -> Hedis.zrangebyscore prefKey start end)\n    whenLeft res (withLogTag \"STANDALONE\" . logTagInfo \"FAILED_TO_ZRANGEBYSCORE\" . show)\n  res <- withTimeRedis \"RedisCluster\" \"zRangeByScore\" $ try @_ @SomeException (runWithPrefix key $ \\prefKey -> Hedis.zrangebyscore prefKey start end)\n  case res of\n    Left err -> do\n      withLogTag \"CLUSTER\" $ logTagInfo \"FAILED_TO_ZRANGEBYSCORE\" $ show err\n      pure [] -- Return an empty list if there was an error\n    Right items -> pure items\n\nzRange :: (HedisFlow m env) => Text -> Integer -> Integer -> m [BS.ByteString]\nzRange key start end = withLogTag \"Redis\" $ do\n  migrating <- asks (.hedisMigrationStage)\n  when migrating $ do\n    res <- withTimeRedis \"RedisStandalone\" \"zRange\" $ try @_ @SomeException (runWithPrefix'_ key $ \\prefKey -> Hedis.zrange prefKey start end)\n    whenLeft res (withLogTag \"STANDALONE\" . logTagInfo \"FAILED_TO_ZRANGE\" . show)\n  res <- withTimeRedis \"RedisCluster\" \"zRange\" $ try @_ @SomeException (runWithPrefix key $ \\prefKey -> Hedis.zrange prefKey start end)\n  case res of\n    Left err -> do\n      withLogTag \"CLUSTER\" $ logTagInfo \"FAILED_TO_ZRANGE\" $ show err\n      pure [] -- Return an empty list if there was an error\n    Right items -> pure items\n\nzRangeWithScores :: (HedisFlow m env) => Text -> Integer -> Integer -> m [(BS.ByteString, Double)]\nzRangeWithScores key start end = withLogTag \"Redis\" $ do\n  migrating <- asks (.hedisMigrationStage)\n  when migrating $ do\n    res <- withTimeRedis \"RedisStandalone\" \"zRangeWithScores\" $ try @_ @SomeException (runWithPrefix'_ key $ \\prefKey -> Hedis.zrangeWithscores prefKey start end)\n    whenLeft res (withLogTag \"STANDALONE\" . logTagInfo \"FAILED_TO_ZRANGE_WITH_SCORES\" . show)\n  res <- withTimeRedis \"RedisCluster\" \"zRangeWithScores\" $ try @_ @SomeException (runWithPrefix key $ \\prefKey -> Hedis.zrangeWithscores prefKey start end)\n  case res of\n    Left err -> do\n      withLogTag \"CLUSTER\" $ logTagInfo \"FAILED_TO_ZRANGE_WITH_SCORES\" $ show err\n      pure [] -- Return an empty list if there was an error\n    Right items -> pure items\n\nzRemRangeByScore :: (HedisFlow m env) => Text -> Double -> Double -> m Integer\nzRemRangeByScore key start end = withLogTag \"Redis\" $ do\n  migrating <- asks (.hedisMigrationStage)\n  when migrating $ do\n    res <- withTimeRedis \"RedisStandalone\" \"zRemRangeByScore\" $ try @_ @SomeException (runWithPrefix'_ key $ \\prefKey -> Hedis.zremrangebyscore prefKey start end)\n    case res of\n      Left err -> withLogTag \"STANDALONE\" $ logTagInfo \"FAILED_TO_ZREMRANGEBYSCORE\" $ show err\n      Right items -> pure items\n  res <- withTimeRedis \"RedisCluster\" \"zRemRangeByScore\" $ try @_ @SomeException (runWithPrefix key $ \\prefKey -> Hedis.zremrangebyscore prefKey start end)\n  case res of\n    Left err -> do\n      withLogTag \"CLUSTER\" $ logTagInfo \"FAILED_TO_ZREMRANGEBYSCORE\" $ show err\n      pure (-1) -- Return -1 if there was an error\n    Right items -> pure items\n\nzRem :: (HedisFlow m env) => Text -> [Text] -> m Integer\nzRem key members = withLogTag \"Redis\" $ do\n  migrating <- asks (.hedisMigrationStage)\n  when migrating $ do\n    res <- withTimeRedis \"RedisStandalone\" \"zRem\" $ try @_ @SomeException (runWithPrefix'_ key $ \\prefKey -> Hedis.zrem prefKey (map cs members))\n    case res of\n      Left err -> withLogTag \"STANDALONE\" $ logTagInfo \"FAILED_TO_ZREM\" $ show err\n      Right items -> pure items\n  res <- withTimeRedis \"RedisCluster\" \"zRem\" $ try @_ @SomeException (runWithPrefix key $ \\prefKey -> Hedis.zrem prefKey (map cs members))\n  case res of\n    Left err -> do\n      withLogTag \"CLUSTER\" $ logTagInfo \"FAILED_TO_ZREM\" $ show err\n      pure (-1) -- Return -1 if there was an error\n    Right items -> pure items\n\nzRem' :: (ToJSON member, HedisFlow m env) => Text -> [member] -> m ()\nzRem' key members = withLogTag \"Redis\" $ do\n  migrating <- asks (.hedisMigrationStage)\n  if migrating\n    then do\n      res <- withTimeRedis \"RedisStandalone\" \"zRem\" $ try @_ @SomeException (runWithPrefix'_ key $ \\prefKey -> Hedis.zrem prefKey $ map (\\val -> BSL.toStrict $ Ae.encode val) members)\n      whenLeft res (\\err -> withLogTag \"STANDALONE\" $ logTagInfo \"FAILED_TO_ZREM\" $ show err)\n    else pure ()\n  res <- withTimeRedis \"RedisCluster\" \"zRem\" $ try @_ @SomeException (runWithPrefix_ key $ \\prefKey -> Hedis.zrem prefKey $ map (\\val -> BSL.toStrict $ Ae.encode val) members)\n  whenLeft res (\\err -> withLogTag \"CLUSTER\" $ logTagInfo \"FAILED_TO_ZREM\" $ show err)\n\nxDel :: (HedisFlow m env) => Text -> [BS.ByteString] -> m Integer\nxDel key entryId = withLogTag \"Redis\" $ do\n  migrating <- asks (.hedisMigrationStage)\n  when migrating $ do\n    res <- withTimeRedis \"RedisStandalone\" \"xDel\" $ try @_ @SomeException (runWithPrefix'_ key $ \\prefKey -> Hedis.xdel prefKey entryId)\n    case res of\n      Left err -> withLogTag \"STANDALONE\" $ logTagInfo \"FAILED_TO_XDEL\" $ show err\n      Right items -> pure items\n  res <- withTimeRedis \"RedisCluster\" \"xDel\" $ try @_ @SomeException (runWithPrefix key $ \\prefKey -> Hedis.xdel prefKey entryId)\n  case res of\n    Left err -> do\n      withLogTag \"CLUSTER\" $ logTagInfo \"FAILED_TO_XDEL\" $ show err\n      pure (-1) -- Return -1 if there was an error\n    Right items -> pure items\n\nxAck :: (HedisFlow m env) => Text -> Text -> [BS.ByteString] -> m Integer\nxAck key groupName entryId = withLogTag \"Redis\" $ do\n  migrating <- asks (.hedisMigrationStage)\n  when migrating $ do\n    res <- withTimeRedis \"RedisStandalone\" \"xAck\" $ try @_ @SomeException (runWithPrefix'_ key $ \\prefKey -> Hedis.xack prefKey (cs groupName) entryId)\n    case res of\n      Left err -> withLogTag \"STANDALONE\" $ logTagInfo \"FAILED_TO_xAck\" $ show err\n      Right items -> pure items\n  res <- withTimeRedis \"RedisCluster\" \"xAck\" $ try @_ @SomeException (runWithPrefix key $ \\prefKey -> Hedis.xack prefKey (cs groupName) entryId)\n  case res of\n    Left err -> do\n      withLogTag \"CLUSTER\" $ logTagInfo \"FAILED_TO_xAck\" $ show err\n      pure (-1) -- Return -1 if there was an error\n    Right items -> pure items\n\nlrem :: (HedisFlow m env) => Text -> Integer -> Text -> m Integer\nlrem key cnt value = withTimeRedis \"RedisCluster\" \"lrem\" $ runWithPrefix key $ \\prefKey -> Hedis.lrem prefKey cnt (BSL.toStrict $ Ae.encode value)\n\nsAddExp :: (ToJSON a, HedisFlow m env) => Text -> [a] -> ExpirationTime -> m ()\nsAddExp key members expirationTime = withLogTag \"Redis\" $ do\n  prefKey <- buildKey key\n  migrating <- asks (.hedisMigrationStage)\n  if migrating\n    then do\n      standaloneRes <-\n        try @_ @SomeException $ do\n          void . runHedisTransaction' $ do\n            void . Hedis.sadd prefKey $ map (BSL.toStrict . Ae.encode) members\n            Hedis.expire prefKey (toInteger expirationTime)\n      whenLeft standaloneRes (\\err -> withLogTag \"STANDALONE\" $ logTagInfo \"FAILED_TO_SADDEXP\" $ show err)\n    else pure ()\n  clusterRes <-\n    try @_ @SomeException $ do\n      void . runHedisTransaction $ do\n        void . Hedis.sadd prefKey $ map (BSL.toStrict . Ae.encode) members\n        Hedis.expire prefKey (toInteger expirationTime)\n  whenLeft clusterRes (\\err -> withLogTag \"CLUSTER\" $ logTagInfo \"FAILED_TO_SADDEXP\" $ show err)\n\nsrem :: (ToJSON a, HedisFlow m env) => Text -> [a] -> m Integer\nsrem key members = withLogTag \"Redis\" $ do\n  migrating <- asks (.hedisMigrationStage)\n  when migrating $ do\n    res <- withTimeRedis \"RedisStandalone\" \"srem\" $ try @_ @SomeException (runWithPrefix'_ key $ \\prefKey -> Hedis.srem prefKey $ map (BSL.toStrict . Ae.encode) members)\n    case res of\n      Left err -> withLogTag \"STANDALONE\" $ logTagInfo \"FAILED_TO_SREM\" $ show err\n      Right items -> pure items\n  res <- withTimeRedis \"RedisCluster\" \"srem\" $ try @_ @SomeException (runWithPrefix key $ \\prefKey -> Hedis.srem prefKey $ map (BSL.toStrict . Ae.encode) members)\n  case res of\n    Left err -> do\n      withLogTag \"CLUSTER\" $ logTagInfo \"FAILED_TO_SREM\" $ show err\n      pure (-1) -- Returning -1 if there was an error\n    Right items -> pure items\n\nsMembers :: (FromJSON a, HedisFlow m env) => Text -> m [a]\nsMembers key = withTimeRedis \"RedisCluster\" \"sMembers\" $ do\n  res <- runWithPrefix key Hedis.smembers\n  mapM (\\a -> Error.fromMaybeM (HedisDecodeError $ cs a) . Ae.decode $ cs a) res\n\nttl :: (HedisFlow m env) => Text -> m Integer\nttl key = withLogTag \"Redis\" $ do\n  migrating <- asks (.hedisMigrationStage)\n  when migrating $ do\n    res <- withTimeRedis \"RedisStandalone\" \"ttl\" $ try @_ @SomeException (runWithPrefix'_ key $ \\prefKey -> Hedis.ttl prefKey)\n    case res of\n      Left err -> withLogTag \"STANDALONE\" $ logTagInfo \"FAILED_TO_TTL\" $ show err\n      Right expSec -> pure expSec\n  res <- withTimeRedis \"RedisCluster\" \"ttl\" $ try @_ @SomeException (runWithPrefix key $ \\prefKey -> Hedis.ttl prefKey)\n  case res of\n    Left err -> do\n      withLogTag \"CLUSTER\" $ logTagInfo \"FAILED_TO_TTL\" $ show err\n      pure (-1) -- Returning -1 if there was an error\n    Right expSec -> pure expSec\n\npublish :: (HedisFlow m env, ToJSON a) => Text -> a -> m ()\npublish channel message = withLogTag \"Redis\" $ do\n  migrating <- asks (.hedisMigrationStage)\n  let encodedMessage = BSL.toStrict $ Ae.encode message\n  when migrating $ do\n    res <- withTimeRedis \"RedisStandalone\" \"publish\" $\n      try @_ @SomeException $\n        runWithPrefix'_ channel $ \\prefChannel ->\n          Hedis.publish prefChannel encodedMessage\n    whenLeft res $ \\err ->\n      withLogTag \"STANDALONE\" $\n        logTagInfo \"FAILED_TO_PUBLISH\" (show err)\n\n  res <- withTimeRedis \"RedisCluster\" \"publish\" $\n    try @_ @SomeException $\n      runWithPrefix_ channel $ \\prefChannel ->\n        Hedis.publish prefChannel encodedMessage\n  whenLeft res $ \\err ->\n    withLogTag \"CLUSTER\" $\n      logTagInfo \"FAILED_TO_PUBLISH\" (show err)\n\ngeoAdd :: (HedisFlow m env) => Text -> [(Double, Double, BS.ByteString)] -> m Integer\ngeoAdd key geoInfo = withLogTag \"Redis\" $ do\n  migrating <- asks (.hedisMigrationStage)\n  when migrating $ do\n    res <- withTimeRedis \"RedisStandalone\" \"geoAdd\" $ try @_ @SomeException (runWithPrefix'_ key $ \\prefKey -> Hedis.geoadd prefKey geoInfo)\n    case res of\n      Left err -> withLogTag \"STANDALONE\" $ logTagInfo \"FAILED_TO_GEOADD\" $ show err\n      Right items -> pure items\n  res <- withTimeRedis \"RedisCluster\" \"geoAdd\" $ try @_ @SomeException (runWithPrefix key $ \\prefKey -> Hedis.geoadd prefKey geoInfo)\n  case res of\n    Left err -> do\n      withLogTag \"CLUSTER\" $ logTagInfo \"FAILED_TO_GEOADD\" $ show err\n      pure (-1) -- Return -1 if there was an error\n    Right items -> pure items\n\ngeoSearch ::\n  (HedisFlow m env) =>\n  Text ->\n  -- | Search origin: either a member or coordinates.\n  Hedis.GeoFrom ->\n  -- | Search shape: radius or bounding box.\n  Hedis.GeoBy ->\n  -- | Search results.\n  m [BS.ByteString]\ngeoSearch key from by = withLogTag \"Redis\" $ do\n  migrating <- asks (.hedisMigrationStage)\n  if migrating\n    then do\n      res <- withTimeRedis \"RedisStandalone\" \"geosearch\" $ try @_ @SomeException (runWithPrefix' key $ \\prefKey -> Hedis.geosearch prefKey from by)\n      case res of\n        Left err -> do\n          withLogTag \"STANDALONE\" $ logTagInfo \"FAILED_TO_GEOSEARCH\" $ show err\n          pure []\n        Right items -> pure items\n    else do\n      res <- withTimeRedis \"RedisCluster\" \"geosearch\" $ try @_ @SomeException (runWithPrefix key $ \\prefKey -> Hedis.geosearch prefKey from by)\n      case res of\n        Left err -> do\n          withLogTag \"CLUSTER\" $ logTagInfo \"FAILED_TO_GEOSEARCH\" $ show err\n          pure [] -- Return an empty list if there was an error\n        Right items -> pure items\n\ngeoSearchDecoded ::\n  (FromJSON a, HedisFlow m env) =>\n  Text ->\n  -- | Search origin: either a member or coordinates.\n  Hedis.GeoFrom ->\n  -- | Search shape: radius or bounding box.\n  Hedis.GeoBy ->\n  -- | Search results.\n  m [a]\ngeoSearchDecoded key from by = withLogTag \"Redis\" $ do\n  let decodeGeoItems :: (FromJSON a, HedisFlow m env) => [BS.ByteString] -> m [a]\n      decodeGeoItems = mapM (\\a -> Error.fromMaybeM (HedisDecodeError $ cs a) . Ae.decode $ cs a)\n  migrating <- asks (.hedisMigrationStage)\n  if migrating\n    then do\n      res <- withTimeRedis \"RedisStandalone\" \"geosearch\" $ try @_ @SomeException (runWithPrefix' key $ \\prefKey -> Hedis.geosearch prefKey from by)\n      case res of\n        Left err -> do\n          withLogTag \"STANDALONE\" $ logTagInfo \"FAILED_TO_GEOSEARCH\" $ show err\n          pure []\n        Right items -> decodeGeoItems items\n    else do\n      res <- withTimeRedis \"RedisCluster\" \"geosearch\" $ try @_ @SomeException (runWithPrefix key $ \\prefKey -> Hedis.geosearch prefKey from by)\n      case res of\n        Left err -> do\n          withLogTag \"CLUSTER\" $ logTagInfo \"FAILED_TO_GEOSEARCH\" $ show err\n          pure [] -- Return an empty list if there was an error\n        Right items -> decodeGeoItems items\n\nsetTtlIfNone :: (HedisFlow m env) => Text -> ExpirationTime -> m ()\nsetTtlIfNone key secs = do\n  current <- ttl key\n  when (current < 0) $\n    expire key secs\n",
      "hash": "5691dd31374a3273e2fe19ac8a274f1f1d6b493ae7ef73a5cbc20ae2bd6254d5",
      "size": 46412
    },
    "/lib/mobility-core/src/Kernel/Storage/Queries/BecknRequest.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n{-# OPTIONS_GHC -Wno-orphans #-}\n\nmodule Kernel.Storage.Queries.BecknRequest where\n\nimport Kernel.Beam.Functions (FromTType' (fromTType'), ToTType' (toTType'), createWithKV)\nimport Kernel.Beam.Lib.UtilsTH\nimport Kernel.Prelude\nimport qualified Kernel.Storage.Beam.BecknRequest as BeamBR\nimport qualified Kernel.Types.BecknRequest as Domain\nimport Kernel.Types.Id\nimport Kernel.Utils.Common\n\nlogBecknRequest :: (HasSchemaName BeamBR.BecknRequestT, MonadFlow m, CacheFlow m r, EsqDBFlow m r) => Text -> Text -> m ()\nlogBecknRequest reqJSON sign = do\n  uuid <- generateGUID\n  now <- getCurrentTime\n  let request =\n        Domain.BecknRequest\n          { id = uuid,\n            timeStamp = now,\n            becknRequest = reqJSON,\n            signatureHeader = sign\n          }\n  createWithKV request\n\ninstance FromTType' BeamBR.BecknRequest Domain.BecknRequest where\n  fromTType' BeamBR.BecknRequestT {..} = do\n    pure $\n      Just\n        Domain.BecknRequest\n          { id = Id id,\n            ..\n          }\n\ninstance ToTType' BeamBR.BecknRequest Domain.BecknRequest where\n  toTType' Domain.BecknRequest {..} = do\n    BeamBR.BecknRequestT\n      { BeamBR.id = getId id,\n        ..\n      }\n",
      "hash": "690a2e2cd0518ae91b6a9e3ffd678a07bbed34ab1bc714a8f6b569d260744cd9",
      "size": 1882
    },
    "/lib/mobility-core/src/Kernel/Storage/Queries/SystemConfigs.hs": {
      "type": "content",
      "content": "{-# OPTIONS_GHC -Wno-orphans #-}\n\nmodule Kernel.Storage.Queries.SystemConfigs where\n\nimport Kernel.Beam.Functions (FromTType' (fromTType'), ToTType' (toTType'), findOneWithDb)\nimport Kernel.Beam.Lib.UtilsTH\nimport Kernel.Prelude\nimport qualified Kernel.Storage.Beam.SystemConfigs as BeamSC\nimport Kernel.Storage.Esqueleto.Config\nimport Kernel.Tools.Metrics.CoreMetrics.Types\nimport Kernel.Types.CacheFlow (CacheFlow)\nimport Kernel.Types.SystemConfigs as Domain\nimport Sequelize as Se\n\nfindById :: (CacheFlow m r, EsqDBFlow m r, HasSchemaName BeamSC.SystemConfigsT) => Text -> m (Maybe Text)\nfindById cfgId = do\n  findOneWithDb [Se.Is BeamSC.id $ Se.Eq cfgId] <&> (<&> Domain.configValue)\n    >>= maybe (incrementSystemConfigsFailedCounter (\"system_configs_find_failed_\" <> schemaName (Proxy :: Proxy BeamSC.SystemConfigsT) <> \"_\" <> cfgId) >> pure Nothing) (pure . Just)\n\ninstance FromTType' BeamSC.SystemConfigs Domain.SystemConfigs where\n  fromTType' BeamSC.SystemConfigsT {..} = do\n    pure $ Just Domain.SystemConfigs {..}\n\ninstance ToTType' BeamSC.SystemConfigs Domain.SystemConfigs where\n  toTType' Domain.SystemConfigs {..} = do\n    BeamSC.SystemConfigsT {..}\n",
      "hash": "b9b3e9db08eb4235eb7d89265aea07151e88961dd7f21d2d2ff4386356ea593e",
      "size": 1167
    },
    "/lib/mobility-core/src/Kernel/Streaming/Kafka/Commons.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n\nmodule Kernel.Streaming.Kafka.Commons where\n\nimport EulerHS.Prelude\nimport Kernel.Utils.Dhall (FromDhall)\n\ntype KafkaBrokerAddress = Text\n\ntype KafkaBrokersList = [KafkaBrokerAddress]\n\ndata KafkaCompression = NO_COMPRESSION | GZIP | SNAPPY | LZ4 deriving (Generic, Show, FromDhall)\n\ntype KafkaTopic = Text\n\ntype KafkaKey = ByteString\n\ntype KafkaHostName = Maybe Text\n\ntype KafkaServiceName = Text\n",
      "hash": "3636593de04ba44cd280333cae878eb4c6402e870e8e4035323a859996b3dac7",
      "size": 1091
    },
    "/lib/mobility-core/src/Kernel/Streaming/Kafka/Consumer.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n\nmodule Kernel.Streaming.Kafka.Consumer\n  ( Kernel.Streaming.Kafka.Consumer.receiveMessage,\n    listenForMessages,\n  )\nwhere\n\nimport qualified Data.Aeson as A\nimport qualified Data.ByteString.Lazy as LBS\nimport Kafka.Consumer as KafkaCons\nimport Kernel.Prelude\nimport Kernel.Streaming.Kafka.Consumer.Types as ConsTypes\nimport qualified Kernel.Streaming.MonadConsumer as MonadCons\nimport Kernel.Types.Error\nimport Kernel.Utils.Error.Throwing (fromMaybeM, throwError)\nimport Kernel.Utils.Logging\n\nreceiveMessage :: (MonadIO m, Log m, MonadThrow m, FromJSON a) => KafkaConsumerTools a -> m (Maybe a)\nreceiveMessage kafkaConsumerTools = withLogTag \"KafkaConsumer\" $ do\n  let timeout = kafkaConsumerTools.kafkaConsumerCfg.timeoutMilliseconds\n  etrMsg <- pollMessage kafkaConsumerTools.consumer (Timeout timeout)\n  case etrMsg of\n    Left err -> handleResponseError err\n    Right res -> do\n      mbErr <- commitAllOffsets OffsetCommit kafkaConsumerTools.consumer\n      whenJust mbErr $ \\err -> logError $ \"Unable to commit offsets: \" <> show err\n      crValue res >>= A.decode . LBS.fromStrict\n        & fromMaybeM KafkaUnableToParseValue\n        <&> Just\n  where\n    handleResponseError err =\n      case err of\n        KafkaResponseError RdKafkaRespErrTimedOut -> do\n          logInfo \"No messages to consume.\"\n          return Nothing\n        _ -> throwError $ KafkaUnableToConsumeMessage err\n\nlistenForMessages ::\n  ( MonadCons.MonadConsumer a m,\n    MonadIO m,\n    MonadCatch m,\n    Log m,\n    MonadThrow m\n  ) =>\n  m Bool ->\n  (a -> m ()) ->\n  m ()\nlistenForMessages isRunning handleMessage = whileM isRunning $ do\n  etrRes <- try @_ @SomeException MonadCons.receiveMessage\n  case etrRes of\n    Left err -> logInfo $ \"Message was not received: \" <> show err\n    Right mbRes -> whenJust mbRes handleMessage\n",
      "hash": "6abd67de152a24b108f7ede2c8c0c913784c83fd7dc01b0cd2d3db4b55c440c7",
      "size": 2498
    },
    "/lib/mobility-core/src/Kernel/Streaming/Kafka/Consumer/Types.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n\nmodule Kernel.Streaming.Kafka.Consumer.Types\n  ( KafkaConsumerCfg (..),\n    KafkaConsumerTools,\n    HasKafkaConsumer,\n    buildKafkaConsumerTools,\n    releaseKafkaConsumerTools,\n    module Reexport,\n  )\nwhere\n\nimport EulerHS.Prelude\nimport GHC.Records.Extra (HasField)\nimport Kafka.Consumer hiding (ConsumerGroupId, groupId)\nimport qualified Kafka.Consumer as Consumer\nimport Kernel.Streaming.Kafka.Commons as Reexport\nimport Kernel.Streaming.Kafka.HasKafkaTopics\nimport Kernel.Types.Error\nimport Kernel.Utils.Dhall (FromDhall)\n\ntype HasKafkaConsumer env r = HasField \"kafkaConsumerEnv\" r env\n\ntype ConsumerGroupId = Text\n\ndata KafkaConsumerCfg = KafkaConsumerCfg\n  { brokers :: KafkaBrokersList,\n    groupId :: ConsumerGroupId,\n    kafkaCompression :: KafkaCompression,\n    timeoutMilliseconds :: Int\n  }\n  deriving (Generic, FromDhall)\n\ndata KafkaConsumerTools a = KafkaConsumerTools\n  { kafkaConsumerCfg :: KafkaConsumerCfg,\n    consumer :: Consumer.KafkaConsumer\n  }\n  deriving (Generic)\n\nconsumerProps :: KafkaConsumerCfg -> ConsumerProperties\nconsumerProps kafkaConsumerCfg =\n  brokersList castBrokers\n    <> Consumer.groupId (Consumer.ConsumerGroupId kafkaConsumerCfg.groupId)\n    <> logLevel KafkaLogDebug\n    <> compression castCompression\n  where\n    castBrokers = BrokerAddress <$> kafkaConsumerCfg.brokers\n    castCompression =\n      case kafkaConsumerCfg.kafkaCompression of\n        NO_COMPRESSION -> NoCompression\n        GZIP -> Gzip\n        SNAPPY -> Snappy\n        LZ4 -> Lz4\n\nconsumerSub :: [KafkaTopic] -> Subscription\nconsumerSub topicList =\n  Consumer.topics castTopics\n    <> offsetReset Earliest\n  where\n    castTopics = TopicName <$> topicList\n\nbuildKafkaConsumerTools :: forall a. HasKafkaTopics a => KafkaConsumerCfg -> IO (KafkaConsumerTools a)\nbuildKafkaConsumerTools kafkaConsumerCfg = do\n  consumer <-\n    newConsumer (consumerProps kafkaConsumerCfg) (consumerSub $ getTopics @a)\n      >>= either (throwM . KafkaUnableToBuildTools) return\n\n  return $ KafkaConsumerTools {..}\n\nreleaseKafkaConsumerTools :: KafkaConsumerTools a -> IO ()\nreleaseKafkaConsumerTools kafkaConsumerTools =\n  closeConsumer kafkaConsumerTools.consumer\n    >>= flip whenJust (throwM . KafkaUnableToReleaseTools)\n",
      "hash": "f03b7540e2e320692c419958b2ac79c5003cde598416ffefb0f9b8710e8f6b6c",
      "size": 2909
    },
    "/lib/mobility-core/src/Kernel/Streaming/Kafka/HasKafkaTopics.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n{-# LANGUAGE AllowAmbiguousTypes #-}\n\nmodule Kernel.Streaming.Kafka.HasKafkaTopics where\n\nimport Kernel.Streaming.Kafka.Commons\n\nclass HasKafkaTopics a where\n  getTopics :: [KafkaTopic]\n",
      "hash": "d8088cb32e1c1f2afe79bc8d1a581bd90f23cc0699d9dbb11f51c1d4fbafaca4",
      "size": 879
    },
    "/lib/mobility-core/src/Kernel/Streaming/Kafka/Producer.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n\nmodule Kernel.Streaming.Kafka.Producer\n  ( buildKafkaProducerTools,\n    Kernel.Streaming.Kafka.Producer.produceMessage,\n    produceMessageInPartition,\n    releaseKafkaProducerTools,\n    (..=),\n    A.Value (Object),\n    A.emptyObject,\n  )\nwhere\n\nimport Data.Aeson (encode)\nimport qualified Data.Aeson as A\nimport qualified Data.Aeson.Key as AesonKey\nimport qualified Data.Aeson.KeyMap as AKM\nimport qualified Data.Aeson.Types as A\nimport qualified Data.ByteString.Lazy as LBS\nimport EulerHS.Prelude\nimport Kafka.Producer as KafkaProd\nimport Kernel.Streaming.Kafka.Producer.Types\nimport Kernel.Types.Error\nimport Kernel.Types.Logging\nimport Kernel.Utils.Error.Throwing (throwError)\n\ntype KPartitionId = Int\n\nproduceMessage :: (Log m, MonadThrow m, MonadIO m, MonadReader r m, HasKafkaProducer r, ToJSON a) => (KafkaTopic, Maybe KafkaKey) -> a -> m ()\nproduceMessage (topic, key) event = produceMessageImpl (topic, key) event Nothing\n\nproduceMessageInPartition :: (Log m, MonadThrow m, MonadIO m, MonadReader r m, HasKafkaProducer r, ToJSON a) => (KafkaTopic, Maybe KafkaKey) -> a -> KPartitionId -> m ()\nproduceMessageInPartition (topic, key) event partitionId = produceMessageImpl (topic, key) event $ Just partitionId\n\nproduceMessageImpl :: (Log m, MonadThrow m, MonadIO m, MonadReader r m, HasKafkaProducer r, ToJSON a) => (KafkaTopic, Maybe KafkaKey) -> a -> Maybe KPartitionId -> m ()\nproduceMessageImpl (topic, key) event mbPartitionId = do\n  when (null topic) $ throwM KafkaTopicIsEmptyString\n  kafkaProducerTools <- asks (.kafkaProducerTools)\n  mbErr <- KafkaProd.produceMessage kafkaProducerTools.producer message\n  whenJust mbErr (throwError . KafkaUnableToProduceMessage)\n  where\n    message =\n      ProducerRecord\n        { prTopic = TopicName topic,\n          prPartition = maybe UnassignedPartition SpecifiedPartition mbPartitionId,\n          prKey = key,\n          prValue = Just . LBS.toStrict $ encode event\n        }\n\n(..=) :: ToJSON a => AesonKey.Key -> a -> AKM.KeyMap A.Value\n(..=) = (A..=)\n",
      "hash": "1600b53ade9778f0457739100d29da7822733cec5ffe316d1418b07f2a88657a",
      "size": 2704
    },
    "/lib/mobility-core/src/Kernel/Streaming/Kafka/Producer/Types.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n\nmodule Kernel.Streaming.Kafka.Producer.Types\n  ( KafkaProducerCfg (..),\n    KafkaProducerTools,\n    buildKafkaProducerTools,\n    buildKafkaProducerTools',\n    releaseKafkaProducerTools,\n    castCompression,\n    HasKafkaProducer,\n    module Reexport,\n  )\nwhere\n\nimport qualified Data.Map as Map\nimport EulerHS.Prelude\nimport GHC.Records.Extra (HasField)\nimport Kafka.Producer as Producer\nimport Kernel.Streaming.Kafka.Commons as Reexport\nimport qualified Kernel.Types.Common as KTC\nimport Kernel.Types.Error\nimport Kernel.Utils.Dhall (FromDhall)\n\ntype HasKafkaProducer r = HasField \"kafkaProducerTools\" r KafkaProducerTools\n\ndata KafkaProducerCfg = KafkaProducerCfg\n  { brokers :: KafkaBrokersList,\n    kafkaCompression :: KafkaCompression\n  }\n  deriving (Generic, FromDhall)\n\nnewtype KafkaProducerTools = KafkaProducerTools\n  { producer :: Producer.KafkaProducer\n  }\n  deriving (Generic)\n\nproducerProps :: KafkaProducerCfg -> ProducerProperties\nproducerProps kafkaProducerCfg =\n  brokersList castBrokers\n    <> compression (castCompression kafkaProducerCfg.kafkaCompression)\n    <> logLevel KafkaLogDebug\n  where\n    castBrokers = BrokerAddress <$> kafkaProducerCfg.brokers\n\naddProperties :: ProducerProperties -> [KTC.KafkaProperties] -> ProducerProperties\naddProperties props kafkaProperties =\n  let updatedKafkaProps = foldl (\\acc kv -> Map.insert (KTC.propName kv) (KTC.propValue kv) acc) (ppKafkaProps props) kafkaProperties\n   in props {ppKafkaProps = updatedKafkaProps}\n\ncastCompression :: KafkaCompression -> KafkaCompressionCodec\ncastCompression kafkaCompression =\n  case kafkaCompression of\n    NO_COMPRESSION -> NoCompression\n    GZIP -> Gzip\n    SNAPPY -> Snappy\n    LZ4 -> Lz4\n\nbuildKafkaProducerTools' :: KafkaProducerCfg -> [KTC.KafkaProperties] -> IO KafkaProducerTools\nbuildKafkaProducerTools' kafkaProducerCfg kafkaProperties = do\n  producer <- newProducer (addProperties (producerProps kafkaProducerCfg) kafkaProperties) >>= either (throwM . KafkaUnableToBuildTools) return\n  return $ KafkaProducerTools {..}\n\nbuildKafkaProducerTools :: KafkaProducerCfg -> IO KafkaProducerTools\nbuildKafkaProducerTools kafkaProducerCfg = do\n  producer <- newProducer (producerProps kafkaProducerCfg) >>= either (throwM . KafkaUnableToBuildTools) return\n  return $ KafkaProducerTools {..}\n\nreleaseKafkaProducerTools :: KafkaProducerTools -> IO ()\nreleaseKafkaProducerTools kafkaProducerTools = closeProducer kafkaProducerTools.producer\n",
      "hash": "31dc5b68fb5cfeaf410122f7358c2e9d6901cc161475f5ac6667cbe9f2d812c6",
      "size": 3132
    },
    "/lib/mobility-core/src/Kernel/Streaming/Kafka/Topic/BusinessEvent.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n\nmodule Kernel.Streaming.Kafka.Topic.BusinessEvent (module Reexport) where\n\nimport Kernel.Streaming.Kafka.Topic.BusinessEvent.Environment as Reexport\nimport Kernel.Streaming.Kafka.Topic.BusinessEvent.Functions as Reexport\nimport Kernel.Streaming.Kafka.Topic.BusinessEvent.Types as Reexport\n",
      "hash": "29eda9730e82596fb0241083af5b5f7b31d1011cd85c433ff651e9db62828e5d",
      "size": 983
    },
    "/lib/mobility-core/src/Kernel/Streaming/Kafka/Topic/BusinessEvent/Environment.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n\nmodule Kernel.Streaming.Kafka.Topic.BusinessEvent.Environment where\n\nimport EulerHS.Prelude\nimport GHC.Records.Extra (HasField)\nimport Kernel.Streaming.Kafka.Producer.Types\nimport Kernel.Utils.App (getPodName)\n\ntype HasKafkaBE r kafkaEnvs = (HasField \"kafkaEnvs\" r kafkaEnvs, HasField \"businessEventEnv\" kafkaEnvs KafkaBEEnv)\n\ndata KafkaBEEnv = KafkaBEEnv\n  { hostName :: KafkaHostName,\n    serviceName :: KafkaServiceName\n  }\n  deriving (Generic)\n\nbuildKafkaBEEnv :: KafkaServiceName -> IO KafkaBEEnv\nbuildKafkaBEEnv serviceName = do\n  hostName <- getPodName\n  return $\n    KafkaBEEnv\n      { ..\n      }\n",
      "hash": "aeae6bbfa599fb353dce16808a9919a9cc8a181f5751a61e8f794962d1bb0c94",
      "size": 1299
    },
    "/lib/mobility-core/src/Kernel/Streaming/Kafka/Topic/BusinessEvent/Functions.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n\nmodule Kernel.Streaming.Kafka.Topic.BusinessEvent.Functions where\n\nimport EulerHS.Prelude\nimport Kernel.Streaming.Kafka.Topic.BusinessEvent.Environment\nimport Kernel.Streaming.Kafka.Topic.BusinessEvent.Types\nimport Kernel.Streaming.MonadProducer (MonadProducer (..))\nimport Kernel.Types.Logging\nimport Kernel.Types.Time\n\nproduceBusinessEventMessage ::\n  ( MonadProducer BusinessEvent m,\n    Log m,\n    MonadTime m,\n    MonadReader r m,\n    HasKafkaBE r kafkaEnvs,\n    ToJSON a,\n    ToJSON b\n  ) =>\n  KafkaBEName ->\n  a ->\n  b ->\n  m ()\nproduceBusinessEventMessage eventName metadata payload = do\n  event <- buildBusinessEvent eventName metadata payload\n  produceMessage (Just $ encodeUtf8 event.eventName) event\n",
      "hash": "daf44f7e57b819e9aa77cf6a2eef597bef6b5509d82f38a0422551d90b716a0e",
      "size": 1406
    },
    "/lib/mobility-core/src/Kernel/Streaming/Kafka/Topic/BusinessEvent/Types.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n\nmodule Kernel.Streaming.Kafka.Topic.BusinessEvent.Types where\n\nimport Data.Aeson (Value)\nimport Data.Time (UTCTime)\nimport EulerHS.Prelude\nimport GHC.Records.Extra (HasField)\nimport Kernel.Streaming.Kafka.HasKafkaTopics (HasKafkaTopics (..))\nimport qualified Kernel.Streaming.Kafka.Producer as Prod\nimport Kernel.Streaming.Kafka.Producer.Types\nimport Kernel.Streaming.Kafka.Topic.BusinessEvent.Environment\nimport Kernel.Streaming.MonadProducer (MonadProducer (..))\nimport Kernel.Types.Flow (FlowR)\nimport Kernel.Types.Logging\nimport Kernel.Types.Time\n\ntype KafkaBEName = Text\n\ntype KafkaBEMetadata = Value\n\ntype KafkaBEPayload = Value\n\ndata BusinessEvent = BusinessEvent\n  { timestamp :: UTCTime,\n    eventName :: KafkaBEName,\n    hostName :: KafkaHostName,\n    serviceName :: KafkaServiceName, -- mobility BAP | BPP\n    metadata :: KafkaBEMetadata,\n    payload :: KafkaBEPayload\n  }\n  deriving (Generic, Show, FromJSON, ToJSON)\n\nbuildBusinessEvent :: (Log m, MonadTime m, MonadReader r m, HasKafkaBE r kafkaEnvs, ToJSON a, ToJSON b) => KafkaBEName -> a -> b -> m BusinessEvent\nbuildBusinessEvent eventName metadata payload = do\n  kafkaBEEnv <- asks (.kafkaEnvs.businessEventEnv)\n  currTime <- getCurrentTime\n  return $\n    BusinessEvent\n      { timestamp = currTime,\n        eventName,\n        hostName = kafkaBEEnv.hostName,\n        serviceName = kafkaBEEnv.serviceName,\n        metadata = toJSON metadata,\n        payload = toJSON payload\n      }\n\ninstance HasKafkaTopics BusinessEvent where\n  getTopics = [\"beckn_business_events\"]\n\ninstance (Log (FlowR r), HasKafkaProducer r, HasKafkaBE r kafkaEnvs) => MonadProducer BusinessEvent (FlowR r) where\n  type Args BusinessEvent = (Maybe KafkaKey)\n  produceMessage key value = mapM_ ($ value) (Prod.produceMessage <$> map (,key) (getTopics @BusinessEvent))\n",
      "hash": "9810773bb4e9cc9e6c19da803c8e75f4c5554d1568ac97f148cbe71d622a04ec",
      "size": 2500
    },
    "/lib/mobility-core/src/Kernel/Streaming/Kafka/Topic/PublicTransportQuoteList.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n\nmodule Kernel.Streaming.Kafka.Topic.PublicTransportQuoteList (module Reexport) where\n\nimport Kernel.Streaming.Kafka.Topic.PublicTransportQuoteList.Functions as Reexport\nimport Kernel.Streaming.Kafka.Topic.PublicTransportQuoteList.Types as Reexport\n",
      "hash": "80339c82cf27b357b3a94ab1e9988ade891c5510db40da2c112f905d2430fee6",
      "size": 942
    },
    "/lib/mobility-core/src/Kernel/Streaming/Kafka/Topic/PublicTransportQuoteList/Functions.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n\nmodule Kernel.Streaming.Kafka.Topic.PublicTransportQuoteList.Functions where\n\nimport EulerHS.Prelude\nimport Kernel.Streaming.Kafka.Topic.PublicTransportQuoteList.Types\nimport Kernel.Streaming.MonadProducer (MonadProducer (..))\n\nproducePublicTransportQuoteListMessage ::\n  ( MonadProducer PublicTransportQuoteList m\n  ) =>\n  TransactionId ->\n  [PublicTransportQuote] ->\n  m ()\nproducePublicTransportQuoteListMessage txnId = do\n  produceMessage () . PublicTransportQuoteList txnId\n",
      "hash": "debbb917872439377c78d2f1cb30c7ea2164e8bb5f564d8e4cd2df08d5a82405",
      "size": 1173
    },
    "/lib/mobility-core/src/Kernel/Streaming/Kafka/Topic/PublicTransportQuoteList/Types.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n\nmodule Kernel.Streaming.Kafka.Topic.PublicTransportQuoteList.Types where\n\nimport Kernel.Prelude\nimport qualified Kernel.Streaming.Kafka.Consumer as Cons\nimport Kernel.Streaming.Kafka.Consumer.Types (HasKafkaConsumer, KafkaConsumerTools)\nimport Kernel.Streaming.Kafka.HasKafkaTopics (HasKafkaTopics (..))\nimport qualified Kernel.Streaming.Kafka.Producer as Prod\nimport Kernel.Streaming.Kafka.Producer.Types\nimport Kernel.Streaming.MonadConsumer (MonadConsumer (..))\nimport Kernel.Streaming.MonadProducer (MonadProducer (..))\nimport Kernel.Types.Common\nimport Kernel.Types.Flow (FlowR)\n\ntype HasKafkaPublicTransportQuotesConsumer env r =\n  ( HasKafkaConsumer env r,\n    HasField \"publicTransportQuotes\" env (KafkaConsumerTools PublicTransportQuoteList)\n  )\n\ntype TransactionId = Text\n\ndata PublicTransportStation = PublicTransportStation\n  { name :: Text,\n    stationCode :: Text,\n    lat :: Double,\n    lon :: Double\n  }\n  deriving (Show, Generic, ToJSON, FromJSON, ToSchema)\n\ndata PublicTransportQuote = PublicTransportQuote\n  { id :: Text,\n    description :: Text,\n    fare :: Money,\n    departureTime :: UTCTime,\n    arrivalTime :: UTCTime,\n    departureStation :: PublicTransportStation,\n    arrivalStation :: PublicTransportStation,\n    createdAt :: UTCTime\n  }\n  deriving (Show, Generic, FromJSON, ToJSON, ToSchema)\n\ndata PublicTransportQuoteList = PublicTransportQuoteList\n  { transactionId :: TransactionId,\n    quoteList :: [PublicTransportQuote]\n  }\n  deriving (Generic, FromJSON, ToJSON)\n\ninstance HasKafkaTopics PublicTransportQuoteList where\n  getTopics = [\"public_transport_bap_quote_list\"]\n\ninstance (Log (FlowR r), HasKafkaProducer r) => MonadProducer PublicTransportQuoteList (FlowR r) where\n  type Args PublicTransportQuoteList = ()\n  produceMessage () value = mapM_ ($ value) (Prod.produceMessage <$> map (,Nothing) (getTopics @PublicTransportQuoteList))\n\ninstance (Log (FlowR r), HasKafkaPublicTransportQuotesConsumer env r) => MonadConsumer PublicTransportQuoteList (FlowR r) where\n  receiveMessage = asks (.kafkaConsumerEnv.publicTransportQuotes) >>= Cons.receiveMessage\n",
      "hash": "c907284828e02df90fdeddf52349a75bd2ab84e3a1dd470c138393f5a7ba1395",
      "size": 2786
    },
    "/lib/mobility-core/src/Kernel/Streaming/Kafka/Topic/PublicTransportSearch.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n\nmodule Kernel.Streaming.Kafka.Topic.PublicTransportSearch (module Reexport) where\n\nimport Kernel.Streaming.Kafka.Topic.PublicTransportSearch.Functions as Reexport\nimport Kernel.Streaming.Kafka.Topic.PublicTransportSearch.Types as Reexport\n",
      "hash": "47a7b37b04f4c2933a7cb10acd57699b3b6a21eed2279c426f19eab5b64bd873",
      "size": 933
    },
    "/lib/mobility-core/src/Kernel/Streaming/Kafka/Topic/PublicTransportSearch/Functions.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n\nmodule Kernel.Streaming.Kafka.Topic.PublicTransportSearch.Functions where\n\nimport Kernel.Streaming.Kafka.Topic.PublicTransportSearch.Types\nimport Kernel.Streaming.MonadProducer (MonadProducer (..))\n\nproducePublicTransportSearchMessage ::\n  ( MonadProducer PublicTransportSearch m\n  ) =>\n  PublicTransportSearch ->\n  m ()\nproducePublicTransportSearchMessage = do\n  produceMessage ()\n",
      "hash": "4fb8c43d34951fc5643b6b35762bd74ea069354bd0b8c63e4d703185ff6b131f",
      "size": 1076
    },
    "/lib/mobility-core/src/Kernel/Streaming/Kafka/Topic/PublicTransportSearch/Types.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n\nmodule Kernel.Streaming.Kafka.Topic.PublicTransportSearch.Types where\n\nimport Kernel.External.Maps.Types (LatLong)\nimport Kernel.Prelude\nimport qualified Kernel.Streaming.Kafka.Consumer as Cons\nimport Kernel.Streaming.Kafka.Consumer.Types (HasKafkaConsumer, KafkaConsumerTools)\nimport Kernel.Streaming.Kafka.HasKafkaTopics (HasKafkaTopics (..))\nimport qualified Kernel.Streaming.Kafka.Producer as Prod\nimport Kernel.Streaming.Kafka.Producer.Types\nimport Kernel.Streaming.MonadConsumer (MonadConsumer (..))\nimport Kernel.Streaming.MonadProducer (MonadProducer (..))\nimport Kernel.Types.Flow (FlowR)\nimport Kernel.Types.Logging\n\ntype HasKafkaPublicTransportSearchConsumer env r =\n  ( HasKafkaConsumer env r,\n    HasField \"publicTransportSearch\" env (KafkaConsumerTools PublicTransportSearch)\n  )\n\ntype SearchId = Text\n\ntype PersonId = Text\n\ndata PublicTransportSearch = PublicTransportSearch\n  { id :: SearchId,\n    gps :: LatLong,\n    requestorId :: PersonId,\n    createdAt :: UTCTime\n  }\n  deriving (Generic, FromJSON, ToJSON)\n\ninstance HasKafkaTopics PublicTransportSearch where\n  getTopics = [\"public_transport_bap_search\"]\n\ninstance (Log (FlowR r), HasKafkaProducer r) => MonadProducer PublicTransportSearch (FlowR r) where\n  type Args PublicTransportSearch = ()\n  produceMessage () value = mapM_ ($ value) (Prod.produceMessage <$> map (,Nothing) (getTopics @PublicTransportSearch))\n\ninstance (Log (FlowR r), HasKafkaPublicTransportSearchConsumer env r) => MonadConsumer PublicTransportSearch (FlowR r) where\n  receiveMessage = asks (.kafkaConsumerEnv.publicTransportSearch) >>= Cons.receiveMessage\n",
      "hash": "2149fe9b04b1ac6566bb44a23efeea7fc09eae556fe3b284aad79f4ed1410c54",
      "size": 2296
    },
    "/lib/mobility-core/src/Kernel/Streaming/MonadConsumer.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n\nmodule Kernel.Streaming.MonadConsumer where\n\nimport Kernel.Prelude\n\nclass MonadConsumer a m where\n  receiveMessage :: m (Maybe a)\n",
      "hash": "78ae30d44315087a54e57d7f18334db5f930680d31673135f8c9023f6ff99b2c",
      "size": 824
    },
    "/lib/mobility-core/src/Kernel/Streaming/MonadProducer.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n\nmodule Kernel.Streaming.MonadProducer where\n\nclass MonadProducer a m where\n  type Args a\n  produceMessage :: Args a -> a -> m ()\n",
      "hash": "c941a02ee48926b16416ef33045686cfeac997276591a6a4da9d7c11cb19d166",
      "size": 823
    },
    "/lib/mobility-core/src/Kernel/Tools/ARTUtils.hs": {
      "type": "content",
      "content": "module Kernel.Tools.ARTUtils where\n\nimport Data.Aeson.Types\nimport qualified Data.ByteString.Lazy as BL\nimport Data.Default.Class\nimport qualified Data.Text.Encoding as TE\nimport qualified Kafka.Producer as KafkaProd\nimport Kernel.Prelude\nimport Kernel.Streaming.Kafka.Producer.Types\nimport Kernel.Utils.IOLogging (LoggerEnv)\n\ntype HasARTFlow r = (HasField \"loggerEnv\" r LoggerEnv, HasField \"shouldLogRequestId\" r Bool, HasField \"requestId\" r (Maybe Text), HasField \"kafkaProducerForART\" r (Maybe KafkaProducerTools))\n\ndata RequestInfo' = RequestInfo'\n  { requestMethod :: Text,\n    rawPathInfo :: Text,\n    rawQueryString :: Text,\n    requestHeaders :: Text,\n    body :: Text\n  }\n  deriving (Generic, Show, ToJSON)\n\ndata ArtData = ArtData\n  { requestId :: Text,\n    request :: Maybe RequestInfo',\n    response :: Maybe Text,\n    queryData :: Maybe QueryData,\n    forkedTag :: Maybe Text,\n    timestamp :: Maybe UTCTime\n  }\n  deriving (Show, Generic)\n\ndata QueryData = QueryData\n  { queryType :: Text,\n    setClause :: Text,\n    whereClause :: Text,\n    table :: Text,\n    tableObject :: Text,\n    kvEnabled :: Bool\n  }\n  deriving (Show, Generic, ToJSON)\n\ninstance ToJSON ArtData where\n  toJSON = genericToJSON defaultOptions {omitNothingFields = True}\n\ninstance Default ArtData where\n  def = ArtData \"\" Nothing Nothing Nothing Nothing Nothing\n\npushToKafka :: Maybe KafkaProducerTools -> BL.ByteString -> Text -> Text -> IO ()\npushToKafka kafkaConn messageRecord topic key = do\n  case kafkaConn of\n    Nothing -> pure ()\n    Just kafkaProducerTools' -> do\n      void $ KafkaProd.produceMessage kafkaProducerTools'.producer (kafkaMessage topic messageRecord key)\n\nkafkaMessage :: Text -> BL.ByteString -> Text -> KafkaProd.ProducerRecord\nkafkaMessage topicName event key =\n  KafkaProd.ProducerRecord\n    { prTopic = KafkaProd.TopicName topicName,\n      prPartition = KafkaProd.UnassignedPartition,\n      prKey = Just $ TE.encodeUtf8 key,\n      prValue = Just . BL.toStrict $ event\n    }\n",
      "hash": "04b45aba996e58c417e62dfbe13a269a6575cf6f3d45f6ff5382f59cc5f63153",
      "size": 1986
    },
    "/lib/mobility-core/src/Kernel/Tools/Logging.hs": {
      "type": "content",
      "content": "{-\n Copyright 2022-23, Juspay India Pvt Ltd\n\n This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program\n\n is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n\n or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of\n\n the GNU Affero General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\nmodule Kernel.Tools.Logging where\n\nimport qualified Data.HashMap.Internal as HM\nimport Data.Time hiding (getCurrentTime)\nimport qualified EulerHS.Language as L\nimport Kernel.Beam.Lib.UtilsTH (HasSchemaName, schemaName)\nimport qualified Kernel.Beam.Types as KT\nimport Kernel.Prelude\nimport qualified Kernel.Storage.Beam.SystemConfigs as BeamSC\nimport Kernel.Storage.Esqueleto.Config (HasEsqEnv)\nimport Kernel.Storage.Hedis.Config\nimport qualified Kernel.Storage.Queries.SystemConfigs as QSC\nimport Kernel.Tools.Metrics.CoreMetrics (HasCoreMetrics, incrementSystemConfigsFailedCounter)\nimport Kernel.Types.App (MonadFlow)\nimport Kernel.Types.CacheFlow (HasCacConfig, HasCacheConfig)\nimport Kernel.Types.Logging\nimport Kernel.Types.Time\nimport Kernel.Utils.IOLogging (HasLog, updateLogLevelAndRawSql)\nimport Kernel.Utils.Text\n\nwithDynamicLogLevel ::\n  (HasLog f, HasCoreMetrics f, HasEsqEnv m f, HedisFlow m f, HasCacheConfig f, HasSchemaName BeamSC.SystemConfigsT, MonadReader f m, MonadFlow m, HasCacConfig f) =>\n  Text ->\n  m a ->\n  m a\nwithDynamicLogLevel keyName fn = do\n  mbDynamicLogLevelConfig <- getDynamicLogLevelConfig\n  local (modifyEnv (HM.lookup keyName =<< mbDynamicLogLevelConfig)) fn\n  where\n    modifyEnv mbLogLevel env = do\n      let logEnv = env.loggerEnv\n          updLogEnv = updateLogLevelAndRawSql mbLogLevel logEnv\n      env{loggerEnv = updLogEnv}\n\ngetDynamicLogLevelConfig ::\n  (HasLog f, HasCoreMetrics f, HasEsqEnv m f, HedisFlow m f, HasCacheConfig f, HasSchemaName BeamSC.SystemConfigsT, MonadReader f m, MonadFlow m, HasCacConfig f) => m (Maybe (HM.HashMap Text LogLevel))\ngetDynamicLogLevelConfig = do\n  now <- getCurrentTime\n  shouldFetchFromDB <-\n    (isNothing <$>) . runMaybeT $ do\n      kvConfigLastUpdatedTime <- MaybeT $ L.getOption KT.LogLevelLastUpdatedTime\n      kvConfigUpdateFrequency <- MaybeT $ L.getOption KT.KvConfigUpdateFrequency\n      MaybeT . pure $ if round (diffUTCTime now kvConfigLastUpdatedTime) > kvConfigUpdateFrequency then Nothing else Just False\n  if shouldFetchFromDB\n    then do\n      res <- QSC.findById \"log_levels\" >>= pure . decodeFromText' @(HM.HashMap Text LogLevel)\n      maybe (incrementSystemConfigsFailedCounter (\"system_configs_decode_failed_\" <> schemaName (Proxy :: Proxy BeamSC.SystemConfigsT) <> \"_log_levels\")) (L.setOption KT.DynamicLogLevelConfig) res\n      void $ L.setOption KT.LogLevelLastUpdatedTime now\n      pure res\n    else L.getOption KT.DynamicLogLevelConfig\n",
      "hash": "68f13762caa3e4eff3415d7d265fce3f4f73e98ecb5aa903429d755a0fdece23",
      "size": 3135
    },
    "/lib/mobility-core/src/Kernel/Tools/LoopGracefully.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n{-# LANGUAGE BangPatterns #-}\n\nmodule Kernel.Tools.LoopGracefully where\n\nimport GHC.Conc (TVar, atomically, newTVarIO, readTVarIO, writeTVar)\nimport Kernel.Prelude hiding (loop)\nimport Kernel.Types.App (MonadFlow)\nimport Kernel.Types.Common (fork)\nimport System.Posix.Signals (Handler (Catch), installHandler, sigINT, sigTERM)\n\nloopGracefully :: forall m a. (MonadFlow m) => [m a] -> m ()\nloopGracefully fns = do\n  stop <-\n    liftIO do\n      stop <- newTVarIO 1\n      _ <- installHandler sigINT (Catch $ onSigInt stop) Nothing\n      _ <- installHandler sigTERM (Catch $ onSigTerm stop) Nothing\n      pure stop\n  case fns of\n    (fstfn : rest) -> do\n      mapM_ (\\fn -> fork \"\" $ loop fn stop) rest\n      loop fstfn stop\n    [] -> pure ()\n\nloop :: forall m a. (MonadFlow m) => m a -> TVar Int -> m ()\nloop fa stop = do\n  stopRequested :: Int <- liftIO $ readTVarIO stop\n  if stopRequested > 1\n    then print (\"bye!\" :: String)\n    else do\n      !_ <- fa\n      loop fa stop\n\nonSigInt :: TVar Int -> IO ()\nonSigInt stop = do\n  print (\"got sigINT\" :: String)\n  atomically $ writeTVar stop 2\n\nonSigTerm :: TVar Int -> IO ()\nonSigTerm stop = do\n  print (\"got sigTERM\" :: String)\n  atomically $ writeTVar stop 2\n",
      "hash": "0768c0deb40b3883a8cb296d451e140593d655bd0f656201f6ab1c640d67cb7d",
      "size": 1899
    },
    "/lib/mobility-core/src/Kernel/Tools/Metrics/AppMetrics.hs": {
      "type": "content",
      "content": "module Kernel.Tools.Metrics.AppMetrics where\n\nimport Data.String.Conversions\nimport Data.Time.Clock\nimport qualified EulerHS.Language as L\nimport Kernel.Prelude\nimport Kernel.Storage.Hedis\nimport Kernel.Storage.Hedis.Queries as Hedis\nimport Kernel.Tools.Metrics.CoreMetrics\nimport qualified System.Environment as SE\n\ndata LatencyAction = SELECT_TO_SEND_REQUEST\n  deriving (Show, Eq, Generic)\n\ngenericLatencyRedisKey :: Text -> Text\ngenericLatencyRedisKey txnId = \"glk_\" <> txnId\n\nshouldPushLatencyMetrics :: IO Bool\nshouldPushLatencyMetrics = fromMaybe False . (>>= readMaybe) <$> SE.lookupEnv \"SHOULD_PUSH_LATENCY_METRICS\"\n\nredisKeyExpiryTime :: Int\nredisKeyExpiryTime = 300\n\nstartGenericLatencyMetrics ::\n  ( HasCoreMetrics r,\n    L.MonadFlow m,\n    HedisFlow m r,\n    MonadReader r m\n  ) =>\n  LatencyAction ->\n  Text ->\n  m ()\nstartGenericLatencyMetrics action txnId = do\n  shouldPush <- liftIO shouldPushLatencyMetrics\n  when shouldPush $ do\n    handle (\\(e :: SomeException) -> L.logError (\"START_METRICS_PUSH_FAILED\" :: Text) $ \"Error in startGenericRequestLatency: for action: \" <> show action <> \" txnId: \" <> txnId <> \" error: \" <> show e) $ do\n      startTime <- liftIO getCurrentTime\n      withCrossAppRedis $ Hedis.setExp (cs $ genericLatencyRedisKey txnId) startTime redisKeyExpiryTime\n\nfinishGenericLatencyMetrics ::\n  ( HasCoreMetrics r,\n    L.MonadFlow m,\n    HedisFlow m r,\n    MonadReader r m\n  ) =>\n  LatencyAction ->\n  Text ->\n  m ()\nfinishGenericLatencyMetrics action txnId = do\n  shouldPush <- liftIO shouldPushLatencyMetrics\n  when shouldPush $ do\n    handle (\\(e :: SomeException) -> L.logError (\"FINISH_METRICS_PUSH_FAILED\" :: Text) $ \"Error in finishGenericRequestLatency: for action: \" <> show action <> \" txnId: \" <> txnId <> \" error: \" <> show e) $ do\n      endTime <- liftIO getCurrentTime\n      startTime <- Hedis.withCrossAppRedis $ Hedis.safeGet (genericLatencyRedisKey txnId)\n      case startTime of\n        Just (a :: UTCTime) -> do\n          -- get diff in Seconds\n          let latency = diffUTCTime endTime a & nominalDiffTimeToSeconds & round\n          addGenericLatencyMetrics (show action) latency\n        Nothing -> do\n          pure ()\n",
      "hash": "07aba437e60266c67c9a2730bfed3daaaf92c789c219f084e5daff6d0b523e0b",
      "size": 2179
    },
    "/lib/mobility-core/src/Kernel/Tools/Metrics/CoreMetrics.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n{-# LANGUAGE OverloadedStrings #-}\n{-# LANGUAGE UndecidableInstances #-}\n\nmodule Kernel.Tools.Metrics.CoreMetrics\n  ( module Kernel.Tools.Metrics.CoreMetrics,\n    module Reexport,\n  )\nwhere\n\nimport Data.Text as DT\nimport qualified EulerHS.Language as L\nimport EulerHS.Prelude as E\nimport Kernel.Tools.Metrics.CoreMetrics.Types as Reexport\nimport Kernel.Types.Error (GenericError (InternalError))\nimport Kernel.Types.Error.BaseError.HTTPError (BaseException (..), HTTPException (..), IsBaseError (toMessage), IsHTTPError (toErrorCode, toHttpCode), IsHTTPException)\nimport Kernel.Types.Time (Milliseconds, Seconds, getMilliseconds)\nimport Kernel.Utils.Servant.BaseUrl\nimport Prometheus as P\nimport Servant.Client (BaseUrl, ClientError (..), ResponseF (..))\n\nincrementErrorCounterImplementation ::\n  ( HasCoreMetrics r,\n    L.MonadFlow m,\n    MonadReader r m\n  ) =>\n  Text ->\n  SomeException ->\n  m ()\nincrementErrorCounterImplementation errorContext err = do\n  cmContainer <- asks (.coreMetrics)\n  version <- asks (.version)\n  incrementErrorCounterImplementation' cmContainer errorContext err version\n\naddUrlCallRetriesImplementation ::\n  ( HasCoreMetrics r,\n    L.MonadFlow m,\n    MonadReader r m\n  ) =>\n  BaseUrl ->\n  Int ->\n  m ()\naddUrlCallRetriesImplementation url retryCount = do\n  cmContainer <- asks (.coreMetrics)\n  version <- asks (.version)\n  addUrlCallRetriesImplementation' cmContainer url retryCount version\n\naddUrlCallFailuresImplementation ::\n  ( HasCoreMetrics r,\n    L.MonadFlow m,\n    MonadReader r m\n  ) =>\n  BaseUrl ->\n  m ()\naddUrlCallFailuresImplementation url = do\n  cmContainer <- asks (.coreMetrics)\n  version <- asks (.version)\n  addUrlCallFailuresImplementation' cmContainer url version\n\naddRequestLatencyImplementation ::\n  ( HasCoreMetrics r,\n    L.MonadFlow m,\n    MonadReader r m\n  ) =>\n  Text ->\n  Text ->\n  Milliseconds ->\n  Either ClientError a ->\n  m ()\naddRequestLatencyImplementation host serviceName dur status = do\n  cmContainer <- asks (.coreMetrics)\n  version <- asks (.version)\n  addRequestLatencyImplementation' cmContainer host serviceName dur status version\n\naddDatastoreLatencyImplementation ::\n  ( HasCoreMetrics r,\n    L.MonadFlow m,\n    MonadReader r m\n  ) =>\n  Text ->\n  Text ->\n  Milliseconds ->\n  m ()\naddDatastoreLatencyImplementation storeType operation latency = do\n  cmContainer <- asks (.coreMetrics)\n  version <- asks (.version)\n  L.runIO $\n    P.withLabel\n      cmContainer.datastoresLatency\n      (storeType, operation, version.getDeploymentVersion)\n      (`P.observe` ((/ 1000) . fromIntegral $ getMilliseconds latency))\n\nincrementSortedSetCounterImplementation ::\n  ( HasCoreMetrics r,\n    L.MonadFlow m,\n    MonadReader r m\n  ) =>\n  Text ->\n  m ()\nincrementSortedSetCounterImplementation context = do\n  cmContainer <- asks (.coreMetrics)\n  version <- asks (.version)\n  incrementSortedSetCounterImplementation' cmContainer context version\n\nincrementStreamCounterImplementation ::\n  ( HasCoreMetrics r,\n    L.MonadFlow m,\n    MonadReader r m\n  ) =>\n  Text ->\n  m ()\nincrementStreamCounterImplementation context = do\n  cmContainer <- asks (.coreMetrics)\n  version <- asks (.version)\n  incrementStreamCounterImplementation' cmContainer context version\n\nincrementSchedulerFailureCounterImplementation ::\n  ( HasCoreMetrics r,\n    L.MonadFlow m,\n    MonadReader r m\n  ) =>\n  Text ->\n  m ()\nincrementSchedulerFailureCounterImplementation context = do\n  cmContainer <- asks (.coreMetrics)\n  version <- asks (.version)\n  incrementSchedulerFailureCounterImplementation' cmContainer context version\n\naddRequestLatencyImplementation' ::\n  L.MonadFlow m =>\n  CoreMetricsContainer ->\n  Text ->\n  Text ->\n  Milliseconds ->\n  Either ClientError a ->\n  DeploymentVersion ->\n  m ()\naddRequestLatencyImplementation' cmContainer host serviceName dur status version = do\n  let requestLatencyMetric = cmContainer.requestLatency\n  L.runIO $\n    P.withLabel\n      requestLatencyMetric\n      (host, serviceName, status', version.getDeploymentVersion)\n      (`P.observe` ((/ 1000) . fromIntegral $ getMilliseconds dur))\n  where\n    status' =\n      case status of\n        Right _ -> \"200\"\n        Left (FailureResponse _ (Response code _ _ _)) -> show code\n        Left (DecodeFailure _ (Response code _ _ _)) -> show code\n        Left (InvalidContentTypeHeader (Response code _ _ _)) -> show code\n        Left (UnsupportedContentType _ (Response code _ _ _)) -> show code\n        Left (ConnectionError _) -> \"Connection error\"\n\nincrementErrorCounterImplementation' :: L.MonadFlow m => CoreMetricsContainer -> Text -> SomeException -> DeploymentVersion -> m ()\nincrementErrorCounterImplementation' cmContainers errorContext exc version\n  | Just (HTTPException err) <- fromException exc = incCounter' err\n  | Just (BaseException err) <- fromException exc = incCounter' . InternalError . fromMaybe (show err) $ toMessage err\n  | otherwise = incCounter' . InternalError $ show exc\n  where\n    errorCounterMetric = cmContainers.errorCounter\n\n    incCounter' :: (L.MonadFlow m, IsHTTPException e) => e -> m ()\n    incCounter' err =\n      L.runIO $\n        P.withLabel\n          errorCounterMetric\n          (show $ toHttpCode err, errorContext, toErrorCode err, version.getDeploymentVersion)\n          P.incCounter\n\naddUrlCallRetriesImplementation' :: L.MonadFlow m => CoreMetricsContainer -> BaseUrl -> Int -> DeploymentVersion -> m ()\naddUrlCallRetriesImplementation' cmContainers url retryCount version = do\n  let urlCallRetriesMetric = cmContainers.urlCallRetries\n  L.runIO $\n    P.withLabel\n      urlCallRetriesMetric\n      (showBaseUrlText url, show retryCount, version.getDeploymentVersion)\n      P.incCounter\n\naddUrlCallFailuresImplementation' :: L.MonadFlow m => CoreMetricsContainer -> BaseUrl -> DeploymentVersion -> m ()\naddUrlCallFailuresImplementation' cmContainers url version = do\n  let urlCallRetriesMetric = cmContainers.urlCallRetryFailures\n  L.runIO $\n    P.withLabel\n      urlCallRetriesMetric\n      (showBaseUrlText url, version.getDeploymentVersion)\n      P.incCounter\n\nincrementSortedSetCounterImplementation' :: L.MonadFlow m => CoreMetricsContainer -> Text -> DeploymentVersion -> m ()\nincrementSortedSetCounterImplementation' cmContainers context version = do\n  let sortedSetMetric = cmContainers.sortedSetCounter\n  L.runIO $\n    P.withLabel\n      sortedSetMetric\n      (context, version.getDeploymentVersion)\n      P.incCounter\n\nincrementStreamCounterImplementation' :: L.MonadFlow m => CoreMetricsContainer -> Text -> DeploymentVersion -> m ()\nincrementStreamCounterImplementation' cmContainers context version = do\n  let sortedSetMetric = cmContainers.streamCounter\n  L.runIO $\n    P.withLabel\n      sortedSetMetric\n      (context, version.getDeploymentVersion)\n      P.incCounter\n\naddGenericLatencyImplementation ::\n  ( HasCoreMetrics r,\n    L.MonadFlow m,\n    MonadReader r m\n  ) =>\n  Text ->\n  Milliseconds ->\n  m ()\naddGenericLatencyImplementation operation latency = do\n  cmContainer <- asks (.coreMetrics)\n  version <- asks (.version)\n  L.runIO $\n    P.withLabel\n      cmContainer.genericLatency\n      (operation, version.getDeploymentVersion)\n      (`P.observe` ((/ 1000) . fromIntegral $ getMilliseconds latency))\n\nincrementSchedulerFailureCounterImplementation' :: L.MonadFlow m => CoreMetricsContainer -> Text -> DeploymentVersion -> m ()\nincrementSchedulerFailureCounterImplementation' cmContainers context version = do\n  let sortedSetMetric = cmContainers.schedulerFailureCounter\n  L.runIO $\n    P.withLabel\n      sortedSetMetric\n      (context, version.getDeploymentVersion)\n      P.incCounter\n\nincrementGenericMetrics' ::\n  ( HasCoreMetrics r,\n    L.MonadFlow m,\n    MonadReader r m\n  ) =>\n  Text ->\n  m ()\nincrementGenericMetrics' operation = do\n  cmContainer <- asks (.coreMetrics)\n  L.runIO $\n    P.withLabel\n      cmContainer.genericCounter\n      operation\n      P.incCounter\n\nincrementSystemConfigsFailedCounter' ::\n  ( HasCoreMetrics r,\n    L.MonadFlow m,\n    MonadReader r m\n  ) =>\n  Text ->\n  m ()\nincrementSystemConfigsFailedCounter' operation = do\n  cmContainer <- asks (.coreMetrics)\n  L.runIO $\n    P.withLabel\n      cmContainer.systemConfigsFailedCounter\n      operation\n      P.incCounter\n\naddGenericLatencyMetricsImplementation ::\n  ( HasCoreMetrics r,\n    L.MonadFlow m,\n    MonadReader r m\n  ) =>\n  Text ->\n  Seconds ->\n  m ()\naddGenericLatencyMetricsImplementation operation latency = do\n  cmContainer <- asks (.coreMetrics)\n  version <- asks (.version)\n  L.runIO $\n    P.withLabel\n      cmContainer.genericLatencyMetrics\n      (operation, version.getDeploymentVersion)\n      (`P.observe` fromIntegral latency)\n",
      "hash": "6319a7f9c5d8100f539f88b865b2bb23dfb7d6f42cc5194f37efaf165e99db5e",
      "size": 9296
    },
    "/lib/mobility-core/src/Kernel/Tools/Metrics/CoreMetrics/Types.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n\nmodule Kernel.Tools.Metrics.CoreMetrics.Types\n  ( HasCoreMetrics,\n    CoreMetrics (..),\n    CoreMetricsContainer (..),\n    DeploymentVersion (..),\n    registerCoreMetricsContainer,\n  )\nwhere\n\nimport qualified EulerHS.KVConnector.Metrics as KVMetrics\nimport EulerHS.Prelude as E\nimport GHC.Records.Extra\nimport Kernel.Types.Time (Milliseconds, Seconds)\nimport Prometheus as P\nimport Servant.Client (BaseUrl, ClientError)\n\ntype RequestLatencyMetric = P.Vector P.Label4 P.Histogram\n\ntype DatastoresLatencyMetric = P.Vector P.Label3 P.Histogram\n\ntype ErrorCounterMetric = P.Vector P.Label4 P.Counter\n\ntype URLCallRetriesMetric = P.Vector P.Label3 P.Counter\n\ntype URLCallRetryFailuresMetric = P.Vector P.Label2 P.Counter\n\ntype SortedSetMetric = P.Vector P.Label2 P.Counter\n\ntype StreamMetric = P.Vector P.Label2 P.Counter\n\ntype GenericLatencyMetric = P.Vector P.Label2 P.Histogram\n\ntype SchedulerFailureMetric = P.Vector P.Label2 P.Counter\n\ntype GenericCounter = P.Vector P.Label1 P.Counter\n\ntype SystemConfigsFailedCounter = P.Vector P.Label1 P.Counter\n\nnewBuckets :: [Double]\nnewBuckets = [0.005, 0.01, 0.025, 0.05, 0.1, 0.25, 0.5, 1, 2.5, 5, 10, 15, 20, 25, 30, 40, 50]\n\ntype HasCoreMetrics r =\n  ( HasField \"coreMetrics\" r CoreMetricsContainer,\n    HasField \"version\" r DeploymentVersion\n  )\n\nnewtype DeploymentVersion = DeploymentVersion {getDeploymentVersion :: Text}\n\nclass CoreMetrics m where\n  addRequestLatency :: Text -> Text -> Milliseconds -> Either ClientError a -> m ()\n  addDatastoreLatency :: Text -> Text -> Milliseconds -> m ()\n  incrementErrorCounter :: Text -> SomeException -> m ()\n  addUrlCallRetries :: BaseUrl -> Int -> m ()\n  addUrlCallRetryFailures :: BaseUrl -> m ()\n  incrementSortedSetCounter :: Text -> m ()\n  incrementStreamCounter :: Text -> m ()\n  addGenericLatency :: Text -> Milliseconds -> m ()\n  incrementSchedulerFailureCounter :: Text -> m ()\n  incrementGenericMetrics :: Text -> m ()\n  incrementSystemConfigsFailedCounter :: Text -> m ()\n  addGenericLatencyMetrics :: Text -> Seconds -> m ()\n\ndata CoreMetricsContainer = CoreMetricsContainer\n  { requestLatency :: RequestLatencyMetric,\n    datastoresLatency :: DatastoresLatencyMetric,\n    genericLatency :: GenericLatencyMetric,\n    errorCounter :: ErrorCounterMetric,\n    urlCallRetries :: URLCallRetriesMetric,\n    urlCallRetryFailures :: URLCallRetryFailuresMetric,\n    sortedSetCounter :: SortedSetMetric,\n    streamCounter :: StreamMetric,\n    schedulerFailureCounter :: SchedulerFailureMetric,\n    genericCounter :: GenericCounter,\n    systemConfigsFailedCounter :: SystemConfigsFailedCounter,\n    kvRedisMetricsContainer :: KVMetrics.KVMetricHandler,\n    genericLatencyMetrics :: GenericLatencyMetric\n  }\n\nregisterCoreMetricsContainer :: IO CoreMetricsContainer\nregisterCoreMetricsContainer = do\n  requestLatency <- registerRequestLatencyMetric\n  datastoresLatency <- registerDatastoresLatencyMetrics\n  genericLatency <- registerGenericLatencyMetrics\n  errorCounter <- registerErrorCounterMetric\n  urlCallRetries <- registerURLCallRetriesMetric\n  urlCallRetryFailures <- registerURLCallRetryFailuresMetric\n  sortedSetCounter <- registerSortedSetMetric\n  streamCounter <- registerStreamCounter\n  schedulerFailureCounter <- registerSchedulerFailureCounter\n  genericCounter <- registerGenericCounter\n  systemConfigsFailedCounter <- registerSystemConfigsFailedCounter\n  kvRedisMetricsContainer <- KVMetrics.mkKVMetricHandler\n  genericLatencyMetrics <- registerLatencyMetrics\n  return CoreMetricsContainer {..}\n\nregisterDatastoresLatencyMetrics :: IO DatastoresLatencyMetric\nregisterDatastoresLatencyMetrics =\n  P.register $\n    P.vector (\"datastore\", \"operation\", \"version\") $\n      P.histogram info P.defaultBuckets\n  where\n    info = P.Info \"datastore_operation_duration\" \"\"\n\nregisterRequestLatencyMetric :: IO RequestLatencyMetric\nregisterRequestLatencyMetric =\n  P.register $\n    P.vector (\"host\", \"service\", \"status\", \"version\") $\n      P.histogram info P.defaultBuckets\n  where\n    info = P.Info \"external_request_duration\" \"\"\n\nregisterErrorCounterMetric :: IO ErrorCounterMetric\nregisterErrorCounterMetric =\n  P.register $\n    P.vector (\"HttpCode\", \"ErrorContext\", \"ErrorCode\", \"version\") $\n      P.counter info\n  where\n    info = P.Info \"error_counter\" \"\"\n\nregisterURLCallRetriesMetric :: IO URLCallRetriesMetric\nregisterURLCallRetriesMetric =\n  P.register $\n    P.vector (\"URL\", \"RetryCount\", \"version\") $\n      P.counter info\n  where\n    info = P.Info \"url_call_retries_counter\" \"\"\n\nregisterURLCallRetryFailuresMetric :: IO URLCallRetryFailuresMetric\nregisterURLCallRetryFailuresMetric =\n  P.register $\n    P.vector (\"URL\", \"version\") $\n      P.counter info\n  where\n    info = P.Info \"url_call_retry_failures_counter\" \"\"\n\nregisterSortedSetMetric :: IO SortedSetMetric\nregisterSortedSetMetric =\n  P.register $\n    P.vector (\"job_type\", \"version\") $\n      P.counter info\n  where\n    info = P.Info \"sortedset_scheduled_jobs_counter\" \"\"\n\nregisterStreamCounter :: IO StreamMetric\nregisterStreamCounter =\n  P.register $\n    P.vector (\"job_type\", \"version\") $\n      P.counter info\n  where\n    info = P.Info \"stream_jobs_counter\" \"\"\n\nregisterGenericLatencyMetrics :: IO GenericLatencyMetric\nregisterGenericLatencyMetrics =\n  P.register $\n    P.vector (\"operation\", \"version\") $\n      P.histogram info newBuckets\n  where\n    info = P.Info \"producer_operation_duration\" \"\"\n\nregisterSchedulerFailureCounter :: IO SchedulerFailureMetric\nregisterSchedulerFailureCounter =\n  P.register $\n    P.vector (\"scheduler_type\", \"version\") $\n      P.counter info\n  where\n    info = P.Info \"scheduler_jobs_fail_counter\" \"\"\n\nregisterGenericCounter :: IO GenericCounter\nregisterGenericCounter =\n  P.register $\n    P.vector \"event\" $\n      P.counter info\n  where\n    info = P.Info \"generic_counter\" \"\"\n\nregisterSystemConfigsFailedCounter :: IO SystemConfigsFailedCounter\nregisterSystemConfigsFailedCounter =\n  P.register $\n    P.vector \"event\" $\n      P.counter info\n  where\n    info = P.Info \"system_configs_failed_counter\" \"\"\n\nregisterLatencyMetrics :: IO GenericLatencyMetric\nregisterLatencyMetrics =\n  P.register $\n    P.vector (\"Action\", \"version\") $\n      P.histogram info newBuckets\n  where\n    info = P.Info \"generic_app_latency_metrics\" \"\"\n",
      "hash": "656e36b74f9717ffa95563baa09029da797b6c5b2069cbee63f06e05f0cb377f",
      "size": 6916
    },
    "/lib/mobility-core/src/Kernel/Tools/Metrics/Init.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n{-# LANGUAGE OverloadedStrings #-}\n{-# LANGUAGE UndecidableInstances #-}\n\nmodule Kernel.Tools.Metrics.Init where\n\nimport Data.CaseInsensitive (CI)\nimport qualified Data.CaseInsensitive as CI\nimport Data.Ratio ((%))\nimport qualified Data.Text as DT\nimport qualified Data.Text as T\nimport Data.Text.Encoding (decodeUtf8)\nimport EulerHS.Prelude as E hiding (decodeUtf8)\nimport Kernel.Prelude (lookup, (!!))\nimport Kernel.Tools.Metrics.CoreMetrics.Types hiding (requestLatency)\nimport Kernel.Utils.Monitoring.Prometheus.Servant\nimport qualified Network.HTTP.Types as HTTP\nimport Network.Wai (Application, Request (..))\nimport qualified Network.Wai as Wai\nimport Network.Wai.Handler.Warp as W\nimport Network.Wai.Middleware.Prometheus (metricsApp)\nimport Prometheus as P\nimport qualified Prometheus as Prom\nimport Prometheus.Metric.GHC (ghcMetrics)\nimport Prometheus.Metric.Proc\nimport System.Clock (Clock (..), TimeSpec, diffTimeSpec, getTime, toNanoSecs)\n\n{-# NOINLINE requestLatency #-}\nrequestLatency :: Prom.Vector Prom.Label3 Prom.Histogram\nrequestLatency =\n  Prom.unsafeRegister $\n    Prom.vector (\"handler\", \"method\", \"status_code\") $\n      Prom.histogram info Prom.defaultBuckets\n  where\n    info =\n      Prom.Info\n        \"http_request_duration_seconds\"\n        \"The HTTP request latencies in seconds.\"\n\n{-# NOINLINE requestLatencyWithVersionLabel #-}\nrequestLatencyWithVersionLabel :: Prom.Vector Prom.Label6 Prom.Histogram\nrequestLatencyWithVersionLabel =\n  Prom.unsafeRegister $\n    Prom.vector (\"handler\", \"method\", \"status_code\", \"version\", \"x_client_version\", \"x_bundle_version\") $\n      Prom.histogram info Prom.defaultBuckets\n  where\n    info =\n      Prom.Info\n        \"http_request_duration_seconds\"\n        \"The HTTP request latencies in seconds.\"\n\nserve :: Int -> IO ()\nserve port = do\n  _ <- register ghcMetrics\n  _ <- register procMetrics\n  putStrLn @String $ \"Prometheus server started at port \" <> show port\n  _ <- forkIO $ W.run port (metricsApp Nothing)\n  return ()\n\naddServantInfo ::\n  SanitizedUrl a =>\n  DeploymentVersion ->\n  Proxy a ->\n  Application ->\n  Application\naddServantInfo version proxy app request respond =\n  let mpath = getSanitizedUrl proxy request\n      fullpath = DT.intercalate \"/\" (pathInfo request)\n   in instrumentHandlerValueWithVersionLabel version.getDeploymentVersion (\\_ -> \"/\" <> fromMaybe fullpath mpath) app request respond\n\ninstrumentHandlerValueWithVersionLabel ::\n  -- | version label\n  Text ->\n  -- | The function used to derive the \"handler\" value in Prometheus\n  (Wai.Request -> Text) ->\n  -- | The app to instrument\n  Wai.Application ->\n  -- | The instrumented app\n  Wai.Application\ninstrumentHandlerValueWithVersionLabel versionLabel = instrumentHandlerValueWithFilter (Just versionLabel) Just\n\n-- | A more flexible variant of 'instrumentHandlerValue'.  The filter can change some\n-- responses, or drop others entirely.\ninstrumentHandlerValueWithFilter ::\n  -- | version label\n  Maybe Text ->\n  -- | Response filter\n  (Wai.Response -> Maybe Wai.Response) ->\n  -- | The function used to derive the \"handler\" value in Prometheus\n  (Wai.Request -> Text) ->\n  -- | The app to instrument\n  Wai.Application ->\n  -- | The instrumented app\n  Wai.Application\ninstrumentHandlerValueWithFilter mbVersionLabel resFilter f app req respond = do\n  start <- getTime Monotonic\n  app req $ \\res -> do\n    case resFilter res of\n      Nothing -> return ()\n      Just res' -> do\n        end <- getTime Monotonic\n        let method = Just $ decodeUtf8 (Wai.requestMethod req)\n        let status = Just $ T.pack (show (HTTP.statusCode (Wai.responseStatus res')))\n        let requiredHeaders = map (T.pack . show <$>) (flip lookup (Wai.requestHeaders req) . stringToCI <$> [\"x-client-version\", \"x-bundle-version\"])\n        observeSeconds mbVersionLabel (f req) method status start end requiredHeaders\n    respond res\n\nstringToCI :: String -> CI ByteString\nstringToCI = CI.mk . fromString\n\nobserveSeconds ::\n  -- | version label\n  Maybe Text ->\n  -- | handler label\n  Text ->\n  -- | method\n  Maybe Text ->\n  -- | status\n  Maybe Text ->\n  -- | start time\n  TimeSpec ->\n  -- | end time\n  TimeSpec ->\n  -- | required headers\n  [Maybe Text] ->\n  IO ()\nobserveSeconds mbVersionLabel handler method status start end requiredHeaders = do\n  let latency :: Double\n      latency = fromRational (toNanoSecs (end `diffTimeSpec` start) % 1000000000)\n  case mbVersionLabel of\n    Nothing -> do\n      Prom.withLabel\n        requestLatency\n        (handler, fromMaybe \"\" method, fromMaybe \"\" status)\n        (flip Prom.observe latency)\n    Just versionLabel -> do\n      Prom.withLabel\n        requestLatencyWithVersionLabel\n        (handler, fromMaybe \"\" method, fromMaybe \"\" status, versionLabel, fromMaybe \"\" (requiredHeaders !! 0), fromMaybe \"\" (requiredHeaders !! 1))\n        (flip Prom.observe latency)\n",
      "hash": "f904474f8f036e1763236ae0709fed206a3d023fb6cb552ecaaac844dc99713f",
      "size": 5521
    },
    "/lib/mobility-core/src/Kernel/Tools/Slack.hs": {
      "type": "content",
      "content": "{-\n Copyright 2022-23, Juspay India Pvt Ltd\n\n This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program\n\n is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n\n or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of\n\n the GNU Affero General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n\nmodule Kernel.Tools.Slack\n  ( notifyOnSlack,\n    notifyOnSlackIO,\n  )\nwhere\n\nimport Data.String.Conversions\nimport qualified EulerHS.Language as L\nimport EulerHS.Prelude\nimport qualified Kernel.Tools.Slack.Internal as SI\nimport Kernel.Utils.Common\nimport qualified Web.Slack as Slack\nimport qualified Web.Slack.Chat as Chat\n\n-- Just \"[{\\\"color\\\" : \\\"#e7700d\\\", \\\"text\\\":\\\"this is test\\\"}]\"\nnotifyOnSlackIO :: SI.SlackEnv -> Text -> Text -> Maybe Text -> Maybe Text -> IO (Slack.Response Chat.PostMsgRsp)\nnotifyOnSlackIO slackEnv title body threadId attachments = do\n  SI.sendSlackMessage slackEnv.slackConfig slackEnv.channel constructMessage threadId attachments\n  where\n    nl = \"\\n\"\n    constructMessage = do\n      let fTitle = title\n      fTitle <> nl <> body\n\nnotifyOnSlack :: (HasField \"slackEnv\" r SI.SlackEnv, Log m, L.MonadFlow m, MonadReader r m) => Text -> Text -> Maybe Text -> m (Slack.Response Chat.PostMsgRsp)\nnotifyOnSlack title body threadId = do\n  slackEnv <- asks (.slackEnv)\n  L.runIO $ notifyOnSlackIO slackEnv title body threadId Nothing\n",
      "hash": "dc1654a8c0d3660c61ac85fa5335f70e1c529f4303190841a654f470f34e5590",
      "size": 1748
    },
    "/lib/mobility-core/src/Kernel/Tools/Slack/Internal.hs": {
      "type": "content",
      "content": "{-\n Copyright 2022-23, Juspay India Pvt Ltd\n\n This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program\n\n is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n\n or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of\n\n the GNU Affero General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n\nmodule Kernel.Tools.Slack.Internal\n  ( sendSlackMessage,\n    createSlackConfig,\n    SlackEnv (..),\n    HasSlackEnv,\n  )\nwhere\n\nimport Data.Aeson\nimport qualified Data.Aeson as A\nimport EulerHS.Prelude\nimport Kernel.Prelude\nimport qualified Web.Slack as Slack\nimport qualified Web.Slack.Chat as Chat\n\ntype HasSlackEnv f = HasField \"slackEnv\" f SlackEnv\n\ndata SlackEnv = SlackEnv\n  { channel :: Text,\n    slackConfig :: Slack.SlackConfig\n  }\n\ndata FileUploadResp = FileUploadResp\n  { ok :: Bool,\n    uploadError :: Maybe Text,\n    file :: Maybe A.Value\n  }\n  deriving (Generic, ToJSON, Show)\n\ninstance FromJSON FileUploadResp where\n  parseJSON = withObject \"FileUploadResp\" $ \\v -> do\n    ok <- v .: \"ok\"\n    uploadError <- v .: \"error\"\n    file <- v .: \"file\"\n    return (FileUploadResp ok uploadError file)\n\ncreateSlackConfig :: Text -> Text -> IO SlackEnv\ncreateSlackConfig token channel = SlackEnv channel <$> Slack.mkSlackConfig token\n\nsendSlackMessage :: Slack.SlackConfig -> Text -> Text -> Maybe Text -> Maybe Text -> IO (Slack.Response Chat.PostMsgRsp)\nsendSlackMessage slackConfig channel message threadTs attachments = do\n  Slack.chatPostMessage slackConfig $ (Chat.mkPostMsgReq channel message) {Chat.postMsgReqThreadTs = threadTs, Chat.postMsgReqAttachments = attachments}\n",
      "hash": "ee9622bf7e43b46dc1bba50e7251d1c7182c5564c585a0340df2fbe79f6f1983",
      "size": 1972
    },
    "/lib/mobility-core/src/Kernel/Tools/Slack/Middleware.hs": {
      "type": "content",
      "content": "{-\n Copyright 2022-23, Juspay India Pvt Ltd\n\n This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program\n\n is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n\n or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of\n\n the GNU Affero General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n{-# OPTIONS_GHC -Wno-error=deprecations #-}\n\nmodule Kernel.Tools.Slack.Middleware where\n\nimport qualified Data.Aeson as A\nimport qualified Data.ByteString as B\nimport qualified Data.ByteString.Lazy as BL\nimport Data.Map as M\nimport Data.String.Conversions\nimport EulerHS.Prelude\nimport GHC.Records.Extra (HasField)\nimport qualified Kernel.Tools.Slack as Slack\nimport qualified Kernel.Tools.Slack.Internal as SI\nimport qualified Network.HTTP.Types as HTTP\nimport qualified Network.Wai as Wai\nimport Servant\nimport qualified Web.Slack as Slack\nimport qualified Web.Slack.Chat as Chat\n\nnotifyOnSlackMiddleware :: (SI.HasSlackEnv f) => f -> Application -> Application\nnotifyOnSlackMiddleware appEnv app req respF = do\n  let headers = Wai.requestHeaders req\n      notifySlackChannel = cs . snd <$> find (\\(headerKey, _) -> headerKey == \"NotifySlack\") headers\n  case notifySlackChannel of\n    Just slackChannel -> do\n      body <- Wai.consumeRequestBodyStrict req\n      let path = Wai.rawPathInfo req\n          queryStrings = Wai.rawQueryString req\n      called :: IORef Int <- newIORef 0\n      let returnBody = do\n            calledTimes <- readIORef called\n            modifyIORef called (+ 1)\n            pure $\n              if calledTimes > 0\n                then B.empty\n                else BL.toStrict body\n      slackThread <- notifyApiCallOnSlack appEnv (BL.toStrict body) (path <> queryStrings) slackChannel\n      app (req {Wai.requestBody = returnBody}) (updateResponseOnThread slackChannel slackThread)\n    Nothing -> app req respF\n  where\n    updateResponseOnThread slackChannel (Right slackThread) resp = notifyApiCallResponseOnSlack slackChannel appEnv resp (Just slackThread) *> respF resp\n    updateResponseOnThread slackChannel (Left err) resp = print (\"Slack SendMessageError: \" <> (show err :: Text) <> \" for channel -\" <> slackChannel) *> respF resp\n\nnotifyApiCallOnSlack :: (HasField \"slackEnv\" env SI.SlackEnv) => env -> ByteString -> ByteString -> Text -> IO (Slack.Response Chat.PostMsgRsp)\nnotifyApiCallOnSlack appEnv body path sc = do\n  let title = \"*API TRIGGERED: *\" <> cs path\n      body' = \"```\" <> cs body <> \"```\"\n      slackEnv = bool (appEnv.slackEnv {SI.channel = sc}) appEnv.slackEnv (sc == \"default\")\n  Slack.notifyOnSlackIO slackEnv title body' Nothing Nothing\n\nnotifyApiCallResponseOnSlack :: (HasField \"slackEnv\" env SI.SlackEnv) => Text -> env -> Wai.Response -> Maybe Chat.PostMsgRsp -> IO (Slack.Response Chat.PostMsgRsp)\nnotifyApiCallResponseOnSlack sc appEnv resp st = do\n  let (status, _, _) = Wai.responseToStream resp\n      code = HTTP.statusCode status\n      slackEnv = bool (appEnv.slackEnv {SI.channel = sc}) appEnv.slackEnv (sc == \"default\")\n      respInfo :: Text = \"statusCode: `\" <> show code <> \"` and message: `\" <> cs (HTTP.statusMessage status) <> \"`\"\n  Slack.notifyOnSlackIO slackEnv \"\" \"\" (Chat.postMsgRspTs <$> st) (attachment code respInfo)\n  where\n    createColoredAttachement color text = cs $ A.encode ([M.insert \"author\" \"Response\" . M.insert \"text\" text $ M.singleton \"color\" color] :: [M.Map Text Text])\n\n    attachment code respInfo =\n      Just $\n        createColoredAttachement\n          ( case div code 100 of\n              2 -> \"#51f436\"\n              4 -> \"#f4bd36\"\n              5 -> \"#f44336\"\n              _ -> \"#36b8f4\"\n          )\n          respInfo\n",
      "hash": "7854e89e83fb535c76d3c8a5eff02b165d72013b26bea447115375d85d3f4293",
      "size": 4014
    },
    "/lib/mobility-core/src/Kernel/Tools/SystemEnv.hs": {
      "type": "content",
      "content": "module Kernel.Tools.SystemEnv where\n\nimport Kernel.Beam.Lib.UtilsTH\nimport Kernel.Prelude\nimport qualified Kernel.Storage.Beam.SystemConfigs as BeamSC\nimport Kernel.Storage.Queries.SystemConfigs\nimport Kernel.Tools.Metrics.CoreMetrics.Types\nimport Kernel.Types.Common\nimport Kernel.Types.Error\nimport Kernel.Utils.Common\nimport Kernel.Utils.Dhall (FromDhall)\nimport qualified System.Environment as Env\n\ndata SystemEnv = SystemEnv\n  { systemEnv :: [(String, String)]\n  }\n  deriving (Generic, Show, ToJSON, FromJSON, FromDhall)\n\nupdateSystemEnv :: (CacheFlow m r, EsqDBFlow m r, HasSchemaName BeamSC.SystemConfigsT) => m ()\nupdateSystemEnv = do\n  systemEnv <- findById \"system_env\" >>= pure . decodeFromText' @SystemEnv\n  case systemEnv of\n    Just env -> liftIO $ mapM_ (uncurry Env.setEnv) (env.systemEnv)\n    Nothing -> do\n      incrementSystemConfigsFailedCounter (\"system_env_decode_failed_\" <> schemaName (Proxy :: Proxy BeamSC.SystemConfigsT) <> \"_system_env\")\n      throwError (InternalError \"system_env_decode_failed\")\n\nupdateSystemEnvInLoopFork :: (CacheFlow m r, EsqDBFlow m r, HasSchemaName BeamSC.SystemConfigsT) => Integer -> m ()\nupdateSystemEnvInLoopFork interval = updateSystemEnv >> (fork \"updateSystemEnvInLoopFork\" $ forever $ updateSystemEnv >> liftIO (threadDelay $ fromIntegral interval * 1000000))\n",
      "hash": "6f4771b83b4281c6652d2057268376d73184db592abe0059f54dd85875d0f36a",
      "size": 1320
    },
    "/lib/mobility-core/src/Kernel/Types/.DS_Store": {
      "type": "binary",
      "hash": "7d8d602413e7458b7de770de04f5d0ceb3ec29f9c4ea0068251bea30ca8869d5",
      "size": 6148,
      "url": "https://raw.githubusercontent.com/nammayatri/shared-kernel/b19b62ccc9511b2ecf8c74a7948725e979e990a2/lib/mobility-core/src/Kernel/Types/.DS_Store"
    },
    "/lib/mobility-core/src/Kernel/Types/APISuccess.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n{-# LANGUAGE OverloadedLists #-}\n\nmodule Kernel.Types.APISuccess (APISuccess (..)) where\n\nimport qualified Control.Lens as L\nimport qualified Data.Aeson as A\nimport Data.Aeson.Types (parseFail, typeMismatch)\nimport Data.OpenApi\nimport EulerHS.Prelude\n\ndata APISuccess = Success deriving (Generic, Show, Eq)\n\n-- Due to custom toJSON defined here, in the API response this guy goes as something else, and we use openAPI spec to generate frontend code, so toSchema should reflect same as its to json (especially if the object is used in API response)\ninstance ToSchema APISuccess where\n  declareNamedSchema _ = do\n    doubleSchema <-\n      case A.decode \"{\\\"enum\\\": [\\\"Success\\\"], \\\"type\\\": \\\"string\\\"}\" of\n        Just res -> pure res\n        Nothing -> declareSchemaRef (Proxy :: Proxy APISuccess)\n    return $\n      NamedSchema (Just \"APISuccess\") $\n        mempty\n          & type_ L.?~ OpenApiObject\n          & properties\n            L..~ [ (\"result\", doubleSchema)\n                 ]\n          & required L..~ [\"result\"]\n\ninstance A.ToJSON APISuccess where\n  toJSON Success = A.object [\"result\" A..= (\"Success\" :: Text)]\n\ninstance A.FromJSON APISuccess where\n  parseJSON (A.Object obj) = do\n    result :: String <- obj A..: \"result\"\n    case result of\n      \"Success\" -> pure Success\n      _ -> parseFail \"Expected \\\"Success\\\" in \\\"result\\\" field.\"\n  parseJSON wrongVal = typeMismatch \"Object APISuccess\" wrongVal\n",
      "hash": "fff4228be93fe92ed1f449a31de0e8f8a9f876195be44be6ddb871e9b696b16f",
      "size": 2111
    },
    "/lib/mobility-core/src/Kernel/Types/App.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n{-# LANGUAGE DerivingStrategies #-}\n{-# LANGUAGE UndecidableInstances #-}\n{-# OPTIONS_GHC -Wno-orphans #-}\n\nmodule Kernel.Types.App\n  ( module Kernel.Types.App,\n    Servant.BaseUrl,\n    Aeson.Value,\n  )\nwhere\n\nimport Control.Lens.Operators\nimport Data.Aeson as Aeson (Value)\nimport Data.OpenApi\nimport qualified EulerHS.Language as L\nimport EulerHS.Prelude\nimport qualified EulerHS.Runtime as R\nimport Kernel.Types.Field (HasFields)\nimport Kernel.Types.Forkable\nimport Kernel.Types.Logging\nimport Kernel.Types.MonadGuid\nimport Kernel.Types.Time\nimport Servant\nimport qualified Servant.Client.Core as Servant\n\ndata EnvR r = EnvR\n  { flowRuntime :: R.FlowRuntime,\n    appEnv :: r\n  }\n  deriving (Generic)\n\ntype MonadFlow m =\n  ( Monad m,\n    MonadIO m,\n    L.MonadFlow m,\n    Forkable m,\n    Log m,\n    MonadGuid m,\n    MonadTime m,\n    MonadClock m,\n    MonadThrow m\n  )\n\n-- | Require monad to be Flow-based and have specified fields in Reader env.\ntype HasFlowEnv m r fields =\n  ( MonadFlow m,\n    MonadReader r m,\n    HasFields r fields\n  )\n\ntype FlowHandlerR r = ReaderT (EnvR r) IO\n\ntype FlowServerR r api = ServerT api (FlowHandlerR r)\n\ntype MandatoryQueryParam name a = QueryParam' '[Required, Strict] name a\n\ntype Limit = Int\n\ntype Offset = Int\n\ntype RegToken = Text\n\n-- FIXME: remove this\ntype AuthHeader = Header' '[Required, Strict] \"token\" RegToken\n\ntype MandatoryHeader name a = Header' '[Required, Strict] name a\n\ninstance ToSchema Servant.BaseUrl where\n  declareNamedSchema _ = do\n    aSchema <- declareSchema (Proxy :: Proxy Text)\n    return $\n      NamedSchema (Just \"BaseUrl\") aSchema\n\ninstance ToSchema Value where\n  declareNamedSchema _ = do\n    aSchema <- declareSchema (Proxy :: Proxy Text)\n    return $\n      NamedSchema (Just \"Value\") $\n        aSchema\n          & description\n            ?~ \"Some JSON.\"\n",
      "hash": "efad54ffe556209ee750cf932ab51282200929074100c2b734ea4ee3979a19af",
      "size": 2520
    },
    "/lib/mobility-core/src/Kernel/Types/Base64.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n{-# LANGUAGE DerivingStrategies #-}\n{-# LANGUAGE GeneralizedNewtypeDeriving #-}\n{-# LANGUAGE PackageImports #-}\n{-# LANGUAGE StandaloneDeriving #-}\n\nmodule Kernel.Types.Base64 where\n\nimport qualified Data.Aeson as A\nimport Data.Bifunctor (bimap)\nimport Data.ByteString\nimport qualified \"base64-bytestring\" Data.ByteString.Base64 as Base64\nimport qualified Data.Text as T\nimport qualified Database.Beam as B\nimport Database.Beam.Backend\nimport Database.Beam.Postgres\nimport Database.PostgreSQL.Simple.FromField (FromField)\nimport Kernel.Prelude\nimport Kernel.Storage.Esqueleto.Queries\n  ( PersistField (..),\n    PersistFieldSql,\n    PersistValue (PersistText),\n  )\nimport Kernel.Utils.Dhall\n\nnewtype Base64 = Base64 ByteString\n  deriving (Show, Eq, Read, Ord)\n  deriving newtype (PersistFieldSql)\n\nderiving newtype instance FromField Base64\n\ninstance HasSqlValueSyntax be String => HasSqlValueSyntax be Base64 where\n  sqlValueSyntax = autoSqlValueSyntax\n\ninstance BeamSqlBackend be => B.HasSqlEqualityCheck be Base64\n\ninstance FromBackendRow Postgres Base64\n\ninstance PersistField Base64 where\n  toPersistValue (Base64 t) = PersistText . decodeUtf8 $ Base64.encode t\n  fromPersistValue (PersistText t) = bimap T.pack Base64 . Base64.decode $ encodeUtf8 t\n  fromPersistValue x = Left $ \"When trying to deserialize an Base64: expected PersistText, received: \" <> T.pack (show x)\n\ninstance FromDhall Base64 where\n  autoWith = customDecoder T.pack (fmap Base64 . Base64.decode . encodeUtf8 @Text) . autoWith\n\ninstance ToJSON Base64 where\n  toJSON (Base64 bs) = A.String $ decodeUtf8 $ Base64.encode bs\n\ninstance FromJSON Base64 where\n  parseJSON = A.withText \"Base64\" decodeBase64\n    where\n      decodeBase64 txt =\n        Base64.decode (encodeUtf8 txt)\n          & either fail (pure . Base64)\n\n-- Use only for constant values in test code\ninstance IsString Base64 where\n  fromString = Base64 . Base64.decodeLenient . encodeUtf8\n",
      "hash": "1e9ed5e9fdafbb71e263269c6b89f41f0a0253bef7116fada592feebbc5bfb8d",
      "size": 2618
    },
    "/lib/mobility-core/src/Kernel/Types/Beckn/Ack.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n\nmodule Kernel.Types.Beckn.Ack where\n\nimport qualified Control.Lens as L\nimport Data.Aeson\nimport qualified Data.Aeson.Key as AesonKey (Key)\nimport Data.Aeson.Types (unexpected)\nimport qualified Data.HashMap.Strict.InsOrd as HMSIO\nimport Data.OpenApi\nimport EulerHS.Prelude\n\ndata AckResponse = Ack\n  deriving (Generic, Show)\n\ninstance ToSchema AckResponse where\n  declareNamedSchema _ = do\n    return $\n      NamedSchema (Just \"AckResponse\") $\n        mempty\n          & type_ L.?~ OpenApiObject\n          & properties\n            L..~ HMSIO.singleton \"message\" messageSchema\n          & required L..~ [\"message\"]\n    where\n      statusSchema =\n        (mempty :: Schema)\n          & type_ L.?~ OpenApiString\n          & enum_ L.?~ [\"ACK\"]\n          & Inline\n      ackSchema =\n        (mempty :: Schema)\n          & type_ L.?~ OpenApiObject\n          & properties\n            L..~ HMSIO.singleton \"status\" statusSchema\n          & required L..~ [\"status\"]\n          & Inline\n      messageSchema =\n        (mempty :: Schema)\n          & type_ L.?~ OpenApiObject\n          & properties\n            L..~ HMSIO.singleton \"ack\" ackSchema\n          & required L..~ [\"ack\"]\n          & Inline\n\ninstance FromJSON AckResponse where\n  parseJSON = withObject \"Ack\" $ \\v -> do\n    status <-\n      (v .: \"message\")\n        >>= (.: \"ack\")\n        >>= (.: \"status\")\n    unless (status == String \"ACK\") (unexpected status)\n    pure Ack\n\ninstance ToJSON AckResponse where\n  toJSON Ack = \"message\" .== \"ack\" .== \"status\" .== String \"ACK\"\n    where\n      (.==) :: AesonKey.Key -> Value -> Value\n      k .== v = Object (k .= v)\n      infixr 9 .==\n",
      "hash": "14e58b7f5eca5692a453f184ba6d95603b4b9f7f0101750b25e47ab23a371067",
      "size": 2320
    },
    "/lib/mobility-core/src/Kernel/Types/Beckn/City.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n{-# LANGUAGE DerivingVia #-}\n{-# LANGUAGE StandaloneDeriving #-}\n{-# LANGUAGE TemplateHaskell #-}\n\nmodule Kernel.Types.Beckn.City (City (..)) where\n\nimport Data.Aeson\nimport Data.Aeson.Types\nimport Data.Char (toLower)\nimport Data.OpenApi hiding (Example)\nimport qualified Data.Text as T\nimport EulerHS.Prelude\nimport Kernel.Beam.Lib.UtilsTH (mkBeamInstancesForEnumAndList)\nimport Kernel.Storage.Esqueleto\nimport Kernel.Utils.GenericPretty\nimport Servant.API (FromHttpApiData (..), ToHttpApiData (..))\n\nderivePersistField \"City\"\n\ndata City\n  = Bangalore\n  | Kolkata\n  | Paris\n  | Kochi\n  | Delhi\n  | Hyderabad\n  | Mumbai\n  | Chennai\n  | TamilNaduCities\n  | Mysore\n  | Pondicherry\n  | Pune\n  | Tumakuru\n  | Noida\n  | Gurugram\n  | Tirunelveli\n  | Thanjavur\n  | Vellore\n  | Madurai\n  | Salem\n  | Hosur\n  | Trichy\n  | Minneapolis\n  | Trivandrum\n  | Thrissur\n  | Kozhikode\n  | Chandigarh\n  | Jaipur\n  | Siliguri\n  | Asansol\n  | Durgapur\n  | Petrapole\n  | Gangtok\n  | Darjeeling\n  | Davanagere\n  | Shivamogga\n  | Hubli\n  | Mangalore\n  | Udupi\n  | Gulbarga\n  | Vijayawada\n  | Vishakapatnam\n  | Guntur\n  | Tirupati\n  | Kurnool\n  | Khammam\n  | Karimnagar\n  | Nizamabad\n  | Mahbubnagar\n  | Suryapet\n  | Nalgonda\n  | Siddipet\n  | Rourkela\n  | Bhubaneshwar\n  | Cuttack\n  | Puri\n  | Warangal\n  | Pudukkottai\n  | Bidar\n  | Srinagar\n  | AnyCity\n  | Alapuzha\n  | Idukki\n  | Kasarkode\n  | Wayanad\n  | Kannur\n  | Kottayam\n  | Palakkad\n  | Kolam\n  | Pathanamthitta\n  | Shillong\n  | Cherrapunji\n  | Pulwama\n  | Jammu\n  | Anantnag\n  | Berhampur\n  | Bardhaman\n  | Ballari\n  | Digha\n  deriving (Eq, Generic, Show, Read, ToSchema, Ord, ToParamSchema)\n  deriving (PrettyShow) via Showable City\n\n$(mkBeamInstancesForEnumAndList ''City)\n\ninstance FromJSON City where\n  parseJSON (String \"std:080\") = pure Bangalore\n  parseJSON (String \"Bangalore\") = pure Bangalore\n  parseJSON (String \"std:033\") = pure Kolkata\n  parseJSON (String \"Kolkata\") = pure Kolkata\n  parseJSON (String \"std:001\") = pure Paris\n  parseJSON (String \"Paris\") = pure Paris\n  parseJSON (String \"std:484\") = pure Kochi\n  parseJSON (String \"std:0484\") = pure Kochi\n  parseJSON (String \"Kochi\") = pure Kochi\n  parseJSON (String \"std:011\") = pure Delhi\n  parseJSON (String \"Delhi\") = pure Delhi\n  parseJSON (String \"std:040\") = pure Hyderabad\n  parseJSON (String \"Hyderabad\") = pure Hyderabad\n  parseJSON (String \"std:022\") = pure Mumbai\n  parseJSON (String \"Mumbai\") = pure Mumbai\n  parseJSON (String \"std:044\") = pure Chennai\n  parseJSON (String \"Chennai\") = pure Chennai\n  parseJSON (String \"std:0422\") = pure TamilNaduCities\n  parseJSON (String \"TamilNaduCities\") = pure TamilNaduCities\n  parseJSON (String \"std:020\") = pure Pune\n  parseJSON (String \"Pune\") = pure Pune\n  parseJSON (String \"std:0413\") = pure Pondicherry\n  parseJSON (String \"Pondicherry\") = pure Pondicherry\n  parseJSON (String \"std:0821\") = pure Mysore\n  parseJSON (String \"Mysore\") = pure Mysore\n  parseJSON (String \"std:0816\") = pure Tumakuru\n  parseJSON (String \"Tumakuru\") = pure Tumakuru\n  parseJSON (String \"std:01189\") = pure Noida\n  parseJSON (String \"Noida\") = pure Noida\n  parseJSON (String \"std:0124\") = pure Gurugram\n  parseJSON (String \"Gurugram\") = pure Gurugram\n  parseJSON (String \"std:0462\") = pure Tirunelveli\n  parseJSON (String \"Tirunelveli\") = pure Tirunelveli\n  parseJSON (String \"std:04362\") = pure Thanjavur\n  parseJSON (String \"Thanjavur\") = pure Thanjavur\n  parseJSON (String \"std:0416\") = pure Vellore\n  parseJSON (String \"Vellore\") = pure Vellore\n  parseJSON (String \"std:0452\") = pure Madurai\n  parseJSON (String \"Madurai\") = pure Madurai\n  parseJSON (String \"std:0427\") = pure Salem\n  parseJSON (String \"Salem\") = pure Salem\n  parseJSON (String \"std:04344\") = pure Hosur\n  parseJSON (String \"Hosur\") = pure Hosur\n  parseJSON (String \"std:0431\") = pure Trichy\n  parseJSON (String \"Trichy\") = pure Trichy\n  parseJSON (String \"std:0820\") = pure Minneapolis\n  parseJSON (String \"Minneapolis\") = pure Minneapolis\n  parseJSON (String \"std:0471\") = pure Trivandrum\n  parseJSON (String \"Trivandrum\") = pure Trivandrum\n  parseJSON (String \"std:0487\") = pure Thrissur\n  parseJSON (String \"Thrissur\") = pure Thrissur\n  parseJSON (String \"std:0495\") = pure Kozhikode\n  parseJSON (String \"Kozhikode\") = pure Kozhikode\n  parseJSON (String \"std:0172\") = pure Chandigarh\n  parseJSON (String \"Chandigarh\") = pure Chandigarh\n  parseJSON (String \"std:0141\") = pure Jaipur\n  parseJSON (String \"Jaipur\") = pure Jaipur\n  parseJSON (String \"std:0353\") = pure Siliguri\n  parseJSON (String \"Siliguri\") = pure Siliguri\n  parseJSON (String \"std:0341\") = pure Asansol\n  parseJSON (String \"Asansol\") = pure Asansol\n  parseJSON (String \"std:0342\") = pure Durgapur\n  parseJSON (String \"Durgapur\") = pure Durgapur\n  parseJSON (String \"std:03215\") = pure Petrapole\n  parseJSON (String \"Petrapole\") = pure Petrapole\n  parseJSON (String \"std:03592\") = pure Gangtok\n  parseJSON (String \"Gangtok\") = pure Gangtok\n  parseJSON (String \"std:0354\") = pure Darjeeling\n  parseJSON (String \"Darjeeling\") = pure Darjeeling\n  parseJSON (String \"std:08192\") = pure Davanagere\n  parseJSON (String \"Davanagere\") = pure Davanagere\n  parseJSON (String \"std:08182\") = pure Shivamogga\n  parseJSON (String \"Shivamogga\") = pure Shivamogga\n  parseJSON (String \"std:0836\") = pure Hubli\n  parseJSON (String \"Hubli\") = pure Hubli\n  parseJSON (String \"std:0824\") = pure Mangalore\n  parseJSON (String \"Mangalore\") = pure Mangalore\n  parseJSON (String \"std:08200\") = pure Udupi\n  parseJSON (String \"Udupi\") = pure Udupi\n  parseJSON (String \"std:08472\") = pure Gulbarga\n  parseJSON (String \"Gulbarga\") = pure Gulbarga\n  parseJSON (String \"std:0866\") = pure Vijayawada\n  parseJSON (String \"Vijayawada\") = pure Vijayawada\n  parseJSON (String \"std:0891\") = pure Vishakapatnam\n  parseJSON (String \"Vishakapatnam\") = pure Vishakapatnam\n  parseJSON (String \"std:0863\") = pure Guntur\n  parseJSON (String \"Guntur\") = pure Guntur\n  parseJSON (String \"std:0877\") = pure Tirupati\n  parseJSON (String \"Tirupati\") = pure Tirupati\n  parseJSON (String \"std:08518\") = pure Kurnool\n  parseJSON (String \"Kurnool\") = pure Kurnool\n  parseJSON (String \"std:08742\") = pure Khammam\n  parseJSON (String \"Khammam\") = pure Khammam\n  parseJSON (String \"std:08722\") = pure Karimnagar\n  parseJSON (String \"Karimnagar\") = pure Karimnagar\n  parseJSON (String \"std:08463\") = pure Nizamabad\n  parseJSON (String \"Nizamabad\") = pure Nizamabad\n  parseJSON (String \"std:08542\") = pure Mahbubnagar\n  parseJSON (String \"Mahbubnagar\") = pure Mahbubnagar\n  parseJSON (String \"std:08684\") = pure Suryapet\n  parseJSON (String \"Suryapet\") = pure Suryapet\n  parseJSON (String \"std:08682\") = pure Nalgonda\n  parseJSON (String \"Nalgonda\") = pure Nalgonda\n  parseJSON (String \"std:08457\") = pure Siddipet\n  parseJSON (String \"Siddipet\") = pure Siddipet\n  parseJSON (String \"std:0661\") = pure Rourkela\n  parseJSON (String \"Rourkela\") = pure Rourkela\n  parseJSON (String \"std:0674\") = pure Bhubaneshwar\n  parseJSON (String \"Bhubaneshwar\") = pure Bhubaneshwar\n  parseJSON (String \"std:0671\") = pure Cuttack\n  parseJSON (String \"Cuttack\") = pure Cuttack\n  parseJSON (String \"std:06752\") = pure Puri\n  parseJSON (String \"Puri\") = pure Puri\n  parseJSON (String \"std:0870\") = pure Warangal\n  parseJSON (String \"Warangal\") = pure Warangal\n  parseJSON (String \"std:04322\") = pure Pudukkottai\n  parseJSON (String \"Pudukkottai\") = pure Pudukkottai\n  parseJSON (String \"std:8482\") = pure Bidar\n  parseJSON (String \"Bidar\") = pure Bidar\n  parseJSON (String \"std:0194\") = pure Srinagar\n  parseJSON (String \"Srinagar\") = pure Srinagar\n  parseJSON (String \"std:0477\") = pure Alapuzha\n  parseJSON (String \"Alapuzha\") = pure Alapuzha\n  parseJSON (String \"std:04863\") = pure Idukki\n  parseJSON (String \"Idukki\") = pure Idukki\n  parseJSON (String \"std:4994\") = pure Kasarkode\n  parseJSON (String \"Kasarkode\") = pure Kasarkode\n  parseJSON (String \"std:4936\") = pure Wayanad\n  parseJSON (String \"Wayanad\") = pure Wayanad\n  parseJSON (String \"std:497\") = pure Kannur\n  parseJSON (String \"Kannur\") = pure Kannur\n  parseJSON (String \"std:0481\") = pure Kottayam\n  parseJSON (String \"Kottayam\") = pure Kottayam\n  parseJSON (String \"std:0491\") = pure Palakkad\n  parseJSON (String \"Palakkad\") = pure Palakkad\n  parseJSON (String \"std:474\") = pure Kolam\n  parseJSON (String \"Kolam\") = pure Kolam\n  parseJSON (String \"std:468\") = pure Pathanamthitta\n  parseJSON (String \"Pathanamthitta\") = pure Pathanamthitta\n  parseJSON (String \"std:0364\") = pure Shillong\n  parseJSON (String \"Shillong\") = pure Shillong\n  parseJSON (String \"std:03637\") = pure Cherrapunji\n  parseJSON (String \"Cherrapunji\") = pure Cherrapunji\n  parseJSON (String \"std:01933\") = pure Pulwama\n  parseJSON (String \"Pulwama\") = pure Pulwama\n  parseJSON (String \"std:0191\") = pure Jammu\n  parseJSON (String \"Jammu\") = pure Jammu\n  parseJSON (String \"std:01932\") = pure Anantnag\n  parseJSON (String \"Anantnag\") = pure Anantnag\n  parseJSON (String \"std:0680\") = pure Berhampur\n  parseJSON (String \"Berhampur\") = pure Berhampur\n  parseJSON (String \"std:0343\") = pure Bardhaman\n  parseJSON (String \"Bardhaman\") = pure Bardhaman\n  parseJSON (String \"std:08392\") = pure Ballari\n  parseJSON (String \"Ballari\") = pure Ballari\n  parseJSON (String \"std:03216\") = pure Digha\n  parseJSON (String \"Digha\") = pure Digha\n  parseJSON (String _) = pure AnyCity\n  parseJSON e = typeMismatch \"String\" e\n\ninstance ToJSON City where\n  toJSON Bangalore = String \"std:080\"\n  toJSON Kolkata = String \"std:033\"\n  toJSON Paris = String \"std:001\"\n  toJSON Kochi = String \"std:0484\"\n  toJSON Delhi = String \"std:011\"\n  toJSON Hyderabad = String \"std:040\"\n  toJSON Mumbai = String \"std:022\"\n  toJSON Chennai = String \"std:044\"\n  toJSON TamilNaduCities = String \"std:0422\"\n  toJSON Pondicherry = String \"std:0413\"\n  toJSON Pune = String \"std:020\"\n  toJSON Mysore = String \"std:0821\"\n  toJSON Tumakuru = String \"std:0816\"\n  toJSON Noida = String \"std:01189\"\n  toJSON Gurugram = String \"std:0124\"\n  toJSON Tirunelveli = String \"std:0462\"\n  toJSON Thanjavur = String \"std:04362\"\n  toJSON Vellore = String \"std:0416\"\n  toJSON Madurai = String \"std:0452\"\n  toJSON Salem = String \"std:0427\"\n  toJSON Hosur = String \"std:04344\"\n  toJSON Trichy = String \"std:0431\"\n  toJSON Minneapolis = String \"std:0820\"\n  toJSON Trivandrum = String \"std:0471\"\n  toJSON Thrissur = String \"std:0487\"\n  toJSON Kozhikode = String \"std:0495\"\n  toJSON Chandigarh = String \"std:0172\"\n  toJSON Jaipur = String \"std:0141\"\n  toJSON Siliguri = String \"std:0353\"\n  toJSON Asansol = String \"std:0341\"\n  toJSON Durgapur = String \"std:0342\"\n  toJSON Petrapole = String \"std:03215\"\n  toJSON Gangtok = String \"std:03592\"\n  toJSON Darjeeling = String \"std:0354\"\n  toJSON Davanagere = String \"std:08192\"\n  toJSON Shivamogga = String \"std:08182\"\n  toJSON Hubli = String \"std:0836\"\n  toJSON Mangalore = String \"std:0824\"\n  toJSON Udupi = String \"std:08200\"\n  toJSON Gulbarga = String \"std:08472\"\n  toJSON Vijayawada = String \"std:0866\"\n  toJSON Vishakapatnam = String \"std:0891\"\n  toJSON Guntur = String \"std:0863\"\n  toJSON Tirupati = String \"std:0877\"\n  toJSON Kurnool = String \"std:08518\"\n  toJSON Khammam = String \"std:08742\"\n  toJSON Karimnagar = String \"std:08722\"\n  toJSON Nizamabad = String \"std:08463\"\n  toJSON Mahbubnagar = String \"std:08542\"\n  toJSON Suryapet = String \"std:08684\"\n  toJSON Nalgonda = String \"std:08682\"\n  toJSON Siddipet = String \"std:08457\"\n  toJSON Rourkela = String \"std:0661\"\n  toJSON Bhubaneshwar = String \"std:0674\"\n  toJSON Cuttack = String \"std:0671\"\n  toJSON Puri = String \"std:06752\"\n  toJSON Warangal = String \"std:0870\"\n  toJSON Pudukkottai = String \"std:04322\"\n  toJSON Bidar = String \"std:8482\"\n  toJSON Srinagar = String \"std:0194\"\n  toJSON Alapuzha = String \"std:0477\"\n  toJSON Idukki = String \"std:04863\"\n  toJSON Kasarkode = String \"std:4994\"\n  toJSON Wayanad = String \"std:4936\"\n  toJSON Kannur = String \"std:497\"\n  toJSON Kottayam = String \"std:0481\"\n  toJSON Palakkad = String \"std:0491\"\n  toJSON Kolam = String \"std:474\"\n  toJSON Pathanamthitta = String \"std:468\"\n  toJSON Shillong = String \"std:0364\"\n  toJSON Cherrapunji = String \"std:03637\"\n  toJSON Pulwama = String \"std:01933\"\n  toJSON Jammu = String \"std:0191\"\n  toJSON Anantnag = String \"std:01932\"\n  toJSON Berhampur = String \"std:0680\"\n  toJSON Bardhaman = String \"std:0343\"\n  toJSON Ballari = String \"std:08392\"\n  toJSON Digha = String \"std:03216\"\n  toJSON AnyCity = String \"*\"\n\ninstance FromHttpApiData City where\n  parseUrlPiece a =\n    let lower = map toLower $ T.unpack a\n     in parseLowerCaseCity lower\n    where\n      parseLowerCaseCity \"std:080\" = Right Bangalore\n      parseLowerCaseCity \"bangalore\" = Right Bangalore\n      parseLowerCaseCity \"std:033\" = Right Kolkata\n      parseLowerCaseCity \"kolkata\" = Right Kolkata\n      parseLowerCaseCity \"std:001\" = Right Paris\n      parseLowerCaseCity \"paris\" = Right Paris\n      parseLowerCaseCity \"std:484\" = Right Kochi\n      parseLowerCaseCity \"std:0484\" = Right Kochi\n      parseLowerCaseCity \"kochi\" = Right Kochi\n      parseLowerCaseCity \"std:011\" = Right Delhi\n      parseLowerCaseCity \"delhi\" = Right Delhi\n      parseLowerCaseCity \"std:040\" = Right Hyderabad\n      parseLowerCaseCity \"hyderabad\" = Right Hyderabad\n      parseLowerCaseCity \"std:022\" = Right Mumbai\n      parseLowerCaseCity \"mumbai\" = Right Mumbai\n      parseLowerCaseCity \"std:044\" = Right Chennai\n      parseLowerCaseCity \"chennai\" = Right Chennai\n      parseLowerCaseCity \"std:0422\" = Right TamilNaduCities\n      parseLowerCaseCity \"tamilnaducities\" = Right TamilNaduCities\n      parseLowerCaseCity \"std:020\" = Right Pune\n      parseLowerCaseCity \"pune\" = Right Pune\n      parseLowerCaseCity \"std:0413\" = Right Pondicherry\n      parseLowerCaseCity \"pondicherry\" = Right Pondicherry\n      parseLowerCaseCity \"std:0821\" = Right Mysore\n      parseLowerCaseCity \"mysore\" = Right Mysore\n      parseLowerCaseCity \"std:0816\" = Right Tumakuru\n      parseLowerCaseCity \"tumakuru\" = Right Tumakuru\n      parseLowerCaseCity \"std:01189\" = Right Noida\n      parseLowerCaseCity \"noida\" = Right Noida\n      parseLowerCaseCity \"std:0124\" = Right Gurugram\n      parseLowerCaseCity \"gurugram\" = Right Gurugram\n      parseLowerCaseCity \"std:0462\" = Right Tirunelveli\n      parseLowerCaseCity \"tirunelveli\" = Right Tirunelveli\n      parseLowerCaseCity \"std:04362\" = Right Thanjavur\n      parseLowerCaseCity \"thanjavur\" = Right Thanjavur\n      parseLowerCaseCity \"std:0416\" = Right Vellore\n      parseLowerCaseCity \"vellore\" = Right Vellore\n      parseLowerCaseCity \"std:0452\" = Right Madurai\n      parseLowerCaseCity \"madurai\" = Right Madurai\n      parseLowerCaseCity \"std:0427\" = Right Salem\n      parseLowerCaseCity \"salem\" = Right Salem\n      parseLowerCaseCity \"std:04344\" = Right Hosur\n      parseLowerCaseCity \"hosur\" = Right Hosur\n      parseLowerCaseCity \"std:0431\" = Right Trichy\n      parseLowerCaseCity \"trichy\" = Right Trichy\n      parseLowerCaseCity \"std:0820\" = Right Minneapolis\n      parseLowerCaseCity \"minneapolis\" = Right Minneapolis\n      parseLowerCaseCity \"std:0471\" = Right Trivandrum\n      parseLowerCaseCity \"trivandrum\" = Right Trivandrum\n      parseLowerCaseCity \"std:0487\" = Right Thrissur\n      parseLowerCaseCity \"thrissur\" = Right Thrissur\n      parseLowerCaseCity \"std:0495\" = Right Kozhikode\n      parseLowerCaseCity \"kozhikode\" = Right Kozhikode\n      parseLowerCaseCity \"std:0172\" = Right Chandigarh\n      parseLowerCaseCity \"chandigarh\" = Right Chandigarh\n      parseLowerCaseCity \"std:0141\" = Right Jaipur\n      parseLowerCaseCity \"jaipur\" = Right Jaipur\n      parseLowerCaseCity \"std:0353\" = Right Siliguri\n      parseLowerCaseCity \"siliguri\" = Right Siliguri\n      parseLowerCaseCity \"std:0341\" = Right Asansol\n      parseLowerCaseCity \"asansol\" = Right Asansol\n      parseLowerCaseCity \"std:0342\" = Right Durgapur\n      parseLowerCaseCity \"durgapur\" = Right Durgapur\n      parseLowerCaseCity \"std:03215\" = Right Petrapole\n      parseLowerCaseCity \"petrapole\" = Right Petrapole\n      parseLowerCaseCity \"std:03592\" = Right Gangtok\n      parseLowerCaseCity \"gangtok\" = Right Gangtok\n      parseLowerCaseCity \"std:0354\" = Right Darjeeling\n      parseLowerCaseCity \"darjeeling\" = Right Darjeeling\n      parseLowerCaseCity \"std:08192\" = Right Davanagere\n      parseLowerCaseCity \"davanagere\" = Right Davanagere\n      parseLowerCaseCity \"std:08182\" = Right Shivamogga\n      parseLowerCaseCity \"shivamogga\" = Right Shivamogga\n      parseLowerCaseCity \"std:0836\" = Right Hubli\n      parseLowerCaseCity \"hubli\" = Right Hubli\n      parseLowerCaseCity \"std:0824\" = Right Mangalore\n      parseLowerCaseCity \"mangalore\" = Right Mangalore\n      parseLowerCaseCity \"std:08200\" = Right Udupi\n      parseLowerCaseCity \"udupi\" = Right Udupi\n      parseLowerCaseCity \"std:08472\" = Right Gulbarga\n      parseLowerCaseCity \"gulbarga\" = Right Gulbarga\n      parseLowerCaseCity \"std:0866\" = Right Vijayawada\n      parseLowerCaseCity \"vijayawada\" = Right Vijayawada\n      parseLowerCaseCity \"std:0891\" = Right Vishakapatnam\n      parseLowerCaseCity \"vishakapatnam\" = Right Vishakapatnam\n      parseLowerCaseCity \"std:0863\" = Right Guntur\n      parseLowerCaseCity \"guntur\" = Right Guntur\n      parseLowerCaseCity \"std:0877\" = Right Tirupati\n      parseLowerCaseCity \"tirupati\" = Right Tirupati\n      parseLowerCaseCity \"std:08518\" = Right Kurnool\n      parseLowerCaseCity \"kurnool\" = Right Kurnool\n      parseLowerCaseCity \"std:08742\" = Right Khammam\n      parseLowerCaseCity \"khammam\" = Right Khammam\n      parseLowerCaseCity \"std:08722\" = Right Karimnagar\n      parseLowerCaseCity \"karimnagar\" = Right Karimnagar\n      parseLowerCaseCity \"std:08463\" = Right Nizamabad\n      parseLowerCaseCity \"nizamabad\" = Right Nizamabad\n      parseLowerCaseCity \"std:08542\" = Right Mahbubnagar\n      parseLowerCaseCity \"mahbubnagar\" = Right Mahbubnagar\n      parseLowerCaseCity \"std:08684\" = Right Suryapet\n      parseLowerCaseCity \"suryapet\" = Right Suryapet\n      parseLowerCaseCity \"std:08682\" = Right Nalgonda\n      parseLowerCaseCity \"nalgonda\" = Right Nalgonda\n      parseLowerCaseCity \"std:08457\" = Right Siddipet\n      parseLowerCaseCity \"siddipet\" = Right Siddipet\n      parseLowerCaseCity \"std:0661\" = Right Rourkela\n      parseLowerCaseCity \"rourkela\" = Right Rourkela\n      parseLowerCaseCity \"std:0674\" = Right Bhubaneshwar\n      parseLowerCaseCity \"bhubaneshwar\" = Right Bhubaneshwar\n      parseLowerCaseCity \"std:0671\" = Right Cuttack\n      parseLowerCaseCity \"cuttack\" = Right Cuttack\n      parseLowerCaseCity \"std:06752\" = Right Puri\n      parseLowerCaseCity \"puri\" = Right Puri\n      parseLowerCaseCity \"std:0870\" = Right Warangal\n      parseLowerCaseCity \"warangal\" = Right Warangal\n      parseLowerCaseCity \"std:04322\" = Right Pudukkottai\n      parseLowerCaseCity \"pudukkottai\" = Right Pudukkottai\n      parseLowerCaseCity \"std:8482\" = Right Bidar\n      parseLowerCaseCity \"bidar\" = Right Bidar\n      parseLowerCaseCity \"std:0194\" = Right Srinagar\n      parseLowerCaseCity \"srinagar\" = Right Srinagar\n      parseLowerCaseCity \"std:0477\" = Right Alapuzha\n      parseLowerCaseCity \"alapuzha\" = Right Alapuzha\n      parseLowerCaseCity \"std:04863\" = Right Idukki\n      parseLowerCaseCity \"idukki\" = Right Idukki\n      parseLowerCaseCity \"std:4994\" = Right Kasarkode\n      parseLowerCaseCity \"kasarkode\" = Right Kasarkode\n      parseLowerCaseCity \"std:4936\" = Right Wayanad\n      parseLowerCaseCity \"wayanad\" = Right Wayanad\n      parseLowerCaseCity \"std:497\" = Right Kannur\n      parseLowerCaseCity \"kannur\" = Right Kannur\n      parseLowerCaseCity \"std:0481\" = Right Kottayam\n      parseLowerCaseCity \"kottayam\" = Right Kottayam\n      parseLowerCaseCity \"std:0491\" = Right Palakkad\n      parseLowerCaseCity \"palakkad\" = Right Palakkad\n      parseLowerCaseCity \"std:474\" = Right Kolam\n      parseLowerCaseCity \"kolam\" = Right Kolam\n      parseLowerCaseCity \"std:468\" = Right Pathanamthitta\n      parseLowerCaseCity \"pathanamthitta\" = Right Pathanamthitta\n      parseLowerCaseCity \"std:0364\" = Right Shillong\n      parseLowerCaseCity \"shillong\" = Right Shillong\n      parseLowerCaseCity \"std:03637\" = Right Cherrapunji\n      parseLowerCaseCity \"cherrapunji\" = Right Cherrapunji\n      parseLowerCaseCity \"std:01933\" = Right Pulwama\n      parseLowerCaseCity \"pulwama\" = Right Pulwama\n      parseLowerCaseCity \"std:0191\" = Right Jammu\n      parseLowerCaseCity \"jammu\" = Right Jammu\n      parseLowerCaseCity \"std:01932\" = Right Anantnag\n      parseLowerCaseCity \"anantnag\" = Right Anantnag\n      parseLowerCaseCity \"std:0680\" = Right Berhampur\n      parseLowerCaseCity \"berhampur\" = Right Berhampur\n      parseLowerCaseCity \"std:0343\" = Right Bardhaman\n      parseLowerCaseCity \"bardhaman\" = Right Bardhaman\n      parseLowerCaseCity \"std:08392\" = Right Ballari\n      parseLowerCaseCity \"ballari\" = Right Ballari\n      parseLowerCaseCity \"std:03216\" = Right Digha\n      parseLowerCaseCity \"digha\" = Right Digha\n      parseLowerCaseCity \"*\" = Right AnyCity\n      parseLowerCaseCity city = Left . T.pack $ (\"ParseFail: Unable to parse city: \" <> city)\n\ninstance ToHttpApiData City where\n  toUrlPiece Bangalore = \"std:080\"\n  toUrlPiece Kolkata = \"std:033\"\n  toUrlPiece Paris = \"std:001\"\n  toUrlPiece Kochi = \"std:0484\"\n  toUrlPiece Delhi = \"std:011\"\n  toUrlPiece Hyderabad = \"std:040\"\n  toUrlPiece Mumbai = \"std:022\"\n  toUrlPiece Chennai = \"std:044\"\n  toUrlPiece TamilNaduCities = \"std:0422\"\n  toUrlPiece Pondicherry = \"std:0413\"\n  toUrlPiece Pune = \"std:020\"\n  toUrlPiece Mysore = \"std:0821\"\n  toUrlPiece Tumakuru = \"std:0816\"\n  toUrlPiece Noida = \"std:01189\"\n  toUrlPiece Gurugram = \"std:0124\"\n  toUrlPiece Tirunelveli = \"std:0462\"\n  toUrlPiece Thanjavur = \"std:04362\"\n  toUrlPiece Vellore = \"std:0416\"\n  toUrlPiece Madurai = \"std:0452\"\n  toUrlPiece Salem = \"std:0427\"\n  toUrlPiece Hosur = \"std:04344\"\n  toUrlPiece Trichy = \"std:0431\"\n  toUrlPiece Minneapolis = \"std:0820\"\n  toUrlPiece Trivandrum = \"std:0471\"\n  toUrlPiece Thrissur = \"std:0487\"\n  toUrlPiece Kozhikode = \"std:0495\"\n  toUrlPiece Chandigarh = \"std:0172\"\n  toUrlPiece Jaipur = \"std:0141\"\n  toUrlPiece Siliguri = \"std:0353\"\n  toUrlPiece Asansol = \"std:0341\"\n  toUrlPiece Durgapur = \"std:0342\"\n  toUrlPiece Petrapole = \"std:03215\"\n  toUrlPiece Gangtok = \"std:03592\"\n  toUrlPiece Darjeeling = \"std:0354\"\n  toUrlPiece Davanagere = \"std:08192\"\n  toUrlPiece Shivamogga = \"std:08182\"\n  toUrlPiece Hubli = \"std:0836\"\n  toUrlPiece Mangalore = \"std:0824\"\n  toUrlPiece Udupi = \"std:08200\"\n  toUrlPiece Gulbarga = \"std:08472\"\n  toUrlPiece Vijayawada = \"std:0866\"\n  toUrlPiece Vishakapatnam = \"std:0891\"\n  toUrlPiece Guntur = \"std:0863\"\n  toUrlPiece Tirupati = \"std:0877\"\n  toUrlPiece Kurnool = \"std:08518\"\n  toUrlPiece Khammam = \"std:08742\"\n  toUrlPiece Karimnagar = \"std:08722\"\n  toUrlPiece Nizamabad = \"std:08463\"\n  toUrlPiece Mahbubnagar = \"std:08542\"\n  toUrlPiece Suryapet = \"std:08684\"\n  toUrlPiece Nalgonda = \"std:08682\"\n  toUrlPiece Siddipet = \"std:08457\"\n  toUrlPiece Rourkela = \"std:0661\"\n  toUrlPiece Bhubaneshwar = \"std:0674\"\n  toUrlPiece Cuttack = \"std:0671\"\n  toUrlPiece Puri = \"std:06752\"\n  toUrlPiece Warangal = \"std:0870\"\n  toUrlPiece Pudukkottai = \"std:04322\"\n  toUrlPiece Bidar = \"std:8482\"\n  toUrlPiece Srinagar = \"std:0194\"\n  toUrlPiece Alapuzha = \"std:0477\"\n  toUrlPiece Idukki = \"std:04863\"\n  toUrlPiece Kasarkode = \"std:4994\"\n  toUrlPiece Wayanad = \"std:4936\"\n  toUrlPiece Kannur = \"std:497\"\n  toUrlPiece Kottayam = \"std:0481\"\n  toUrlPiece Palakkad = \"std:0491\"\n  toUrlPiece Kolam = \"std:474\"\n  toUrlPiece Pathanamthitta = \"std:468\"\n  toUrlPiece Shillong = \"std:0364\"\n  toUrlPiece Cherrapunji = \"std:03637\"\n  toUrlPiece Pulwama = \"std:01933\"\n  toUrlPiece Jammu = \"std:0191\"\n  toUrlPiece Anantnag = \"std:01932\"\n  toUrlPiece Berhampur = \"std:0680\"\n  toUrlPiece Bardhaman = \"std:0343\"\n  toUrlPiece Ballari = \"std:08392\"\n  toUrlPiece Digha = \"std:03216\"\n  toUrlPiece AnyCity = \"*\"\n",
      "hash": "1aa59d94a77211c20c423502f79964d3ee025befe80b5d8f4b52e78e832b30d8",
      "size": 24461
    },
    "/lib/mobility-core/src/Kernel/Types/Beckn/Context.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n{-# LANGUAGE DerivingVia #-}\n\nmodule Kernel.Types.Beckn.Context (module Kernel.Types.Beckn.Context, module Reexport) where\n\nimport Data.Aeson\nimport Data.Maybe (fromJust)\nimport Data.OpenApi (ToSchema)\nimport EulerHS.Prelude\nimport Kernel.Types.App\nimport Kernel.Types.Beckn.City as Reexport\nimport Kernel.Types.Beckn.Country as Reexport\nimport Kernel.Types.Beckn.Domain as Reexport\nimport Kernel.Types.Beckn.IndianState as Reexport\nimport qualified Kernel.Types.Registry.Subscriber as Subscriber\nimport Kernel.Types.TimeRFC339 (UTCTimeRFC3339 (..))\nimport Kernel.Utils.Example\nimport Kernel.Utils.GenericPretty\nimport Kernel.Utils.JSON\nimport Servant.Client (parseBaseUrl)\n\ndata Context = Context\n  { domain :: Domain,\n    country :: Country,\n    city :: City,\n    action :: Action,\n    core_version :: Text,\n    bap_id :: Text,\n    bap_uri :: BaseUrl,\n    bpp_id :: Maybe Text,\n    bpp_uri :: Maybe BaseUrl,\n    transaction_id :: Maybe Text,\n    message_id :: Text,\n    timestamp :: UTCTimeRFC3339,\n    max_callbacks :: Maybe Int\n  }\n  deriving (Generic, FromJSON, Show, ToSchema, PrettyShow)\n\ninstance ToJSON Context where\n  toJSON = genericToJSON $ defaultOptions {omitNothingFields = True}\n\ninstance Example Context where\n  example =\n    Context\n      { domain = example,\n        action = example,\n        core_version = \"0.9.3\",\n        bap_id = \"API.DOMAIN\",\n        bap_uri = fromJust $ parseBaseUrl \"https://api.domain.com/\",\n        bpp_id = Just \"API.DOMAIN\",\n        bpp_uri = parseBaseUrl \"https://api.domain.com/\",\n        transaction_id = Just idExample,\n        message_id = idExample,\n        timestamp = UTCTimeRFC3339 example,\n        country = India,\n        city = Kochi,\n        max_callbacks = Just 1\n      }\n\ndata Action\n  = SEARCH\n  | SELECT\n  | INIT\n  | CONFIRM\n  | UPDATE\n  | STATUS\n  | TRACK\n  | CANCEL\n  | RATING\n  | SUPPORT\n  | ON_SEARCH\n  | ON_SELECT\n  | ON_INIT\n  | ON_CONFIRM\n  | ON_UPDATE\n  | ON_STATUS\n  | ON_TRACK\n  | ON_CANCEL\n  | ON_RATING\n  | ON_SUPPORT\n  | ISSUE\n  | ON_ISSUE\n  | ISSUE_STATUS\n  | ON_ISSUE_STATUS\n  deriving (Generic, Show, Eq, ToSchema)\n  deriving (PrettyShow) via Showable Action\n\ninstance FromJSON Action where\n  parseJSON = genericParseJSON constructorsToLowerOptions\n\ninstance ToJSON Action where\n  toJSON = genericToJSON constructorsToLowerOptions\n\ninstance Example Action where\n  example = SEARCH\n\nmapToCbAction :: Action -> Maybe Action\nmapToCbAction = \\case\n  SEARCH -> Just ON_SEARCH\n  SELECT -> Just ON_SELECT\n  INIT -> Just ON_INIT\n  CONFIRM -> Just ON_CONFIRM\n  UPDATE -> Just ON_UPDATE\n  STATUS -> Just ON_STATUS\n  TRACK -> Just ON_TRACK\n  CANCEL -> Just ON_CANCEL\n  RATING -> Just ON_RATING\n  SUPPORT -> Just ON_SUPPORT\n  ISSUE -> Just ON_ISSUE\n  ISSUE_STATUS -> Just ON_ISSUE_STATUS\n  _ -> Nothing\n\ngetSubscriberType :: Action -> Subscriber.SubscriberType\ngetSubscriberType action = if isNothing (mapToCbAction action) then Subscriber.BPP else Subscriber.BAP\n",
      "hash": "b729bd93211e376fb60b912906c66e045f51a3fd3c36ea7a95f0ee502a81d1fe",
      "size": 3624
    },
    "/lib/mobility-core/src/Kernel/Types/Beckn/Country.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n{-# LANGUAGE DerivingVia #-}\n{-# LANGUAGE StandaloneDeriving #-}\n{-# LANGUAGE TemplateHaskell #-}\n\nmodule Kernel.Types.Beckn.Country (Country (..)) where\n\nimport Data.Aeson\nimport Data.Aeson.Types\nimport Data.OpenApi hiding (Example)\nimport EulerHS.Prelude\nimport Kernel.Beam.Lib.UtilsTH (mkBeamInstancesForEnum)\nimport Kernel.Storage.Esqueleto\nimport Kernel.Utils.GenericPretty\n\nderivePersistField \"Country\"\n\ndata Country = India | France | USA | AnyCountry\n  deriving (Eq, Generic, Show, Read, ToSchema, Ord)\n  deriving (PrettyShow) via Showable Country\n\n$(mkBeamInstancesForEnum ''Country)\n\ninstance FromJSON Country where\n  parseJSON (String \"IND\") = pure India\n  parseJSON (String \"FRA\") = pure France\n  parseJSON (String \"USA\") = pure USA\n  parseJSON (String \"*\") = pure AnyCountry\n  parseJSON (String _) = parseFail \"Invalid Country\"\n  parseJSON e = typeMismatch \"String\" e\n\ninstance ToJSON Country where\n  toJSON India = String \"IND\"\n  toJSON France = String \"FRA\"\n  toJSON USA = String \"USA\"\n  toJSON AnyCountry = String \"*\"\n",
      "hash": "dd002b65570bf8fcbe0816e82c7bbb80aa4a378b23c8aee6af1673229fcdc664",
      "size": 1727
    },
    "/lib/mobility-core/src/Kernel/Types/Beckn/DecimalValue.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n{-# LANGUAGE DerivingStrategies #-}\n{-# LANGUAGE GeneralizedNewtypeDeriving #-}\n{-# LANGUAGE UndecidableInstances #-}\n{-# OPTIONS_GHC -Wwarn=identities #-}\n\n-- Functions rationalToString, validate\n-- are only exported for testing purposes.\nmodule Kernel.Types.Beckn.DecimalValue\n  ( DecimalValue (..),\n    valueToString,\n    valueFromString,\n  )\nwhere\n\nimport Control.Lens.Operators\nimport Data.Char\nimport Data.OpenApi hiding (Example, value)\nimport Data.Proxy\nimport qualified Data.Ratio as R\nimport qualified Data.Text as T\nimport EulerHS.Prelude\nimport Kernel.Utils.Example\nimport Kernel.Utils.GenericPretty (PrettyShow)\nimport qualified Money as M\n\n-- | A type for decimal values based on Rational.\n-- Uses \"integer.fractional\" format for serialization / deserialization.\n-- Maximum precision (total number of digits) is defined in this module.\n-- Note: serialization of numbers whose integer part has more digits than\n-- the maximum precision will fail with an error.\n-- Functions / and recip will fail with an error if the denominator is zero.\nnewtype DecimalValue = DecimalValue Rational\n  deriving (Eq, Ord, Show, Read, Generic)\n  deriving newtype (Num, Real, Fractional, RealFrac)\n  deriving anyclass (PrettyShow)\n\ninstance Example DecimalValue where\n  example = DecimalValue 10\n\nmaxPrecisionWord8 :: Word8\nmaxPrecisionWord8 = 30\n\nmaxPrecision :: Int\nmaxPrecision = fromIntegral maxPrecisionWord8\n\nmessage :: Text\nmessage =\n  \"Maximum allowed precision (total number of digits) is \"\n    <> show maxPrecision\n\n-- Functions rationalToString and valueToString should only be used\n-- for serialization. They don't perform any proper rounding and simply\n-- stop generating digits when at the maximum precision.\n-- Note: rationalToString will return Nothing if the integer\n-- part of the number exceeds the precision (total number of digits).\nrationalToString :: Int -> Rational -> Maybe String\nrationalToString precision rational\n  | length intPart > precision = Nothing\n  | otherwise = Just result\n  where\n    result =\n      if fracPrecision <= 0 || null fracPart\n        then intPart\n        else intPart <> \".\" <> take fracPrecision fracPart\n    rNumerator = R.numerator rational\n    rDenominator = R.denominator rational\n    sign = if rNumerator < 0 then \"-\" else \"\"\n    intPart = sign <> show quotient\n    fracPrecision = precision - length intPart\n    fracPart = expand remainder\n    (quotient, remainder) = abs rNumerator `quotRem` rDenominator\n    expand currentRemainder\n      | currentRemainder == 0 = \"\"\n      | otherwise = show digit <> expand nextRemainder\n      where\n        (digit, nextRemainder) = (10 * currentRemainder) `quotRem` rDenominator\n\n-- Note: valueToString will fail with an error if the integer\n-- part of the number exceeds the precision (total number of digits).\nvalueToString :: DecimalValue -> Text\nvalueToString value =\n  maybe\n    (error (\"Cannot convert \" <> show value <> \" to a string. \" <> message))\n    T.pack\n    (rationalToString maxPrecision (toRational value))\n\nvalueFromString :: Text -> Maybe DecimalValue\nvalueFromString valueString =\n  DecimalValue . toRational <$> M.denseFromDecimal decimalConf valueString\n  where\n    -- The exact value passed in DecimalConf.decimalConf_digits to\n    -- denseFromDecimal does not matter, but it should be large enough to\n    -- make sure there is no precision loss.\n    decimalConf =\n      M.defaultDecimalConf\n        { M.decimalConf_digits = maxPrecisionWord8\n        }\n\nvalidate :: Int -> Text -> Bool\nvalidate precision valueString =\n  T.length valueString <= maxPossibleLength\n    && countDigits valueString <= precision\n  where\n    -- Combined length of \"-\" and \".\"\n    maxNonDigitLength = 2\n    maxPossibleLength = T.length valueString + maxNonDigitLength\n    countDigits = T.length . T.filter isDigit\n\n-- Note: toJSON will fail with an error if the integer\n-- part of the number exceeds the precision (total number of digits).\ninstance ToJSON DecimalValue where\n  toJSON = toJSON . valueToString\n\ninstance FromJSON DecimalValue where\n  parseJSON value = do\n    valueString <- parseJSON value\n    unless (validate maxPrecision valueString) $ failText message\n    maybe (parseError valueString) pure $ valueFromString valueString\n    where\n      parseError valueString =\n        failText $ \"Cannot parse \" <> valueString <> \" as a DecimalValue.\"\n      failText = fail . T.unpack\n\ninstance ToSchema DecimalValue where\n  declareNamedSchema _ = do\n    aSchema <- declareSchema (Proxy :: Proxy Text)\n    return $\n      NamedSchema (Just \"DecimalValue\") $\n        aSchema\n          & description\n            ?~ \"Decimal value in a string representation \\\n               \\with an optional leading \\\"-\\\" for negative numbers. \\\n               \\Integer and fractional parts are separated with a dot.\"\n              <> message\n              <> \" String format is used to prevent loss of precision.\"\n          & format ?~ \"[-]?(?:0|[1-9][0-9]*)(?:\\\\.[0-9]+)?\"\n",
      "hash": "e53d561d66519d0827a48f320098418531205caab6a389ee4d9d6d7536a1c833",
      "size": 5640
    },
    "/lib/mobility-core/src/Kernel/Types/Beckn/Domain.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n{-# LANGUAGE DerivingVia #-}\n{-# LANGUAGE StandaloneKindSignatures #-}\n{-# LANGUAGE TemplateHaskell #-}\n\nmodule Kernel.Types.Beckn.Domain where\n\nimport Data.Aeson\nimport Data.Aeson.Types\nimport Data.OpenApi hiding (Example)\nimport Data.Singletons.TH\nimport EulerHS.Prelude\nimport Kernel.Beam.Lib.UtilsTH (mkBeamInstancesForEnumAndList)\nimport Kernel.Storage.Esqueleto\nimport Kernel.Utils.Dhall (FromDhall)\nimport Kernel.Utils.Example\nimport Kernel.Utils.GenericPretty\n\nderivePersistField \"Domain\"\n\ndata Domain\n  = MOBILITY\n  | LOCAL_RETAIL\n  | FOOD_AND_BEVERAGE\n  | HEALTHCARE\n  | METRO\n  | PARKING\n  | PUBLIC_TRANSPORT\n  | LOGISTICS\n  deriving (Eq, Generic, Show, Read, FromDhall, ToSchema, Ord, ToParamSchema)\n  deriving (PrettyShow) via Showable Domain\n\n$(mkBeamInstancesForEnumAndList ''Domain)\n\ngenSingletons [''Domain]\n\ninstance Example Domain where\n  example = MOBILITY\n\ninstance FromJSON Domain where\n  parseJSON (String \"nic2004:60221\") = pure MOBILITY\n  parseJSON (String \"ONDC:TRV10\") = pure MOBILITY\n  parseJSON (String \"nic2004:52110\") = pure LOCAL_RETAIL\n  -- parseJSON (String \"nic2004:60212\") = pure METRO\n  parseJSON (String \"nic2004:63031\") = pure PARKING\n  parseJSON (String \"ONDC:TRV11\") = pure PUBLIC_TRANSPORT\n  parseJSON (String \"nic2004:60232\") = pure LOGISTICS\n  parseJSON (String _) = parseFail \"Invalid Domain\"\n  parseJSON e = typeMismatch \"String\" e\n\ninstance ToJSON Domain where\n  toJSON MOBILITY = String \"ONDC:TRV10\"\n  toJSON LOCAL_RETAIL = String \"nic2004:52110\"\n  toJSON METRO = String \"ONDC:TRV11\"\n  toJSON PARKING = String \"nic2004:63031\"\n  toJSON PUBLIC_TRANSPORT = String \"ONDC:TRV11\"\n  toJSON LOGISTICS = String \"nic2004:60232\"\n  toJSON _ = error \"Invalid Domain\"\n",
      "hash": "5dfb37488dfd788e69c3385303097e2987fd9eaae52ac8ca945cccb87ae6a16d",
      "size": 2395
    },
    "/lib/mobility-core/src/Kernel/Types/Beckn/Error.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n{-# LANGUAGE DerivingVia #-}\n\nmodule Kernel.Types.Beckn.Error where\n\nimport Data.OpenApi (ToSchema)\nimport EulerHS.Prelude\nimport Kernel.Utils.GenericPretty (PrettyShow, Showable (Showable))\nimport Kernel.Utils.JSON\n\ndata Error = Error\n  { _type :: ErrorType,\n    code :: Text,\n    path :: Maybe Text,\n    message :: Maybe Text\n  }\n  deriving (Generic, Show, Eq, ToSchema, PrettyShow)\n\ndata ErrorType\n  = CONTEXT_ERROR\n  | CORE_ERROR\n  | INTERNAL_ERROR -- Not a spec value. TODO: get rid of it.\n  | DOMAIN_ERROR\n  | POLICY_ERROR\n  | JSON_SCHEMA_ERROR\n  deriving stock (Generic, Show, Eq)\n  deriving anyclass (ToSchema)\n  deriving (PrettyShow) via Showable ErrorType\n\ninstance FromJSON ErrorType where\n  parseJSON = genericParseJSON constructorsWithHyphens\n\ninstance ToJSON ErrorType where\n  toJSON = genericToJSON constructorsWithHyphens\n\ninstance FromJSON Error where\n  parseJSON = genericParseJSON stripPrefixUnderscoreIfAny\n\ninstance ToJSON Error where\n  toJSON = genericToJSON stripPrefixUnderscoreIfAny\n",
      "hash": "7c2fba4686056c6446eab1bb1d488b77dde4c1e33b2aef8c4d643d4c19dd021a",
      "size": 1701
    },
    "/lib/mobility-core/src/Kernel/Types/Beckn/Gps.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n\nmodule Kernel.Types.Beckn.Gps (Gps (..)) where\n\nimport Control.Arrow ((>>>))\nimport Data.Aeson\nimport Data.Aeson.Types (parseFail)\nimport Data.OpenApi (ToSchema)\nimport qualified Data.Text as T\nimport EulerHS.Prelude hiding (many, try, (<|>))\nimport Kernel.Utils.Error.Throwing (fromEitherM')\nimport Kernel.Utils.Example\nimport Kernel.Utils.GenericPretty (PrettyShow)\nimport Text.Parsec\nimport Text.Parsec.Language (emptyDef)\nimport qualified Text.Parsec.Token as P\n\n-- Regular expression: ^[-+]?([1-8]?\\d(\\.\\d+)?|90(\\.0+)?),\\s*[-+]?(180(\\.0+)?|((1[0-7]\\d)|([1-9]?\\d))(\\.\\d+)?)$\n\ndata Gps = Gps\n  { lat :: Double,\n    lon :: Double\n  }\n  deriving (Generic, Show, ToSchema, PrettyShow, Eq)\n\ninstance Example Gps where\n  example =\n    Gps\n      { lat = 20.5937,\n        lon = 78.9629\n      }\n\ninstance FromJSON Gps where\n  parseJSON =\n    withText \"Gps\" $\n      T.unpack\n        >>> parse parseGps \"\"\n        >>> fromEitherM' (parseFail . show)\n\ninstance ToJSON Gps where\n  toJSON (Gps lat lon) = String $ show lat <> \", \" <> show lon\n\nparseGps :: Parser Gps\nparseGps =\n  Gps\n    <$> (double >>= validate ((<= 90.0) . abs))\n    <* char ','\n    <* spaces\n    <*> (double >>= validate ((<= 180.0) . abs))\n    <* eof\n\ntype Parser = Parsec String ()\n\nlexer :: P.GenTokenParser String u Identity\nlexer = P.makeTokenParser emptyDef\n\ndouble :: Parser Double\ndouble = P.float lexer\n\nvalidate :: Show a => (a -> Bool) -> a -> Parser a\nvalidate p a = if p a then pure a else unexpected (show a)\n",
      "hash": "13999f38f84341379bb531169da0126aa9d1bf32dba28a182ef419d0b8f52e2f",
      "size": 2177
    },
    "/lib/mobility-core/src/Kernel/Types/Beckn/IndianState.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n{-# LANGUAGE DerivingVia #-}\n{-# LANGUAGE StandaloneDeriving #-}\n{-# LANGUAGE TemplateHaskell #-}\n\nmodule Kernel.Types.Beckn.IndianState (IndianState (..)) where\n\nimport Data.Aeson\nimport Data.Aeson.Types\nimport Data.OpenApi hiding (Example)\nimport EulerHS.Prelude\nimport Kernel.Beam.Lib.UtilsTH (mkBeamInstancesForEnumAndList)\nimport Kernel.Storage.Esqueleto\nimport Kernel.Utils.GenericPretty\n\nderivePersistField \"IndianState\"\n\ndata IndianState\n  = AndhraPradesh\n  | ArunachalPradesh\n  | Assam\n  | Bihar\n  | Chhattisgarh\n  | Goa\n  | Gujarat\n  | Haryana\n  | HimachalPradesh\n  | Jharkhand\n  | Karnataka\n  | Kerala\n  | MadhyaPradesh\n  | Maharashtra\n  | Manipur\n  | Meghalaya\n  | Mizoram\n  | Nagaland\n  | Odisha\n  | Punjab\n  | Rajasthan\n  | Sikkim\n  | TamilNadu\n  | Telangana\n  | Tripura\n  | UttarPradesh\n  | Uttarakhand\n  | WestBengal\n  | AndamanAndNicobarIslands\n  | ChandigarhUT\n  | DadraAndNagarHaveli\n  | DamanAndDiu\n  | NationalCapitalTerritory\n  | Lakshadweep\n  | Puducherry\n  | Minnesota\n  | AnyState\n  deriving (Eq, Generic, Show, Read, ToSchema, Ord)\n  deriving (PrettyShow) via Showable IndianState\n\n$(mkBeamInstancesForEnumAndList ''IndianState)\n\ninstance FromJSON IndianState where\n  parseJSON (String \"AndhraPradesh\") = pure AndhraPradesh\n  parseJSON (String \"ArunachalPradesh\") = pure ArunachalPradesh\n  parseJSON (String \"Assam\") = pure Assam\n  parseJSON (String \"Bihar\") = pure Bihar\n  parseJSON (String \"Chhattisgarh\") = pure Chhattisgarh\n  parseJSON (String \"Goa\") = pure Goa\n  parseJSON (String \"Gujarat\") = pure Gujarat\n  parseJSON (String \"Haryana\") = pure Haryana\n  parseJSON (String \"HimachalPradesh\") = pure HimachalPradesh\n  parseJSON (String \"Jharkhand\") = pure Jharkhand\n  parseJSON (String \"Karnataka\") = pure Karnataka\n  parseJSON (String \"Kerala\") = pure Kerala\n  parseJSON (String \"MadhyaPradesh\") = pure MadhyaPradesh\n  parseJSON (String \"Maharashtra\") = pure Maharashtra\n  parseJSON (String \"Manipur\") = pure Manipur\n  parseJSON (String \"Meghalaya\") = pure Meghalaya\n  parseJSON (String \"Mizoram\") = pure Mizoram\n  parseJSON (String \"Nagaland\") = pure Nagaland\n  parseJSON (String \"Odisha\") = pure Odisha\n  parseJSON (String \"Punjab\") = pure Punjab\n  parseJSON (String \"Rajasthan\") = pure Rajasthan\n  parseJSON (String \"Sikkim\") = pure Sikkim\n  parseJSON (String \"TamilNadu\") = pure TamilNadu\n  parseJSON (String \"Telangana\") = pure Telangana\n  parseJSON (String \"Tripura\") = pure Tripura\n  parseJSON (String \"UttarPradesh\") = pure UttarPradesh\n  parseJSON (String \"Uttarakhand\") = pure Uttarakhand\n  parseJSON (String \"WestBengal\") = pure WestBengal\n  parseJSON (String \"AndamanAndNicobarIslands\") = pure AndamanAndNicobarIslands\n  parseJSON (String \"ChandigarhUT\") = pure ChandigarhUT\n  parseJSON (String \"DadraAndNagarHaveli\") = pure DadraAndNagarHaveli\n  parseJSON (String \"DamanAndDiu\") = pure DamanAndDiu\n  parseJSON (String \"NationalCapitalTerritory\") = pure NationalCapitalTerritory\n  parseJSON (String \"Lakshadweep\") = pure Lakshadweep\n  parseJSON (String \"Puducherry\") = pure Puducherry\n  parseJSON (String \"Minnesota\") = pure Minnesota\n  parseJSON (String \"*\") = pure AnyState\n  parseJSON (String _) = parseFail \"Invalid IndianState\"\n  parseJSON e = typeMismatch \"String\" e\n\ninstance ToJSON IndianState where\n  toJSON ArunachalPradesh = String \"ArunachalPradesh\"\n  toJSON AndhraPradesh = String \"AndhraPradesh\"\n  toJSON Assam = String \"Assam\"\n  toJSON Bihar = String \"Bihar\"\n  toJSON Chhattisgarh = String \"Chhattisgarh\"\n  toJSON Goa = String \"Goa\"\n  toJSON Gujarat = String \"Gujarat\"\n  toJSON Haryana = String \"Haryana\"\n  toJSON HimachalPradesh = String \"HimachalPradesh\"\n  toJSON Jharkhand = String \"Jharkhand\"\n  toJSON Karnataka = String \"Karnataka\"\n  toJSON Kerala = String \"Kerala\"\n  toJSON MadhyaPradesh = String \"MadhyaPradesh\"\n  toJSON Maharashtra = String \"Maharashtra\"\n  toJSON Manipur = String \"Manipur\"\n  toJSON Meghalaya = String \"Meghalaya\"\n  toJSON Mizoram = String \"Mizoram\"\n  toJSON Nagaland = String \"Nagaland\"\n  toJSON Odisha = String \"Odisha\"\n  toJSON Punjab = String \"Punjab\"\n  toJSON Rajasthan = String \"Rajasthan\"\n  toJSON Sikkim = String \"Sikkim\"\n  toJSON TamilNadu = String \"TamilNadu\"\n  toJSON Telangana = String \"Telangana\"\n  toJSON Tripura = String \"Tripura\"\n  toJSON UttarPradesh = String \"UttarPradesh\"\n  toJSON Uttarakhand = String \"Uttarakhand\"\n  toJSON WestBengal = String \"WestBengal\"\n  toJSON AndamanAndNicobarIslands = String \"AndamanAndNicobarIslands\"\n  toJSON ChandigarhUT = String \"ChandigarhUT\"\n  toJSON DadraAndNagarHaveli = String \"DadraAndNagarHaveli\"\n  toJSON DamanAndDiu = String \"DamanAndDiu\"\n  toJSON NationalCapitalTerritory = String \"NationalCapitalTerritory\"\n  toJSON Lakshadweep = String \"Lakshadweep\"\n  toJSON Puducherry = String \"Puducherry\"\n  toJSON Minnesota = String \"Minnesota\"\n  toJSON AnyState = String \"*\"\n",
      "hash": "b43cb2f142a1cd381a6c55b66efd046657225c8c8b664c5fe93050f77e5bd8e5",
      "size": 5501
    },
    "/lib/mobility-core/src/Kernel/Types/Beckn/ReqTypes.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n\nmodule Kernel.Types.Beckn.ReqTypes where\n\nimport qualified Control.Lens as L\nimport Data.Aeson\nimport Data.OpenApi\nimport Data.Typeable\nimport EulerHS.Prelude hiding (fromList, (.~))\nimport GHC.Exts (IsList (fromList))\nimport Kernel.Types.Beckn.Context (Context)\nimport Kernel.Types.Beckn.Error (Error)\nimport Kernel.Utils.GenericPretty\n\ndata BecknReq a = BecknReq\n  { context :: Context,\n    message :: a\n  }\n  deriving (Generic, Show, FromJSON, ToJSON, PrettyShow)\n\ninstance ToSchema a => ToSchema (BecknReq a)\n\ndata BecknCallbackReq a = BecknCallbackReq\n  { context :: Context,\n    contents :: Either Error a\n  }\n  deriving (Generic, Show, PrettyShow)\n\ninstance (ToSchema a) => ToSchema (BecknCallbackReq a) where\n  declareNamedSchema _ = do\n    context <- declareSchemaRef (Proxy :: Proxy Context)\n    err <- declareSchemaRef (Proxy :: Proxy Error)\n    let messageTypeName = show $ typeRep (Proxy :: Proxy a)\n    message <- declareSchemaRef (Proxy :: Proxy a)\n    let errVariant =\n          Inline $\n            mempty\n              & type_ L.?~ OpenApiObject\n              & properties L..~ fromList [(\"context\", context), (\"error\", err)]\n              & required L..~ [\"context\", \"error\"]\n        messageVariant =\n          Inline $\n            mempty\n              & type_ L.?~ OpenApiObject\n              & properties L..~ fromList [(\"context\", context), (\"message\", message)]\n              & required L..~ [\"context\", \"message\"]\n    return $\n      NamedSchema (Just $ \"BecknCallbackReq_\" <> messageTypeName) $\n        mempty\n          & type_ L.?~ OpenApiObject\n          & oneOf L.?~ [messageVariant, errVariant]\n\ninstance ToJSON a => ToJSON (BecknCallbackReq a) where\n  toJSON (BecknCallbackReq context contents) = object $ contextField : errorOrMessage\n    where\n      contextField = \"context\" .= context\n      errorOrMessage = case contents of\n        Left err -> [\"error\" .= err]\n        Right message -> [\"message\" .= message]\n\ninstance FromJSON a => FromJSON (BecknCallbackReq a) where\n  parseJSON = withObject \"BecknCallbackReq\" $ \\o ->\n    BecknCallbackReq\n      <$> o .: \"context\"\n      <*> (Left <$> o .: \"error\" <|> Right <$> o .: \"message\")\n",
      "hash": "e8c8c952128f96e50ccdd5de7edc6a2372945eadf4ecf25f55bfcc9b519b579c",
      "size": 2857
    },
    "/lib/mobility-core/src/Kernel/Types/BecknRequest.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n{-# LANGUAGE UndecidableInstances #-}\n\nmodule Kernel.Types.BecknRequest where\n\nimport Data.Time (UTCTime)\nimport EulerHS.Prelude hiding (id)\nimport Kernel.Types.Id (Id)\n\ndata BecknRequest = BecknRequest\n  { id :: Id BecknRequest,\n    becknRequest :: Text,\n    signatureHeader :: Text,\n    timeStamp :: UTCTime\n  }\n  deriving (Generic)\n",
      "hash": "a011dc1822b516ca17805fc40d8b27b665d5fbd1114f1670e68ae527a4e40e11",
      "size": 1028
    },
    "/lib/mobility-core/src/Kernel/Types/Cac.hs": {
      "type": "content",
      "content": "module Kernel.Types.Cac where\n\nimport Data.Aeson as DA\nimport qualified Data.Aeson.Key as DAK\nimport Data.Maybe\nimport qualified Data.Text as Text\nimport qualified EulerHS.Language as L\nimport qualified EulerHS.Types as T\nimport Kernel.Prelude\nimport qualified Kernel.Storage.Hedis as Hedis\nimport Kernel.Tools.Metrics.CoreMetrics.Types\nimport Kernel.Types.App\nimport Kernel.Types.Error\nimport Kernel.Utils.Common (CacheFlow, EsqDBFlow, logDebug, logError)\nimport Kernel.Utils.Error.Throwing (throwError)\nimport System.Random\n\nnewtype CacKeyValue = CacKeyValue\n  { getCacKeyValue :: Text\n  }\n  deriving (Show, Eq, Generic, ToJSON, FromJSON)\n\nfromJSONHelper :: (MonadFlow m, FromJSON a) => Value -> Text -> m (Maybe a)\nfromJSONHelper k tn = case fromJSON k of\n  Success a -> pure (Just a)\n  DA.Error err -> do\n    logError $ \"Error in parsing the value for the table: \" <> tn <> \" with error: \" <> Text.pack err <> \" for config:\" <> show k\n    pure Nothing\n\ndropPrefixFromConfig :: Text.Text -> Key -> Key\ndropPrefixFromConfig key config = maybe config DAK.fromText $ Text.stripPrefix key (DAK.toText config)\n\ninitializeCACThroughConfig :: (CacheFlow m r, EsqDBFlow m r) => (String -> Int -> String -> String -> IO Int) -> Text -> String -> String -> Int -> m ()\ninitializeCACThroughConfig func config tenant' host interval = do\n  status <- liftIO $ func tenant' interval (Text.unpack config) host\n  logDebug $ \"status of creating the client for tenant backup \" <> Text.pack tenant' <> \" is \" <> Text.pack (show status)\n  if status == 0\n    then pure ()\n    else do\n      incrementSystemConfigsFailedCounter \"cac_client_creation_failure\"\n      throwError $ InternalError $ \"error in creating the client for tenant\" <> Text.pack tenant'\n\ndata CACData = CACData\n  { id :: Text,\n    idType :: Text,\n    context :: Text,\n    configName :: Text,\n    variantIds :: Text\n  }\n  deriving (Show, Eq, Generic, ToJSON, FromJSON)\n\ngetToss :: (CacheFlow m r) => Maybe Text -> m Int\ngetToss srId = do\n  gen <- newStdGen\n  expTime <- fromIntegral <$> asks (.cacConfig.cacExpTime)\n  let (toss', _) = randomR (1, 100) gen :: (Int, StdGen)\n  maybe\n    (pure toss')\n    ( \\srId' -> do\n        Hedis.withCrossAppRedis (Hedis.safeGet (makeCACConfigKey srId')) >>= \\case\n          Just (a :: Int) -> pure a\n          Nothing -> do\n            _ <- Hedis.withCrossAppRedis $ Hedis.setExp (makeCACConfigKey srId') toss' expTime\n            pure toss'\n    )\n    srId\n\nmakeCACConfigKey :: Text -> Text\nmakeCACConfigKey id = \"CAC:STKID\" <> id\n\ngetConfigFromMemoryCommon :: (CacheFlow m r, EsqDBFlow m r, T.OptionEntity b a) => b -> Bool -> (String -> IO Bool) -> m (Maybe a)\ngetConfigFromMemoryCommon configCondition isExpired expmt = do\n  config <- L.getOption configCondition\n  tenant' <- asks (.cacConfig.tenant)\n  isExperiment <- liftIO $ expmt tenant'\n  if isExpired || isExperiment\n    then pure Nothing\n    else pure config\n",
      "hash": "7746b2ab56d174e41443ab33684d398cd5e95c155d5c1729789223edb4f66c86",
      "size": 2902
    },
    "/lib/mobility-core/src/Kernel/Types/Cache.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n{-# LANGUAGE AllowAmbiguousTypes #-}\n\nmodule Kernel.Types.Cache where\n\nimport Kernel.Prelude\nimport Kernel.Types.Time (Seconds)\n\nclass Cache a m where\n  type CacheKey a\n  getKey :: CacheKey a -> m (Maybe a)\n  setKey :: CacheKey a -> a -> m ()\n  delKey :: CacheKey a -> m ()\n\nclass Cache a m => CacheEx a m where\n  setKeyEx :: Seconds -> CacheKey a -> a -> m ()\n\ncaching ::\n  (CacheEx a m, Monad m) =>\n  (a -> Seconds) ->\n  (CacheKey a -> m (Maybe a)) ->\n  CacheKey a ->\n  m (Maybe a)\ncaching getTtl getData key =\n  getKey key >>= \\case\n    Nothing -> do\n      mbRes <- getData key\n      whenJust mbRes \\res -> setKeyEx (getTtl res) key res\n      pure mbRes\n    res -> pure res\n",
      "hash": "a2760b2c19943f0b25b6767defc50714972218ef2b41fe3aa83a93ea66b3eccc",
      "size": 1370
    },
    "/lib/mobility-core/src/Kernel/Types/CacheFlow.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\nmodule Kernel.Types.CacheFlow where\n\nimport Kernel.Prelude\nimport Kernel.Storage.Hedis (HedisFlow)\nimport Kernel.Types.Common\nimport Kernel.Utils.Dhall\n\nnewtype CacheConfig = CacheConfig\n  { configsExpTime :: Seconds\n  }\n  deriving (Generic, FromDhall)\n\ndata CacConfig = CacConfig\n  { host :: String,\n    interval :: Natural,\n    tenant :: String,\n    retryConnection :: Bool,\n    cacExpTime :: Seconds,\n    enablePolling :: Bool,\n    enableCac :: Bool\n  }\n  deriving (Generic, FromDhall)\n\ndata SuperPositionConfig = SuperPositionConfig\n  { host :: String,\n    interval :: Natural,\n    tenants :: [String],\n    retryConnection :: Bool,\n    enablePolling :: Bool,\n    enableSuperPosition :: Bool\n  }\n  deriving (Generic, FromDhall)\n\ntype HasCacheConfig r = HasField \"cacheConfig\" r CacheConfig\n\ntype HasCacConfig r = HasField \"cacConfig\" r CacConfig\n\ntype CacheFlow m r = (HasCacheConfig r, HedisFlow m r, HasCacConfig r)\n",
      "hash": "c033da4059384dd559d31a509ac503c9cdd2051088d25ba031af85b45d89f882",
      "size": 1614
    },
    "/lib/mobility-core/src/Kernel/Types/Centesimal.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n{-# LANGUAGE DerivingStrategies #-}\n{-# LANGUAGE GeneralizedNewtypeDeriving #-}\n\nmodule Kernel.Types.Centesimal (Centesimal (..), toCentesimal) where\n\nimport Control.Lens.Operators\nimport Data.Aeson\nimport Data.Fixed (Centi, Fixed (MkFixed))\nimport Data.OpenApi\nimport Database.Beam\nimport qualified Database.Beam as B\nimport Database.Beam.Backend\nimport Database.Beam.Postgres\nimport Database.PostgreSQL.Simple.FromField (FromField, fromField)\nimport Kernel.Prelude\nimport Kernel.Storage.Esqueleto\nimport Kernel.Types.FromField\nimport Kernel.Utils.GenericPretty\n\nnewtype Centesimal = Centesimal {getCenti :: Centi}\n  deriving (Eq, Ord, Generic, Enum)\n  deriving newtype (Num, Real, RealFrac, ToJSON, Read, Show, PersistField, PersistFieldSql)\n  deriving anyclass (PrettyShow)\n\ninstance FromJSON Centesimal where\n  parseJSON = withScientific \"Centesimal\" (pure . realToFrac)\n\ninstance Fractional Centesimal where\n  (Centesimal a) / (Centesimal b) = Centesimal $ a / b\n  recip (Centesimal a) = Centesimal $ recip a\n  fromRational rat = Centesimal . fromRational $ roundToPowerOfTen (-2) rat\n\nmaxPrecision :: Int\nmaxPrecision = 30\n\nmessage :: Text\nmessage =\n  \"Maximum allowed precision (total number of digits) is \"\n    <> show maxPrecision\n\ntoCentesimal :: Int -> Centesimal\ntoCentesimal = Centesimal . MkFixed . toInteger\n\ninstance ToSchema Centesimal where\n  declareNamedSchema _ = do\n    aSchema <- declareSchema (Proxy :: Proxy Centi)\n    return $\n      NamedSchema (Just \"Centesimal\") $\n        aSchema\n          & description\n            ?~ \"Monetary amount in a string representation \\\n               \\with an optional leading \\\"-\\\" for negative numbers. \\\n               \\Integer and fractional parts are separated with a dot.\"\n              <> message\n              <> \" String format is used to prevent loss of precision.\"\n          & format ?~ \"[-]?(?:0|[1-9][0-9]*)(?:\\\\.[0-9]+)?\"\n\ninstance BeamSqlBackend be => B.HasSqlEqualityCheck be Centesimal\n\ninstance FromBackendRow Postgres Centesimal\n\ninstance FromField Centesimal where\n  fromField = fromFieldEnum\n\ninstance HasSqlValueSyntax be Centi => HasSqlValueSyntax be Centesimal where\n  sqlValueSyntax = sqlValueSyntax . getCenti\n",
      "hash": "b5ea5ab3cd5fd345b012e34c9b7c978d81444a49cd5eb47e96346323db0e427d",
      "size": 2886
    },
    "/lib/mobility-core/src/Kernel/Types/Common.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n{-# LANGUAGE DerivingVia #-}\n{-# LANGUAGE DuplicateRecordFields #-}\n{-# OPTIONS_GHC -Wno-orphans #-}\n{-# OPTIONS_GHC -Wno-unrecognised-pragmas #-}\n\n{-# HLINT ignore \"Use newtype instead of data\" #-}\n\nmodule Kernel.Types.Common\n  ( module Kernel.Types.Common,\n    module Common,\n    HasField,\n  )\nwhere\n\nimport Data.Aeson\nimport Data.ByteString.Internal (ByteString)\nimport Data.Fixed (Centi, Fixed (MkFixed))\nimport Data.Generics.Labels ()\nimport qualified Data.HashMap.Strict as HM\nimport Data.OpenApi hiding (value)\nimport Data.Text as T\nimport qualified Data.Vector as V\nimport Database.Beam\nimport qualified Database.Beam as B\nimport Database.Beam.Backend\nimport qualified Database.Beam.Backend.SQL.AST as B\nimport Database.Beam.Postgres\nimport Database.Beam.Postgres.Syntax\nimport qualified Database.Beam.Query as BQ\nimport Database.PostgreSQL.Simple.FromField (FromField, fromField)\nimport GHC.Records.Extra (HasField)\nimport Kernel.External.Encryption\nimport Kernel.External.Encryption as Common (EncFlow)\nimport Kernel.Prelude as KP\nimport Kernel.Storage.Esqueleto.Config as Common (EsqDBFlow)\nimport Kernel.Storage.Esqueleto.Types\nimport Kernel.Types.App as Common\nimport Kernel.Types.Centesimal as Common\nimport Kernel.Types.Distance as Common\nimport Kernel.Types.Forkable as Common\nimport Kernel.Types.FromField as Common\nimport Kernel.Types.GuidLike as Common\nimport Kernel.Types.Logging as Common\nimport Kernel.Types.MonadGuid as Common\nimport Kernel.Types.Price as Common\nimport Kernel.Types.SharedRedisKeys as Common\nimport Kernel.Types.Time as Common\nimport Kernel.Utils.Dhall (FromDhall)\n\nnewtype IdObject = IdObject\n  { id :: Text\n  }\n  deriving stock (Generic, Show)\n  deriving anyclass (ToJSON, FromJSON, ToSchema)\n\ndata Tables = Tables\n  { disableForKV :: [Text],\n    kvTablesTtl :: HM.HashMap Text Integer,\n    useCAC :: [Text],\n    useCACForFrontend :: Bool,\n    readFromMasterDb :: [Text],\n    defaultShardMod :: Int,\n    tableShardModRange :: HM.HashMap Text (Int, Int),\n    tableRedisKeyPrefix :: HM.HashMap Text Text,\n    allTablesDisabled :: Maybe Bool\n  }\n  deriving (Generic, Show, ToJSON, FromJSON, FromDhall)\n\ndefaultTableData :: Tables\ndefaultTableData =\n  Tables\n    { disableForKV = [],\n      kvTablesTtl = HM.empty,\n      useCAC = [],\n      useCACForFrontend = False,\n      readFromMasterDb = [],\n      defaultShardMod = 128,\n      tableShardModRange = HM.empty,\n      tableRedisKeyPrefix = HM.empty,\n      allTablesDisabled = Just True\n    }\n\ndata KafkaProperties = KafkaProperties\n  { propName :: Text,\n    propValue :: Text\n  }\n  deriving (Generic, Show, ToJSON, FromJSON, FromDhall)\n\ndata KvConfigLastUpdatedTime = KvConfigLastUpdatedTime UTCTime\n  deriving (Generic, Show, ToJSON, FromJSON, FromDhall)\n\ndata KvConfigUpdateFrequency = KvConfigUpdateFrequency Int\n  deriving (Generic, Show, ToJSON, FromJSON, FromDhall)\n\ninstance HasSqlValueSyntax be String => HasSqlValueSyntax be Tables where\n  sqlValueSyntax = autoSqlValueSyntax\n\ninstance BeamSqlBackend be => B.HasSqlEqualityCheck be Tables\n\ninstance FromBackendRow Postgres Tables\n\ninstance FromField Tables where\n  fromField = fromFieldJSON\n\ninstance FromField Centi where\n  fromField = fromFieldEnum\n\ninstance HasSqlValueSyntax be String => HasSqlValueSyntax be Minutes where\n  sqlValueSyntax = autoSqlValueSyntax\n\ninstance BeamSqlBackend be => B.HasSqlEqualityCheck be Minutes\n\ninstance FromBackendRow Postgres Minutes\n\n-- FIXME isn't it the same as deriving newtype?\ninstance FromField Minutes where\n  fromField f mbValue = Minutes <$> fromFieldDefault f mbValue\n\nnewtype CentiDouble = CentiDouble Double\n\n-- Conversion functions\ncentiToDouble :: Centi -> CentiDouble\ncentiToDouble (MkFixed n) = CentiDouble (fromIntegral n / 100)\n\ndoubleToCenti :: CentiDouble -> Centi\ndoubleToCenti (CentiDouble d) = MkFixed (round (d * 100))\n\n-- Define HasSqlValueSyntax instances\ninstance HasSqlValueSyntax be Double => HasSqlValueSyntax be CentiDouble where\n  sqlValueSyntax (CentiDouble d) = sqlValueSyntax d\n\ninstance HasSqlValueSyntax be Double => HasSqlValueSyntax be Centi where\n  sqlValueSyntax = sqlValueSyntax . centiToDouble\n\ninstance HasSqlValueSyntax B.Value (V.Vector Text) where\n  sqlValueSyntax = autoSqlValueSyntax\n\ninstance (HasSqlValueSyntax be (V.Vector Text)) => HasSqlValueSyntax be [Text] where\n  sqlValueSyntax x = sqlValueSyntax (V.fromList x)\n\ninstance BeamSqlBackend be => B.HasSqlEqualityCheck be [Text]\n\ninstance FromBackendRow Postgres [Text]\n\ninstance FromField [Text] where\n  fromField f mbValue = V.toList <$> fromField f mbValue\n\ninstance BeamSqlBackend be => B.HasSqlEqualityCheck be Centi\n\ninstance FromBackendRow Postgres Centi\n\ninstance HasSqlValueSyntax be Int => HasSqlValueSyntax be Seconds where\n  sqlValueSyntax = sqlValueSyntax . getSeconds\n\ninstance BeamSqlBackend be => B.HasSqlEqualityCheck be Seconds\n\ninstance FromBackendRow Postgres Seconds\n\ninstance FromField Seconds where\n  fromField f mbValue = Seconds <$> fromFieldDefault f mbValue\n\ninstance FromField ByteString => FromField DbHash where\n  fromField f mb = do\n    val <- fromField f mb\n    pure $ DbHash val\n\ninstance HasSqlValueSyntax be ByteString => HasSqlValueSyntax be DbHash where\n  sqlValueSyntax = sqlValueSyntax . unDbHash\n\ninstance BeamSqlBackend be => B.HasSqlEqualityCheck be DbHash\n\ninstance FromBackendRow Postgres DbHash\n\ninstance (HasSqlValueSyntax be (V.Vector Int)) => HasSqlValueSyntax be [Int] where\n  sqlValueSyntax x = sqlValueSyntax (V.fromList x)\n\ninstance BeamSqlBackend be => B.HasSqlEqualityCheck be [Int]\n\ninstance FromBackendRow Postgres [Int]\n\ninstance FromField [Int] where\n  fromField f mbValue = V.toList <$> fromField f mbValue\n\ngetPoint :: (Double, Double) -> BQ.QGenExpr context Postgres s Point\ngetPoint (lat, lon) = BQ.QExpr (\\_ -> PgExpressionSyntax (emit $ \"ST_SetSRID (ST_Point (\" <> KP.show lon <> \" , \" <> KP.show lat <> \"),4326)\"))\n\ncontainsPoint'' :: (Double, Double) -> BQ.QGenExpr context Postgres s BQ.SqlBool\ncontainsPoint'' (lon, lat) = B.sqlBool_ (BQ.QExpr (\\_ -> PgExpressionSyntax (emit $ \"st_contains (\" <> KP.show lon <> \" , \" <> KP.show lat <> \")\")))\n\ncontainsPoint' :: (Double, Double) -> BQ.QGenExpr context Postgres s BQ.SqlBool\ncontainsPoint' (lon, lat) = B.sqlBool_ (BQ.QExpr (\\_ -> PgExpressionSyntax (emit $ \"st_contains (geom, ST_GeomFromText('POINT (\" <> KP.show lon <> \" \" <> KP.show lat <> \")'))\")))\n\nbuildRadiusWithin' :: Point -> (Double, Double) -> Int -> BQ.QGenExpr context Postgres s BQ.SqlBool\nbuildRadiusWithin' pnt (lat, lon) rad =\n  BQ.QExpr (\\_ -> PgExpressionSyntax (emit $ \"ST_DWithin(\" <> KP.show pnt <> \" , \" <> getPoint' <> \" , \" <> KP.show rad <> \")\"))\n  where\n    getPoint' = \"(SRID=4326;POINT(\" <> KP.show lon <> \" \" <> KP.show lat <> \"))\"\n\nbuildRadiusWithin'' :: (Double, Double) -> Int -> BQ.QGenExpr context Postgres s BQ.SqlBool\nbuildRadiusWithin'' (lat, lon) rad =\n  BQ.QExpr (\\_ -> PgExpressionSyntax (emit $ \"ST_DWithin(point\" <> \" , \" <> getPoint' <> \" , \" <> KP.show rad <> \")\"))\n  where\n    getPoint' = \"(ST_SetSRID (ST_Point (\" <> KP.show lon <> \" , \" <> KP.show lat <> \"),4326))\"\n\n(<->.) :: Point -> Point -> BQ.QGenExpr context Postgres s Double\n(<->.) p1 p2 = BQ.QExpr (\\_ -> PgExpressionSyntax (emit $ KP.show p1 <> \" <-> \" <> KP.show p2))\n",
      "hash": "1657e5ec01cdfd135db3af202ca9dd89a92188d5797570e1703da49e95c8114a",
      "size": 7926
    },
    "/lib/mobility-core/src/Kernel/Types/Confidence.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n{-# LANGUAGE DerivingVia #-}\n{-# LANGUAGE GeneralizedNewtypeDeriving #-}\n{-# LANGUAGE TemplateHaskell #-}\n\nmodule Kernel.Types.Confidence where\n\nimport Data.Aeson\nimport Kernel.Beam.Lib.UtilsTH (mkBeamInstancesForEnumAndList)\nimport Kernel.Prelude\nimport Kernel.Utils.TH (mkHttpInstancesForEnum)\n\ndata Confidence = Sure | Unsure | Neutral deriving (Eq, Ord, Show, Read, Generic, ToJSON, FromJSON, ToSchema, ToParamSchema)\n\n$(mkBeamInstancesForEnumAndList ''Confidence)\n\n$(mkHttpInstancesForEnum ''Confidence)\n",
      "hash": "555f625d6efa4e6f68049d95d070df15a05b0d2a5d1c87b1cca698d098ce03fe",
      "size": 1202
    },
    "/lib/mobility-core/src/Kernel/Types/Credentials.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n\nmodule Kernel.Types.Credentials where\n\nimport Kernel.Prelude\nimport Kernel.Types.Base64\nimport Kernel.Types.Beckn.Domain\nimport Kernel.Types.Registry.Subscriber (SubscriberType)\nimport Kernel.Utils.Dhall\n\ntype PrivateKey = Base64\n\ntype PublicKey = Base64\n\ndata Credential = Credential\n  { shortOrgId :: Text,\n    uniqueKeyId :: Text,\n    signPubKey :: PublicKey,\n    url :: BaseUrl,\n    domain :: Domain,\n    _type :: SubscriberType\n  }\n  deriving (Generic, FromDhall)\n",
      "hash": "4ae45430098ff450f714acddafc94b795608c59612047e35bb144f16acdfbc9a",
      "size": 1163
    },
    "/lib/mobility-core/src/Kernel/Types/Distance.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n{-# LANGUAGE DerivingVia #-}\n{-# LANGUAGE GeneralizedNewtypeDeriving #-}\n{-# LANGUAGE StandaloneDeriving #-}\n{-# LANGUAGE TemplateHaskell #-}\n{-# OPTIONS_GHC -Wwarn=identities #-}\n\nmodule Kernel.Types.Distance where\n\nimport Data.Aeson\nimport Data.OpenApi hiding (value)\nimport qualified Data.Text as T\nimport Database.Beam\nimport qualified Database.Beam as B\nimport Database.Beam.Backend\nimport Database.Beam.Postgres\nimport Database.Persist.Class\nimport Database.Persist.Sql\nimport Database.PostgreSQL.Simple.FromField (FromField, fromField)\nimport GHC.Float (double2Int, int2Double)\nimport GHC.Records.Extra (HasField)\nimport Kernel.Prelude as KP\nimport qualified Kernel.Types.Beckn.DecimalValue as DecimalValue\nimport Kernel.Types.Centesimal\nimport Kernel.Types.FromField\nimport Kernel.Utils.Dhall (FromDhall)\nimport Kernel.Utils.GenericPretty\nimport Kernel.Utils.TH (mkHttpInstancesForEnum)\nimport Sequelize.SQLObject (SQLObject (..), ToSQLObject (convertToSQLObject))\nimport Servant\nimport Text.Show (Show (..))\n\nnewtype HighPrecDistance = HighPrecDistance\n  { getHighPrecDistance :: Rational\n  }\n  deriving stock (Generic)\n  deriving newtype (Num, FromDhall, Real, Fractional, RealFrac, Ord, Eq, Enum, PrettyShow, PersistField, PersistFieldSql)\n\ninstance Show HighPrecDistance where\n  show = Text.Show.show @Double . realToFrac\n\ninstance Read HighPrecDistance where\n  readsPrec d s = do\n    (dobuleVal, s1) :: (Double, String) <- readsPrec d s\n    return (realToFrac dobuleVal, s1)\n\ninstance ToJSON HighPrecDistance where\n  toJSON = toJSON @Double . realToFrac\n\ninstance FromJSON HighPrecDistance where\n  parseJSON = fmap realToFrac . parseJSON @Double\n\ninstance ToParamSchema HighPrecDistance where\n  toParamSchema _ = toParamSchema (Proxy @Double)\n\ninstance FromField HighPrecDistance where\n  fromField f mbValue = HighPrecDistance <$> fromFieldDefault f mbValue\n\ninstance HasSqlValueSyntax be Rational => HasSqlValueSyntax be HighPrecDistance where\n  sqlValueSyntax = sqlValueSyntax . getHighPrecDistance\n\ninstance BeamSqlBackend be => B.HasSqlEqualityCheck be HighPrecDistance\n\ninstance FromBackendRow Postgres HighPrecDistance\n\ninstance ToSchema HighPrecDistance where\n  declareNamedSchema _ = do\n    aSchema <- declareSchema (Proxy :: Proxy Double)\n    return $ NamedSchema (Just \"HighPrecDistance\") aSchema\n\n$(mkHttpInstancesForEnum ''HighPrecDistance)\n\ntoHighPrecDistance :: Real a => a -> HighPrecDistance\ntoHighPrecDistance = HighPrecDistance . toRational\n\ndata DistanceUnit = Meter | Mile | Yard | Kilometer\n  deriving stock (Generic, Show, Read, Eq, Ord)\n  deriving anyclass (ToJSON, FromJSON, ToSchema, ToParamSchema)\n  deriving (PrettyShow) via Showable DistanceUnit\n\n$(mkHttpInstancesForEnum ''DistanceUnit)\n\n-- cycle imports\n\n-- $(mkBeamInstancesForEnum ''DistanceUnit)\n\ninstance FromField DistanceUnit where\n  fromField = fromFieldEnum\n\ninstance HasSqlValueSyntax be String => HasSqlValueSyntax be DistanceUnit where\n  sqlValueSyntax = autoSqlValueSyntax\n\ninstance BeamSqlBackend be => B.HasSqlEqualityCheck be DistanceUnit\n\ninstance FromBackendRow Postgres DistanceUnit\n\nconvertMetersToDistance :: DistanceUnit -> Meters -> Distance\nconvertMetersToDistance distanceUnit = convertDistance distanceUnit . metersToDistance\n  where\n    metersToDistance :: Meters -> Distance\n    metersToDistance meters =\n      Distance\n        { value = realToFrac @Meters @HighPrecDistance meters,\n          unit = Meter\n        }\n\nconvertHighPrecMetersToDistance :: DistanceUnit -> HighPrecMeters -> Distance\nconvertHighPrecMetersToDistance distanceUnit = convertDistance distanceUnit . highPrecMetersToDistance\n  where\n    highPrecMetersToDistance :: HighPrecMeters -> Distance\n    highPrecMetersToDistance highPrecMeters =\n      Distance\n        { value = realToFrac @HighPrecMeters @HighPrecDistance highPrecMeters,\n          unit = Meter\n        }\n\nconvertToMeters :: Distance -> Distance\nconvertToMeters = convertDistance Meter\n\nconvertDistance :: DistanceUnit -> Distance -> Distance\nconvertDistance unit2 (Distance v unit1) = Distance ((v * distanceConversionRate unit1) / distanceConversionRate unit2) unit2\n\ndistanceConversionRate :: DistanceUnit -> HighPrecDistance\ndistanceConversionRate = \\case\n  Meter -> 1.0\n  Mile -> 1609.34\n  Kilometer -> 1000\n  Yard -> 0.9144\n\n-- | On DB side we use single distanceUnit field for each table\n--   So we should check that unit for current Distance is correct, and convert if it is not correct\ndistanceToHighPrecDistance :: DistanceUnit -> Distance -> HighPrecDistance\ndistanceToHighPrecDistance distanceUnit distance = do\n  if distanceUnit == distance.unit\n    then distance.value\n    else (.value) . convertDistance distanceUnit $ distance\n\ndata Distance = Distance\n  { -- valueInt :: Int, -- To be deprecated\n    value :: HighPrecDistance,\n    unit :: DistanceUnit\n  }\n  deriving stock (Generic, Show)\n  deriving anyclass (ToJSON, FromJSON, ToSchema)\n  deriving (PrettyShow) via Showable Distance\n\ninstance Eq Distance where\n  a == b = withUnitChecking a b (\\_unit -> (==))\n\ninstance Ord Distance where\n  a <= b = withUnitChecking a b (\\_unit -> (<=))\n\n-- using Num instance is unsafe, because (*) operator and other functions can show different result depending on units:\n-- 1 KiloMeter * 1 KiloMeter = 1 Kilometer, 1000 Meter * 1000 Meter = 1000000 Meter\n(.+) :: Distance -> Distance -> Distance\na .+ b = withUnitChecking a b (\\unit a' b' -> Distance (a' + b') unit)\n\ninfixl 6 .+\n\n(.-) :: Distance -> Distance -> Distance\na .- b = withUnitChecking a b (\\unit a' b' -> Distance (a' + b') unit)\n\ninfixl 6 .-\n\nnegateDistance :: Distance -> Distance\nnegateDistance = modifyDistanceValue negate\n\nabsDistance :: Distance -> Distance\nabsDistance = modifyDistanceValue abs\n\nmodifyDistanceValue :: (HighPrecDistance -> HighPrecDistance) -> Distance -> Distance\nmodifyDistanceValue func d = d{value = func d.value}\n\nwithUnitChecking ::\n  Distance ->\n  Distance ->\n  (DistanceUnit -> HighPrecDistance -> HighPrecDistance -> a) ->\n  a\nwithUnitChecking d1 d2 func =\n  if d1.unit == d2.unit\n    then func d1.unit d1.value d2.value\n    else func Meter ((convertToMeters d1).value) ((convertToMeters d2).value)\n\nwithUnitCheckingList ::\n  NonEmpty Distance ->\n  (DistanceUnit -> NonEmpty HighPrecDistance -> a) ->\n  a\nwithUnitCheckingList ds@(d1 :| _) func =\n  if all (\\d -> d.unit == d1.unit) ds\n    then func d1.unit (ds <&> (.value))\n    else func Meter (ds <&> (.value) . convertToMeters)\n\nsumDistance :: NonEmpty Distance -> Distance\nsumDistance ds = withUnitCheckingList ds $ \\unit ds' -> Distance (sum ds') unit\n\n-- data DistanceAPIEntity = DistanceAPIEntity\n--   { value :: HighPrecDistance,\n--     unit :: DistanceUnit\n--   }\n--   deriving stock (Generic, Show)\n--   deriving anyclass (ToJSON, FromJSON, ToSchema)\n\n-- mkDistanceAPIEntity :: Distance -> DistanceAPIEntity\n-- mkDistanceAPIEntity Distance {..} = DistanceAPIEntity {..}\n\nnewtype Meters = Meters\n  { getMeters :: Int\n  }\n  deriving newtype (Show, Read, Num, FromDhall, FromJSON, ToJSON, Integral, Real, Ord, Eq, Enum, ToSchema, ToParamSchema, FromHttpApiData, ToHttpApiData, PrettyShow, PersistField, PersistFieldSql)\n  deriving stock (Generic)\n\nnewtype HighPrecMeters = HighPrecMeters\n  { getHighPrecMeters :: Centesimal\n  }\n  deriving newtype (Show, Read, Num, FromDhall, FromJSON, ToJSON, Fractional, Real, RealFrac, Ord, Eq, Enum, ToSchema, PrettyShow, PersistField, PersistFieldSql)\n  deriving stock (Generic)\n\nnewtype Kilometers = Kilometers\n  { getKilometers :: Int\n  }\n  deriving newtype (Show, Read, Num, FromDhall, FromJSON, ToJSON, Integral, Real, Ord, Eq, Enum, ToSchema, PrettyShow, PersistField, PersistFieldSql)\n  deriving stock (Generic)\n\nderiving newtype instance FromField Kilometers\n\ninstance HasSqlValueSyntax be Int => HasSqlValueSyntax be Kilometers where\n  sqlValueSyntax = sqlValueSyntax . getKilometers\n\ninstance BeamSqlBackend be => B.HasSqlEqualityCheck be Kilometers\n\ninstance FromBackendRow Postgres Kilometers\n\nkilometersToMeters :: Kilometers -> Meters\nkilometersToMeters (Kilometers n) = Meters $ n * 1000\n\nmetersToKilometers :: Meters -> Kilometers\nmetersToKilometers (Meters n) = Kilometers $ n `div` 1000\n\nmetersToHighPrecMeters :: Meters -> HighPrecMeters\nmetersToHighPrecMeters (Meters n) = HighPrecMeters . realToFrac $ int2Double n\n\nhighPrecMetersToMeters :: HighPrecMeters -> Meters\nhighPrecMetersToMeters (HighPrecMeters n) = Meters . double2Int $ realToFrac n\n\ninstance HasSqlValueSyntax be Centesimal => HasSqlValueSyntax be HighPrecMeters where\n  sqlValueSyntax = sqlValueSyntax . getHighPrecMeters\n\ninstance BeamSqlBackend be => B.HasSqlEqualityCheck be HighPrecMeters\n\ninstance FromBackendRow Postgres HighPrecMeters\n\ninstance FromField HighPrecMeters where\n  fromField f mbValue = HighPrecMeters <$> fromFieldDefault f mbValue\n\ninstance HasSqlValueSyntax be Int => HasSqlValueSyntax be Meters where\n  sqlValueSyntax = sqlValueSyntax . getMeters\n\ninstance BeamSqlBackend be => B.HasSqlEqualityCheck be Meters\n\ninstance FromBackendRow Postgres Meters\n\ninstance FromField Meters where\n  fromField = fromFieldJSON\n\ninstance {-# OVERLAPPING #-} ToSQLObject Meters where\n  convertToSQLObject = SQLObjectValue . KP.show . getMeters\n\nmkDistanceWithDefaultMeters :: Maybe DistanceUnit -> Maybe HighPrecDistance -> Meters -> Distance\nmkDistanceWithDefaultMeters mbUnit mbValue defDistance = case mbValue of\n  Just value ->\n    Distance\n      { value,\n        unit = fromMaybe Meter mbUnit\n      }\n  Nothing -> convertMetersToDistance (fromMaybe Meter mbUnit) defDistance\n\nmkDistanceWithDefault :: Maybe DistanceUnit -> Maybe HighPrecDistance -> HighPrecMeters -> Distance\nmkDistanceWithDefault mbUnit mbValue defDistance = case mbValue of\n  Just value ->\n    Distance\n      { value,\n        unit = fromMaybe Meter mbUnit\n      }\n  Nothing -> convertHighPrecMetersToDistance (fromMaybe Meter mbUnit) defDistance\n\ndistanceToMeters :: Distance -> Meters\ndistanceToMeters = Meters . round @HighPrecDistance @Int . (.value) . convertToMeters\n\ndistanceToHighPrecMeters :: Distance -> HighPrecMeters\ndistanceToHighPrecMeters = realToFrac @HighPrecDistance @HighPrecMeters . (.value) . convertToMeters\n\nhighPrecDistanceToText :: HighPrecDistance -> Text\nhighPrecDistanceToText = DecimalValue.valueToString . DecimalValue.DecimalValue . getHighPrecDistance\n\nunitsToText :: DistanceUnit -> Text\nunitsToText = (<> \"s\") . T.toLower . KP.show\n\ndistanceToText :: Distance -> Text\ndistanceToText distance = highPrecDistanceToText distance.value <> \" \" <> unitsToText distance.unit\n\nshowDistanceAsMeters :: Distance -> Text\nshowDistanceAsMeters = highPrecDistanceToText . (.value) . convertToMeters\n",
      "hash": "0dc7263edde6bc30ffaecf1550466880bf4247ee78cac91bf2cc0963ac376038",
      "size": 11326
    },
    "/lib/mobility-core/src/Kernel/Types/Documents.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n{-# LANGUAGE TemplateHaskell #-}\n\nmodule Kernel.Types.Documents where\n\nimport Data.Aeson\nimport Kernel.Beam.Lib.UtilsTH (mkBeamInstancesForEnumAndList)\nimport Kernel.Prelude\n\ndata VerificationStatus = PENDING | VALID | INVALID | MANUAL_VERIFICATION_REQUIRED | UNAUTHORIZED deriving (Eq, Ord, Show, Read, Generic, ToJSON, FromJSON, ToSchema)\n\n$(mkBeamInstancesForEnumAndList ''VerificationStatus)\n",
      "hash": "f650ab57c1038ab22d7356b4e0f7b5fc29058c6388309f4f48d636c904153a55",
      "size": 1089
    },
    "/lib/mobility-core/src/Kernel/Types/Error.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n{-# LANGUAGE DeriveAnyClass #-}\n{-# LANGUAGE TemplateHaskell #-}\n{-# OPTIONS_GHC -fno-warn-orphans #-}\n\nmodule Kernel.Types.Error where\n\nimport qualified Data.Aeson as DA\nimport qualified Data.Text as T\nimport EulerHS.Prelude\nimport EulerHS.Types (KVDBReply)\nimport qualified Kafka.Types as Kafka\nimport Kernel.External.SMS.MyValueFirst.Types (SubmitSmsRes, submitSmsResToText)\nimport Kernel.Types.Error.BaseError\nimport Kernel.Types.Error.BaseError.HTTPError\nimport Kernel.Types.Error.BaseError.HTTPError.FromResponse (FromResponse (fromResponse))\nimport Kernel.Utils.Servant.BaseUrl\nimport Network.HTTP.Types (Header, Status (statusCode))\nimport Network.HTTP.Types.Header (HeaderName)\nimport Servant.Client (BaseUrl, ClientError, ResponseF (responseStatusCode))\n\n-- TODO: sort out proper codes, namings and usages for Unauthorized and AccessDenied\ndata AuthError\n  = Unauthorized\n  | InvalidAuthData\n  | TokenExpired\n  | TokenIsNotVerified\n  | TokenNotFound Text\n  | InvalidToken Text\n  | AuthBlocked Text\n  | IncorrectOTP\n  | AccessDenied\n  | HitsLimitError Int\n  deriving (Eq, Show, IsBecknAPIError)\n\ninstanceExceptionWithParent 'HTTPException ''AuthError\n\ninstance IsBaseError AuthError where\n  toMessage = \\case\n    TokenNotFound tokenId -> Just $ \"Token with tokenId \\\"\" <> show tokenId <> \"\\\" not found.\"\n    InvalidToken token -> Just $ \"Invalid token: \" <> token\n    AuthBlocked reason -> Just $ \"Authentication process blocked: \" <> reason\n    AccessDenied -> Just \"You have no access to this operation.\"\n    HitsLimitError hitsLimitResetTime -> Just $ \"Hits limit reached. Try again in \" <> show hitsLimitResetTime <> \" sec.\"\n    _ -> Nothing\n\ninstance IsHTTPError AuthError where\n  toErrorCode = \\case\n    Unauthorized -> \"UNAUTHORIZED\"\n    InvalidAuthData -> \"INVALID_AUTH_DATA\"\n    TokenExpired -> \"TOKEN_EXPIRED\"\n    TokenIsNotVerified -> \"TOKEN_IS_NOT_VERIFIED\"\n    TokenNotFound _ -> \"TOKEN_NOT_FOUND\"\n    InvalidToken _ -> \"INVALID_TOKEN\"\n    AuthBlocked _ -> \"AUTH_BLOCKED\"\n    IncorrectOTP -> \"INCORRECT_OTP\"\n    AccessDenied -> \"ACCESS_DENIED\"\n    HitsLimitError _ -> \"HITS_LIMIT_EXCEED\"\n  toHttpCode = \\case\n    Unauthorized -> E401\n    InvalidToken _ -> E401\n    AccessDenied -> E403\n    TokenIsNotVerified -> E403\n    HitsLimitError _ -> E429\n    _ -> E400\n\ninstance IsAPIError AuthError\n\ndata HeaderError\n  = MissingHeader HeaderName\n  | InvalidHeader HeaderName Text\n  deriving (Eq, Show, IsBecknAPIError)\n\ninstanceExceptionWithParent 'HTTPException ''HeaderError\n\ninstance IsBaseError HeaderError where\n  toMessage = \\case\n    MissingHeader headerName -> Just $ \"Header \" +|| headerName ||+ \" is missing\"\n    InvalidHeader headerName err -> Just $ \"Header \" +|| headerName ||+ \" is invalid: \" +|| err ||+ \"\"\n\ninstance IsHTTPError HeaderError where\n  toErrorCode = \\case\n    MissingHeader _ -> \"MISSING_HEADER\"\n    InvalidHeader _ _ -> \"INVALID_HEADER\"\n  toHttpCode _ = E400\n\ninstance IsAPIError HeaderError\n\ndata SignatureError\n  = SignatureVerificationFailure [Header]\n  | CannotDecodeSignature String\n  deriving (Eq, Show, IsBecknAPIError)\n\ninstanceExceptionWithParent 'HTTPException ''SignatureError\n\ninstance IsBaseError SignatureError where\n  toMessage = \\case\n    CannotDecodeSignature err -> Just (fromString err)\n    _ -> Nothing\n\ninstance IsHTTPError SignatureError where\n  toErrorCode = \\case\n    SignatureVerificationFailure _ -> \"SIGNATURE_VERIFICATION_FAILURE\"\n    CannotDecodeSignature _ -> \"CANNOT_DECODE_SIGNATURE\"\n  toHttpCode _ = E401\n  toCustomHeaders (SignatureVerificationFailure headers) = headers\n  toCustomHeaders _ = []\n\ninstance IsAPIError SignatureError\n\ndata AuthPIError = NotAnExecutor deriving (Eq, Show, IsBecknAPIError)\n\ninstanceExceptionWithParent 'HTTPException ''AuthPIError\n\ninstance IsBaseError AuthPIError where\n  toMessage NotAnExecutor = Just \"You are not an executor of this operation.\"\n\ninstance IsHTTPError AuthPIError where\n  toErrorCode NotAnExecutor = \"NOT_AN_EXECUTOR\"\n  toHttpCode NotAnExecutor = E403\n\ninstance IsAPIError AuthPIError\n\ndata VehicleError\n  = VehicleNotFound Text\n  | VehicleDoesNotExist Text\n  | VehicleAlreadyLinked\n  deriving (Eq, Show, IsBecknAPIError)\n\ninstanceExceptionWithParent 'HTTPException ''VehicleError\n\ninstance IsBaseError VehicleError where\n  toMessage = \\case\n    VehicleNotFound vehicleId -> Just $ \"Vehicle with vehicleId \\\"\" <> show vehicleId <> \"\\\" not found.\"\n    VehicleDoesNotExist vehicleId -> Just $ \"Vehicle with vehicleId \\\"\" <> show vehicleId <> \"\\\" not exist.\"\n    _ -> Nothing\n\ninstance IsHTTPError VehicleError where\n  toErrorCode = \\case\n    VehicleNotFound _ -> \"VEHICLE_NOT_FOUND\"\n    VehicleDoesNotExist _ -> \"VEHICLE_DOES_NOT_EXIST\"\n    VehicleAlreadyLinked -> \"VEHICLE_ALREADY_LINKED\"\n  toHttpCode = \\case\n    VehicleNotFound _ -> E500\n    VehicleDoesNotExist _ -> E400\n    VehicleAlreadyLinked -> E400\n\ninstance IsAPIError VehicleError\n\ndata PersonError\n  = PersonNotFound Text\n  | PersonDoesNotExist Text\n  | PersonFieldNotPresent Text\n  | PersonWithPhoneNotFound Text\n  | PersonEmailExists\n  | PersonCityInformationDoesNotExist Text\n  | PersonCityInformationNotFound Text\n  | PersonMobileNumberIsNULL Text\n  deriving (Eq, Show, IsBecknAPIError)\n\ninstanceExceptionWithParent 'HTTPException ''PersonError\n\ninstance IsBaseError PersonError where\n  toMessage = \\case\n    PersonNotFound personId -> Just $ \"Person with personId \\\"\" <> show personId <> \"\\\" not found.\"\n    PersonDoesNotExist personId -> Just $ \"No person matches passed data \\\"\" <> show personId <> \"\\\" not exist.\"\n    PersonFieldNotPresent field -> Just $ \"Required field \" <> field <> \" is null for this person.\"\n    PersonWithPhoneNotFound phone -> Just $ \"Person with mobile number \\\"\" <> show phone <> \"\\\" not found.\"\n    PersonEmailExists -> Just \"Email is already registered.\"\n    PersonCityInformationDoesNotExist searchKey -> Just $ \"No person city information matches passed data \" <> show searchKey <> \".\"\n    PersonCityInformationNotFound searchKey -> Just $ \"Person city information with personId \\\"\" <> show searchKey <> \"\\\" not found.\"\n    PersonMobileNumberIsNULL personId -> Just $ \"Mobile Number is NULL for personId \\\"\" <> personId\n\ninstance IsHTTPError PersonError where\n  toErrorCode = \\case\n    PersonNotFound _ -> \"PERSON_NOT_FOUND\"\n    PersonDoesNotExist _ -> \"PERSON_DOES_NOT_EXIST\"\n    PersonFieldNotPresent _ -> \"PERSON_FIELD_NOT_PRESENT\"\n    PersonWithPhoneNotFound _ -> \"PERSON_NOT_FOUND\"\n    PersonEmailExists -> \"PERSON_EMAIL_ALREADY_EXISTS\"\n    PersonCityInformationDoesNotExist _ -> \"PERSON_CITY_INFORMATION_DOES_NOT_EXIST\"\n    PersonCityInformationNotFound _ -> \"PERSON_CITY_INFORMATION_NOT_FOUND\"\n    PersonMobileNumberIsNULL _ -> \"PERSON_MOBILE_NUMBER_IS_NULL\"\n  toHttpCode = \\case\n    PersonNotFound _ -> E500\n    PersonDoesNotExist _ -> E400\n    PersonFieldNotPresent _ -> E500\n    PersonWithPhoneNotFound _ -> E422\n    PersonEmailExists -> E400\n    PersonCityInformationDoesNotExist _ -> E400\n    PersonCityInformationNotFound _ -> E500\n    PersonMobileNumberIsNULL _ -> E400\n\ninstance IsAPIError PersonError\n\ndata TransporterError\n  = TransporterConfigNotFound Text\n  | TransporterConfigDoesNotExist Text\n  deriving (Eq, Show, IsBecknAPIError)\n\ninstanceExceptionWithParent 'HTTPException ''TransporterError\n\ninstance IsBaseError TransporterError where\n  toMessage (TransporterConfigNotFound merchantOperatingCityId) = Just $ \"Transporter with merchantOperatingCityId \\\"\" <> show merchantOperatingCityId <> \"\\\" not found.\"\n  toMessage (TransporterConfigDoesNotExist merchantOperatingCityId) = Just $ \"Transporter with merchantOperatingCityId \\\"\" <> show merchantOperatingCityId <> \"\\\" does not exist.\"\n\ninstance IsHTTPError TransporterError where\n  toErrorCode = \\case\n    TransporterConfigNotFound _ -> \"TRANSPORTER_NOT_FOUND\"\n    TransporterConfigDoesNotExist _ -> \"TRANSPORTER_NOT_EXISTS\"\n  toHttpCode = \\case\n    TransporterConfigNotFound _ -> E500\n    TransporterConfigDoesNotExist _ -> E400\n\ninstance IsAPIError TransporterError\n\ndata MerchantError\n  = MerchantNotFound Text\n  | MerchantDoesNotExist Text\n  | MerchantServiceUsageConfigNotFound Text\n  | MerchantServiceConfigNotFound Text Text Text\n  | MerchantOperatingCityNotFound Text\n  | MerchantOperatingCityDoesNotExist Text\n  deriving (Eq, Show, IsBecknAPIError)\n\ninstanceExceptionWithParent 'HTTPException ''MerchantError\n\ninstance IsBaseError MerchantError where\n  toMessage (MerchantNotFound merchantId) = Just $ \"Merchant with merchantId \\\"\" <> show merchantId <> \"\\\" not found.\"\n  toMessage (MerchantDoesNotExist merchantId) = Just $ \"No merchant matches passed data \" <> show merchantId <> \".\"\n  toMessage (MerchantServiceUsageConfigNotFound merchantOperatingCityId) = Just $ \"MerchantServiceUsageConfig with merchantOperatingCityId \\\"\" <> show merchantOperatingCityId <> \"\\\" not found.\"\n  toMessage (MerchantServiceConfigNotFound merchantId serviceType service) = Just $ \"MerchantServiceConfig for \" <> serviceType <> \" service \" <> service <> \" with merchantId \\\"\" <> merchantId <> \"\\\" not found.\"\n  toMessage (MerchantOperatingCityNotFound merchantId) = Just $ \"MerchantOperatingCity with merchantId \\\"\" <> show merchantId <> \"\\\" not found.\"\n  toMessage (MerchantOperatingCityDoesNotExist searchKey) = Just $ \"No merchant operating city matches passed data \" <> show searchKey <> \".\"\n\ninstance IsHTTPError MerchantError where\n  toErrorCode = \\case\n    MerchantNotFound _ -> \"MERCHANT_NOT_FOUND\"\n    MerchantDoesNotExist _ -> \"MERCHANT_DOES_NOT_EXIST\"\n    MerchantServiceUsageConfigNotFound _ -> \"MERCHANT_SERVICE_USAGE_CONFIG_NOT_FOUND\"\n    MerchantServiceConfigNotFound {} -> \"MERCHANT_SERVICE_CONFIG_NOT_FOUND\"\n    MerchantOperatingCityNotFound _ -> \"MERCHANT_OPERATING_CITY_NOT_FOUND\"\n    MerchantOperatingCityDoesNotExist _ -> \"MERCHANT_OPERATING_CITY_DOES_NOT_EXIST\"\n\n  toHttpCode = \\case\n    MerchantNotFound _ -> E500\n    MerchantDoesNotExist _ -> E400\n    MerchantServiceUsageConfigNotFound _ -> E500\n    MerchantServiceConfigNotFound {} -> E500\n    MerchantOperatingCityNotFound _ -> E500\n    MerchantOperatingCityDoesNotExist _ -> E400\n\ninstance IsAPIError MerchantError\n\ndata ExophoneError\n  = ExophoneNotFound Text\n  | ExophoneDoesNotExist Text\n  deriving (Eq, Show, IsBecknAPIError)\n\ninstanceExceptionWithParent 'HTTPException ''ExophoneError\n\ninstance IsBaseError ExophoneError where\n  toMessage (ExophoneNotFound merchantOperatingCityId) = Just $ \"Exophone for merchantOperatingCityId \\\"\" <> show merchantOperatingCityId <> \"\\\" not found.\"\n  toMessage (ExophoneDoesNotExist phoneNumber) = Just $ \"No exophone matches passed data \" <> show phoneNumber <> \".\"\n\ninstance IsHTTPError ExophoneError where\n  toErrorCode = \\case\n    ExophoneNotFound _ -> \"EXOPHONE_NOT_FOUND\"\n    ExophoneDoesNotExist _ -> \"EXOPHONE_DOES_NOT_EXIST\"\n  toHttpCode = \\case\n    ExophoneNotFound _ -> E500\n    ExophoneDoesNotExist _ -> E400\n\ninstance IsAPIError ExophoneError\n\ndata LocationError = LocationNotFound\n  deriving (Eq, Show, IsBecknAPIError)\n\ninstanceExceptionWithParent 'HTTPException ''LocationError\n\ninstance IsBaseError LocationError where\n  toMessage LocationNotFound = Just \"Location not found.\"\n\ninstance IsHTTPError LocationError where\n  toErrorCode LocationNotFound = \"LOCATION_NOT_FOUND\"\n  toHttpCode LocationNotFound = E500\n\ninstance IsAPIError LocationError\n\ndata GenericError\n  = InternalError Text\n  | InvalidRequest Text\n  deriving (Eq, Show, IsBecknAPIError)\n\ninstanceExceptionWithParent 'HTTPException ''GenericError\n\ninstance IsBaseError GenericError where\n  toMessage = \\case\n    InternalError msg -> Just msg\n    InvalidRequest msg -> Just msg\n\ninstance IsHTTPError GenericError where\n  toErrorCode = \\case\n    InternalError _ -> \"INTERNAL_ERROR\"\n    InvalidRequest _ -> \"INVALID_REQUEST\"\n  toHttpCode = \\case\n    InternalError _ -> E500\n    InvalidRequest _ -> E400\n\ninstance IsAPIError GenericError\n\ndata SearchRequestError\n  = SearchRequestNotFound Text\n  | SearchRequestDoesNotExist Text\n  | SearchRequestExpired\n  deriving (Eq, Show, IsBecknAPIError)\n\ninstanceExceptionWithParent 'HTTPException ''SearchRequestError\n\ninstance IsBaseError SearchRequestError where\n  toMessage = \\case\n    SearchRequestNotFound searchId -> Just $ \"Search with searchId \\\"\" <> show searchId <> \"\\\"not found. \"\n    SearchRequestDoesNotExist searchId -> Just $ \"No case matches passed data \\\"<>\" <> show searchId <> \"\\\" not exist\"\n    _ -> Nothing\n\ninstance IsHTTPError SearchRequestError where\n  toErrorCode = \\case\n    SearchRequestNotFound _ -> \"SEARCH_REQUEST_NOT_FOUND\"\n    SearchRequestDoesNotExist _ -> \"SEARCH_REQUEST_DOES_NOT_EXIST\"\n    SearchRequestExpired -> \"SEARCH_REQUEST_EXPIRED\"\n  toHttpCode = \\case\n    SearchRequestNotFound _ -> E500\n    SearchRequestDoesNotExist _ -> E400\n    SearchRequestExpired -> E400\n\ninstance IsAPIError SearchRequestError\n\ndata QuoteError\n  = QuoteNotFound Text\n  | QuoteDoesNotExist Text\n  | QuoteExpired Text\n  | QuoteFieldNotPresent Text\n  deriving (Eq, Show, IsBecknAPIError)\n\ninstanceExceptionWithParent 'HTTPException ''QuoteError\n\ninstance IsBaseError QuoteError where\n  toMessage = \\case\n    QuoteNotFound quoteId -> Just $ \"Quote with quoteId \\\"\" <> show quoteId <> \"\\\" not found. \"\n    QuoteDoesNotExist quoteId -> Just $ \"No quote matches passed data \\\"\" <> show quoteId <> \"\\\" not exist. \"\n    QuoteExpired quoteId -> Just $ \"Quote with quoteId \\\"\" <> show quoteId <> \"\\\" has already expired. \"\n    QuoteFieldNotPresent field -> Just $ \"Required field \" <> field <> \" is null for this quote.\"\n\ninstance IsHTTPError QuoteError where\n  toErrorCode = \\case\n    QuoteNotFound _ -> \"QUOTE_NOT_FOUND\"\n    QuoteDoesNotExist _ -> \"QUOTE_DOES_NOT_EXIST\"\n    QuoteExpired _ -> \"QUOTE_EXPIRED\"\n    QuoteFieldNotPresent _ -> \"QUOTE_FIELD_NOT_PRESENT\"\n  toHttpCode = \\case\n    QuoteNotFound _ -> E500\n    QuoteDoesNotExist _ -> E400\n    QuoteExpired _ -> E400\n    QuoteFieldNotPresent _ -> E500\n\ninstance IsAPIError QuoteError\n\ndata ShouldNotHappenError\n  = ShouldNotHappen Text\n  deriving (Eq, Show, IsBecknAPIError)\n\ninstanceExceptionWithParent 'HTTPException ''ShouldNotHappenError\n\ninstance IsBaseError ShouldNotHappenError where\n  toMessage = \\case\n    ShouldNotHappen txt -> Just $ \"This shouldn't have happened -\" <> show txt\n\ninstance IsHTTPError ShouldNotHappenError where\n  toErrorCode = \\case\n    ShouldNotHappen _ -> \"SHOULD_NOT_HAPPEN\"\n  toHttpCode = \\case\n    ShouldNotHappen _ -> E500\n\ninstance IsAPIError ShouldNotHappenError\n\ndata BookingError\n  = BookingNotFound Text\n  | BookingDoesNotExist Text\n  | BookingFieldNotPresent Text\n  | BookingForRiderNotFound Text\n  | BookingInvalidStatus Text\n  | BookingBppOrderIdNotFound\n  deriving (Eq, Show, IsBecknAPIError)\n\ninstanceExceptionWithParent 'HTTPException ''BookingError\n\ninstance IsBaseError BookingError where\n  toMessage = \\case\n    BookingNotFound bookingId -> Just $ \"Booking with bookingId \\\"\" <> show bookingId <> \"\\\" not found. \"\n    BookingDoesNotExist bookingId -> Just $ \"No booking matches passed data \\\"\" <> show bookingId <> \"\\\" not exist. \"\n    BookingFieldNotPresent field -> Just $ \"Required field \" <> field <> \" is null for this booking.\"\n    BookingForRiderNotFound riderId -> Just $ \"Booking with riderId \\\"\" <> show riderId <> \"\\\" not found. \"\n    BookingInvalidStatus msg -> Just $ \"Attempted to do some action in wrong booking status. \" <> msg\n    _ -> Nothing\n\ninstance IsHTTPError BookingError where\n  toErrorCode = \\case\n    BookingNotFound _ -> \"BOOKING_NOT_FOUND\"\n    BookingDoesNotExist _ -> \"BOOKING_DOES_NOT_EXIST\"\n    BookingFieldNotPresent _ -> \"BOOKING_FIELD_NOT_PRESENT\"\n    BookingForRiderNotFound _ -> \"BOOKING_NOT_FOUND\"\n    BookingInvalidStatus _ -> \"BOOKING_INVALID_STATUS\"\n    BookingBppOrderIdNotFound -> \"BOOKING_BPP_ORDER_ID_NOT_FOUND\"\n  toHttpCode = \\case\n    BookingNotFound _ -> E500\n    BookingDoesNotExist _ -> E400\n    BookingFieldNotPresent _ -> E500\n    BookingForRiderNotFound _ -> E400\n    BookingInvalidStatus _ -> E400\n    BookingBppOrderIdNotFound -> E500\n\ninstance IsAPIError BookingError\n\ndata RideError\n  = RideNotFound Text\n  | RideDoesNotExist Text\n  | RideFieldNotPresent Text\n  | RideWithBookingIdNotFound Text\n  | RideForDriverNotFound Text\n  | RideInvalidStatus Text\n  | DriverNotAtPickupLocation Text\n  deriving (Eq, Show, IsBecknAPIError)\n\ninstanceExceptionWithParent 'HTTPException ''RideError\n\ninstance IsBaseError RideError where\n  toMessage = \\case\n    RideNotFound rideId -> Just $ \"Ride with rideId \\\"\" <> show rideId <> \"\\\"not found. \"\n    RideDoesNotExist rideId -> Just $ \"No ride matches passed data \\\"\" <> show rideId <> \"\\\" not exist. \"\n    RideFieldNotPresent field -> Just $ \"Required field \" <> field <> \" is null for this ride.\"\n    RideWithBookingIdNotFound bookingId -> Just $ \"Ride with booking id \\\"\" <> show bookingId <> \"\\\"not found. \"\n    RideForDriverNotFound driverId -> Just $ \"Ride for driver id \\\"\" <> show driverId <> \"\\\"not found. \"\n    RideInvalidStatus msg -> Just $ \"Attempted to do some action in wrong ride status. \" <> msg\n    DriverNotAtPickupLocation driverId -> Just $ \"Driver id \\\"\" <> show driverId <> \"\\\" has not reached the pickup location.\"\n\ninstance IsHTTPError RideError where\n  toErrorCode = \\case\n    RideNotFound _ -> \"RIDE_NOT_FOUND\"\n    RideDoesNotExist _ -> \"RIDE_DOES_NOT_EXIST\"\n    RideFieldNotPresent _ -> \"RIDE_FIELD_NOT_PRESENT\"\n    RideWithBookingIdNotFound _ -> \"RIDE_NOT_FOUND\"\n    RideForDriverNotFound _ -> \"RIDE_NOT_FOUND\"\n    RideInvalidStatus _ -> \"RIDE_INVALID_STATUS\"\n    DriverNotAtPickupLocation _ -> \"DRIVER_NOT_AT_PICKUP_LOCATION\"\n\n  toHttpCode = \\case\n    RideNotFound _ -> E500\n    RideDoesNotExist _ -> E400\n    RideFieldNotPresent _ -> E500\n    RideWithBookingIdNotFound _ -> E500\n    RideForDriverNotFound _ -> E422\n    RideInvalidStatus _ -> E400\n    DriverNotAtPickupLocation _ -> E400\n\ninstance IsAPIError RideError\n\ndata DatabaseError\n  = SQLRequestError Text Text\n  | SQLResultError Text\n  | DBUnknownError Text\n  deriving (Eq, Show, IsBecknAPIError)\n\ninstanceExceptionWithParent 'HTTPException ''DatabaseError\n\ninstance IsBaseError DatabaseError where\n  toMessage = \\case\n    SQLRequestError sqlErr desc -> Just $ \"SQL request error: \" <> sqlErr <> \". Description: \" <> desc\n    SQLResultError msg -> Just msg\n    DBUnknownError msg -> Just msg\n\ninstance IsHTTPError DatabaseError where\n  toErrorCode = \\case\n    SQLRequestError _ _ -> \"DB_SQL_REQUEST_ERROR\"\n    SQLResultError _ -> \"DB_SQL_RESULT_ERROR\"\n    DBUnknownError _ -> \"DB_UNKNOWN_ERROR\"\n  toHttpCode _ = E500\n\ninstance IsAPIError DatabaseError\n\ndata ContextError\n  = UnsupportedCoreVer\n  | InvalidDomain\n  | InvalidCountry\n  | InvalidAction\n  deriving (Eq, Show)\n\ninstanceExceptionWithParent 'HTTPException ''ContextError\n\ninstance IsBaseError ContextError\n\ninstance IsHTTPError ContextError where\n  toErrorCode UnsupportedCoreVer = \"UNSUPPORTED_CORE_VERSION\"\n  toErrorCode InvalidDomain = \"INVALID_DOMAIN\"\n  toErrorCode InvalidCountry = \"INVALID_COUNTRY\"\n  toErrorCode InvalidAction = \"INVALID_ACTION\"\n  toHttpCode _ = E400\n\ninstance IsAPIError ContextError\n\ninstance IsBecknAPIError ContextError where\n  toType _ = CONTEXT_ERROR\n\nexternalAPICallErrorMessage :: BaseUrl -> ClientError -> Maybe Text\nexternalAPICallErrorMessage baseUrl clientErr =\n  Just $\n    \"Failure in the external API call to \"\n      <> showBaseUrlText baseUrl\n      <> \": \"\n      <> show clientErr\n\ndata ExternalAPICallError = ExternalAPICallError\n  { errCode :: Maybe Text,\n    baseUrl :: BaseUrl,\n    clientError :: ClientError\n  }\n  deriving (Eq, Show, IsBecknAPIError)\n\ninstanceExceptionWithParent 'HTTPException ''ExternalAPICallError\n\ninstance IsBaseError ExternalAPICallError where\n  toMessage (ExternalAPICallError _ url err) = externalAPICallErrorMessage url err\n\ninstance IsHTTPError ExternalAPICallError where\n  toErrorCode (ExternalAPICallError codeMb _ _) = fromMaybe \"EXTERNAL_API_CALL_ERROR\" codeMb\n\ninstance IsAPIError ExternalAPICallError\n\ndata HealthCheckError\n  = ServiceUnavailable\n  deriving (Eq, Show, IsBecknAPIError)\n\ninstanceExceptionWithParent 'HTTPException ''HealthCheckError\n\ninstance IsBaseError HealthCheckError\n\ninstance IsHTTPError HealthCheckError where\n  toErrorCode ServiceUnavailable = \"SERVICE_UNAVAILABLE\"\n  toHttpCode ServiceUnavailable = E503\n\ninstance IsAPIError HealthCheckError\n\ndata ServerError\n  = ServerUnavailable\n  deriving (Eq, Show, IsBecknAPIError)\n\ninstanceExceptionWithParent 'HTTPException ''ServerError\n\ninstance IsBaseError ServerError where\n  toMessage ServerUnavailable = Just \"Server is working, but is not available.\"\n\ninstance IsHTTPError ServerError where\n  toErrorCode ServerUnavailable = \"SERVER_UNAVAILABLE\"\n  toHttpCode ServerUnavailable = E503\n\ninstance IsAPIError ServerError\n\nnewtype RedisError\n  = RedisError KVDBReply\n  deriving (Eq, Show, IsBecknAPIError)\n\ninstanceExceptionWithParent 'HTTPException ''RedisError\n\ninstance IsBaseError RedisError where\n  toMessage = \\case\n    RedisError err -> Just $ show err\n\ninstance IsHTTPError RedisError where\n  toErrorCode = \\case\n    RedisError _ -> \"REDIS_ERROR\"\n  toHttpCode _ = E500\n\ninstance IsAPIError RedisError\n\ndata SMSError\n  = SMSError SubmitSmsRes\n  | SMSInvalidNumber\n  deriving (Eq, Show, IsBecknAPIError)\n\ninstanceExceptionWithParent 'HTTPException ''SMSError\n\ninstance IsBaseError SMSError where\n  toMessage = \\case\n    SMSError err -> Just $ submitSmsResToText err\n    _ -> Nothing\n\ninstance IsHTTPError SMSError where\n  toErrorCode = \\case\n    SMSError _ -> \"SMS_NOT_SENT\"\n    SMSInvalidNumber -> \"SMS_INVALID_NUMBER\"\n\n  toHttpCode = \\case\n    SMSError _ -> E500\n    SMSInvalidNumber -> E400\n\ninstance IsAPIError SMSError\n\ndata SpecialZoneError\n  = OtpNotFoundForSpecialZoneBooking Text\n  | BookingNotFoundForSpecialZoneOtp Text\n  | SpecialZoneNotFound\n  | PointNotFound\n  deriving (Eq, Show, IsBecknAPIError)\n\ninstanceExceptionWithParent 'HTTPException ''SpecialZoneError\n\ninstance IsBaseError SpecialZoneError where\n  toMessage = \\case\n    OtpNotFoundForSpecialZoneBooking bookingId -> Just $ \"No otp found for special zone booking with \\\"\" <> bookingId <> \"\\\"bookingId\"\n    BookingNotFoundForSpecialZoneOtp otp -> Just $ \"No booking found for special zone otp with \\\"\" <> otp <> \"\\\"otp\"\n    SpecialZoneNotFound -> Just \"Special Zone not found.\"\n    PointNotFound -> Just \"Point not found.\"\n\ninstance IsHTTPError SpecialZoneError where\n  toErrorCode = \\case\n    OtpNotFoundForSpecialZoneBooking _ -> \"OTP_NOT_FOUND_FOR_SPECIAL_ZONE_BOOKING\"\n    BookingNotFoundForSpecialZoneOtp _ -> \"BOOKING_NOT_FOUND_FOR_SPECIAL_ZONE_OTP\"\n    SpecialZoneNotFound -> \"SPECIAL_ZONE_NOT_FOUND\"\n    PointNotFound -> \"POINT_NOT_FOUND\"\n\n  toHttpCode = \\case\n    OtpNotFoundForSpecialZoneBooking _ -> E400\n    BookingNotFoundForSpecialZoneOtp _ -> E400\n    SpecialZoneNotFound -> E400\n    PointNotFound -> E400\n\ninstance IsAPIError SpecialZoneError\n\ndata GoogleMapsCallError = GoogleMapsInvalidRequest | GoogleMapsCallError Text\n  deriving (Eq, Show, IsBecknAPIError)\n\ninstanceExceptionWithParent 'HTTPException ''GoogleMapsCallError\n\ninstance IsBaseError GoogleMapsCallError where\n  toMessage = \\case\n    GoogleMapsInvalidRequest -> Just \"Invalid request to Google Maps.\"\n    GoogleMapsCallError googleErrorCode -> Just googleErrorCode\n\ninstance IsHTTPError GoogleMapsCallError where\n  toErrorCode = \\case\n    GoogleMapsInvalidRequest -> \"GOOGLE_MAPS_INVALID_REQUEST\"\n    GoogleMapsCallError _ -> \"GOOGLE_MAPS_CALL_ERROR\"\n  toHttpCode = \\case\n    GoogleMapsInvalidRequest -> E400\n    GoogleMapsCallError _ -> E500\n\ninstance IsAPIError GoogleMapsCallError\n\ndata GoogleTranslateCallError = GoogleTranslateInvalidRequest\n  deriving (Eq, Show, IsBecknAPIError)\n\ninstanceExceptionWithParent 'HTTPException ''GoogleTranslateCallError\n\ninstance IsBaseError GoogleTranslateCallError where\n  toMessage GoogleTranslateInvalidRequest = Just \"Invalid request to Google Translate.\"\n\ninstance IsHTTPError GoogleTranslateCallError where\n  toErrorCode GoogleTranslateInvalidRequest = \"GOOGLE_TRANSLATE_INVALID_REQUEST\"\n  toHttpCode GoogleTranslateInvalidRequest = E400\n\ninstance IsAPIError GoogleTranslateCallError\n\ndata GupShupError\n  = GupShupInvalidRequest\n  | GupShupNotConfigured\n  | GupShupUserIdNotFound\n  | GupShupInvalidPhoneNumber\n  | GupShupUnauthorized\n  | GupShupWrongMethodService\n  | GupShupInterNationalPhoneNumber\n  | GupShupTooManyRequests\n  | GupShupUnknownServerError\n  deriving (Eq, Show, IsBecknAPIError)\n\ninstanceExceptionWithParent 'HTTPException ''GupShupError\n\ninstance IsBaseError GupShupError where\n  toMessage = \\case\n    GupShupInvalidRequest -> Just \"Invalid request to GupShup.\"\n    GupShupNotConfigured -> Just \"GupShup env variables aren't properly set.\"\n    GupShupUserIdNotFound -> Just \"GupShup Authentication Failed as userid X does not exist.\"\n    GupShupInvalidPhoneNumber -> Just \"The phone number XXXXX is not a valid phone number.\"\n    GupShupUnauthorized -> Just \"Authentication failed due to invalid userId or password.\"\n    GupShupWrongMethodService -> Just \"The method is not supported.\"\n    GupShupInterNationalPhoneNumber -> Just \"The INTERNATIONAL_PHONE service is disabled for you. Kindly get the service enabled before using this action\"\n    GupShupTooManyRequests -> Just \"The phone number has already been marked as requested\"\n    GupShupUnknownServerError -> Just \"An unknown exception has occurred. Please retry the request after some time.\"\n\ninstance IsHTTPError GupShupError where\n  toErrorCode = \\case\n    GupShupNotConfigured -> \"GUPSHUP_NOT_CONFIGURED\"\n    GupShupInvalidRequest -> \"GUPSHUP_INVALID_REQUEST\"\n    GupShupUserIdNotFound -> \"GUPSHUP_USER_NOT_FOUND\"\n    GupShupInvalidPhoneNumber -> \"GUPSHUP_INVALID_PHONE_NUMBER\"\n    GupShupUnauthorized -> \"GUPSHUP_AUTHENTICATION_FAILED\"\n    GupShupWrongMethodService -> \"GUPSHUP_WRONG_METHOD_SERVICE\"\n    GupShupInterNationalPhoneNumber -> \"GUPSHUP_INTERNATIONAL_PHONE_DISABLED\"\n    GupShupTooManyRequests -> \"GUPSHUP_TOO_MANY_REQUEST_FOR_SAME\"\n    GupShupUnknownServerError -> \"GUPSHUP_UNKNOWN_ERROR\"\n\ninstance FromResponse GupShupError where\n  fromResponse resp = case statusCode $ responseStatusCode resp of\n    400 -> Just GupShupInvalidRequest\n    _ -> Just GupShupNotConfigured\n\ninstance IsAPIError GupShupError\n\ndata TwillioError\n  = TwillioBadRequest\n  | TwillioForbidden\n  | TwillioAPIDoesNotExist\n  | TwillioAccountNotActive\n  | TwillioTrialAccountFound\n  | TwillioConcurrencyLimitExceeded\n  | TwillioInvalidURLFormat\n  | TwillioInternalServerError\n  | TwillioUnknownError\n  deriving (Eq, Show, IsBecknAPIError)\n\ninstanceExceptionWithParent 'HTTPException ''TwillioError\n\ninstance IsBaseError TwillioError where\n  toMessage = \\case\n    TwillioBadRequest -> Just \"Invalid request to Twillio.\"\n    TwillioForbidden -> Just \"Forbidden request to Twillio.\"\n    TwillioAPIDoesNotExist -> Just \"API does not exist in Twillio.\"\n    TwillioAccountNotActive -> Just \"Account is not active in Twillio.\"\n    TwillioTrialAccountFound -> Just \"Trial account found in Twillio.\"\n    TwillioConcurrencyLimitExceeded -> Just \"Concurrency limit exceeded in Twillio.\"\n    TwillioInvalidURLFormat -> Just \"Invalid URL format in Twillio.\"\n    TwillioInternalServerError -> Just \"Internal server error in Twillio.\"\n    TwillioUnknownError -> Just \"Unknown error in Twillio.\"\n\ninstance IsHTTPError TwillioError where\n  toErrorCode = \\case\n    TwillioBadRequest -> \"TWILLIO_BAD_REQUEST\"\n    TwillioForbidden -> \"TWILLIO_FORBIDDEN\"\n    TwillioAPIDoesNotExist -> \"TWILLIO_API_DOES_NOT_EXIST\"\n    TwillioAccountNotActive -> \"TWILLIO_ACCOUNT_NOT_ACTIVE\"\n    TwillioTrialAccountFound -> \"TWILLIO_TRIAL_ACCOUNT_FOUND\"\n    TwillioConcurrencyLimitExceeded -> \"TWILLIO_CONCURRENCY_LIMIT_EXCEEDED\"\n    TwillioInvalidURLFormat -> \"TWILLIO_INVALID_URL_FORMAT\"\n    TwillioInternalServerError -> \"TWILLIO_INTERNAL_SERVER_ERROR\"\n    TwillioUnknownError -> \"TWILLIO_UNKNOWN_ERROR\"\n\ninstance FromResponse TwillioError where\n  fromResponse resp = case statusCode $ responseStatusCode resp of\n    400 -> Just TwillioBadRequest\n    403 -> Just TwillioForbidden\n    410 -> Just TwillioUnknownError\n    404 -> Just TwillioAPIDoesNotExist\n    10001 -> Just TwillioAccountNotActive\n    10002 -> Just TwillioTrialAccountFound\n    10004 -> Just TwillioConcurrencyLimitExceeded\n    11100 -> Just TwillioInvalidURLFormat\n    503 -> Just TwillioInternalServerError\n    _ -> Just TwillioUnknownError\n\ninstance IsAPIError TwillioError\n\nnewtype AgencyDisabled\n  = AgencyDisabled Text\n  deriving (Eq, Show, IsBecknAPIError)\n\ninstanceExceptionWithParent 'HTTPException ''AgencyDisabled\n\ninstance IsBaseError AgencyDisabled where\n  toMessage (AgencyDisabled agencyId) = Just $ \"Agency with agencyId: \" <> show agencyId <> \" is disabled.\"\n\ninstance IsHTTPError AgencyDisabled where\n  toErrorCode (AgencyDisabled _) = \"AGENCY_DISABLED\"\n  toHttpCode (AgencyDisabled _) = E403\n\ninstance IsAPIError AgencyDisabled\n\ndata ExotelError\n  = ExotelNotConfigured\n  | ExotelBadRequest\n  | ExotelUnauthorized\n  | ExitelPaymentRequired\n  | ExotelAccessDenied\n  | ExotelNotFound\n  | ExotelConflict\n  | ExotelTooManyRequests\n  | ExotelServerError\n  deriving (Eq, Show, IsBecknAPIError)\n\ninstanceExceptionWithParent 'HTTPException ''ExotelError\n\ninstance FromResponse ExotelError where\n  fromResponse resp = case statusCode $ responseStatusCode resp of\n    400 -> Just ExotelBadRequest\n    401 -> Just ExotelUnauthorized\n    402 -> Just ExitelPaymentRequired\n    403 -> Just ExotelAccessDenied\n    404 -> Just ExotelNotFound\n    409 -> Just ExotelConflict\n    429 -> Just ExotelTooManyRequests\n    _ -> Just ExotelServerError\n\ninstance IsBaseError ExotelError where\n  toMessage = \\case\n    ExotelNotConfigured -> Just \"Exotel env variables aren't properly set.\"\n    ExotelBadRequest -> Just \"Something in your header or request body was malformed.\"\n    ExotelUnauthorized -> Just \"Necessary credentials were either missing or invalid.\"\n    ExitelPaymentRequired -> Just \"The action is not available on your plan, or you have exceeded usage limits for your current plan.\"\n    ExotelAccessDenied -> Just \"Your credentials are valid, but you dont have access to the requested resource.\"\n    ExotelNotFound -> Just \"The object youre requesting doesnt exist.\"\n    ExotelConflict -> Just \"You might be trying to update the same resource concurrently.\"\n    ExotelTooManyRequests -> Just \"You are calling our APIs more frequently than we allow.\"\n    ExotelServerError -> Just \"Something went wrong on our end. Please try again.\"\n\ninstance IsHTTPError ExotelError where\n  toErrorCode = \\case\n    ExotelNotConfigured -> \"EXOTEL_NOT_CONFIGURED\"\n    ExotelBadRequest -> \"EXOTEL_BAD_REQUEST\"\n    ExotelUnauthorized -> \"EXOTEL_UNAUTHORIZED\"\n    ExitelPaymentRequired -> \"EXOTEL_PAYMENT_REQUIRED\"\n    ExotelAccessDenied -> \"EXOTEL_ACCESS_DENIED\"\n    ExotelNotFound -> \"EXOTEL_NOT_FOUND\"\n    ExotelConflict -> \"EXOTEL_CONFLICT\"\n    ExotelTooManyRequests -> \"EXOTEL_TOO_MANY_REQUESTS\"\n    ExotelServerError -> \"EXOTEL_SERVER_ERROR\"\n\ninstance IsAPIError ExotelError\n\ndata KafkaError\n  = KafkaUnableToBuildTools Kafka.KafkaError\n  | KafkaUnableToReleaseTools Kafka.KafkaError\n  | KafkaUnableToProduceMessage Kafka.KafkaError\n  | KafkaUnableToConsumeMessage Kafka.KafkaError\n  | KafkaUnableToParseValue\n  | KafkaTopicIsEmptyString\n  deriving (Show, IsBecknAPIError)\n\ninstanceExceptionWithParent 'HTTPException ''KafkaError\n\ninstance IsBaseError KafkaError where\n  toMessage = \\case\n    KafkaUnableToBuildTools err -> Just $ \"Attemption to build Kafka tools ended with error: \" <> show err\n    KafkaUnableToReleaseTools err -> Just $ \"Attemption to release Kafka tools ended with error: \" <> show err\n    KafkaUnableToProduceMessage err -> Just $ \"Attemption to produce message ended with error: \" <> show err\n    KafkaUnableToConsumeMessage err -> Just $ \"Attemption to consume message ended with error: \" <> show err\n    KafkaUnableToParseValue -> Just \"Unable to parse value of received message.\"\n    KafkaTopicIsEmptyString -> Just \"Kafka topic is empty string.\"\n\ninstance IsHTTPError KafkaError where\n  toErrorCode = \\case\n    KafkaUnableToBuildTools _ -> \"KAFKA_UNABLE_TO_BUILD_TOOLS\"\n    KafkaUnableToReleaseTools _ -> \"KAFKA_UNABLE_TO_RELEASE_TOOLS\"\n    KafkaUnableToProduceMessage _ -> \"KAFKA_UNABLE_TO_PRODUCE_MESSAGE\"\n    KafkaUnableToConsumeMessage _ -> \"KAFKA_UNABLE_TO_CONSUME_MESSAGE\"\n    KafkaUnableToParseValue -> \"KAFKA_UNABLE_TO_PARSE_VALUE\"\n    KafkaTopicIsEmptyString -> \"KAFKA_TOPIC_IS_EMPTY_STRING\"\n\ninstance IsAPIError KafkaError\n\ndata CallStatusError\n  = CallStatusDoesNotExist\n  | CallStatusFieldNotPresent Text\n  | CallIDDoesNotExist Text\n  deriving (Eq, Show, IsBecknAPIError)\n\ninstanceExceptionWithParent 'HTTPException ''CallStatusError\n\ninstance IsBaseError CallStatusError where\n  toMessage CallStatusDoesNotExist = Just \"No call callback received yet.\"\n  toMessage (CallStatusFieldNotPresent field) = Just $ \"Required field \" <> field <> \" is null for this call.\"\n  toMessage (CallIDDoesNotExist callId) = Just $ \"Call with callId \" <> callId <> \" does not exist.\"\n\ninstance IsHTTPError CallStatusError where\n  toErrorCode CallStatusDoesNotExist = \"CALL_DOES_NOT_EXIST\"\n  toErrorCode (CallStatusFieldNotPresent _) = \"CALL_FIELD_NOT_PRESENT\"\n  toErrorCode (CallIDDoesNotExist _) = \"CALL_ID_DOES_NOT_EXIST\"\n  toHttpCode CallStatusDoesNotExist = E400\n  toHttpCode (CallStatusFieldNotPresent _) = E500\n  toHttpCode (CallIDDoesNotExist _) = E400\n\ninstance IsAPIError CallStatusError\n\ndata ServiceabilityError\n  = RideNotServiceable\n  | RideNotServiceableInState Text\n  deriving (Eq, Show, IsBecknAPIError)\n\ninstanceExceptionWithParent 'HTTPException ''ServiceabilityError\n\ninstance IsBaseError ServiceabilityError where\n  toMessage RideNotServiceable = Just \"Requested ride is not serviceable due to georestrictions.\"\n  toMessage (RideNotServiceableInState state_) = Just (\"Selected state \" <> state_ <> \" is not serviceable since it does not fall within the state boundary.\")\n\ninstance IsHTTPError ServiceabilityError where\n  toErrorCode = \\case\n    RideNotServiceable -> \"RIDE_NOT_SERVICEABLE\"\n    RideNotServiceableInState _ -> \"RIDE_NOT_SERVICEABLE_IN_STATE\"\n  toHttpCode = \\case\n    RideNotServiceable -> E400\n    RideNotServiceableInState _ -> E400\n\ninstance IsAPIError ServiceabilityError\n\ndata IdfyCallError\n  = IdfyBadRequest\n  | IdfyUnauthorized\n  | IdfyAccessDenied\n  | IdfyNotFound\n  | IdfySizeLimit\n  | IdfyUnprocessableEntity\n  | IdfyTooManyRequests\n  | IdfyServerError\n  | IdfyCallError Text\n  deriving (Eq, Show, IsBecknAPIError)\n\ninstanceExceptionWithParent 'HTTPException ''IdfyCallError\n\ninstance FromResponse IdfyCallError where\n  fromResponse resp = case statusCode $ responseStatusCode resp of\n    400 -> Just IdfyBadRequest\n    401 -> Just IdfyUnauthorized\n    402 -> Just IdfyAccessDenied\n    404 -> Just IdfyNotFound\n    413 -> Just IdfySizeLimit\n    422 -> Just IdfyUnprocessableEntity\n    429 -> Just IdfyTooManyRequests\n    _ -> Just IdfyServerError\n\ninstance IsBaseError IdfyCallError where\n  toMessage = \\case\n    IdfyBadRequest -> Just \"Something in your header or request body was malformed.\"\n    IdfyUnauthorized -> Just \"Necessary credentials were either missing or invalid.\"\n    IdfyAccessDenied -> Just \"Your credentials are valid, but you dont have access to the requested resource.\"\n    IdfyNotFound -> Just \"The object youre requesting doesnt exist.\"\n    IdfySizeLimit -> Just \"You might be trying to update the same resource concurrently.\"\n    IdfyUnprocessableEntity -> Just \"Unprocessable Entity\"\n    IdfyTooManyRequests -> Just \"You are calling our APIs more frequently than we allow.\"\n    IdfyServerError -> Just \"Something went wrong on our end. Please try again.\"\n    IdfyCallError googleErrorCode -> Just googleErrorCode\n\ninstance IsHTTPError IdfyCallError where\n  toErrorCode = \\case\n    IdfyBadRequest -> \"IDFY_BAD_REQUEST\"\n    IdfyUnauthorized -> \"IDFY_UNAUTHORIZED\"\n    IdfyAccessDenied -> \"IDFY_ACCESS_DENIED\"\n    IdfyNotFound -> \"IDFY_NOT_FOUND\"\n    IdfySizeLimit -> \"IDFY_CONFLICT\"\n    IdfyTooManyRequests -> \"IDFY_TOO_MANY_REQUESTS\"\n    IdfyServerError -> \"IDFY_SERVER_ERROR\"\n    IdfyCallError _ -> \"IDFY_CALL_ERROR\"\n    IdfyUnprocessableEntity -> \"IDFY_UNPROCESSABLE_ENTITY\"\n\ninstance IsAPIError IdfyCallError\n\ndata VersionError = VersionUnexpectedVersion Text\n  deriving (Eq, Show, IsBecknAPIError)\n\ninstanceExceptionWithParent 'HTTPException ''VersionError\n\ninstance IsBaseError VersionError where\n  toMessage (VersionUnexpectedVersion err) = Just $ \"Version can't be read. \" <> err\n\ninstance IsHTTPError VersionError where\n  toErrorCode (VersionUnexpectedVersion _) = \"UNEXPECTED_VERSION\"\n  toHttpCode (VersionUnexpectedVersion _) = E400\n\ninstance IsAPIError VersionError\n\ndata MMIError\n  = MMINotConfigured\n  | MMIBadRequest\n  | MMIUnauthorized\n  | MMIForbidden\n  | MMIServerError\n  | MMIUnderMaintenance\n  | MMIDBConnectionError\n  deriving (Eq, Show, IsBecknAPIError)\n\ninstanceExceptionWithParent 'HTTPException ''MMIError\n\ninstance FromResponse MMIError where\n  fromResponse resp = case statusCode $ responseStatusCode resp of\n    400 -> Just MMIBadRequest\n    401 -> Just MMIUnauthorized\n    403 -> Just MMIForbidden\n    503 -> Just MMIUnderMaintenance\n    204 -> Just MMIDBConnectionError\n    _ -> Just MMIServerError\n\ninstance IsBaseError MMIError where\n  toMessage = \\case\n    MMINotConfigured -> Just \"MMI env variables aren't properly set.\"\n    MMIBadRequest -> Just \"Bad request; User made an error while creating a valid request.\"\n    MMIUnauthorized -> Just \"Unauthorized, either clientID doesnt exist or an invalid clientSecret is provided.\"\n    MMIForbidden -> Just \"Forbidden.\"\n    MMIUnderMaintenance -> Just \"Maintenance break.\"\n    MMIDBConnectionError -> Just \"DB Connection error\"\n    MMIServerError -> Just \"Something went wrong.\"\n\ninstance IsHTTPError MMIError where\n  toErrorCode = \\case\n    MMINotConfigured -> \"MMI_NOT_CONFIGURED\"\n    MMIBadRequest -> \"MMI_BAD_REQUEST\"\n    MMIUnauthorized -> \"MMI_UNAUTHORIZED\"\n    MMIForbidden -> \"MMI_FORBIDDEN\"\n    MMIUnderMaintenance -> \"MMI_UNDER_MAINTENANCE\"\n    MMIDBConnectionError -> \"MMIDBConnectionError\"\n    MMIServerError -> \"MMI_SERVER_ERROR\"\n\ninstance IsAPIError MMIError\n\ndata MerchantMessageError\n  = MerchantMessageNotFound Text Text\n  deriving (Eq, Show, IsBecknAPIError)\n\ninstanceExceptionWithParent 'HTTPException ''MerchantMessageError\n\ninstance IsBaseError MerchantMessageError where\n  toMessage = \\case\n    MerchantMessageNotFound merchantOperatingCityId messageKey -> Just $ \"MerchantMessage with merchantOperatingCityId \\\"\" <> show merchantOperatingCityId <> \" and message key\" <> show messageKey <> \"\\\" not found. \"\n\ninstance IsHTTPError MerchantMessageError where\n  toErrorCode = \\case\n    MerchantMessageNotFound _ _ -> \"MERCHANT_MESSAGE_NOT_FOUND\"\n  toHttpCode = \\case\n    MerchantMessageNotFound _ _ -> E500\n\ninstance IsAPIError MerchantMessageError\n\nnewtype SosError = SosIdDoesNotExist Text\n  deriving (Eq, Show, IsBecknAPIError)\n\ninstanceExceptionWithParent 'HTTPException ''SosError\n\ninstance IsBaseError SosError where\n  toMessage (SosIdDoesNotExist sosId) = Just $ \"Sos with sosId \\\"\" <> show sosId <> \"\\\" not found. \"\n\ninstance IsHTTPError SosError where\n  toErrorCode _ = \"SOS_ID_DOES_NOT_EXITS\"\n  toHttpCode _ = E400\n\ninstance IsAPIError SosError\n\ndata PaymentOrderError\n  = PaymentOrderNotFound Text\n  | PaymentOrderDoesNotExist Text\n  | PayoutOrderAlreadyExists Text\n  | PayoutOrderDoesNotExist Text\n  | PayoutOrderNotFound Text\n  deriving (Eq, Show, IsBecknAPIError)\n\ninstanceExceptionWithParent 'HTTPException ''PaymentOrderError\n\ninstance IsBaseError PaymentOrderError where\n  toMessage = \\case\n    PaymentOrderNotFound orderId -> Just $ \"PaymentOrder with orderId \\\"\" <> show orderId <> \"\\\"not found. \"\n    PaymentOrderDoesNotExist orderId -> Just $ \"No payment order matches passed data \\\"\" <> show orderId <> \"\\\" not exist. \"\n    PayoutOrderAlreadyExists orderId -> Just $ \"Payout order with orderId \\\"\" <> show orderId <> \"\\\" already exists.\"\n    PayoutOrderDoesNotExist orderId -> Just $ \"No payout order matches passed data \\\"\" <> show orderId <> \"\\\" not exist. \"\n    PayoutOrderNotFound orderId -> Just $ \"Payout order with orderId \\\"\" <> show orderId <> \"\\\" not found.\"\n\ninstance IsHTTPError PaymentOrderError where\n  toErrorCode = \\case\n    PaymentOrderNotFound _ -> \"PAYMENT_ORDER_NOT_FOUND\"\n    PayoutOrderAlreadyExists _ -> \"PAYOUT_ORDER_ALREADY_EXISTS\"\n    PayoutOrderDoesNotExist _ -> \"PAYOUT_ORDER_DOES_NOT_EXIST\"\n    PayoutOrderNotFound _ -> \"PAYOUT_ORDER_NOT_FOUND\"\n    PaymentOrderDoesNotExist _ -> \"PAYMENT_ORDER_DOES_NOT_EXIST\"\n\n  toHttpCode = \\case\n    PaymentOrderNotFound _ -> E500\n    PayoutOrderAlreadyExists _ -> E400\n    PayoutOrderDoesNotExist _ -> E400\n    PayoutOrderNotFound _ -> E500\n    PaymentOrderDoesNotExist _ -> E400\n\ninstance IsAPIError PaymentOrderError\n\ndata DriverFeeError\n  = DriverFeeNotFound Text\n  | DriverFeeAlreadySettled Text\n  | DriverFeeNotInUse Text\n  deriving (Eq, Show, IsBecknAPIError)\n\ninstanceExceptionWithParent 'HTTPException ''DriverFeeError\n\ninstance IsBaseError DriverFeeError where\n  toMessage = \\case\n    DriverFeeNotFound driverFeeId -> Just $ \"DriverFee with id \\\"\" <> show driverFeeId <> \"\\\"not found. \"\n    DriverFeeAlreadySettled driverFeeId -> Just $ \"DriverFee with id \\\"\" <> show driverFeeId <> \"\\\"is already settled.\"\n    DriverFeeNotInUse driverFeeId -> Just $ \"DriverFee with id \\\"\" <> show driverFeeId <> \"\\\"is either Ongoing or Inactive.\"\n\ninstance IsHTTPError DriverFeeError where\n  toErrorCode = \\case\n    DriverFeeNotFound _ -> \"DRIVER_FEE_NOT_FOUND\"\n    DriverFeeAlreadySettled _ -> \"DRIVER_FEE_ALREADY_SETTLED\"\n    DriverFeeNotInUse _ -> \"DRIVER_FEE_NOT_ACTIVE\"\n\n  toHttpCode = \\case\n    DriverFeeNotFound _ -> E500\n    DriverFeeAlreadySettled _ -> E400\n    DriverFeeNotInUse _ -> E400\n\ninstance IsAPIError DriverFeeError\n\nnewtype TicketError\n  = TicketDoesNotExist Text\n  deriving (Eq, Show, IsBecknAPIError)\n\ninstanceExceptionWithParent 'HTTPException ''TicketError\n\ninstance IsBaseError TicketError where\n  toMessage = \\case\n    TicketDoesNotExist ticketId -> Just $ \"Ticket with ticketId \\\"\" <> show ticketId <> \"\\\"not found. \"\n\ninstance IsHTTPError TicketError where\n  toErrorCode = \\case\n    TicketDoesNotExist _ -> \"TICKET_DOES_NOT_EXIST\"\n  toHttpCode = \\case\n    TicketDoesNotExist _ -> E400\n\ninstance IsAPIError TicketError\n\ndata OsrmError\n  = FailedToCallOsrmRouteAPI Text\n  | FailedToCallOsrmTableAPI Text\n  | FailedToCallOsrmMatchAPI Text\n  deriving (Eq, Show, IsBecknAPIError)\n\ninstanceExceptionWithParent 'HTTPException ''OsrmError\n\ninstance IsBaseError OsrmError where\n  toMessage = \\case\n    FailedToCallOsrmRouteAPI err -> Just $ \"Failed to call osrm route API: \" <> err\n    FailedToCallOsrmTableAPI err -> Just $ \"Failed to call osrm table API: \" <> err\n    FailedToCallOsrmMatchAPI err -> Just $ \"Failed to call orsm match API: \" <> err\n\ninstance IsHTTPError OsrmError where\n  toErrorCode = \\case\n    FailedToCallOsrmRouteAPI _ -> \"FAILED_TO_CALL_OSRM_ROUTE_API\"\n    FailedToCallOsrmTableAPI _ -> \"FAILED_TO_CALL_OSRM_TABLE_API\"\n    FailedToCallOsrmMatchAPI _ -> \"FAILED_TO_CALL_OSRM_MATCH_API\"\n  toHttpCode = \\case\n    FailedToCallOsrmRouteAPI _ -> E400\n    FailedToCallOsrmTableAPI _ -> E400\n    FailedToCallOsrmMatchAPI _ -> E400\n\ninstance IsAPIError OsrmError\n\ndata EditLocationError\n  = PickupOrDropLocationNotFound\n  | EditPickupLocationNotServiceable\n  | DriverAboutToReachAtInitialPickup Text\n  | EditLocationAttemptsExhausted\n  deriving (Eq, Show, IsBecknAPIError)\n\ninstanceExceptionWithParent 'HTTPException ''EditLocationError\n\ninstance IsBaseError EditLocationError where\n  toMessage = \\case\n    PickupOrDropLocationNotFound -> Just \"Both pickup and/or drop location not found. Any one of them must be passed\"\n    EditPickupLocationNotServiceable -> Just \"Editing Pickup Locaton is not serviceable due as the requested location in not within the allowed pickup location distance threshold\"\n    DriverAboutToReachAtInitialPickup x -> Just $ \"Driver is \\\"\" <> show x <> \"\\\" meters away from your initial pickup location so editing pickup location is not possible\"\n    EditLocationAttemptsExhausted -> Just \"Number of attempts for editing location have exhausted\"\n\ninstance IsHTTPError EditLocationError where\n  toErrorCode = \\case\n    PickupOrDropLocationNotFound -> \"PICKUP_OR_DROP_LOCATION_NOT_FOUND\"\n    EditPickupLocationNotServiceable -> \"EDIT_PICKUP_LOCATION_NOT_SERVICEABLE\"\n    DriverAboutToReachAtInitialPickup _ -> \"DRIVER_ABOUT_TO_REACH_AT_INITIAL_PICKUP\"\n    EditLocationAttemptsExhausted -> \"EDIT_LOCATION_ATTEMPTS_EXHAUSTED\"\n\n  toHttpCode = \\case\n    PickupOrDropLocationNotFound -> E400\n    EditPickupLocationNotServiceable -> E400\n    DriverAboutToReachAtInitialPickup _ -> E400\n    EditLocationAttemptsExhausted -> E400\n\ninstance IsAPIError EditLocationError\n\ndata NextBillionError\n  = FailedToCallNextBillionRouteAPI Text\n  deriving (Eq, Show, IsBecknAPIError)\n\ninstanceExceptionWithParent 'HTTPException ''NextBillionError\n\ninstance IsBaseError NextBillionError where\n  toMessage = \\case\n    FailedToCallNextBillionRouteAPI err -> Just $ \"Failed to call next billion route API: \" <> err\n\ninstance IsHTTPError NextBillionError where\n  toErrorCode = \\case\n    FailedToCallNextBillionRouteAPI _ -> \"FAILED_TO_CALL_NEXT_BILLION_ROUTE_API\"\n  toHttpCode = \\case\n    FailedToCallNextBillionRouteAPI _ -> E400\n\ninstance IsAPIError NextBillionError\n\ndata RideRelatedNotificationError\n  = RideRelatedNotificationConfigNotFound Text\n  deriving (Eq, Show, IsBecknAPIError)\n\ninstanceExceptionWithParent 'HTTPException ''RideRelatedNotificationError\n\ninstance IsBaseError RideRelatedNotificationError where\n  toMessage (RideRelatedNotificationConfigNotFound merchantOperatingCityId) = Just $ \"RideRelatedNotification with merchantOperatingCityId \\\"\" <> show merchantOperatingCityId <> \"\\\" not found.\"\n\ninstance IsHTTPError RideRelatedNotificationError where\n  toErrorCode = \\case\n    RideRelatedNotificationConfigNotFound _ -> \"RIDE_RELATED_NOTIFICATION_CONFIG_NOT_FOUND\"\n  toHttpCode = \\case\n    RideRelatedNotificationConfigNotFound _ -> E500\n\ninstance IsAPIError RideRelatedNotificationError\n\ndata MerchantPNError\n  = MerchantPNNotFound Text Text\n  deriving (Eq, Show, IsBecknAPIError)\n\ninstanceExceptionWithParent 'HTTPException ''MerchantPNError\n\ninstance IsBaseError MerchantPNError where\n  toMessage = \\case\n    MerchantPNNotFound merchantOperatingCityId messageKey -> Just $ \"MerchantPushNotification with merchantOperatingCityId \\\"\" <> show merchantOperatingCityId <> \" and message key\" <> show messageKey <> \"\\\" not found. \"\n\ninstance IsHTTPError MerchantPNError where\n  toErrorCode = \\case\n    MerchantPNNotFound _ _ -> \"MERCHANT_PN_NOT_FOUND\"\n  toHttpCode = \\case\n    MerchantPNNotFound _ _ -> E500\n\ninstance IsAPIError MerchantPNError\n\ndata PayoutConfigError\n  = PayoutConfigNotFound Text Text\n  deriving (Eq, Show, IsBecknAPIError)\n\ninstanceExceptionWithParent 'HTTPException ''PayoutConfigError\n\ninstance IsBaseError PayoutConfigError where\n  toMessage = \\case\n    PayoutConfigNotFound merchantOperatingCityId vehicleCategory -> Just $ \"Payout for merchantOperatingCityId \\\"\" <> show merchantOperatingCityId <> \" and Vehicle category \" <> show vehicleCategory <> \"\\\" not found. \"\n\ninstance IsHTTPError PayoutConfigError where\n  toErrorCode = \\case\n    PayoutConfigNotFound _ _ -> \"PAYOUT_CONFIG_NOT_FOUND\"\n  toHttpCode = \\case\n    PayoutConfigNotFound _ _ -> E500\n\ninstance IsAPIError PayoutConfigError\n\ndata CallFeedbackError\n  = CallFeedbackOptionsDoesNotExist Text\n  deriving (Eq, Show, IsBecknAPIError)\n\ninstanceExceptionWithParent 'HTTPException ''CallFeedbackError\n\ninstance IsBaseError CallFeedbackError where\n  toMessage (CallFeedbackOptionsDoesNotExist callFeedbackOptionID) = Just $ \"No Call Feedback Options found for \" <> callFeedbackOptionID\n\ninstance IsHTTPError CallFeedbackError where\n  toErrorCode = \\case\n    CallFeedbackOptionsDoesNotExist _ -> \"CALL_FEEDBACK_OPTIONS_DOES_NOT_EXIST\"\n  toHttpCode = \\case\n    CallFeedbackOptionsDoesNotExist _ -> E400\n\ninstance IsAPIError CallFeedbackError\n\ndata ClickToCallError\n  = ClickToCallNotConfigured\n  | ClickToCallBadRequest\n  | ClickToCallUnauthorized\n  | ClickToCallPaymentRequired\n  | ClickToCallAccessDenied\n  | ClickToCallNotFound\n  | ClickToCallConflict\n  | ClickToCallTooManyRequests\n  | ClickToCallServerError\n  | ClickToCallGenericError Text\n  deriving (Eq, Show, IsBecknAPIError)\n\ninstanceExceptionWithParent 'HTTPException ''ClickToCallError\n\ninstance FromResponse ClickToCallError where\n  fromResponse resp = case statusCode $ responseStatusCode resp of\n    400 -> Just ClickToCallBadRequest\n    401 -> Just ClickToCallUnauthorized\n    402 -> Just ClickToCallPaymentRequired\n    403 -> Just ClickToCallAccessDenied\n    404 -> Just ClickToCallNotFound\n    409 -> Just ClickToCallConflict\n    429 -> Just ClickToCallTooManyRequests\n    500 -> Just ClickToCallServerError\n    _ -> Just (ClickToCallGenericError (\"Unexpected status code: \" <> T.pack (show $ statusCode $ responseStatusCode resp)))\n\ninstance IsBaseError ClickToCallError where\n  toMessage = \\case\n    ClickToCallNotConfigured -> Just \"Tata ClickToCall env variables aren't properly set.\"\n    ClickToCallBadRequest -> Just \"Something in your header or request body was malformed.\"\n    ClickToCallUnauthorized -> Just \"Necessary credentials were either missing or invalid.\"\n    ClickToCallPaymentRequired -> Just \"The action is not available on your plan, or you have exceeded usage limits for your current plan.\"\n    ClickToCallAccessDenied -> Just \"Your credentials are valid, but you don't have access to the requested resource.\"\n    ClickToCallNotFound -> Just \"The object you're requesting doesn't exist.\"\n    ClickToCallConflict -> Just \"You might be trying to update the same resource concurrently.\"\n    ClickToCallTooManyRequests -> Just \"You are calling our APIs more frequently than we allow.\"\n    ClickToCallServerError -> Just \"Something went wrong on our end. Please try again.\"\n    ClickToCallGenericError msg -> Just (\"ClickToCall encountered an unexpected error: \" <> msg)\n\ninstance IsHTTPError ClickToCallError where\n  toErrorCode = \\case\n    ClickToCallNotConfigured -> \"CLICKTOCALL_NOT_CONFIGURED\"\n    ClickToCallBadRequest -> \"CLICKTOCALL_BAD_REQUEST\"\n    ClickToCallUnauthorized -> \"CLICKTOCALL_UNAUTHORIZED\"\n    ClickToCallPaymentRequired -> \"CLICKTOCALL_PAYMENT_REQUIRED\"\n    ClickToCallAccessDenied -> \"CLICKTOCALL_ACCESS_DENIED\"\n    ClickToCallNotFound -> \"CLICKTOCALL_NOT_FOUND\"\n    ClickToCallConflict -> \"CLICKTOCALL_CONFLICT\"\n    ClickToCallTooManyRequests -> \"CLICKTOCALL_TOO_MANY_REQUESTS\"\n    ClickToCallServerError -> \"CLICKTOCALL_SERVER_ERROR\"\n    ClickToCallGenericError msg -> \"CLICKTOCALL_GENERIC_ERROR: \" <> msg\n\ninstance IsAPIError ClickToCallError\n\ndata DigoEngageError\n  = DigoEngageInvalidRequest\n  | DigoEngageNotConfigured\n  | DigoEngageUserIdNotFound\n  | DigoEngageInvalidPhoneNumber\n  | DigoEngageUnauthorized\n  | DigoEngageWrongMethodService\n  | DigoEngageInterNationalPhoneNumber\n  | DigoEngageTooManyRequests\n  | DigoEngageUnknownServerError\n  | DigoEngageValidationError Text\n  deriving (Eq, Show, IsBecknAPIError)\n\ninstanceExceptionWithParent 'HTTPException ''DigoEngageError\n\ninstance IsBaseError DigoEngageError where\n  toMessage = \\case\n    DigoEngageInvalidRequest -> Just \"Invalid request to DigoEngage.\"\n    DigoEngageNotConfigured -> Just \"DigoEngage env variables aren't properly set.\"\n    DigoEngageUserIdNotFound -> Just \"DigoEngage Authentication Failed as userid X does not exist.\"\n    DigoEngageInvalidPhoneNumber -> Just \"The phone number XXXXX is not a valid phone number.\"\n    DigoEngageUnauthorized -> Just \"Authentication failed due to invalid userId or password.\"\n    DigoEngageWrongMethodService -> Just \"The method is not supported.\"\n    DigoEngageInterNationalPhoneNumber -> Just \"The INTERNATIONAL_PHONE service is disabled for you. Kindly get the service enabled before using this action\"\n    DigoEngageTooManyRequests -> Just \"The phone number has already been marked as requested\"\n    DigoEngageUnknownServerError -> Just \"An unknown exception has occurred. Please retry the request after some time.\"\n    DigoEngageValidationError msg -> Just (\"Error: \" <> msg)\n\ninstance IsHTTPError DigoEngageError where\n  toErrorCode = \\case\n    DigoEngageNotConfigured -> \"DIGOENGAGE_NOT_CONFIGURED\"\n    DigoEngageInvalidRequest -> \"DIGOENGAGE_INVALID_REQUEST\"\n    DigoEngageUserIdNotFound -> \"DIGOENGAGE_USER_NOT_FOUND\"\n    DigoEngageInvalidPhoneNumber -> \"DIGOENGAGE_INVALID_PHONE_NUMBER\"\n    DigoEngageUnauthorized -> \"DIGOENGAGE_AUTHENTICATION_FAILED\"\n    DigoEngageWrongMethodService -> \"DIGOENGAGE_WRONG_METHOD_SERVICE\"\n    DigoEngageInterNationalPhoneNumber -> \"DIGOENGAGE_INTERNATIONAL_PHONE_DISABLED\"\n    DigoEngageTooManyRequests -> \"DIGOENGAGE_TOO_MANY_REQUEST_FOR_SAME\"\n    DigoEngageUnknownServerError -> \"DIGOENGAGE_UNKNOWN_ERROR\"\n    DigoEngageValidationError msg -> \"DIGOENGAGE_ERROR: \" <> msg\n\ninstance FromResponse DigoEngageError where\n  fromResponse resp = case statusCode $ responseStatusCode resp of\n    400 -> Just DigoEngageInvalidRequest\n    401 -> Just DigoEngageUnauthorized\n    500 -> Just DigoEngageUnknownServerError\n    404 -> Just DigoEngageUserIdNotFound\n    _ -> Just DigoEngageNotConfigured\n\ninstance IsAPIError DigoEngageError\n\ndata TataCommunicationsWhatsappError\n  = TataCommunicationsWhatsappInvalidRequest\n  | TataCommunicationsWhatsappNotConfigured\n  | TataCommunicationsWhatsappUserIdNotFound\n  | TataCommunicationsWhatsappInvalidPhoneNumber\n  | TataCommunicationsWhatsappUnauthorized\n  | TataCommunicationsWhatsappWrongMethodService\n  | TataCommunicationsWhatsappInterNationalPhoneNumber\n  | TataCommunicationsWhatsappTooManyRequests\n  | TataCommunicationsWhatsapPermissionDenied\n  | TataCommunicationsWhatsapServiceUnavailable\n  | TataCommunicationsWhatsappUnknownServerError\n  | TataCommunicationsWhatsappGenericError Text\n  deriving (Eq, Show, IsBecknAPIError)\n\ninstanceExceptionWithParent 'HTTPException ''TataCommunicationsWhatsappError\n\ninstance IsBaseError TataCommunicationsWhatsappError where\n  toMessage = \\case\n    TataCommunicationsWhatsappInvalidRequest -> Just \"Invalid request to TataCommunicationsWhatsap.\"\n    TataCommunicationsWhatsappNotConfigured -> Just \"TataCommunicationsWhatsap env variables aren't properly set.\"\n    TataCommunicationsWhatsappUserIdNotFound -> Just \"TataCommunicationsWhatsap Authentication Failed as userid X does not exist.\"\n    TataCommunicationsWhatsappInvalidPhoneNumber -> Just \"The phone number XXXXX is not a valid phone number.\"\n    TataCommunicationsWhatsappUnauthorized -> Just \"Your access token has expired.\"\n    TataCommunicationsWhatsappWrongMethodService -> Just \"The method is not supported.\"\n    TataCommunicationsWhatsappInterNationalPhoneNumber -> Just \"The INTERNATIONAL_PHONE service is disabled for you. Kindly get the service enabled before using this action\"\n    TataCommunicationsWhatsappTooManyRequests -> Just \"The phone number has already been marked as requested\"\n    TataCommunicationsWhatsapPermissionDenied -> Just \"Permission is either not granted or has been removed.\"\n    TataCommunicationsWhatsapServiceUnavailable -> Just \"Temporary due to downtime or due to being overloaded.\"\n    TataCommunicationsWhatsappUnknownServerError -> Just \"An unknown exception has occurred. Please retry the request after some time.\"\n    TataCommunicationsWhatsappGenericError msg -> Just (\"Error: \" <> msg)\n\ninstance IsHTTPError TataCommunicationsWhatsappError where\n  toErrorCode = \\case\n    TataCommunicationsWhatsappNotConfigured -> \"TATA_COMMUNICATIONS_WHATSAPP_NOT_CONFIGURED\"\n    TataCommunicationsWhatsappInvalidRequest -> \"TATA_COMMUNICATIONS_WHATSAPP_INVALID_REQUEST\"\n    TataCommunicationsWhatsappUserIdNotFound -> \"TATA_COMMUNICATIONS_WHATSAPP_USER_NOT_FOUND\"\n    TataCommunicationsWhatsappInvalidPhoneNumber -> \"TATA_COMMUNICATIONS_WHATSAPP_INVALID_PHONE_NUMBER\"\n    TataCommunicationsWhatsappUnauthorized -> \"TATA_COMMUNICATIONS_WHATSAPP_AUTHENTICATION_FAILED\"\n    TataCommunicationsWhatsappWrongMethodService -> \"TATA_COMMUNICATIONS_WHATSAPP_WRONG_METHOD_SERVICE\"\n    TataCommunicationsWhatsappInterNationalPhoneNumber -> \"TATA_COMMUNICATIONS_WHATSAPP_INTERNATIONAL_PHONE_DISABLED\"\n    TataCommunicationsWhatsappTooManyRequests -> \"TATA_COMMUNICATIONS_WHATSAPP_TOO_MANY_REQUEST_FOR_SAME\"\n    TataCommunicationsWhatsapPermissionDenied -> \"TATA_COMMUNICATIONS_WHATSAPP_PERMISSION_DENIED\"\n    TataCommunicationsWhatsapServiceUnavailable -> \"TATA_COMMUNICATIONS_WHATSAPP_SERVICE_UNAVAILABLE\"\n    TataCommunicationsWhatsappUnknownServerError -> \"TATA_COMMUNICATIONS_WHATSAPP_UNKNOWN_ERROR\"\n    TataCommunicationsWhatsappGenericError msg -> \"TATA_COMMUNICATIONS_WHATSAPP_ERROR: \" <> msg\n\ninstance FromResponse TataCommunicationsWhatsappError where\n  fromResponse resp = case statusCode $ responseStatusCode resp of\n    400 -> Just TataCommunicationsWhatsappInvalidRequest\n    401 -> Just TataCommunicationsWhatsappUnauthorized\n    403 -> Just TataCommunicationsWhatsapPermissionDenied\n    500 -> Just TataCommunicationsWhatsappUnknownServerError\n    503 -> Just TataCommunicationsWhatsapServiceUnavailable\n    404 -> Just TataCommunicationsWhatsappUserIdNotFound\n    _ -> Just TataCommunicationsWhatsappNotConfigured\n\ninstance IsAPIError TataCommunicationsWhatsappError\n\ninstance ToJSON ClientError where\n  toJSON = DA.String . show\n",
      "hash": "e177de38539dfdacc4e7cbf12b3d3d63c448bb9d8bce46247199237f89483720",
      "size": 57994
    },
    "/lib/mobility-core/src/Kernel/Types/Error/BaseError.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n\nmodule Kernel.Types.Error.BaseError where\n\nimport Control.Exception\nimport EulerHS.Prelude hiding (Show, pack, show)\nimport Prelude (Show (..))\n\ntype IsBaseException e = (IsBaseError e, Exception e)\n\nclass IsBaseError e where\n  toMessage :: e -> Maybe Text\n  toMessage _ = Nothing\n\ndata BaseException = forall e. IsBaseException e => BaseException e\n\ninstance Show BaseException where\n  show (BaseException e) = show e\n\ninstance Exception BaseException\n",
      "hash": "a50dcc30cb7ffe9a054416f486916fa115475ff901e0c2b81a1c5b8fa199da97",
      "size": 1147
    },
    "/lib/mobility-core/src/Kernel/Types/Error/BaseError/HTTPError.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n{-# LANGUAGE TemplateHaskell #-}\n\nmodule Kernel.Types.Error.BaseError.HTTPError\n  ( module Kernel.Types.Error.BaseError.HTTPError,\n    module Kernel.Types.Error.BaseError.HTTPError.HttpCode,\n    module Kernel.Types.Error.BaseError.HTTPError.APIError,\n    module Kernel.Types.Error.BaseError.HTTPError.BecknAPIError,\n    module Kernel.Types.Error.BaseError,\n    instanceExceptionWithParent,\n  )\nwhere\n\nimport Control.Exception\nimport EulerHS.Prelude hiding (Show, pack, show)\nimport Kernel.Types.Error.BaseError\nimport Kernel.Types.Error.BaseError.HTTPError.APIError\nimport Kernel.Types.Error.BaseError.HTTPError.BecknAPIError\nimport Kernel.Types.Error.BaseError.HTTPError.HttpCode\nimport Kernel.Utils.Error.Hierarchy (instanceExceptionWithParent)\nimport Network.HTTP.Types (Header)\nimport Prelude (Show (..))\n\ntype IsHTTPException e = (IsHTTPError e, IsAPIError e, IsBecknAPIError e, Exception e)\n\nclass IsBaseError e => IsHTTPError e where\n  toErrorCode :: e -> Text\n\n  toHttpCode :: e -> HttpCode\n  toHttpCode _ = E500\n\n  toCustomHeaders :: e -> [Header]\n  toCustomHeaders _ = []\n\ndata HTTPException = forall e. (Exception e, IsHTTPException e) => HTTPException e\n\ninstance IsBaseError HTTPException where\n  toMessage (HTTPException e) = toMessage e\n\ninstance IsHTTPError HTTPException where\n  toErrorCode (HTTPException e) = toErrorCode e\n  toHttpCode (HTTPException e) = toHttpCode e\n  toCustomHeaders (HTTPException e) = toCustomHeaders e\n\ninstance Show HTTPException where\n  show (HTTPException e) = show e\n\ninstanceExceptionWithParent 'BaseException ''HTTPException\n\ntoMessageIfNotInternal :: IsHTTPError e => e -> Maybe Text\ntoMessageIfNotInternal e = if isInternalError (toHttpCode e) then Nothing else toMessage e\n",
      "hash": "34bb8354453aeb7e5e63164792bffdf17c99f2ffde5b86f4062d6ab0a8950817",
      "size": 2417
    },
    "/lib/mobility-core/src/Kernel/Types/Error/BaseError/HTTPError/APIError.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n\nmodule Kernel.Types.Error.BaseError.HTTPError.APIError\n  ( module Kernel.Types.Error.BaseError.HTTPError.APIError,\n    module Kernel.Types.Error.BaseError.HTTPError.HttpCode,\n    module Kernel.Types.Error.BaseError,\n  )\nwhere\n\nimport Control.Exception\nimport Data.Aeson (Value (Null))\nimport EulerHS.Prelude hiding (Show, pack, show)\nimport Kernel.Types.Error.BaseError\nimport Kernel.Types.Error.BaseError.HTTPError.FromResponse\nimport Kernel.Types.Error.BaseError.HTTPError.HttpCode\nimport Prelude (Show (..))\n\ntype IsAPIException e = (IsAPIError e, Exception e)\n\ndata APIError = APIError\n  { errorCode :: Text,\n    errorMessage :: Maybe Text,\n    errorPayload :: Value\n  }\n  deriving (Generic, Show, FromJSON, ToJSON)\n\ninstance FromResponse APIError where\n  fromResponse = fromJsonResponse\n\nclass IsAPIError e where\n  toPayload :: e -> Value\n  toPayload _ = Null\n",
      "hash": "b0ffe82c9ce6157459a546e13cd5ac336b905c583dea732e8bc1cead258ed04f",
      "size": 1559
    },
    "/lib/mobility-core/src/Kernel/Types/Error/BaseError/HTTPError/BecknAPIError.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n\nmodule Kernel.Types.Error.BaseError.HTTPError.BecknAPIError\n  ( module Kernel.Types.Error.BaseError.HTTPError.BecknAPIError,\n    Error.Error (..),\n    Error.ErrorType (..),\n  )\nwhere\n\nimport Data.Aeson.Types\nimport EulerHS.Prelude hiding (Show, show)\nimport qualified Kernel.Types.Beckn.Error as Error\nimport Kernel.Types.Error.BaseError.HTTPError.FromResponse\nimport Prelude (Show (..))\n\nclass IsBecknAPIError e where\n  toType :: e -> Error.ErrorType\n  toType _ = Error.INTERNAL_ERROR\n\n  toPath :: e -> Maybe Text\n  toPath _ = Nothing\n\nnewtype BecknAPIError = BecknAPIError Error.Error\n  deriving (Generic, Eq, Show)\n\ninstance FromJSON BecknAPIError where\n  parseJSON (Object v) = BecknAPIError <$> v .: \"error\"\n  parseJSON invalid =\n    prependFailure\n      \"Parsing BecknAPIError failed, \"\n      (typeMismatch \"Object\" invalid)\n\ninstance ToJSON BecknAPIError where\n  toJSON (BecknAPIError err) = object [\"message\" .= ack, \"error\" .= err]\n    where\n      ack = object [\"ack\" .= status]\n      status = object [\"status\" .= (\"NACK\" :: Text)]\n\ninstance FromResponse BecknAPIError where\n  fromResponse = fromJsonResponse\n",
      "hash": "f1d5b96694081072995476172d45f578bf08a43676d659e96dde2bb340276ad4",
      "size": 1812
    },
    "/lib/mobility-core/src/Kernel/Types/Error/BaseError/HTTPError/CallAPIError.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n\nmodule Kernel.Types.Error.BaseError.HTTPError.CallAPIError where\n\nimport EulerHS.Prelude\nimport Kernel.Types.Common\nimport Kernel.Types.Error\nimport Kernel.Types.Error.BaseError.HTTPError (IsBaseException)\nimport Kernel.Types.Error.BaseError.HTTPError.FromResponse\nimport Kernel.Utils.Error.Throwing\nimport Servant.Client (ClientError (..))\n\ndata CallAPIError err = RawError ClientError | APIError err\n\nextractApiError ::\n  FromResponse err =>\n  Either ClientError a ->\n  Either (CallAPIError err) a\nextractApiError = \\case\n  Left err@(FailureResponse _ response) ->\n    Left $ maybe (RawError err) APIError (fromResponse response)\n  Left l -> Left (RawError l)\n  Right a -> Right a\n\nunwrapEitherCallAPIError ::\n  ( MonadThrow m,\n    Log m,\n    IsBaseException e\n  ) =>\n  Maybe Text ->\n  BaseUrl ->\n  (err -> e) ->\n  Either (CallAPIError err) a ->\n  m a\nunwrapEitherCallAPIError errorCodeMb baseUrl toBaseException = fromEitherM' $ \\case\n  RawError cliErr -> throwError $ ExternalAPICallError errorCodeMb baseUrl cliErr\n  APIError err -> throwError (toBaseException err)\n\nunwrapEitherOnlyFromRawError ::\n  (MonadThrow m, Log m) =>\n  Maybe Text ->\n  BaseUrl ->\n  Either (CallAPIError err) a ->\n  m (Either err a)\nunwrapEitherOnlyFromRawError errorCodeMb baseUrl = either left (pure . Right)\n  where\n    left = \\case\n      RawError cliErr -> throwError $ ExternalAPICallError errorCodeMb baseUrl cliErr\n      APIError err -> pure (Left err)\n",
      "hash": "e57ac5ad9d9ed53ea4115db3b4cb1ba6d60327cc522c6ee33c51d0f936ade553",
      "size": 2133
    },
    "/lib/mobility-core/src/Kernel/Types/Error/BaseError/HTTPError/FromResponse.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n\nmodule Kernel.Types.Error.BaseError.HTTPError.FromResponse where\n\nimport qualified Data.Aeson as A\nimport EulerHS.Prelude\nimport Servant.Client (Response, ResponseF (Response))\n\nclass FromResponse e where\n  fromResponse :: Response -> Maybe e\n\nfromJsonResponse :: FromJSON a => Response -> Maybe a\nfromJsonResponse (Response _ _ _ body) = A.decode body\n",
      "hash": "3ff0e28a4192feed754159db66524ad5de87358e40a8380212a2dc16bb040017",
      "size": 1047
    },
    "/lib/mobility-core/src/Kernel/Types/Error/BaseError/HTTPError/HttpCode.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n\nmodule Kernel.Types.Error.BaseError.HTTPError.HttpCode where\n\nimport EulerHS.Prelude\nimport Servant.Server.Internal\n\ndata HttpCode\n  = E400\n  | E401\n  | E402\n  | E403\n  | E404\n  | E409\n  | E412\n  | E413\n  | E415\n  | E422\n  | E429\n  | E500\n  | E501\n  | E503\n  deriving (Show)\n\ncodeToHttpCode :: Int -> Maybe HttpCode\ncodeToHttpCode = \\case\n  400 -> Just E400\n  401 -> Just E401\n  402 -> Just E402\n  403 -> Just E403\n  404 -> Just E404\n  409 -> Just E409\n  412 -> Just E412\n  413 -> Just E413\n  415 -> Just E415\n  422 -> Just E422\n  429 -> Just E429\n  500 -> Just E500\n  501 -> Just E501\n  503 -> Just E503\n  _ -> Nothing\n\ncodeToHttpCodeWith500Default :: Int -> HttpCode\ncodeToHttpCodeWith500Default = fromMaybe E500 . codeToHttpCode\n\ntoServerError :: HttpCode -> ServerError\ntoServerError = \\case\n  E400 -> err400\n  E401 -> err401\n  E402 -> err402\n  E403 -> err403\n  E404 -> err404\n  E409 -> err409\n  E412 -> err412\n  E413 -> err413\n  E415 -> err415\n  E422 -> err422\n  E429 ->\n    ServerError\n      { errHTTPCode = 429,\n        errReasonPhrase = \"Too Many Requests\",\n        errBody = \"\",\n        errHeaders = []\n      }\n  E500 -> err500\n  E501 -> err501\n  E503 -> err503\n\nisInternalError :: HttpCode -> Bool\nisInternalError = \\case\n  E400 -> False\n  E401 -> False\n  E402 -> False\n  E403 -> False\n  E404 -> False\n  E409 -> False\n  E412 -> False\n  E413 -> False\n  E415 -> False\n  E422 -> False\n  E429 -> False\n  E500 -> True\n  E501 -> True\n  E503 -> True\n",
      "hash": "6c2acf6bde9cd8ee0c067b649010ea9105a91ca31e815c4666d7fab5b7b147c7",
      "size": 2147
    },
    "/lib/mobility-core/src/Kernel/Types/Field.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n\nmodule Kernel.Types.Field where\n\nimport qualified Data.Generics.Labels as GL\nimport Data.Kind (Constraint, Type)\nimport GHC.Base (Symbol)\nimport GHC.Records.Extra (HasField)\n\n-- | An alias for type-level pair of name and type.\ntype (name :: Symbol) ::: (ty :: Type) = '(name, ty)\n\n-- | Version of 'HasField' which complies with both record-dot-preprocessor\n-- and @.field@ syntax supported by generics-lens.\n--\n-- Re-evaluate this once we decide on a uniform way to access fields.\ntype HasFieldSuper name r ty = (HasField name r ty, GL.Field name r r ty ty)\n\n-- | Bulk version of @HasField@.\ntype family HasFields (r :: Type) (fields :: [(Symbol, Type)]) :: Constraint where\n  HasFields r '[] = () :: Constraint\n  HasFields r ('(name, ty) ': fields) =\n    (HasFieldSuper name r ty, HasFields r fields)\n",
      "hash": "8201321c0aab0e010f6e81bb6099049ce41dc95b91f021d62dca73ca86241c12",
      "size": 1496
    },
    "/lib/mobility-core/src/Kernel/Types/Flow.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n{-# LANGUAGE DerivingStrategies #-}\n{-# LANGUAGE GeneralizedNewtypeDeriving #-}\n{-# OPTIONS_GHC -Wno-orphans #-}\n\nmodule Kernel.Types.Flow (FlowR, runFlowR, HasFlowHandlerR, logRequestIdForFork) where\n\nimport Control.Monad.IO.Unlift\nimport Data.Aeson\nimport Data.Default.Class\nimport qualified Data.Map.Strict as M\nimport qualified EulerHS.Interpreters as I\nimport qualified EulerHS.Language as L\nimport EulerHS.Prelude\nimport qualified EulerHS.Runtime as R\nimport Kernel.Beam.Lib.UtilsTH\nimport Kernel.Prelude hiding (forM_, mapM_)\nimport Kernel.Storage.Beam.SystemConfigs\nimport Kernel.Storage.Esqueleto.Config\nimport Kernel.Storage.Hedis.Config\nimport Kernel.Tools.ARTUtils (ArtData (..), HasARTFlow, pushToKafka)\nimport qualified Kernel.Tools.Metrics.CoreMetrics as Metrics\nimport Kernel.Tools.Metrics.CoreMetrics.Types\nimport Kernel.Types.CacheFlow\nimport Kernel.Types.Forkable\nimport Kernel.Types.Logging\nimport Kernel.Types.MonadGuid\nimport Kernel.Types.Time\nimport qualified Kernel.Utils.IOLogging as IOLogging\nimport Kernel.Utils.Logging\nimport Prometheus (MonadMonitor (..))\n\nrunFlowR :: R.FlowRuntime -> r -> FlowR r a -> IO a\nrunFlowR flowRt r (FlowR x) = I.runFlow flowRt . runReaderT x $ r\n\nnewtype FlowR r a = FlowR {unFlowR :: ReaderT r L.Flow a}\n  deriving newtype\n    ( Functor,\n      Applicative,\n      Monad,\n      MonadReader r,\n      MonadThrow,\n      MonadCatch,\n      MonadMask\n    )\n\ntype HasFlowHandlerR m r =\n  ( HasCacheConfig r,\n    HasCacConfig r,\n    HasCoreMetrics r,\n    HedisFlow m r,\n    EsqDBFlow m r,\n    IOLogging.HasLog r,\n    HasSchemaName SystemConfigsT\n  )\n\ninstance L.MonadFlow (FlowR r) where\n  {-# INLINEABLE callServantAPI #-}\n  callServantAPI mbMgrSel url cl = FlowR $ L.callServantAPI mbMgrSel url cl\n  {-# INLINEABLE callAPIUsingManager #-}\n  callAPIUsingManager mgr url cl = FlowR $ L.callAPIUsingManager mgr url cl\n  {-# INLINEABLE lookupHTTPManager #-}\n  lookupHTTPManager mMgrSel = FlowR $ L.lookupHTTPManager mMgrSel\n  {-# INLINEABLE getHTTPManager #-}\n  getHTTPManager settings = FlowR $ L.getHTTPManager settings\n  {-# INLINEABLE getConfig #-}\n  getConfig k = FlowR $ L.getConfig k\n  {-# INLINEABLE setConfig #-}\n  setConfig k v = FlowR $ L.setConfig k v\n  {-# INLINEABLE trySetConfig #-}\n  trySetConfig k v = FlowR $ L.trySetConfig k v\n  {-# INLINEABLE delConfig #-}\n  delConfig k = FlowR $ L.delConfig k\n  {-# INLINEABLE acquireConfigLock #-}\n  acquireConfigLock k = FlowR $ L.acquireConfigLock k\n  {-# INLINEABLE releaseConfigLock #-}\n  releaseConfigLock k = FlowR $ L.releaseConfigLock k\n  {-# INLINEABLE modifyConfig #-}\n  modifyConfig k f = FlowR $ L.modifyConfig k f\n  {-# INLINEABLE modifyOption #-}\n  modifyOption k f = FlowR $ L.modifyOption k f\n  {-# INLINEABLE delOptionLocal #-}\n  delOptionLocal k = FlowR $ L.delOptionLocal k\n\n  -- \"callHTTPWithCert\" seems DEPRECATED, it advises the following in Euler-hs comments:-\n  -- Use \"getHTTPManager\"/\"callHTTPUsingManager\" instead. This method does not allow custom CA store\n  -- Commenting it out, to be deleted in a later iteration.\n  -- {-# INLINEABLE callHTTPWithCert #-}\n  -- callHTTPWithCert url cert = FlowR $ L.callHTTPWithCert url cert\n\n  {-# INLINEABLE evalLogger' #-}\n  evalLogger' logAct = FlowR $ L.evalLogger' logAct\n  {-# INLINEABLE runIO' #-}\n  runIO' descr ioAct = FlowR $ L.runIO' descr ioAct\n  {-# INLINEABLE getOption #-}\n  getOption k = FlowR $ L.getOption k\n  {-# INLINEABLE setOption #-}\n  setOption k v = FlowR $ L.setOption k v\n  {-# INLINEABLE getOptionLocal #-}\n  getOptionLocal k = FlowR $ L.getOptionLocal k\n  {-# INLINEABLE setOptionLocal #-}\n  setOptionLocal k v = FlowR $ L.setOptionLocal k v\n  {-# INLINEABLE delOption #-}\n  delOption k = FlowR $ L.delOption k\n  {-# INLINEABLE generateGUID #-}\n  generateGUID = FlowR L.generateGUID\n  {-# INLINEABLE runSysCmd #-}\n  runSysCmd cmd = FlowR $ L.runSysCmd cmd\n  {-# INLINEABLE initSqlDBConnection #-}\n  initSqlDBConnection cfg = FlowR $ L.initSqlDBConnection cfg\n  {-# INLINEABLE deinitSqlDBConnection #-}\n  deinitSqlDBConnection conn = FlowR $ L.deinitSqlDBConnection conn\n  {-# INLINEABLE getSqlDBConnection #-}\n  getSqlDBConnection cfg = FlowR $ L.getSqlDBConnection cfg\n  {-# INLINEABLE initKVDBConnection #-}\n  initKVDBConnection cfg = FlowR $ L.initKVDBConnection cfg\n  {-# INLINEABLE deinitKVDBConnection #-}\n  deinitKVDBConnection conn = FlowR $ L.deinitKVDBConnection conn\n  {-# INLINEABLE getKVDBConnection #-}\n  getKVDBConnection cfg = FlowR $ L.getKVDBConnection cfg\n  {-# INLINEABLE runDB #-}\n  runDB conn dbAct = FlowR $ L.runDB conn dbAct\n  {-# INLINEABLE runTransaction #-}\n  runTransaction conn dbAct = FlowR $ L.runTransaction conn dbAct\n  {-# INLINEABLE await #-}\n  await mbMcs awaitable = FlowR $ L.await mbMcs awaitable\n  {-# INLINEABLE runSafeFlow #-}\n  runSafeFlow flow = FlowR $ L.runSafeFlow flow\n  {-# INLINEABLE runKVDB #-}\n  runKVDB cName act = FlowR $ L.runKVDB cName act\n  {-# INLINEABLE runPubSub #-}\n  runPubSub act = FlowR $ L.runPubSub act\n  {-# INLINEABLE publish #-}\n  publish channel payload = FlowR $ L.publish channel payload\n  {-# INLINEABLE subscribe #-}\n  subscribe channels cb = FlowR $ L.subscribe channels cb\n  {-# INLINEABLE psubscribe #-}\n  psubscribe channels cb = FlowR $ L.psubscribe channels cb\n  {-# INLINEABLE withModifiedRuntime #-}\n  withModifiedRuntime f flow = FlowR $ L.withModifiedRuntime f flow\n  {-# INLINEABLE setLoggerContext #-}\n  setLoggerContext k v = FlowR $ L.setLoggerContext k v\n  {-# INLINEABLE getLoggerContext #-}\n  getLoggerContext k = FlowR $ L.getLoggerContext k\n  {-# INLINEABLE setLoggerContextMap #-}\n  setLoggerContextMap m = FlowR $ L.setLoggerContextMap m\n  {-# INLINEABLE callHTTPUsingManager #-}\n  callHTTPUsingManager mgr url = FlowR . L.callHTTPUsingManager mgr url\n  {-# INLINEABLE fork #-}\n  fork (FlowR f) = FlowR $ L.fork f\n  {-# INLINEABLE awaitableFork #-}\n  awaitableFork (FlowR f) = FlowR $ L.awaitableFork f\n\n-- {-# INLINEABLE callAPIUsingManager #-}\n-- callAPIUsingManager f flow = FlowR $ L.callAPIUsingManager f flow\n-- {-# INLINEABLE lookupHTTPManager #-}\n-- lookupHTTPManager f flow = FlowR $ L.lookupHTTPManager f flow\n-- {-# INLINEABLE getHTTPManager #-}\n-- getHTTPManager f flow = FlowR $ L.getHTTPManager f flow\n-- {-# INLINEABLE callHTTPUsingManager #-}\n-- callHTTPUsingManager f flow = FlowR $ L.callHTTPUsingManager f flow\n-- {-# INLINEABLE setLoggerContext #-}\n-- setLoggerContext f flow = FlowR $ L.setLoggerContext f flow\n-- {-# INLINEABLE setLoggerContext #-}\n-- setLoggerContext f flow = FlowR $ L.setLoggerContext f flow\n-- {-# INLINEABLE setLoggerContext #-}\n-- setLoggerContext f flow = FlowR $ L.setLoggerContext f flow\n-- {-# INLINEABLE setLoggerContext #-}\n-- setLoggerContext f flow = FlowR $ L.setLoggerContext f flow\n-- {-# INLINEABLE setLoggerContext #-}\n-- setLoggerContext f flow = FlowR $ L.setLoggerContext f flow\n-- {-# INLINEABLE setLoggerContext #-}\n-- setLoggerContext f flow = FlowR $ L.setLoggerContext f flow\n-- {-# INLINEABLE setLoggerContext #-}\n-- setLoggerContext f flow = FlowR $ L.setLoggerContext f flow\n-- {-# INLINEABLE setLoggerContext #-}\n-- setLoggerContext f flow = FlowR $ L.setLoggerContext f flow\n-- {-# INLINEABLE setLoggerContext #-}\n-- setLoggerContext f flow = FlowR $ L.setLoggerContext f flow\n-- {-# INLINEABLE setLoggerContext #-}\n-- setLoggerContext f flow = FlowR $ L.setLoggerContext f flow\n-- {-# INLINEABLE setLoggerContext #-}\n-- setLoggerContext f flow = FlowR $ L.setLoggerContext f flow\n\n-- `L.callAPIUsingManager', `L.lookupHTTPManager', `L.getHTTPManager',\n--       `L.callHTTPUsingManager', `L.getLoggerContext',\n--       `L.setLoggerContextMap', `L.modifyOption', `L.delOptionLocal',\n--       `L.getConfig', `L.setConfig', `L.modifyConfig', `L.trySetConfig',\n--       `L.delConfig', `L.acquireConfigLock',\n--       `L.releaseConfigLock', and `L.fork'\n\ninstance MonadIO (FlowR r) where\n  liftIO = FlowR . L.runIO\n\ninstance {-# OVERLAPPABLE #-} IOLogging.HasLog r => Log (FlowR r) where\n  logOutput = IOLogging.logOutputImplementation\n  withLogTag lc (FlowR flowR) = FlowR $ IOLogging.withLogTagImplementation lc flowR\n\ninstance MonadTime (FlowR r) where\n  getCurrentTime = liftIO getCurrentTime\n\ninstance MonadClock (FlowR r) where\n  getClockTime = liftIO getClockTime\n\ninstance Metrics.HasCoreMetrics r => Metrics.CoreMetrics (FlowR r) where\n  addRequestLatency = Metrics.addRequestLatencyImplementation\n  addDatastoreLatency = Metrics.addDatastoreLatencyImplementation\n  incrementErrorCounter = Metrics.incrementErrorCounterImplementation\n  addUrlCallRetries = Metrics.addUrlCallRetriesImplementation\n  addUrlCallRetryFailures = Metrics.addUrlCallFailuresImplementation\n  incrementSortedSetCounter = Metrics.incrementSortedSetCounterImplementation\n  incrementStreamCounter = Metrics.incrementStreamCounterImplementation\n  addGenericLatency = Metrics.addGenericLatencyImplementation\n  incrementSchedulerFailureCounter = Metrics.incrementSchedulerFailureCounterImplementation\n  incrementGenericMetrics = Metrics.incrementGenericMetrics'\n  incrementSystemConfigsFailedCounter = Metrics.incrementSystemConfigsFailedCounter'\n  addGenericLatencyMetrics = Metrics.addGenericLatencyMetricsImplementation\n\ninstance MonadMonitor (FlowR r) where\n  doIO = liftIO\n\ninstance MonadGuid (FlowR r) where\n  generateGUIDText = FlowR L.generateGUID\n\ninstance (Log (FlowR r), Metrics.CoreMetrics (FlowR r), HasARTFlow r) => Forkable (FlowR r) where\n  fork tag f = do\n    newLocalOptions <- newMVar mempty\n    -- logRequestIdForFork tag\n    FlowR $ ReaderT $ L.forkFlow tag . L.withModifiedRuntime (refreshLocalOptions newLocalOptions) . runReaderT (unFlowR $ handleForkExecution tag f)\n\n  forkMultiple tagAndFunction = do\n    newLocalOptions <- newMVar mempty\n    FlowR $ ReaderT $ L.forkFlow \"multiple-Forks\" . L.withModifiedRuntime (refreshLocalOptions newLocalOptions) . runReaderT (unFlowR $ handleForkExecutionMultiple tagAndFunction)\n\n  awaitableFork tag f = do\n    newLocalOptions <- newMVar mempty\n    FlowR $ ReaderT $ L.forkFlow' tag . L.withModifiedRuntime (refreshLocalOptions newLocalOptions) . runReaderT (unFlowR $ handleExc f)\n    where\n      handleExc f' = do\n        res <- try f'\n        case res of\n          Right a -> return a\n          Left e -> do\n            logError $ \"awaitableFork Thread \" <> show tag <> \" died with error: \" <> makeLogSomeException e\n            Metrics.incrementErrorCounter \"AWAITABLE_FORK_THREAD_ERROR\" e\n            liftIO $ throwIO e\n\nlogRequestIdForFork :: (Log (FlowR r), HasARTFlow r, Metrics.CoreMetrics (FlowR r)) => Text -> FlowR r ()\nlogRequestIdForFork tag = do\n  shouldLogRequestId <- asks (.shouldLogRequestId)\n  when (shouldLogRequestId && tag /= \"ArtData\") $ do\n    requestId <- fromMaybe \"\" <$> asks (.requestId)\n    kafkaConn <- asks (.kafkaProducerForART)\n    timestamp <- getCurrentTime\n    let response = def {requestId = requestId, forkedTag = Just tag, timestamp = Just timestamp}\n    liftIO $ pushToKafka kafkaConn (encode response) \"ART-Logs\" requestId\n\nhandleForkExecutionMultiple :: (Log (FlowR r), Metrics.CoreMetrics (FlowR r), HasARTFlow r) => [(Text, FlowR r ())] -> FlowR r ()\nhandleForkExecutionMultiple tagAndFunction = forM_ tagAndFunction $ \\(tag, f) -> do\n  handleForkExecution tag f\n\nhandleForkExecution :: (Log (FlowR r), Metrics.CoreMetrics (FlowR r)) => Text -> FlowR r () -> FlowR r ()\nhandleForkExecution tag f = try f >>= (`whenLeft` err)\n  where\n    err (e :: SomeException) = do\n      logError $ \"Thread \" <> tag <> \" died with error: \" <> makeLogSomeException e\n      Metrics.incrementErrorCounter \"FORKED_THREAD_ERROR\" e\n\nrefreshLocalOptions :: MVar (M.Map Text Any) -> R.FlowRuntime -> R.FlowRuntime\nrefreshLocalOptions newLocalOptions flowRt = flowRt {R._optionsLocal = newLocalOptions}\n",
      "hash": "013c856922d422e2644bfe27c2a7ae07208ed97b26e03a0abd3cde6a413044f6",
      "size": 12419
    },
    "/lib/mobility-core/src/Kernel/Types/Forkable.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n\nmodule Kernel.Types.Forkable where\n\nimport EulerHS.Prelude\nimport EulerHS.Types\n\nclass Forkable m where\n  fork :: Text -> m () -> m ()\n  awaitableFork :: Text -> m a -> m (Awaitable (Either Text a))\n  forkMultiple :: [(Text, m ())] -> m ()\n",
      "hash": "a4ee9a6ba5cc14c7dbfab9a69f9528aa78047dcdd65042a353456a05f983d9f0",
      "size": 934
    },
    "/lib/mobility-core/src/Kernel/Types/FromField.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n\nmodule Kernel.Types.FromField where\n\nimport Data.Aeson\nimport Data.ByteString.Internal (ByteString, unpackChars)\nimport Data.ByteString.Lazy (fromStrict)\nimport Data.Generics.Labels ()\nimport Database.Beam\nimport Database.Beam.Postgres\nimport qualified Database.PostgreSQL.Simple.FromField as DPSF\nimport Kernel.Prelude as KP\n\nfromFieldJSON ::\n  (Typeable a, FromJSON a) =>\n  DPSF.Field ->\n  Maybe ByteString ->\n  DPSF.Conversion a\nfromFieldJSON f mbValue = case mbValue of\n  Nothing -> DPSF.returnError UnexpectedNull f mempty\n  Just value' -> case decode $ fromStrict value' of\n    Just res -> pure res\n    Nothing -> DPSF.returnError ConversionFailed f (\"Could not 'read'\" <> KP.show value')\n\nfromFieldEnum ::\n  (Typeable a, Read a) =>\n  DPSF.Field ->\n  Maybe ByteString ->\n  DPSF.Conversion a\nfromFieldEnum f mbValue = case mbValue of\n  Nothing -> DPSF.returnError UnexpectedNull f mempty\n  Just value' ->\n    case readMaybe (unpackChars value') of\n      Just val -> pure val\n      _ -> DPSF.returnError ConversionFailed f (\"Could not 'read'\" <> KP.show value')\n\nfromFieldDefault ::\n  (Typeable a, Read a, DPSF.FromField a) =>\n  DPSF.Field ->\n  Maybe ByteString ->\n  DPSF.Conversion a\nfromFieldDefault f mbValue = case mbValue of\n  Nothing -> DPSF.returnError UnexpectedNull f mempty\n  Just _ -> DPSF.fromField f mbValue\n",
      "hash": "0cc385a95b7fcb351d9fbdd0d2f56018279ea04e0f9d4b3cabb3ff86879b2646",
      "size": 2019
    },
    "/lib/mobility-core/src/Kernel/Types/Geofencing.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n{-# LANGUAGE DerivingStrategies #-}\n{-# LANGUAGE StandaloneDeriving #-}\n{-# OPTIONS_GHC -Wno-orphans #-}\n\nmodule Kernel.Types.Geofencing where\n\nimport qualified Data.Text as T\nimport qualified Data.Vector as V\nimport qualified Database.Beam as B\nimport Database.Beam.Backend\nimport Database.Beam.Postgres\nimport Database.Esqueleto.Experimental\nimport Database.PostgreSQL.Simple.FromField (FromField (fromField))\nimport qualified Database.PostgreSQL.Simple.FromField as DPSF\nimport EulerHS.Prelude\nimport Kernel.Storage.Esqueleto.Types\nimport Kernel.Utils.Dhall hiding (maybe)\nimport Kernel.Utils.GenericPretty\n\ndata GeoRestriction\n  = Unrestricted\n  | Regions [Text]\n  deriving (Show, Generic, FromDhall, FromJSON, ToJSON, Read, Eq, Ord)\n\nfromFieldEnum' ::\n  DPSF.Field ->\n  Maybe ByteString ->\n  DPSF.Conversion GeoRestriction\nfromFieldEnum' f mbValue = case mbValue of\n  Nothing -> pure Unrestricted\n  Just _ -> Regions . V.toList <$> fromField f mbValue\n\ninstance FromField GeoRestriction where\n  fromField = fromFieldEnum'\n\ninstance HasSqlValueSyntax be Text => HasSqlValueSyntax be GeoRestriction where\n  sqlValueSyntax Unrestricted = sqlValueSyntax $ T.pack \"Unrestricted\"\n  sqlValueSyntax (Regions regions) = sqlValueSyntax $ \"{\" <> T.intercalate \",\" regions <> \"}\"\n\ninstance BeamSqlBackend be => B.HasSqlEqualityCheck be GeoRestriction\n\ninstance FromBackendRow Postgres GeoRestriction\n\ninstance PrettyShow GeoRestriction where\n  prettyShow = prettyShow . geoRestrictionToMaybeList\n\ngeoRestrictionToMaybeList :: GeoRestriction -> Maybe [Text]\ngeoRestrictionToMaybeList Unrestricted = Nothing\ngeoRestrictionToMaybeList (Regions xs) = Just xs\n\nmaybeListToGeoRestriction :: Maybe [Text] -> GeoRestriction\nmaybeListToGeoRestriction = maybe Unrestricted Regions\n\ninstance PersistField GeoRestriction where\n  toPersistValue = toPersistValue . fmap PostgresList . geoRestrictionToMaybeList\n  fromPersistValue x = maybeListToGeoRestriction <$> fromPersistValue x\n\ninstance PersistFieldSql GeoRestriction where\n  sqlType _ = SqlString\n\ndata GeofencingConfig = GeofencingConfig\n  { origin :: GeoRestriction,\n    destination :: GeoRestriction\n  }\n  deriving (Show, Generic, FromDhall, PrettyShow, FromJSON, ToJSON, Read)\n",
      "hash": "091b0ee9c46c0a9b940e09f154dede2ad28a2c85b46ee673fbcbd16932296fdb",
      "size": 2910
    },
    "/lib/mobility-core/src/Kernel/Types/GuidLike.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n\nmodule Kernel.Types.GuidLike where\n\nimport EulerHS.Prelude\nimport Kernel.Types.MonadGuid\n\nclass GuidLike m a where\n  generateGUID :: m a\n\ninstance MonadGuid m => GuidLike m Text where\n  generateGUID = generateGUIDText\n",
      "hash": "802292b06b6c708de20c99ea92d365d6992149736821baf2ffef64ebbaae29cd",
      "size": 912
    },
    "/lib/mobility-core/src/Kernel/Types/HideSecrets.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n{-# LANGUAGE DerivingStrategies #-}\n\nmodule Kernel.Types.HideSecrets where\n\nimport Kernel.Prelude\n\nclass ToJSON (ReqWithoutSecrets req) => HideSecrets req where\n  type ReqWithoutSecrets req\n  hideSecrets :: req -> ReqWithoutSecrets req\n  type ReqWithoutSecrets req = req\n\n-- FIXME next default implementation is not working\n-- default hideSecrets :: req -> req\n-- hideSecrets = identity\n\ninstance HideSecrets () where\n  hideSecrets = identity\n",
      "hash": "dc62f94fb9c08fde0449c49e300c4bb76f03e6e820434ab32d6d416559aa8717",
      "size": 1136
    },
    "/lib/mobility-core/src/Kernel/Types/Id.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n{-# LANGUAGE DerivingStrategies #-}\n{-# LANGUAGE GeneralizedNewtypeDeriving #-}\n\nmodule Kernel.Types.Id where\n\nimport Data.Hashable\nimport Data.OpenApi (ToParamSchema, ToSchema)\nimport qualified Data.Text as Text\nimport Database.PostgreSQL.Simple.FromField (FromField)\nimport Dhall\nimport EulerHS.Prelude\nimport Kernel.Types.GuidLike\nimport Kernel.Types.MonadGuid\nimport Kernel.Utils.Example (Example (..), idExample)\nimport Kernel.Utils.GenericPretty\nimport Servant (FromHttpApiData (parseUrlPiece), ToHttpApiData)\n\nnewtype Id domain = Id\n  {getId :: Text}\n  deriving stock (Generic, Show, Eq, Ord, Read)\n  deriving newtype (ToJSON, FromJSON, ToHttpApiData, ToSchema, ToParamSchema, FromField, PrettyShow)\n\ncast :: Id a -> Id b\ncast = Id . getId\n\ninstance Example (Id a) where\n  example = Id idExample\n\ninstance IsString (Id d) where\n  fromString = Id . Text.pack\n\ninstance FromHttpApiData (Id a) where\n  parseUrlPiece = pure . Id\n\ninstance (MonadGuid m) => GuidLike m (Id a) where\n  generateGUID = Id <$> generateGUIDText\n\nnewtype ShortId domain = ShortId\n  { getShortId :: Text\n  }\n  deriving stock (Generic, Show, Eq, Ord, Read)\n  deriving newtype (ToJSON, FromJSON, ToHttpApiData, ToSchema, ToParamSchema, PrettyShow)\n\ninstance FromDhall (ShortId a) where\n  autoWith _ = ShortId <$> strictText\n\ninstance IsString (ShortId d) where\n  fromString = ShortId . Text.pack\n\ninstance FromHttpApiData (ShortId a) where\n  parseUrlPiece = pure . ShortId\n\ninstance (MonadGuid m) => GuidLike m (ShortId a) where\n  generateGUID = ShortId <$> generateGUIDText\n\ninstance Hashable (Id a) where\n  hashWithSalt s (Id t) = hashWithSalt s t\n  hash (Id t) = hash t\n\ninstance Hashable (ShortId a) where\n  hashWithSalt s (ShortId t) = hashWithSalt s t\n  hash (ShortId t) = hash t\n",
      "hash": "15d9187f51fd1cdf39085902cad4dfb45dd4268514e39ae28cc0a7efba7d0809",
      "size": 2454
    },
    "/lib/mobility-core/src/Kernel/Types/Logging.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n\nmodule Kernel.Types.Logging where\n\nimport EulerHS.Prelude\nimport Kernel.Utils.Dhall (FromDhall)\n\ndata LogLevel = DEBUG | INFO | WARNING | ERROR\n  deriving (Generic, Show, Eq, Ord, FromDhall, ToJSON, FromJSON)\n\nclass Log m where\n  logOutput :: LogLevel -> Text -> m ()\n  withLogTag :: Text -> m a -> m a\n\ndata LoggerConfig = LoggerConfig\n  { level :: LogLevel,\n    logToFile :: Bool,\n    logFilePath :: FilePath,\n    logToConsole :: Bool,\n    logRawSql :: Bool,\n    prettyPrinting :: Bool\n  }\n  deriving (Generic, FromDhall)\n\ndefaultLoggerConfig :: LoggerConfig\ndefaultLoggerConfig =\n  LoggerConfig\n    { level = DEBUG,\n      logFilePath = \"/tmp/default\",\n      logToFile = False,\n      logToConsole = False,\n      logRawSql = False,\n      prettyPrinting = False\n    }\n",
      "hash": "dc2ce13c555e570bcd97ce239d7585525871d82a7529da287477bc2579bc17fe",
      "size": 1462
    },
    "/lib/mobility-core/src/Kernel/Types/MonadGuid.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n\nmodule Kernel.Types.MonadGuid where\n\nimport qualified Data.UUID as UUID\nimport qualified Data.UUID.V4 as UUID\nimport EulerHS.Prelude\n\nclass Monad m => MonadGuid m where\n  generateGUIDText :: m Text\n\ngenerateGUIDTextIO :: IO Text\ngenerateGUIDTextIO = UUID.toText <$> liftIO UUID.nextRandom\n",
      "hash": "e10555addd0199ffe4bc8486af1eb611878ed03f39ba9bbe1e6c0072b3c62f47",
      "size": 983
    },
    "/lib/mobility-core/src/Kernel/Types/Predicate.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n\nmodule Kernel.Types.Predicate\n  ( module Kernel.Types.Predicate,\n    module Kleene,\n    (\\/),\n  )\nwhere\n\nimport Algebra.Lattice\nimport qualified Data.Foldable as F\nimport Data.Ix (inRange)\nimport Data.List (nub)\nimport qualified Data.Text as T\nimport EulerHS.Prelude\nimport GHC.Records.Extra\nimport GHC.TypeLits (KnownSymbol, symbolVal)\nimport Kernel.Types.Value\nimport Kleene\nimport qualified Kleene.DFA as KDFA\nimport Kleene.Internal.Pretty (pretty)\n\ntype PredShow p = p -> Text -> Text\n\ntype PredFun p a = p -> a -> Bool\n\nclass Predicate a p where\n  pFun :: PredFun p a\n\nclass ShowablePredicate p where\n  pShow :: PredShow p\n\ntype Regex = RE Char\n\nanyOf :: [Char] -> Regex\nanyOf = joins . map (fromString . (: []))\n\ninstance Predicate String Regex where\n  pFun = match . KDFA.fromRE\n\ninstance Predicate Text Regex where\n  pFun re a = match (KDFA.fromRE re) (T.unpack a)\n\ninstance ShowablePredicate Regex where\n  pShow regex var = var <> \" matches regex /\" <> T.pack (pretty regex) <> \"/\"\n\ndata And p1 p2 = And p1 p2\n\ninstance (Predicate x p1, Predicate x p2) => Predicate x (And p1 p2) where\n  pFun (And p1 p2) = liftBinPredFun (&&) p1 p2\n\ninstance (ShowablePredicate p1, ShowablePredicate p2) => ShowablePredicate (And p1 p2) where\n  pShow (And p1 p2) = liftBinPredShow \"and\" p1 p2\n\ndata Or p1 p2 = Or p1 p2\n\ninstance (Predicate x p1, Predicate x p2) => Predicate x (Or p1 p2) where\n  pFun (Or p1 p2) = liftBinPredFun (||) p1 p2\n\ninstance (ShowablePredicate p1, ShowablePredicate p2) => ShowablePredicate (Or p1 p2) where\n  pShow (Or p1 p2) = liftBinPredShow \"or\" p1 p2\n\nnewtype Not p = Not p\n\ninstance (Predicate x p) => Predicate x (Not p) where\n  pFun (Not p) = not . pFun p\n\ninstance (ShowablePredicate p) => ShowablePredicate (Not p) where\n  pShow (Not p) = liftPredShow \"not\" p\n\nnewtype InMaybe p = InMaybe p\n\ninstance (Predicate x p) => Predicate (Maybe x) (InMaybe p) where\n  pFun (InMaybe p) = maybe True (pFun p)\n\ninstance (ShowablePredicate p) => ShowablePredicate (InMaybe p) where\n  pShow (InMaybe p) = liftPredShow \"ifNotNull\" p\n\nnewtype InValue p = InValue p\n\ninstance (Predicate x p) => Predicate (MandatoryValue x) (InValue p) where\n  pFun (InValue p) (MandatoryValue x) = pFun p x\n\ninstance (Predicate x p) => Predicate (OptionalValue x) (InValue p) where\n  pFun (InValue p) (OptionalValue x) = maybe True (pFun p) x\n\ninstance (ShowablePredicate p) => ShowablePredicate (InValue p) where\n  pShow (InValue p) = liftPredShow \"inValue\" p\n\nnewtype InList p = InList p\n\ninstance (Predicate x p) => Predicate [x] (InList p) where\n  pFun (InList p) = all (pFun p)\n\ninstance (ShowablePredicate p) => ShowablePredicate (InList p) where\n  pShow (InList p) = liftPredShow \"eachElement\" p\n\nnewtype ExactLength = ExactLength Int\n\ninstance ShowablePredicate ExactLength where\n  pShow (ExactLength len) name = showFunction \"length\" name <> \" == \" <> show len\n\ninstance F.Foldable l => Predicate (l a) ExactLength where\n  pFun (ExactLength len) l = F.length l == len\n\ninstance Predicate Text ExactLength where\n  pFun (ExactLength len) l = T.length l == len\n\ndata LengthInRange = LengthInRange Int Int\n\ninstance ShowablePredicate LengthInRange where\n  pShow (LengthInRange a b) name = show a <> \" <= \" <> showFunction \"length\" name <> \" <= \" <> show b\n\ninstance F.Foldable l => Predicate (l a) LengthInRange where\n  pFun (LengthInRange a b) l = inRange (a, b) $ F.length l\n\ninstance Predicate Text LengthInRange where\n  pFun (LengthInRange a b) l = inRange (a, b) $ T.length l\n\nnewtype MinLength = MinLength Int\n\ninstance ShowablePredicate MinLength where\n  pShow (MinLength m) name = showFunction \"length\" name <> \" >= \" <> show m\n\ninstance F.Foldable l => Predicate (l a) MinLength where\n  pFun (MinLength m) l = F.length l >= m\n\ninstance Predicate Text MinLength where\n  pFun (MinLength m) l = T.length l >= m\n\nnewtype MaxLength = MaxLength Int\n\ninstance ShowablePredicate MaxLength where\n  pShow (MaxLength m) name = showFunction \"length\" name <> \" <= \" <> show m\n\ninstance F.Foldable l => Predicate (l a) MaxLength where\n  pFun (MaxLength m) l = F.length l <= m\n\ninstance Predicate Text MaxLength where\n  pFun (MaxLength m) l = T.length l <= m\n\ndata NotEmpty = NotEmpty\n\ninstance ShowablePredicate NotEmpty where\n  pShow NotEmpty name = name <> \" is not empty\"\n\ninstance F.Foldable l => Predicate (l a) NotEmpty where\n  pFun NotEmpty l = not (F.null l)\n\ninstance Predicate Text NotEmpty where\n  pFun NotEmpty l = not (T.null l)\n\ndata InRange n = InRange n n\n\ninstance Show n => ShowablePredicate (InRange n) where\n  pShow (InRange a b) name = show a <> \" <= \" <> name <> \" <= \" <> show b\n\ninstance Ord n => Predicate n (InRange n) where\n  pFun (InRange a b) n = a <= n && n <= b\n\nnewtype Min n = Min n\n\ninstance Show n => ShowablePredicate (Min n) where\n  pShow (Min m) name = name <> \" >= \" <> show m\n\ninstance Ord n => Predicate n (Min n) where\n  pFun (Min m) = (>= m)\n\nnewtype Max n = Max n\n\ninstance Show n => ShowablePredicate (Max n) where\n  pShow (Max m) name = name <> \" <= \" <> show m\n\ninstance Ord n => Predicate n (Max n) where\n  pFun (Max m) = (<= m)\n\ndata UniqueField f = UniqueField\n\ninstance KnownSymbol f => ShowablePredicate (UniqueField f) where\n  pShow _ name = T.pack (symbolVal (Proxy @f)) <> \" field must be unique for each element of the \" <> name <> \" list.\"\n\ninstance (Container c, Ord a, HasField n (Element c) a) => Predicate c (UniqueField n) where\n  pFun _ list = length list == (length . nub . map (getField @n) $ toList list)\n\nliftPredShow :: ShowablePredicate p => Text -> p -> Text -> Text\nliftPredShow fname p text = showFunction fname (pShow p text)\n\nshowFunction :: Text -> Text -> Text\nshowFunction fname arg = fname <> parenthesized arg\n\nliftBinPredShow ::\n  (ShowablePredicate p1, ShowablePredicate p2) =>\n  Text ->\n  p1 ->\n  p2 ->\n  Text ->\n  Text\nliftBinPredShow str a b text = parenthesized $ pShow a text <> \" \" <> str <> \" \" <> pShow b text\n\nliftBinPredFun ::\n  (Predicate x p1, Predicate x p2) =>\n  (Bool -> Bool -> Bool) ->\n  p1 ->\n  p2 ->\n  x ->\n  Bool\nliftBinPredFun op a b x = pFun a x `op` pFun b x\n\nparenthesized :: Text -> Text\nparenthesized x = \"(\" <> x <> \")\"\n\nnewtype Exact n = Exact n\n\ninstance Show n => ShowablePredicate (Exact n) where\n  pShow (Exact m) name = name <> \" == \" <> show m\n\ninstance Eq n => Predicate n (Exact n) where\n  pFun (Exact m) = (== m)\n\ndata PredicateFunc a = PredicateFunc (Text -> Text) (a -> Bool)\n\ninstance Predicate a (PredicateFunc a) where\n  pFun (PredicateFunc _ func) a = func a\n\ninstance ShowablePredicate (PredicateFunc a) where\n  pShow (PredicateFunc mkMessage _) field = mkMessage field\n",
      "hash": "0346e997d649751bbb059f2c56da70f1107f154e0b0b97dcb0f204960c4e1466",
      "size": 7285
    },
    "/lib/mobility-core/src/Kernel/Types/Price.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n{-# LANGUAGE DerivingVia #-}\n{-# LANGUAGE GeneralizedNewtypeDeriving #-}\n{-# LANGUAGE TemplateHaskell #-}\n{-# OPTIONS_GHC -Wno-orphans #-}\n{-# OPTIONS_GHC -Wwarn=identities #-}\n\nmodule Kernel.Types.Price where\n\nimport Data.Aeson\nimport Data.OpenApi hiding (value)\nimport Database.Beam\nimport qualified Database.Beam as B\nimport Database.Beam.Backend\nimport Database.Beam.Postgres\nimport Database.Persist.Class\nimport Database.Persist.Sql\nimport Database.PostgreSQL.Simple.FromField (FromField, fromField)\nimport Kernel.Prelude as KP\nimport qualified Kernel.Types.Beckn.DecimalValue as DecimalValue\nimport Kernel.Types.Error (GenericError (InternalError))\nimport Kernel.Types.FromField\nimport Kernel.Types.Logging\nimport Kernel.Utils.Dhall (FromDhall)\nimport Kernel.Utils.Error.Throwing as E (throwError)\nimport Kernel.Utils.GenericPretty\nimport Kernel.Utils.TH (mkHttpInstancesForEnum)\nimport Servant\nimport Text.Show (Show (..))\n\n-- To be deprecated\nnewtype Money = Money\n  { getMoney :: Int\n  }\n  deriving stock (Generic)\n  deriving newtype (Show, Read, PrettyShow, Enum, Eq, Ord, Num, Real, Integral, PersistField, PersistFieldSql, ToJSON, FromJSON, ToSchema, ToParamSchema, FromHttpApiData, ToHttpApiData)\n\ninstance HasSqlValueSyntax be Int => HasSqlValueSyntax be Money where\n  sqlValueSyntax = sqlValueSyntax . getMoney\n\ninstance BeamSqlBackend be => B.HasSqlEqualityCheck be Money\n\ninstance FromBackendRow Postgres Money\n\ninstance FromField Money where\n  fromField = fromFieldJSON\n\nnewtype HighPrecMoney = HighPrecMoney\n  { getHighPrecMoney :: Rational\n  }\n  deriving stock (Generic)\n  deriving newtype (Num, FromDhall, Real, Fractional, RealFrac, Ord, Eq, Enum, PrettyShow, PersistField, PersistFieldSql)\n\ninstance Show HighPrecMoney where\n  show = Text.Show.show @Double . realToFrac\n\ninstance Read HighPrecMoney where\n  readsPrec d s = do\n    (dobuleVal, s1) :: (Double, String) <- readsPrec d s\n    return (realToFrac dobuleVal, s1)\n\ninstance ToJSON HighPrecMoney where\n  toJSON = toJSON @Double . realToFrac\n\ninstance FromJSON HighPrecMoney where\n  parseJSON = fmap realToFrac . parseJSON @Double\n\ninstance ToParamSchema HighPrecMoney where\n  toParamSchema _ = toParamSchema (Proxy @Double)\n\ninstance FromField HighPrecMoney where\n  fromField f mbValue = HighPrecMoney <$> fromFieldDefault f mbValue\n\ninstance HasSqlValueSyntax be Rational => HasSqlValueSyntax be HighPrecMoney where\n  sqlValueSyntax = sqlValueSyntax . getHighPrecMoney\n\ninstance HasSqlValueSyntax be Double => HasSqlValueSyntax be Rational where\n  sqlValueSyntax = sqlValueSyntax . (fromRational :: Rational -> Double)\n\ninstance BeamSqlBackend be => B.HasSqlEqualityCheck be HighPrecMoney\n\ninstance FromBackendRow Postgres HighPrecMoney\n\ninstance ToSchema HighPrecMoney where\n  declareNamedSchema _ = do\n    aSchema <- declareSchema (Proxy :: Proxy Double)\n    return $ NamedSchema (Just \"HighPrecMoney\") aSchema\n\n$(mkHttpInstancesForEnum ''HighPrecMoney)\n\ndata Currency = INR | USD | EUR\n  deriving stock (Generic, Show, Read, Eq, Ord)\n  deriving anyclass (ToJSON, FromJSON, ToSchema, ToParamSchema)\n  deriving (PrettyShow) via Showable Currency\n\n$(mkHttpInstancesForEnum ''Currency)\n\n-- cycle imports\n\n-- $(mkBeamInstancesForEnum ''Currency)\n\ninstance FromField Currency where\n  fromField = fromFieldEnum\n\ninstance HasSqlValueSyntax be String => HasSqlValueSyntax be Currency where\n  sqlValueSyntax = autoSqlValueSyntax\n\ninstance BeamSqlBackend be => B.HasSqlEqualityCheck be Currency\n\ninstance FromBackendRow Postgres Currency\n\ndata Price = Price\n  { amountInt :: Money, -- To be deprecated\n    amount :: HighPrecMoney,\n    currency :: Currency\n  }\n  deriving anyclass (ToJSON, FromJSON, ToSchema)\n  deriving stock (Generic, Show, Read, Eq)\n  deriving (PrettyShow) via Showable Price\n\nmkPrice :: Maybe Currency -> HighPrecMoney -> Price\nmkPrice mbCurrency amount =\n  Price\n    { amountInt = roundToIntegral amount,\n      amount,\n      currency = fromMaybe INR mbCurrency\n    }\n\nmkPriceWithDefault :: Maybe HighPrecMoney -> Maybe Currency -> Money -> Price -- FIXME Currency\nmkPriceWithDefault mbAmount mbCurrency defAmount =\n  Price\n    { amountInt = maybe defAmount roundToIntegral mbAmount,\n      amount = mkAmountWithDefault mbAmount defAmount,\n      currency = fromMaybe INR mbCurrency\n    }\n\nmkAmountWithDefault :: Maybe HighPrecMoney -> Money -> HighPrecMoney\nmkAmountWithDefault mbAmount defAmount = fromMaybe (HighPrecMoney $ toRational defAmount) mbAmount\n\nmkPriceFromAPIEntity :: PriceAPIEntity -> Price\nmkPriceFromAPIEntity priceAPIEntity = mkPrice (Just priceAPIEntity.currency) priceAPIEntity.amount\n\n-- To be deprecated\nmkPriceFromMoney :: Maybe Currency -> Money -> Price\nmkPriceFromMoney = mkPriceWithDefault Nothing\n\n-- To be deprecated when remove Money\ndata PriceAPIEntity = PriceAPIEntity\n  { amount :: HighPrecMoney,\n    currency :: Currency\n  }\n  deriving stock (Generic, Show, Read, Eq, Ord)\n  deriving anyclass (ToJSON, FromJSON, ToSchema)\n\nmkPriceAPIEntity :: Price -> PriceAPIEntity\nmkPriceAPIEntity Price {..} = PriceAPIEntity {..}\n\nwithCurrencyChecking ::\n  (MonadThrow m, Log m) =>\n  Price ->\n  Price ->\n  (HighPrecMoney -> HighPrecMoney -> a) ->\n  m a\nwithCurrencyChecking p1 p2 func = do\n  if p1.currency == p2.currency\n    then pure $ func p1.amount p2.amount\n    else\n      E.throwError $\n        InternalError $ \"Trying to make operation for prices with different currencies: \" <> KP.show p1 <> \"; \" <> KP.show p2\n\nwithCurrencyChecking3 ::\n  (MonadThrow m, Log m) =>\n  Price ->\n  Price ->\n  Price ->\n  (HighPrecMoney -> HighPrecMoney -> HighPrecMoney -> a) ->\n  m a\nwithCurrencyChecking3 p1 p2 p3 func = do\n  if p1.currency == p2.currency && p2.currency == p3.currency\n    then pure $ func p1.amount p2.amount p3.amount\n    else\n      E.throwError $\n        InternalError $ \"Trying to make operation for prices with different currencies: \" <> KP.show p1 <> \"; \" <> KP.show p2 <> \"; \" <> KP.show p3\n\n-- | Do not use on endless lists\nwithCurrencyCheckingList ::\n  (MonadThrow m, Log m) =>\n  [Price] ->\n  (Maybe Currency -> [HighPrecMoney] -> a) ->\n  m a\nwithCurrencyCheckingList [] func = pure $ func Nothing []\nwithCurrencyCheckingList ps@(p1 : _) func = do\n  if all (\\p -> p.currency == p1.currency) ps\n    then pure $ func (Just p1.currency) (ps <&> (.amount))\n    else\n      E.throwError $\n        InternalError $ \"Trying to make operation for prices with different currencies: \" <> KP.show ps\n\naddPrice :: (MonadThrow m, Log m) => Price -> Price -> m Price\naddPrice p1 p2 = mkPrice (Just p1.currency) <$> withCurrencyChecking p1 p2 (+)\n\nsubtractPrice :: (MonadThrow m, Log m) => Price -> Price -> m Price\nsubtractPrice p1 p2 = mkPrice (Just p1.currency) <$> withCurrencyChecking p1 p2 (-)\n\nmodifyPrice :: Price -> (HighPrecMoney -> HighPrecMoney) -> Price\nmodifyPrice price func = mkPrice (Just price.currency) (func price.amount)\n\nhighPrecMoneyFromText :: Text -> Maybe HighPrecMoney\nhighPrecMoneyFromText txt = do\n  DecimalValue.DecimalValue rational <- DecimalValue.valueFromString txt\n  pure $ HighPrecMoney rational\n\nhighPrecMoneyToText :: HighPrecMoney -> Text\nhighPrecMoneyToText = DecimalValue.valueToString . DecimalValue.DecimalValue . getHighPrecMoney\n\ntoHighPrecMoney :: Real a => a -> HighPrecMoney\ntoHighPrecMoney = HighPrecMoney . toRational\n\nshowPriceWithRounding :: Price -> Text\nshowPriceWithRounding price = case getAccuracy price.currency of\n  0 -> KP.show @Text @Integer (round price.amount) <> \" \" <> KP.show price.currency\n  accuracy -> KP.show @Text @Double (fromIntegral (round (price.amount.getHighPrecMoney * 10 ^ accuracy) :: Integer) / 10 ^ accuracy) <> \" \" <> KP.show price.currency\n\ngetAccuracy :: Currency -> Int\ngetAccuracy INR = 0\ngetAccuracy USD = 2\ngetAccuracy EUR = 2\n\nshowPriceWithRoundingWithoutCurrency :: Price -> Text\nshowPriceWithRoundingWithoutCurrency price = case getAccuracy price.currency of\n  0 -> KP.show @Text @Integer (round price.amount)\n  accuracy -> KP.show @Text @Double (fromIntegral (round (price.amount.getHighPrecMoney * 10 ^ accuracy) :: Integer) / 10 ^ accuracy)\n",
      "hash": "467d155226a5636d9d3e1b7f22c88e4082e7a6601af02b0059feae90f4e3f72b",
      "size": 8738
    },
    "/lib/mobility-core/src/Kernel/Types/Registry.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n\nmodule Kernel.Types.Registry\n  ( module Kernel.Types.Registry,\n    module E,\n  )\nwhere\n\nimport Kernel.Prelude\nimport qualified Kernel.Types.Beckn.Domain as Domain\nimport Kernel.Types.Registry.Subscriber as E\n\nclass Registry m where\n  registryLookup :: SimpleLookupRequest -> m (Maybe Subscriber)\n\ndata SimpleLookupRequest = SimpleLookupRequest\n  { unique_key_id :: Text,\n    subscriber_id :: Text,\n    merchant_id :: Text,\n    subscriber_type :: E.SubscriberType,\n    domain :: Domain.Domain\n  }\n  deriving (Eq, Ord)\n\nlookupRequestToRedisKey :: SimpleLookupRequest -> Text\nlookupRequestToRedisKey SimpleLookupRequest {..} = unique_key_id <> \"|\" <> subscriber_id\n",
      "hash": "c7070c5a17d1cb2a4b10c543859d8fc171b7b6c40bd05f9535b24d1b18dbd77d",
      "size": 1356
    },
    "/lib/mobility-core/src/Kernel/Types/Registry/API.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n\nmodule Kernel.Types.Registry.API where\n\nimport Data.OpenApi (ToSchema)\nimport EulerHS.Prelude\nimport Kernel.Types.Beckn.City (City)\nimport Kernel.Types.Beckn.Country (Country)\nimport Kernel.Types.Beckn.Domain (Domain)\nimport Kernel.Types.Registry.Subscriber (Subscriber, SubscriberType)\nimport Kernel.Utils.JSON (stripPrefixUnderscoreIfAny)\n\ndata LookupRequest = LookupRequest\n  { unique_key_id :: Maybe Text,\n    subscriber_id :: Maybe Text,\n    _type :: Maybe SubscriberType,\n    domain :: Maybe Domain,\n    country :: Maybe Country,\n    city :: Maybe City\n  }\n  deriving (Show, Generic, ToSchema)\n\nemptyLookupRequest :: LookupRequest\nemptyLookupRequest = LookupRequest Nothing Nothing Nothing Nothing Nothing Nothing\n\ninstance FromJSON LookupRequest where\n  parseJSON = genericParseJSON stripPrefixUnderscoreIfAny\n\ninstance ToJSON LookupRequest where\n  toJSON = genericToJSON stripPrefixUnderscoreIfAny\n\ntype LookupResponse = [Subscriber]\n",
      "hash": "eb422eaeb297f13c4824dcd855f10389bd8c12b9583f43510c4d4a2a00617243",
      "size": 1636
    },
    "/lib/mobility-core/src/Kernel/Types/Registry/Routes.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n\nmodule Kernel.Types.Registry.Routes where\n\nimport EulerHS.Prelude\nimport qualified Kernel.Types.Registry.API as API\nimport Servant\n\ntype LookupAPI =\n  \"lookup\"\n    :> ReqBody '[JSON] API.LookupRequest\n    :> Post '[JSON] API.LookupResponse\n\nlookupAPI :: Proxy LookupAPI\nlookupAPI = Proxy\n",
      "hash": "cf09080cf2fcfff04b94e07745a595815e95235a879f7207aba9e77ef30ae94d",
      "size": 982
    },
    "/lib/mobility-core/src/Kernel/Types/Registry/Subscriber.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n\nmodule Kernel.Types.Registry.Subscriber where\n\nimport Data.Aeson\nimport Data.Aeson.Types\nimport Data.OpenApi (ToSchema)\nimport qualified Data.Text as T\nimport Data.Time (UTCTime)\nimport EulerHS.Prelude\nimport Kernel.Types.Base64\nimport Kernel.Types.Beckn.City (City)\nimport Kernel.Types.Beckn.Country (Country)\nimport Kernel.Types.Beckn.Domain (Domain)\nimport Kernel.Utils.Dhall (FromDhall)\nimport Servant.Client (BaseUrl)\n\ndata Subscriber = Subscriber\n  { unique_key_id :: Text,\n    subscriber_id :: Text,\n    subscriber_url :: BaseUrl,\n    _type :: SubscriberType,\n    domain :: Domain,\n    city :: [City],\n    country :: Maybe Country,\n    signing_public_key :: Base64,\n    encr_public_key :: Maybe Base64,\n    valid_from :: Maybe UTCTime,\n    valid_until :: Maybe UTCTime,\n    status :: Maybe SubscriberStatus,\n    created :: UTCTime,\n    updated :: UTCTime\n  }\n  deriving (Show, Generic)\n\njsonOptions :: Options\njsonOptions =\n  defaultOptions\n    { fieldLabelModifier = \\case\n        \"unique_key_id\" -> \"ukId\"\n        \"_type\" -> \"type\"\n        other -> other\n    }\n\ninstance FromJSON Subscriber where\n  parseJSON (Object obj) = do\n    unique_key_id <- obj .: \"ukId\"\n    _type <- obj .: \"type\"\n    subscriber_id <- obj .: \"subscriber_id\"\n    subscriber_url <- obj .: \"subscriber_url\"\n    domain <- obj .: \"domain\"\n    country <- obj .: \"country\"\n    signing_public_key <- obj .: \"signing_public_key\"\n    encr_public_key <- obj .: \"encr_public_key\"\n    valid_from <- obj .: \"valid_from\"\n    valid_until <- obj .: \"valid_until\"\n    status <- obj .: \"status\"\n    updated <- obj .: \"updated\"\n    created <- obj .: \"created\"\n    city' <- obj .: \"city\"\n    city <- parseCities city'\n    pure Subscriber {..}\n    where\n      parseCities cities' = do\n        let cities :: Result [City] = sequence . filter isSuccess $ map (fromJSON . String . T.strip) (T.splitOn \",\" cities')\n        case cities of\n          Success cities'' -> pure cities''\n          Error _ -> error \"failed\"\n      isSuccess a = case a of\n        Success _ -> True\n        Error _ -> False\n  parseJSON wrongVal = typeMismatch \"Object Subscriber\" wrongVal\n\ninstance ToJSON Subscriber where\n  toJSON Subscriber {..} = do\n    object\n      [ \"ukId\" .= unique_key_id,\n        \"type\" .= _type,\n        \"subscriber_id\" .= subscriber_id,\n        \"subscriber_url\" .= subscriber_url,\n        \"domain\" .= domain,\n        \"country\" .= country,\n        \"signing_public_key\" .= signing_public_key,\n        \"encr_public_key\" .= encr_public_key,\n        \"valid_from\" .= valid_from,\n        \"valid_until\" .= valid_until,\n        \"status\" .= status,\n        \"updated\" .= updated,\n        \"created\" .= created,\n        \"city\" .= (toCity city)\n      ]\n    where\n      toCity cities = String . (T.intercalate \",\") $ map (toStringMe . toJSON) cities\n        where\n          toStringMe (String a) = a\n          toStringMe e = error \"Unexpected value type, expected String for City \" <> show e\n\ndata SubscriberType\n  = BAP\n  | BPP\n  | BG\n  | LREG\n  | CREG\n  | RREG\n  deriving (Show, Read, Generic, Eq, Ord, ToSchema, FromJSON, ToJSON, FromDhall)\n\ndata SubscriberStatus\n  = INITIATED\n  | UNDER_SUBSCRIPTION\n  | SUBSCRIBED\n  | EXPIRED\n  | UNSUBSCRIBED\n  | INVALID_SSL\n  deriving (Show, Read, Generic, FromJSON, ToJSON)\n",
      "hash": "e4b81c917078283627150f3f2e74e27dacbaa2e09e50a43aa4ff0c793765588f",
      "size": 3954
    },
    "/lib/mobility-core/src/Kernel/Types/Servant.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n\nmodule Kernel.Types.Servant where\n\nimport EulerHS.Prelude hiding (encodeUtf8, fromStrict, toStrict)\nimport qualified Network.HTTP.Media as M\nimport Servant\n\ndata PlainText_ISO_8859_1 deriving (Typeable)\n\ninstance Accept PlainText_ISO_8859_1 where\n  contentType _ = \"text\" M.// \"plain\" M./: (\"charset\", \"ISO-8859-1\")\n",
      "hash": "c452cf1f99de48ba3a6f5b1c0b53d1c1c6755ef19baf05b3ed3992c71b69587e",
      "size": 1010
    },
    "/lib/mobility-core/src/Kernel/Types/SharedRedisKeys.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n\nmodule Kernel.Types.SharedRedisKeys where\n\nimport Kernel.Prelude\nimport Kernel.Types.Time\n\ndata BatchConfig = BatchConfig\n  { totalBatches :: Int,\n    batchTime :: Seconds,\n    batchingStartedAt :: UTCTime,\n    batchingExpireAt :: UTCTime\n  }\n  deriving (Eq, Generic, Show, FromJSON, ToJSON, ToSchema)\n",
      "hash": "9ea4adc889cc50064243f2c80a1c86de8851600af4b69fb8695b773099227f0d",
      "size": 996
    },
    "/lib/mobility-core/src/Kernel/Types/SlidingWindowCounters.hs": {
      "type": "content",
      "content": "{-# LANGUAGE DerivingStrategies #-}\n{-# LANGUAGE StandaloneDeriving #-}\n{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n{-# LANGUAGE TemplateHaskell #-}\n\nmodule Kernel.Types.SlidingWindowCounters where\n\nimport qualified Data.Aeson as A\nimport Data.ByteString (ByteString)\nimport qualified Database.Beam as B\nimport Database.Beam.Backend\nimport Database.Beam.Postgres\nimport Database.PostgreSQL.Simple.FromField (FromField (fromField))\nimport qualified Database.PostgreSQL.Simple.FromField as DPSF\nimport Kernel.Prelude\nimport Kernel.Storage.Esqueleto (derivePersistFieldJSON)\nimport Kernel.Utils.Dhall (FromDhall)\n\ndata SlidingWindowOptions = SlidingWindowOptions\n  { period :: Integer,\n    periodType :: PeriodType\n  }\n  deriving (Read, Generic, FromDhall, Show, FromJSON, ToJSON, ToSchema, Ord, Eq)\n\nfromFieldSWC ::\n  DPSF.Field ->\n  Maybe ByteString ->\n  DPSF.Conversion SlidingWindowOptions\nfromFieldSWC f mbValue = do\n  value <- fromField f mbValue\n  case A.fromJSON value of\n    A.Success a -> pure a\n    _ -> DPSF.returnError DPSF.ConversionFailed f \"Conversion failed\"\n\ninstance FromField SlidingWindowOptions where\n  fromField = fromFieldSWC\n\ninstance HasSqlValueSyntax be A.Value => HasSqlValueSyntax be SlidingWindowOptions where\n  sqlValueSyntax = sqlValueSyntax . A.toJSON\n\ninstance BeamSqlBackend be => B.HasSqlEqualityCheck be SlidingWindowOptions\n\ninstance FromBackendRow Postgres SlidingWindowOptions\n\ndata PeriodType = Minutes | Hours | Days | Months | Years deriving (Read, Generic, FromDhall, Show, Eq, FromJSON, ToJSON, ToSchema, Ord)\n\ntype TimePair = (UTCTime, UTCTime) -- (startTime, endTime)\n\nderivePersistFieldJSON \"SlidingWindowOptions\"\n",
      "hash": "9afc43fc55f105acf2f409c766dafaea818fe9bb837164e1cc31d7dd02b9755b",
      "size": 2308
    },
    "/lib/mobility-core/src/Kernel/Types/SlidingWindowLimiter.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n\nmodule Kernel.Types.SlidingWindowLimiter where\n\nimport EulerHS.Prelude\nimport Kernel.Prelude\nimport Kernel.Utils.Dhall (FromDhall)\n\ndata APIRateLimitOptions = APIRateLimitOptions\n  { limit :: Int,\n    limitResetTimeInSec :: Int\n  }\n  deriving (Generic, FromDhall, Show, FromJSON, ToJSON, ToSchema)\n",
      "hash": "f177f4905017bc2fb586a6e81dacab8a674f389dc64628c313763db7486abc81",
      "size": 992
    },
    "/lib/mobility-core/src/Kernel/Types/SystemConfigs.hs": {
      "type": "content",
      "content": "module Kernel.Types.SystemConfigs where\n\nimport Kernel.Prelude\n\ndata SystemConfigs = SystemConfigs\n  { id :: Text,\n    configValue :: Text\n  }\n  deriving (Generic, Show)\n",
      "hash": "e12ce74427317a4536956fcec310e5ebe2a9a72c582f3bc7fbc617215942adb0",
      "size": 170
    },
    "/lib/mobility-core/src/Kernel/Types/Time.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n{-# LANGUAGE DerivingStrategies #-}\n{-# LANGUAGE GeneralizedNewtypeDeriving #-}\n{-# LANGUAGE StandaloneDeriving #-}\n\nmodule Kernel.Types.Time where\n\nimport Data.OpenApi (ToParamSchema, ToSchema)\nimport Data.Time (UTCTime)\nimport qualified Data.Time as Time\nimport qualified Database.Beam as B\nimport Database.Beam.Backend\nimport Database.Beam.Postgres (Postgres)\nimport Database.Persist.Class\nimport Database.Persist.Sql\nimport Database.PostgreSQL.Simple.FromField (FromField)\nimport EulerHS.Prelude\nimport Kernel.Utils.Dhall (FromDhall)\nimport Kernel.Utils.GenericPretty\nimport Servant (FromHttpApiData, ToHttpApiData)\nimport qualified System.Clock as Clock\n\nnewtype Microseconds = Microseconds\n  { getMicroseconds :: Int\n  }\n  deriving newtype (Show, Read, Num, FromDhall, FromJSON, ToJSON, Integral, Real, Ord, Eq, Enum, ToSchema, PrettyShow, PersistField, PersistFieldSql)\n  deriving stock (Generic)\n\nnewtype Milliseconds = Milliseconds\n  { getMilliseconds :: Int\n  }\n  deriving newtype (Show, Read, Num, FromDhall, FromJSON, ToJSON, Integral, Real, Ord, Eq, Enum, ToSchema, PrettyShow, PersistField, PersistFieldSql)\n  deriving stock (Generic)\n\nnewtype Seconds = Seconds\n  { getSeconds :: Int\n  }\n  deriving newtype (Show, Read, Num, FromDhall, FromJSON, ToJSON, Integral, Real, Ord, Eq, Enum, ToSchema, PrettyShow, PersistField, PersistFieldSql)\n  deriving stock (Generic)\n\nnewtype Minutes = Minutes\n  { getMinutes :: Int\n  }\n  deriving newtype (Show, Read, Num, FromDhall, FromJSON, ToJSON, Integral, Real, Ord, Eq, Enum, ToSchema, ToParamSchema, FromHttpApiData, ToHttpApiData, PrettyShow, PersistField, PersistFieldSql)\n  deriving stock (Generic)\n\nnewtype Hours = Hours\n  { getHours :: Int\n  }\n  deriving newtype (Show, Read, Num, FromDhall, FromJSON, ToJSON, Integral, Real, Ord, Eq, Enum, ToSchema, PrettyShow, PersistField, PersistFieldSql)\n  deriving stock (Generic)\n\nderiving newtype instance FromField Hours\n\ninstance HasSqlValueSyntax be Int => HasSqlValueSyntax be Hours where\n  sqlValueSyntax = sqlValueSyntax . getHours\n\ninstance BeamSqlBackend be => B.HasSqlEqualityCheck be Hours\n\ninstance FromBackendRow Postgres Hours\n\nnewtype Days = Days\n  { getDays :: Int\n  }\n  deriving newtype (Show, Read, Num, FromDhall, FromJSON, ToJSON, Integral, Real, Ord, Eq, Enum, ToSchema, PrettyShow, PersistField, PersistFieldSql)\n  deriving stock (Generic)\n\ndaysToSeconds :: Days -> Seconds\ndaysToSeconds = Seconds . (* 86400) . getDays\n\nminutesToSeconds :: Minutes -> Seconds\nminutesToSeconds = Seconds . (* 60) . getMinutes\n\nnewtype Months = Months\n  { getMonths :: Int\n  }\n  deriving newtype (Show, Read, Num, FromDhall, FromJSON, ToJSON, Integral, Real, Ord, Eq, Enum, ToSchema, PrettyShow, PersistField, PersistFieldSql)\n  deriving stock (Generic)\n\nderiving newtype instance FromField Months\n\ninstance HasSqlValueSyntax be Int => HasSqlValueSyntax be Months where\n  sqlValueSyntax = sqlValueSyntax . getMonths\n\ninstance BeamSqlBackend be => B.HasSqlEqualityCheck be Months\n\ninstance FromBackendRow Postgres Months\n\ntype MeasuringDuration m a = MonadClock m => m a -> m a\n\nclass Monad m => MonadTime m where\n  getCurrentTime :: m UTCTime\n\nclass Monad m => MonadClock m where\n  getClockTime :: m Clock.TimeSpec\n\ninstance MonadTime IO where\n  getCurrentTime = Time.getCurrentTime\n\ninstance MonadClock IO where\n  getClockTime = Clock.getTime Clock.Monotonic\n",
      "hash": "fa0cf889cc94a076487d4b2975f112de975db14664e7bf4d57a63ccf83ee4b29",
      "size": 4057
    },
    "/lib/mobility-core/src/Kernel/Types/TimeBound.hs": {
      "type": "content",
      "content": "{-# LANGUAGE ApplicativeDo #-}\n{-# LANGUAGE DerivingVia #-}\n{-# LANGUAGE TemplateHaskell #-}\n\nmodule Kernel.Types.TimeBound\n  ( BoundedPeaks (..),\n    TimeBound (..),\n    findBoundedDomain,\n    timeBoundsOverlap,\n  )\nwhere\n\nimport Control.Applicative ((<|>))\nimport Data.Aeson\nimport qualified Data.Text as Text\nimport Data.Time\nimport Data.Time.Calendar.WeekDate\nimport Kernel.Beam.Lib.UtilsTH (mkBeamInstancesForEnum)\nimport Kernel.Prelude\nimport Kernel.Utils.Common\nimport Kernel.Utils.GenericPretty\nimport qualified Text.Show\n\ndata BoundedPeaks = BoundedPeaks\n  { monday :: [(TimeOfDay, TimeOfDay)],\n    tuesday :: [(TimeOfDay, TimeOfDay)],\n    wednesday :: [(TimeOfDay, TimeOfDay)],\n    thursday :: [(TimeOfDay, TimeOfDay)],\n    friday :: [(TimeOfDay, TimeOfDay)],\n    saturday :: [(TimeOfDay, TimeOfDay)],\n    sunday :: [(TimeOfDay, TimeOfDay)]\n  }\n  deriving (Eq, Ord, Generic, Show, Read)\n  deriving anyclass (FromJSON, ToJSON, ToSchema)\n  deriving (PrettyShow) via Showable BoundedPeaks\n\ndata TimeBound\n  = BoundedByWeekday BoundedPeaks\n  | BoundedByDay [(Day, [(TimeOfDay, TimeOfDay)])]\n  | Unbounded\n  deriving (Eq, Ord, Generic)\n  deriving anyclass (ToJSON, ToSchema)\n  deriving (PrettyShow) via Showable TimeBound\n\ninstance Show TimeBound where\n  show Unbounded = \"Unbounded\"\n  show (BoundedByWeekday peaks) = show peaks\n  show (BoundedByDay days) = show days\n\ninstance Read TimeBound where\n  readsPrec _ str\n    | str == \"Unbounded\" = [(Unbounded, \"\")]\n    | otherwise =\n      case (readMaybe str :: Maybe BoundedPeaks) of\n        Just bound -> [(BoundedByWeekday bound, \"\")]\n        Nothing ->\n          case (readMaybe str :: Maybe [(Day, [(TimeOfDay, TimeOfDay)])]) of\n            Just bound -> [(BoundedByDay bound, \"\")]\n            Nothing -> [(Unbounded, \"\")]\n\ninstance FromJSON TimeBound where\n  parseJSON (String val) = do\n    case (readMaybe (Text.unpack val) :: Maybe TimeBound) of\n      Just bound -> pure bound\n      Nothing -> fail \"Invalid TimeBound\"\n  parseJSON other = genericParseJSON defaultOptions other\n\n$(mkBeamInstancesForEnum ''TimeBound)\n\nfindBoundedDomain :: (HasField \"timeBounds\" domain TimeBound) => [domain] -> UTCTime -> [domain]\nfindBoundedDomain domains localTime = do\n  let currTimeOfDay = utcTimeToDiffTime localTime\n      currentDay = utctDay localTime\n      (_, _, currentDayOfWeek) = toWeekDate currentDay\n  let (domainsBoundedByWeekday, domainsBoundedByDay) =\n        foldl\n          ( \\acc@(domainsBoundedByWeekday_, domainsBoundedByDay_) domain ->\n              case domain.timeBounds of\n                BoundedByWeekday timeBounds ->\n                  if isWithin currTimeOfDay (handleTwentyFourHourClockCycle $ getPeaksForCurrentDay currentDayOfWeek timeBounds)\n                    then (domainsBoundedByWeekday_ <> [domain], domainsBoundedByDay_)\n                    else acc\n                BoundedByDay days ->\n                  if maybe False (isWithin currTimeOfDay) (handleTwentyFourHourClockCycle <$> snd <$> find (\\(day, _) -> day == currentDay) days)\n                    then (domainsBoundedByWeekday_, domainsBoundedByDay_ <> [domain])\n                    else acc\n                Unbounded -> acc\n          )\n          ([], [])\n          domains\n  domainsBoundedByWeekday <|> domainsBoundedByDay\n  where\n    isWithin _ [] = False\n    isWithin currTime [(startTime, endTime)] = currTime > timeOfDayToTime startTime && currTime < timeOfDayToTime endTime\n    isWithin currTime ((startTime, endTime) : xs) = (currTime > timeOfDayToTime startTime && currTime < timeOfDayToTime endTime) || isWithin currTime xs\n\n    handleTwentyFourHourClockCycle =\n      foldl\n        ( \\timeBounds (startTime, endTime) ->\n            if endTime < startTime\n              then timeBounds <> [(startTime, TimeOfDay 23 59 59), (TimeOfDay 00 00 00, endTime)]\n              else timeBounds <> [(startTime, endTime)]\n        )\n        []\n\n    getPeaksForCurrentDay currentDayOfWeek peaks =\n      case currentDayOfWeek of\n        1 -> peaks.monday\n        2 -> peaks.tuesday\n        3 -> peaks.wednesday\n        4 -> peaks.thursday\n        5 -> peaks.friday\n        6 -> peaks.saturday\n        7 -> peaks.sunday\n        _ -> peaks.monday -- This case should never come.\n\n-- A helper function to check if two time intervals overlap\noverlaps :: (TimeOfDay, TimeOfDay) -> (TimeOfDay, TimeOfDay) -> Bool\noverlaps (start1, end1) (start2, end2) = not (end1 <= start2 || end2 <= start1)\n\n-- A function to check if any time intervals overlap in a list\nanyOverlap :: [(TimeOfDay, TimeOfDay)] -> [(TimeOfDay, TimeOfDay)] -> Bool\nanyOverlap xs ys = any (\\x -> any (overlaps x) ys) xs\n\n-- A function to check if two TimeBounds overlap\ntimeBoundsOverlap :: TimeBound -> TimeBound -> Bool\ntimeBoundsOverlap Unbounded _ = True\ntimeBoundsOverlap _ Unbounded = True\ntimeBoundsOverlap (BoundedByWeekday bp1) (BoundedByWeekday bp2) =\n  anyOverlap (monday bp1) (monday bp2)\n    || anyOverlap (tuesday bp1) (tuesday bp2)\n    || anyOverlap (wednesday bp1) (wednesday bp2)\n    || anyOverlap (thursday bp1) (thursday bp2)\n    || anyOverlap (friday bp1) (friday bp2)\n    || anyOverlap (saturday bp1) (saturday bp2)\n    || anyOverlap (sunday bp1) (sunday bp2)\ntimeBoundsOverlap (BoundedByDay bd1) (BoundedByDay bd2) =\n  any (\\(d1, ts1) -> any (\\(d2, ts2) -> d1 == d2 && anyOverlap ts1 ts2) bd2) bd1\ntimeBoundsOverlap _ _ = False\n",
      "hash": "95fd75f76ed44e3263303e8abe29546473d10d87cea90e5d827a8161dedd87b1",
      "size": 5342
    },
    "/lib/mobility-core/src/Kernel/Types/TimeRFC339.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n{-# LANGUAGE DeriveDataTypeable #-}\n{-# LANGUAGE DerivingVia #-}\n\nmodule Kernel.Types.TimeRFC339 (module Kernel.Types.TimeRFC339, module Reexport) where\n\nimport Control.Lens hiding (Context)\nimport Data.Aeson\nimport Data.Data (Data)\nimport Data.OpenApi (NamedSchema (NamedSchema), ToSchema (..), declareSchema, description)\nimport Data.Time (UTCTime)\nimport Data.Time.Format\nimport EulerHS.Prelude\nimport Kernel.Types.Beckn.Domain as Reexport\nimport Kernel.Utils.GenericPretty\n\nnewtype UTCTimeRFC3339 = UTCTimeRFC3339 UTCTime\n  deriving (Show, Eq, Ord, Read, Generic, FromJSON, Data)\n\ninstance PrettyShow UTCTimeRFC3339 where\n  prettyShow = prettyShow . Showable\n\ninstance ToSchema UTCTimeRFC3339 where\n  declareNamedSchema _ = do\n    aSchema <- declareSchema (Proxy :: Proxy Text)\n    return $\n      NamedSchema (Just \"UTCTimeRFC3339\") $\n        aSchema\n          & description\n            ?~ \"UTCTimeRFC3339 is a representation \\\n               \\of UTCTime in milliseconds instead of microseconds.\"\n\ninstance ToJSON UTCTimeRFC3339 where\n  toJSON (UTCTimeRFC3339 time) = toJSON (convertRFCStringToUTC (convertTimeToRFC time))\n\nconvertTimeToRFC :: UTCTime -> String\nconvertTimeToRFC = formatTime defaultTimeLocale \"%Y-%m-%dT%H:%M:%S%3QZ\"\n\nconvertRFCStringToUTC :: String -> UTCTime\nconvertRFCStringToUTC = parseTimeOrError True defaultTimeLocale \"%Y-%m-%dT%H:%M:%S%QZ\"\n\nconvertRFC3339ToUTC :: UTCTimeRFC3339 -> UTCTime\nconvertRFC3339ToUTC (UTCTimeRFC3339 time) = time\n",
      "hash": "6f4371d26955e5261b2611820da97485ab21ae9d52e53cff240190ba7a171b90",
      "size": 2161
    },
    "/lib/mobility-core/src/Kernel/Types/Validation.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n\nmodule Kernel.Types.Validation where\n\nimport qualified Data.Either.Validation as V\nimport EulerHS.Prelude\n\ntype Validation = V.Validation [ValidationDescription] ()\n\ndata ValidationDescription = ValidationDescription\n  { fieldName :: [Text], -- field.subfield ~ [\"field\", \"subfield\"]\n    expectation :: Text\n  }\n  deriving (Generic, ToJSON, Show)\n\ntype Validate a = a -> Validation\n",
      "hash": "ba97ff3e196a6065c2d0af9df37e6bb8a79fab5ca71e2b1e59b1ae23b62f8305",
      "size": 1076
    },
    "/lib/mobility-core/src/Kernel/Types/Value.hs": {
      "type": "content",
      "content": "{-# LANGUAGE DerivingStrategies #-}\n{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n{-# LANGUAGE StandaloneDeriving #-}\n\nmodule Kernel.Types.Value where\n\nimport Kernel.Prelude\n\nnewtype MandatoryValue a = MandatoryValue {value :: a}\n  deriving stock (Show, Generic)\n\nderiving anyclass instance ToJSON a => ToJSON (MandatoryValue a)\n\nderiving anyclass instance FromJSON a => FromJSON (MandatoryValue a)\n\nderiving anyclass instance ToSchema a => ToSchema (MandatoryValue a)\n\nnewtype OptionalValue a = OptionalValue {value :: Maybe a}\n  deriving stock (Show, Generic)\n\nderiving anyclass instance ToJSON a => ToJSON (OptionalValue a)\n\nderiving anyclass instance FromJSON a => FromJSON (OptionalValue a)\n\nderiving anyclass instance ToSchema a => ToSchema (OptionalValue a)\n",
      "hash": "dcf35275587820389c08a287ef1ec11c8e4cf6f6b0680885aec279d4b4000957",
      "size": 1412
    },
    "/lib/mobility-core/src/Kernel/Types/Version.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n{-# LANGUAGE TemplateHaskell #-}\n\nmodule Kernel.Types.Version where\n\nimport Control.Lens\nimport Data.OpenApi (OpenApiType (OpenApiString), ToParamSchema (..))\nimport Data.OpenApi.Lens as L\nimport Data.Text as T\nimport Kernel.Beam.Lib.UtilsTH\nimport Kernel.Prelude as Prelude\nimport Servant (FromHttpApiData (..), ToHttpApiData (..))\nimport Text.Regex\n\ndata Version = Version\n  { major :: Int,\n    minor :: Int,\n    maintenance :: Int,\n    preRelease :: Maybe Text,\n    build :: Maybe Text\n  }\n  deriving (Show, Eq, Generic, FromJSON, ToJSON, ToSchema)\n\nversionToText :: Version -> Text\nversionToText Version {..} =\n  pack (show major) <> \".\" <> pack (show minor) <> \".\" <> pack (show maintenance)\n    <> maybe \"\" (\"-\" <>) preRelease\n    <> maybe \"\" (\"+\" <>) build\n\ninstance Ord Version where\n  compare a b =\n    compare (major a) (major b)\n      <> compare (minor a) (minor b)\n      <> compare (maintenance a) (maintenance b)\n      <> comparePre (preRelease a) (preRelease b)\n\ncomparePre :: Maybe Text -> Maybe Text -> Ordering\ncomparePre Nothing Nothing = EQ\ncomparePre Nothing (Just _) = GT\ncomparePre (Just _) Nothing = LT\ncomparePre (Just x) (Just y) = compare x y\n\ndata DeviceType = IOS | ANDROID\n  deriving (Show, Eq, Ord, Generic, Read, ToJSON, FromJSON, ToSchema, ToParamSchema)\n\ndata Device = Device\n  { deviceType :: DeviceType,\n    deviceVersion :: Text,\n    deviceModel :: Text,\n    deviceManufacturer :: Maybe Text\n  }\n  deriving (Show, Eq, Ord, Generic, Read, ToJSON, FromJSON, ToSchema)\n\ntextToVersion :: Text -> Either Text Version\ntextToVersion versionText =\n  let versionStr = unpack versionText\n      regex = mkRegex \"^([0-9]+)\\\\.([0-9]+)\\\\.([0-9]+)(-[^+]+)?(\\\\+.+)?$\"\n      matchResult = matchRegex regex versionStr\n   in case matchResult of\n        Just [majorStr, minorStr, maintenanceStr, preReleaseStr, buildStr] -> do\n          let mbMajor = readMaybe majorStr\n          let mbMinor = readMaybe minorStr\n          let mbMaintenance = readMaybe maintenanceStr\n          let preRelease = if preReleaseStr /= \"\" then Just (T.tail $ pack preReleaseStr) else Nothing -- Tail to remove the leading '-'\n          let build = if buildStr /= \"\" then Just (T.tail $ pack buildStr) else Nothing -- Tail to remove the leading '+'\n          case (mbMajor, mbMinor, mbMaintenance) of\n            (Just major, Just minor, Just maintenance) -> Right Version {..}\n            _ -> Right Version {major = 0, minor = 0, maintenance = 0, preRelease = Nothing, build = Nothing}\n        _ -> Right Version {major = 0, minor = 0, maintenance = 0, preRelease = Nothing, build = Nothing}\n\ninstance ToParamSchema Version where\n  toParamSchema _ =\n    mempty\n      & type_ ?~ OpenApiString\n      & L.pattern ?~ \"^\\\\d+.\\\\d+.\\\\d+\"\n\ninstance ToHttpApiData Version where\n  toUrlPiece = versionToText\n\ninstance FromHttpApiData Version where\n  parseUrlPiece = textToVersion\n\n$(mkBeamInstancesForEnum ''DeviceType)\n\ninstance FromHttpApiData DeviceType where\n  parseUrlPiece txt = case toLower (txt) of\n    \"ios\" -> Right IOS\n    \"android\" -> Right ANDROID\n    _ -> Left \"Invalid DeviceType\"\n",
      "hash": "9e3d0bdfd558d0c176b8c6809e4761386436a7baa923cdc1db3c11a781b43dee",
      "size": 3775
    },
    "/lib/mobility-core/src/Kernel/Utils/.DS_Store": {
      "type": "binary",
      "hash": "659ae00fde6cf6667d6a4008010ef93012212993dbd04382b7dc14e2c4f228d2",
      "size": 6148,
      "url": "https://raw.githubusercontent.com/nammayatri/shared-kernel/b19b62ccc9511b2ecf8c74a7948725e979e990a2/lib/mobility-core/src/Kernel/Utils/.DS_Store"
    },
    "/lib/mobility-core/src/Kernel/Utils/App.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n{-# LANGUAGE PackageImports #-}\n{-# OPTIONS_GHC -Wno-warnings-deprecations #-}\n\nmodule Kernel.Utils.App\n  ( Shutdown,\n    handleLeftIO,\n    handleLeft,\n    handleShutdown,\n    logRequestAndResponse,\n    withModifiedEnv,\n    hashBodyForSignature,\n    getPodName,\n    lookupDeploymentVersion,\n    supportProxyAuthorization,\n    logRequestAndResponseGeneric,\n    withModifiedEnvGeneric,\n    withModifiedEnv',\n    logRequestAndResponse',\n  )\nwhere\n\nimport qualified Data.Aeson as A\nimport qualified Data.ByteArray as BA\nimport qualified Data.ByteString as B\nimport qualified \"base64-bytestring\" Data.ByteString.Base64 as Base64\nimport Data.ByteString.Builder (toLazyByteString)\nimport qualified Data.ByteString.Lazy as LB\nimport qualified Data.CaseInsensitive as CI\nimport Data.Default.Class\nimport qualified Data.HashMap.Internal as HM\nimport Data.List (lookup)\nimport Data.String.Conversions\nimport qualified Data.Text as T (pack)\nimport Data.UUID.V4 (nextRandom)\nimport qualified EulerHS.Language as L\nimport EulerHS.Prelude hiding (unpack)\nimport qualified EulerHS.Runtime as R\nimport Kernel.Beam.Lib.UtilsTH (HasSchemaName)\nimport qualified Kernel.Storage.Beam.SystemConfigs as BeamSC\nimport Kernel.Storage.Esqueleto.Config (EsqDBEnv)\nimport Kernel.Storage.Hedis\nimport Kernel.Tools.ARTUtils\nimport Kernel.Tools.Logging\nimport Kernel.Tools.Metrics.CoreMetrics (DeploymentVersion (..))\nimport Kernel.Tools.Metrics.CoreMetrics.Types (HasCoreMetrics)\nimport Kernel.Types.App\nimport Kernel.Types.Flow\nimport Kernel.Utils.Common\nimport qualified Kernel.Utils.FlowLogging as L\nimport Kernel.Utils.IOLogging (HasLog, appendLogTag, updateLogLevelAndRawSql)\nimport Kernel.Utils.Shutdown\nimport qualified Kernel.Utils.SignatureAuth as HttpSig\nimport Network.HTTP.Types (Method, RequestHeaders)\nimport qualified Network.HTTP.Types as HTTP\nimport Network.Wai\nimport qualified Network.Wai as Wai\nimport Network.Wai.Internal\nimport System.Environment (lookupEnv)\nimport System.Exit (ExitCode)\nimport qualified Text.Regex as TR\n\ndata RequestInfo = RequestInfo\n  { requestMethod :: Method,\n    rawPathInfo :: ByteString,\n    rawQueryString :: ByteString,\n    requestHeaders :: RequestHeaders\n  }\n  deriving (Show)\n\ndata ResponseInfo = ResponseInfo\n  { statusCode :: Int,\n    statusMessage :: Text,\n    headers :: [(Text, Text)]\n  }\n  deriving (Show)\n\nhandleLeftIO :: forall a b. (Show a) => ExitCode -> Text -> Either a b -> IO b\nhandleLeftIO exitCode msg =\n  fromEitherM' \\err -> do\n    print (msg <> show err)\n    liftIO $ exitWith exitCode\n\nhandleLeft :: forall a b m. (Show a, Log m, MonadIO m) => ExitCode -> Text -> Either a b -> m b\nhandleLeft exitCode msg =\n  fromEitherM' \\err -> do\n    logError (msg <> show err)\n    liftIO $ exitWith exitCode\n\nhashBodyForSignature :: Application -> Application\nhashBodyForSignature f req respF = do\n  req' <-\n    if anyAuthHeaders\n      then do\n        body <- strictRequestBody req <&> LB.toStrict\n        mvar <- newMVar body\n        let requestHeaders =\n              ( HttpSig.bodyHashHeader,\n                Base64.encode $ BA.convert $ HttpSig.becknSignatureHash body\n              ) :\n              Wai.requestHeaders req\n        pure req {requestBody = mkRequestBody mvar, requestHeaders}\n      else pure req\n  f req' respF\n  where\n    mkRequestBody mvar = tryTakeMVar mvar <&> fromMaybe B.empty\n    headers = map fst $ Wai.requestHeaders req\n    anyAuthHeaders =\n      any\n        (`elem` headers)\n        [ \"Authorization\",\n          \"Proxy-Authorization\",\n          \"X-Gateway-Authorization\",\n          \"Signature\"\n        ]\n\n-- TODO: remove when Proxy-Authorization becomes deprecated\nsupportProxyAuthorization :: Application -> Application\nsupportProxyAuthorization f =\n  f . modifyRequestHeaders \\headers ->\n    case lookup \"X-Gateway-Authorization\" headers of\n      Nothing ->\n        -- check for proxy-auth only if there's no x-gateway-auth\n        case lookup \"Proxy-Authorization\" headers of\n          Just h -> (\"X-Gateway-Authorization\", h) : headers\n          Nothing -> headers\n      Just _ -> headers\n\nmodifyRequestHeaders :: (RequestHeaders -> RequestHeaders) -> Request -> Request\nmodifyRequestHeaders f req = req {Wai.requestHeaders = f (Wai.requestHeaders req)}\n\nlogRequestAndResponse :: HasLog f => EnvR f -> Application -> Application\nlogRequestAndResponse (EnvR flowRt appEnv) =\n  logRequestAndResponseGeneric logInfoIO\n  where\n    logInfoIO tag info = runFlowR flowRt appEnv $ logTagInfo tag info\n\nlogRequestAndResponse' :: (HasARTFlow f) => EnvR f -> Application -> Application\nlogRequestAndResponse' (EnvR flowRt appEnv) =\n  logRequestAndResponseGeneric' appEnv logInfoIO\n  where\n    logInfoIO tag info = runFlowR flowRt appEnv $ logTagInfo tag info\n\nlogRequestAndResponseGeneric' :: HasARTFlow f => f -> (Text -> Text -> IO ()) -> Application -> Application\nlogRequestAndResponseGeneric' appEnv logInfoIO f req respF = do\n  if not appEnv.shouldLogRequestId\n    then logRequestAndResponseGeneric logInfoIO f req respF\n    else do\n      timestamp <- getCurrentTime\n      body <- Wai.consumeRequestBodyStrict req\n      let requestMethod = Wai.requestMethod req\n          rawPathInfo = Wai.rawPathInfo req\n          rawQueryString = Wai.rawQueryString req\n          requestHeaders = Wai.requestHeaders req\n\n      let request = RequestInfo' {body = T.pack $ show body, requestHeaders = show requestHeaders, requestMethod = show requestMethod, rawPathInfo = show rawPathInfo, rawQueryString = show rawQueryString}\n      called :: IORef Int <- newIORef 0\n      let returnBody = do\n            calledTimes <- readIORef called\n            modifyIORef called (+ 1)\n            pure $\n              if calledTimes > 0\n                then B.empty\n                else LB.toStrict body\n      f (req {requestBody = returnBody}) (loggedRespF timestamp request)\n  where\n    toRequestInfo Request {..} = RequestInfo {..}\n    toResponseInfo resp =\n      let (status, headers, _) = responseToStream resp\n          code = HTTP.statusCode status\n          decodeHeader = bimap (decodeUtf8 . CI.original) decodeUtf8\n          respInfo =\n            ResponseInfo\n              { statusCode = code,\n                statusMessage = decodeUtf8 $ HTTP.statusMessage status,\n                headers = decodeHeader <$> headers\n              }\n       in if code >= 300 then show respInfo else \"Successful response\"\n\n    getBody resp = case resp of\n      (ResponseBuilder _ _ builder) -> decodeUtf8 $ toLazyByteString builder\n      _ -> \"No Body Found for requestId : \" <> fromMaybe \"\" (appEnv.requestId)\n\n    loggedRespF timestamp request resp = do\n      let respLogText = toResponseInfo resp\n      logInfoIO \"Request&Response\" $ \"Request: \" <> show (toRequestInfo req) <> \" || Response: \" <> respLogText\n      when appEnv.shouldLogRequestId $ do\n        let artData = def {requestId = fromMaybe \"\" appEnv.requestId, request = Just request, response = Just $ getBody resp, timestamp = Just timestamp}\n        void $ forkIO $ pushToKafka appEnv.kafkaProducerForART (A.encode artData) \"ART-Logs\" (fromMaybe \"\" appEnv.requestId)\n      respF resp\n\nlogRequestAndResponseGeneric :: (Text -> Text -> IO ()) -> Application -> Application\nlogRequestAndResponseGeneric logInfoIO f req respF =\n  f req loggedRespF\n  where\n    toRequestInfo Request {..} = RequestInfo {..}\n    toResponseInfo resp =\n      let (status, headers, _) = responseToStream resp\n          code = HTTP.statusCode status\n          decodeHeader = bimap (decodeUtf8 . CI.original) decodeUtf8\n          respInfo =\n            ResponseInfo\n              { statusCode = code,\n                statusMessage = decodeUtf8 $ HTTP.statusMessage status,\n                headers = decodeHeader <$> headers\n              }\n       in if code >= 300 then show respInfo else \"Successful response\"\n    loggedRespF resp = do\n      let respLogText = toResponseInfo resp\n      logInfoIO \"Request&Response\" $ \"Request: \" <> show (toRequestInfo req) <> \" || Response: \" <> respLogText\n      respF resp\n\nwithModifiedEnv :: HasLog f => (EnvR f -> Application) -> EnvR f -> Application\nwithModifiedEnv = withModifiedEnvFn $ \\_ env requestId -> do\n  let appEnv = env.appEnv\n      updLogEnv = appendLogTag requestId appEnv.loggerEnv\n  newFlowRt <- L.updateLoggerContext (L.appendLogContext requestId) $ flowRuntime env\n  newOptionsLocal <- newMVar mempty\n  pure $\n    env{appEnv = appEnv{loggerEnv = updLogEnv},\n        flowRuntime = newFlowRt {R._optionsLocal = newOptionsLocal}\n       }\n\nwithModifiedEnv' :: (HasARTFlow f, HasCoreMetrics f, HasField \"esqDBEnv\" f EsqDBEnv, HedisFlowEnv f, HasCacheConfig f, HasSchemaName BeamSC.SystemConfigsT, HasCacConfig f) => (EnvR f -> Application) -> EnvR f -> Application\nwithModifiedEnv' = withModifiedEnvFn $ \\req env requestId -> do\n  let sanitizedUrl = removeUUIDs . cs $ Wai.rawPathInfo req\n  mbDynamicLogLevelConfig <- runFlowR env.flowRuntime env.appEnv $ getDynamicLogLevelConfig\n  modifyEnvR env (HM.lookup sanitizedUrl =<< mbDynamicLogLevelConfig) requestId\n  where\n    removeUUIDs path = do\n      T.pack $ TR.subRegex (TR.mkRegex \"[0-9a-z]{8}-([0-9a-z]{4}-){3}[0-9a-z]{12}\") path \":id\"\n    modifyEnvR env mbLogLevel requestId = do\n      let appEnv = env.appEnv\n          updLogEnv = appendLogTag requestId appEnv.loggerEnv\n          updLogEnv' = updateLogLevelAndRawSql mbLogLevel updLogEnv\n      let requestId' = bool Nothing (Just requestId) appEnv.shouldLogRequestId\n      newFlowRt <- L.updateLoggerContext (L.appendLogContext requestId) $ flowRuntime env\n      newOptionsLocal <- newMVar mempty\n      pure $\n        env{appEnv = appEnv{loggerEnv = updLogEnv', requestId = requestId'},\n            flowRuntime = newFlowRt {R._optionsLocal = newOptionsLocal}\n           }\n\nwithModifiedEnvFn :: HasLog f => (Wai.Request -> EnvR f -> Text -> IO (EnvR f)) -> (EnvR f -> Application) -> EnvR f -> Application\nwithModifiedEnvFn modifierFn f env = \\req resp -> do\n  requestId <- getRequestId $ Wai.requestHeaders req\n  modifiedEnv <- modifierFn req env requestId\n  let app = f modifiedEnv\n  app req resp\n  where\n    getRequestId headers = do\n      let value = lookup \"x-request-id\" headers\n      case value of\n        Just val -> pure (\"requestId-\" <> decodeUtf8 val)\n        Nothing -> pure \"randomRequestId-\" <> show <$> nextRandom\n\nwithModifiedEnvGeneric :: HasLog env => (env -> Application) -> env -> Application\nwithModifiedEnvGeneric f env = \\req resp -> do\n  requestId <- getRequestId $ Wai.requestHeaders req\n  let modifiedEnv = modifyEnv requestId\n  let app = f modifiedEnv\n  app req resp\n  where\n    modifyEnv requestId = do\n      let appEnv = env\n          updLogEnv = appendLogTag requestId appEnv.loggerEnv\n      env{loggerEnv = updLogEnv\n         }\n    getRequestId headers = do\n      let value = lookup \"x-request-id\" headers\n      case value of\n        Just val -> pure (\"requestId-\" <> decodeUtf8 val)\n        Nothing -> pure \"randomRequestId-\" <> show <$> nextRandom\n\ngetPodName :: IO (Maybe Text)\ngetPodName = fmap T.pack <$> lookupEnv \"POD_NAME\"\n\nlookupDeploymentVersion :: IO DeploymentVersion\nlookupDeploymentVersion = DeploymentVersion . T.pack . fromMaybe \"DEV\" <$> lookupEnv \"DEPLOYMENT_VERSION\"\n",
      "hash": "29df613211aaba20b2a7588cfda9186d83b2fa570769172f790b2864d572e5d6",
      "size": 11835
    },
    "/lib/mobility-core/src/Kernel/Utils/CalculateDistance.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n\nmodule Kernel.Utils.CalculateDistance where\n\nimport EulerHS.Prelude hiding (id, state)\nimport Kernel.External.Maps.Types\nimport Kernel.Prelude (atan2, tail)\nimport Kernel.Types.Common (HighPrecMeters (..))\n\ndistanceBetweenInMeters :: LatLong -> LatLong -> HighPrecMeters\ndistanceBetweenInMeters (LatLong lat1 lon1) (LatLong lat2 lon2) =\n  -- Calculating using haversine formula\n  let r = 6371000 -- Radius of earth in meters\n      dlat = deg2Rad $ lat2 - lat1\n      dlon = deg2Rad $ lon2 - lon1\n      rlat1 = deg2Rad lat1\n      rlat2 = deg2Rad lat2\n      sq x = x * x\n      -- Calculated distance is real (not imaginary) when 0 <= h <= 1\n      -- Ideally in our use case h wouldn't go out of bounds\n      h = sq (sin (dlat / 2)) + cos rlat1 * cos rlat2 * sq (sin (dlon / 2))\n   in realToFrac $ 2 * r * atan2 (sqrt h) (sqrt (1 - h))\n\n-- This returns the array of inflection latlong points as an array and the distance between two such points as straightline distance\ngetEverySnippetWhichIsNot :: (HighPrecMeters -> Bool) -> [LatLong] -> [(LatLong, LatLong, HighPrecMeters)]\ngetEverySnippetWhichIsNot p points = go [] points\n  where\n    go accPoints (x1 : x2 : xs) = do\n      let distance = distanceBetweenInMeters x1 x2\n      go\n        (if p distance then accPoints else accPoints <> [(x1, x2, distance)])\n        (x2 : xs)\n    go acc _ = acc\n\nsplitWith :: [LatLong] -> [LatLong] -> [[LatLong]]\nsplitWith markerPoints allPoints = reverse . map reverse $ go [[]] markerPoints allPoints\n  where\n    go (a : ax) [] restPoints = ((reverse restPoints <> a) : ax)\n    go (a : ax) (marker : restMarkers) (p1 : px) = do\n      let (newMarker, newAcc) =\n            if marker == p1\n              then (restMarkers, [[], p1 : a] <> ax)\n              else ((marker : restMarkers), (p1 : a) : ax)\n      go newAcc newMarker px\n    go acc _ _ = acc\n\neverySnippetIs :: (HighPrecMeters -> Bool) -> [LatLong] -> Bool\neverySnippetIs p (x1 : x2 : xs) =\n  let distance = distanceBetweenInMeters x1 x2\n   in p distance && everySnippetIs p (x2 : xs)\neverySnippetIs _ _ = True\n\ndeg2Rad :: Double -> Double\ndeg2Rad degree = degree * pi / 180\n\ngetRouteLinearLength :: [LatLong] -> Maybe LatLong -> HighPrecMeters\ngetRouteLinearLength [] _ = 0\ngetRouteLinearLength [_] _ = 0\ngetRouteLinearLength pts Nothing = sum $ zipWith distanceBetweenInMeters pts (tail pts)\ngetRouteLinearLength pts (Just refPoint) = do\n  let (nearestPointIdx, _) = findNearestPointFromEnd\n      remainingPoints = case nearestPointIdx of\n        Just idx -> drop idx pts\n        Nothing -> []\n\n  if null remainingPoints || length remainingPoints < 2\n    then 0\n    else sum $ zipWith distanceBetweenInMeters remainingPoints (tail remainingPoints)\n  where\n    findNearestPointFromEnd = go Nothing Nothing (reverse pts) (length pts - 1)\n\n    go prevIdx prevDist [] _ = (prevIdx, prevDist)\n    go prevIdx prevDist (p : ps) idx =\n      let currDist = distanceBetweenInMeters p refPoint\n       in case prevDist of\n            Nothing -> go (Just idx) (Just currDist) ps (idx - 1)\n            -- If distance increased, we've passed the nearest point, so return previous\n            Just dist ->\n              if currDist > dist\n                then (prevIdx, prevDist)\n                else go (Just idx) (Just currDist) ps (idx - 1)\n",
      "hash": "91a5ea388110cc8302457a05b1c0ed91389992c5edc804b1a39c30453491e9ef",
      "size": 3966
    },
    "/lib/mobility-core/src/Kernel/Utils/Callback.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n\nmodule Kernel.Utils.Callback (withBecknCallbackMig, WithBecknCallbackMig) where\n\nimport Control.Lens ((.~))\nimport qualified Data.HashMap.Strict as HM\nimport EulerHS.Prelude hiding ((.~))\nimport qualified EulerHS.Types as ET\nimport Kernel.Tools.Metrics.CoreMetrics\nimport Kernel.Types.Beckn.Ack\nimport qualified Kernel.Types.Beckn.Context as M.Context\nimport Kernel.Types.Beckn.ReqTypes\nimport Kernel.Types.Common\nimport Kernel.Types.Error\nimport Kernel.Types.Error.BaseError.HTTPError.BecknAPIError\nimport Kernel.Types.TimeRFC339 (UTCTimeRFC3339 (..))\nimport Kernel.Utils.Common\nimport Kernel.Utils.Monitoring.Prometheus.Servant\nimport Servant.Client\n\nsomeExceptionToCallbackReqMig :: M.Context.Context -> SomeException -> BecknCallbackReq a\nsomeExceptionToCallbackReqMig context exc =\n  let BecknAPIError err = someExceptionToBecknApiError exc\n   in BecknCallbackReq\n        { contents = Left err,\n          context\n        }\n\ntype WithBecknCallbackMig api callback_success m =\n  ( MonadFlow m,\n    SanitizedUrl api,\n    CoreMetrics m,\n    HasClient ET.EulerClient api,\n    Client ET.EulerClient api\n      ~ (BecknCallbackReq callback_success -> ET.EulerClient AckResponse)\n  ) =>\n  M.Context.Action ->\n  Proxy api ->\n  M.Context.Context ->\n  BaseUrl ->\n  HM.HashMap BaseUrl BaseUrl ->\n  m callback_success ->\n  m AckResponse\n\nwithBecknCallbackMig ::\n  (m () -> m ()) ->\n  Maybe ET.ManagerSelector ->\n  WithBecknCallbackMig api callback_success m\nwithBecknCallbackMig doWithCallback auth actionName api context cbUrl internalEndPointHashMap action = do\n  now <- getCurrentTime\n  cbAction <-\n    M.Context.mapToCbAction actionName\n      & fromMaybeM (InternalError $ \"Beckn \" <> show actionName <> \" action doesn't have callback\")\n  let cbContext =\n        context\n          & #action .~ cbAction\n          & #timestamp .~ UTCTimeRFC3339 now\n  forkBecknCallback\n    (someExceptionToCallbackReqMig cbContext)\n    (BecknCallbackReq cbContext . Right)\n    (doWithCallback . void . callBecknAPI auth Nothing (show cbAction) api cbUrl internalEndPointHashMap)\n    (show actionName)\n    action\n  return Ack\n\nforkBecknCallback ::\n  (Forkable m, MonadCatch m, Log m) =>\n  (SomeException -> result) ->\n  (success -> result) ->\n  (result -> m ()) ->\n  Text ->\n  m success ->\n  m ()\nforkBecknCallback fromError fromSuccess doWithResult actionName action =\n  fork actionName $\n    try action >>= \\case\n      Right success -> doWithResult $ fromSuccess success\n      Left err -> do\n        logError $ \"Error executing callback action \" <> actionName <> \": \" <> show err\n        doWithResult $ fromError err\n",
      "hash": "828a2c06df817bf0bd2213386a933851d7a3d60cc489955bde9bdec029d16584",
      "size": 3289
    },
    "/lib/mobility-core/src/Kernel/Utils/Common.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n\nmodule Kernel.Utils.Common\n  ( module Kernel.Utils.Common,\n    module Common,\n    callBecknAPI,\n  )\nwhere\n\nimport qualified Crypto.Number.Generate as Cryptonite\nimport qualified Data.Text as T\nimport EulerHS.Prelude hiding (id)\nimport Kernel.Prelude as Common (everyPossibleVariant, foldWIndex, identity, show)\nimport Kernel.Types.Beckn.Ack as Common\nimport Kernel.Types.CacheFlow as Common\nimport Kernel.Types.Common as Common\nimport Kernel.Types.Error.BaseError.HTTPError as Common\nimport Kernel.Types.Field as Common\nimport Kernel.Types.Id (ShortId (ShortId))\nimport Kernel.Utils.Context as Common\nimport Kernel.Utils.Error as Common\nimport Kernel.Utils.Error.BaseError.HTTPError.BecknAPIError (callBecknAPI)\nimport Kernel.Utils.Error.DB as Common\nimport Kernel.Utils.Logging as Common\nimport Kernel.Utils.Servant.Client as Common\nimport Kernel.Utils.Shutdown as Common (Shutdown)\nimport Kernel.Utils.Text as Common\nimport Kernel.Utils.Time as Common\nimport qualified Test.RandomStrings as RS\n\ngenerateShortId :: MonadFlow m => m (ShortId a)\ngenerateShortId = ShortId . T.pack <$> liftIO (RS.randomString (RS.onlyAlphaNum RS.randomASCII) 10)\n\ngenerateOTPCode :: MonadFlow m => m Text\ngenerateOTPCode =\n  liftIO $ padNumber 4 <$> Cryptonite.generateBetween 1 9999\n\ngenerateAplhaNumbericCode :: MonadFlow m => Int -> m Text\ngenerateAplhaNumbericCode len = T.pack <$> liftIO (RS.randomString (RS.onlyAlphaNum RS.randomASCII) len)\n",
      "hash": "29ae31acbeaf95f7ba9bf0d60b1f0e06f9684a67ea036157bf0932b742859f0a",
      "size": 2124
    },
    "/lib/mobility-core/src/Kernel/Utils/ComputeIntersection.hs": {
      "type": "content",
      "content": "{-\n Copyright 2022-23, Juspay India Pvt Ltd\n\n This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program\n\n is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n\n or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of\n\n the GNU Affero General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n{-# LANGUAGE TemplateHaskell #-}\n\nmodule Kernel.Utils.ComputeIntersection where\n\nimport Kernel.Beam.Lib.UtilsTH\nimport Kernel.External.Maps.Types\nimport Kernel.Prelude\nimport Kernel.Utils.GenericPretty (PrettyShow)\n\ntype RoutePoints = [LatLong]\n\ndata BoundingBox = BoundingBox\n  { topLeft :: LatLong,\n    topRight :: LatLong,\n    bottomLeft :: LatLong,\n    bottomRight :: LatLong\n  }\n  deriving (Generic, Eq, Show, Read)\n\ndata LineSegment = LineSegment\n  { start :: LatLong,\n    end :: LatLong\n  }\n  deriving (Show, Eq, Generic, FromJSON, ToJSON, ToSchema, PrettyShow, Ord, Read)\n\n$(mkBeamInstancesForEnumAndList ''LineSegment)\n\ndata Orientation = Collinear | Clockwise | AntiClockwise\n  deriving (Generic, Eq, Show, Read)\n\n-- Function to calculate cross product of two vectors (PQ x QR)\ncrossProduct :: LatLong -> LatLong -> LatLong -> Double\ncrossProduct p q r = (q.lat - p.lat) * (r.lon - q.lon) - (r.lat - q.lat) * (q.lon - p.lon)\n\n-- Function to determine orientation of three points\norientation :: LatLong -> LatLong -> LatLong -> Orientation\norientation p q r =\n  let val = crossProduct p q r\n   in if val == 0 then Collinear else if val > 0 then Clockwise else AntiClockwise\n\n-- Function to check if point q lies on segment p-r\nonSegment :: LatLong -> LatLong -> LatLong -> Bool\nonSegment p q r =\n  q.lat <= max (p.lat) (r.lat)\n    && q.lat >= min (p.lat) (r.lat)\n    && q.lon <= max (p.lon) (r.lon)\n    && q.lon >= min (p.lon) (r.lon)\n\n-- Function to check if two line segments intersect\ndoIntersect :: LineSegment -> LineSegment -> Bool\ndoIntersect (LineSegment p1 q1) (LineSegment p2 q2) =\n  let o1 = orientation p1 q1 p2\n      o2 = orientation p1 q1 q2\n      o3 = orientation p2 q2 p1\n      o4 = orientation p2 q2 q1\n   in (o1 /= o2 && o3 /= o4)\n        || (o1 == Collinear && onSegment p1 p2 q1)\n        || (o2 == Collinear && onSegment p1 q2 q1)\n        || (o3 == Collinear && onSegment p2 p1 q2)\n        || (o4 == Collinear && onSegment p2 q1 q2)\n\n-- Check if a point lies within a bounding box\npointWithinBoundingBox :: LatLong -> BoundingBox -> Bool\npointWithinBoundingBox (LatLong lat lon) (BoundingBox (LatLong topLeftLat topLeftLon) (LatLong topRightLat topRightLon) (LatLong bottomLeftLat bottomLeftLon) (LatLong bottomRightLat bottomRightLon)) =\n  lat <= max topLeftLat topRightLat && lat >= min bottomLeftLat bottomRightLat && lon >= min topLeftLon bottomLeftLon && lon <= max topRightLon bottomRightLon\n\n-- Check if a line segment is within the bounding box\nlineSegmentWithinBoundingBox :: LineSegment -> BoundingBox -> Bool\nlineSegmentWithinBoundingBox lineSegment@(LineSegment startPoint endPoint) boundingBox@(BoundingBox topLeft topRight bottomLeft bottomRight) = do\n  let startPointCheck = pointWithinBoundingBox startPoint boundingBox\n  let endPointCheck = pointWithinBoundingBox endPoint boundingBox\n\n  -- If both points are within the bounding box, return True\n  (startPointCheck && endPointCheck)\n    || ( do\n           -- Create line segments for each side of the bounding box\n           let boundingBoxEdges =\n                 [ LineSegment topLeft topRight, -- Top edge\n                   LineSegment topLeft bottomLeft, -- Left edge\n                   LineSegment bottomLeft bottomRight, -- Bottom edge\n                   LineSegment bottomRight topRight -- Right edge\n                 ]\n\n           -- Early return as soon as an intersection is found\n           let checkIntersections [] = False\n               checkIntersections (edge : remainingEdges) = do\n                 let intersects = doIntersect lineSegment edge\n                 intersects || checkIntersections remainingEdges\n\n           checkIntersections boundingBoxEdges\n       )\n\n-- Check if any line between two route points passes through intersection points\ndoRouteIntersectWithLine :: RoutePoints -> LineSegment -> Bool\ndoRouteIntersectWithLine [] _ = False\ndoRouteIntersectWithLine [_] _ = False\ndoRouteIntersectWithLine (p1 : p2 : ps) line =\n  doIntersect (LineSegment p1 p2) line || doRouteIntersectWithLine (p2 : ps) line\n\ngetBoundingBox :: RoutePoints -> BoundingBox\ngetBoundingBox points =\n  let lats = map lat points\n      lons = map lon points\n      minLat = minimum lats\n      maxLat = maximum lats\n      minLon = minimum lons\n      maxLon = maximum lons\n      topLeftPoint = LatLong maxLat minLon\n      topRightPoint = LatLong maxLat maxLon\n      bottomLeftPoint = LatLong minLat minLon\n      bottomRightPoint = LatLong minLat maxLon\n   in BoundingBox topLeftPoint topRightPoint bottomLeftPoint bottomRightPoint\n\n-- Check if intersection points lie within a bounding box and if any line between two route points passes through the intersection line\ncheckIntersection :: RoutePoints -> LineSegment -> Bool\ncheckIntersection [] _ = False\ncheckIntersection [_] _ = False\ncheckIntersection points intersectionLine = do\n  lineSegmentWithinBoundingBox intersectionLine (getBoundingBox points)\n    && doRouteIntersectWithLine points intersectionLine\n",
      "hash": "5d92c23af8be122a7604ceaa46ff8ed4982dbe1275dcab21a996eb2fcdd94f7c",
      "size": 5647
    },
    "/lib/mobility-core/src/Kernel/Utils/Context.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n\nmodule Kernel.Utils.Context where\n\nimport EulerHS.Prelude\nimport Kernel.Types.App\nimport qualified Kernel.Types.Beckn.Context as Cab\nimport Kernel.Types.MonadGuid\nimport Kernel.Types.Time\nimport Kernel.Types.TimeRFC339 (UTCTimeRFC3339 (..))\n\nbuildTaxiContext ::\n  (MonadTime m, MonadGuid m) =>\n  Cab.Action ->\n  Text ->\n  Maybe Text ->\n  Text ->\n  BaseUrl ->\n  Maybe Text ->\n  Maybe BaseUrl ->\n  Cab.City ->\n  Cab.Country ->\n  Bool ->\n  m Cab.Context\nbuildTaxiContext action msgId txnId bapId bapUri bppId bppUri city country autoAssignEnabled = do\n  currTime <- getCurrentTime\n  let max_callbacks = if autoAssignEnabled && action == Cab.SELECT then Just 1 else Nothing\n  return $\n    Cab.Context\n      { domain = Cab.MOBILITY,\n        action,\n        core_version = \"0.9.4\",\n        bap_id = bapId,\n        bap_uri = bapUri,\n        bpp_id = bppId,\n        bpp_uri = bppUri,\n        transaction_id = txnId,\n        message_id = msgId,\n        timestamp = UTCTimeRFC3339 currTime,\n        country,\n        city,\n        max_callbacks\n      }\n",
      "hash": "60214bdd37f21e592fa8d8b7f787ec41ce329480a4ab5d937d5cd976e9ae2505",
      "size": 1736
    },
    "/lib/mobility-core/src/Kernel/Utils/DatastoreLatencyCalculator.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n\nmodule Kernel.Utils.DatastoreLatencyCalculator where\n\nimport Kernel.Prelude\nimport Kernel.Storage.Hedis.Config\nimport Kernel.Tools.Metrics.CoreMetrics\nimport Kernel.Utils.Logging\nimport Kernel.Utils.Time\n\nwithTimeRedis ::\n  ( MonadReader r m,\n    HedisFlow m r,\n    Log m,\n    Monad m,\n    MonadClock m,\n    MonadTime m,\n    CoreMetrics m\n  ) =>\n  Text ->\n  Text ->\n  m a ->\n  m a\nwithTimeRedis storeType operationName operation = do\n  enableRedisLatencyLogging <- asks (.enableRedisLatencyLogging)\n  enablePrometheusMetricLogging <- asks (.enablePrometheusMetricLogging)\n  withTime storeType operationName enableRedisLatencyLogging enablePrometheusMetricLogging operation\n\nwithTime ::\n  ( MonadReader r m,\n    Log m,\n    Monad m,\n    MonadClock m,\n    MonadTime m,\n    CoreMetrics m\n  ) =>\n  Text ->\n  Text ->\n  Bool ->\n  Bool ->\n  m a ->\n  m a\nwithTime storeType operationName enableKibanaLatencyLogging enablePrometheusMetricLogging operation = do\n  (res, latency) <- measureDuration operation\n  when enableKibanaLatencyLogging $ logTagInfo (storeType <> \":\" <> operationName) $ show latency\n  when enablePrometheusMetricLogging $ addDatastoreLatency storeType operationName latency\n  pure res\n\nwithTimeGeneric ::\n  ( MonadReader r m,\n    Log m,\n    Monad m,\n    MonadClock m,\n    MonadTime m,\n    CoreMetrics m\n  ) =>\n  Text ->\n  m a ->\n  m (a, Milliseconds)\nwithTimeGeneric operationName operation = do\n  (res, latency) <- measureDuration operation\n  addGenericLatency operationName latency\n  pure (res, latency)\n\nwithTimeAPI ::\n  ( MonadReader r m,\n    HasField \"enableAPILatencyLogging\" r Bool,\n    HasField \"enableAPIPrometheusMetricLogging\" r Bool,\n    Log m,\n    Monad m,\n    MonadClock m,\n    MonadTime m,\n    CoreMetrics m\n  ) =>\n  Text ->\n  Text ->\n  m a ->\n  m a\nwithTimeAPI storeType operationName operation = do\n  enableAPILatencyLogging <- asks (.enableAPILatencyLogging)\n  enableAPIPrometheusMetricLogging <- asks (.enableAPIPrometheusMetricLogging)\n  withTime storeType operationName enableAPILatencyLogging enableAPIPrometheusMetricLogging operation\n",
      "hash": "84665f65f34bc3c2dbfb60435ad53bdada01f8df7bfaae78da846d0d00226832",
      "size": 2764
    },
    "/lib/mobility-core/src/Kernel/Utils/Dhall.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n{-# LANGUAGE CPP #-}\n{-# LANGUAGE StandaloneDeriving #-}\n{-# LANGUAGE UndecidableInstances #-}\n{-# OPTIONS_GHC -Wno-orphans #-}\n\nmodule Kernel.Utils.Dhall\n  ( module Dhall,\n    readDhallConfig,\n    readDhallConfigDefault,\n    customDecoder,\n  )\nwhere\n\nimport Data.Char (toUpper)\nimport Dhall hiding (map)\nimport EulerHS.Prelude\nimport qualified EulerHS.Types as T\nimport Servant.Client (BaseUrl, Scheme, parseBaseUrl)\nimport Servant.Client.Core (InvalidBaseUrlException (..))\nimport System.Environment (lookupEnv)\n\n-- | Reads config which lies under the given path.\nreadDhallConfig :: FromDhall b => FilePath -> IO b\nreadDhallConfig = inputFile auto\n\n-- | Reads config with a given type env. Gets application name as the second argument.\n-- E.g. if @appname@ is \"mock-provider-backend\" the function first looks into \"MOCK_PROVIDER_BACKEND_CONFIG_PATH\"\n-- env variable, if it's not set, it tries to read config from \"./config/mock-provider-backend.dhall\"\nreadDhallConfigDefault :: FromDhall b => String -> IO b\nreadDhallConfigDefault appname = do\n  fname <- fromMaybe defCfgPath <$> lookupEnv envVarName\n  readDhallConfig fname\n  where\n    defCfgPath = \"./dhall-configs/dev/\" ++ appname ++ \".dhall\"\n    envVarName = map norm appname ++ \"_CONFIG_PATH\"\n    norm '-' = '_'\n    norm c = toUpper c\n\n-----------------------------------------------------\n\ninstance {-# OVERLAPS #-} Num a => FromDhall a where\n  autoWith inn = fmap fromInteger (autoWith inn :: Decoder Integer)\n\n-- Use the instance from Dhall itself\n-- instance FromDhall Word16 where\n--   autoWith inn = fmap fromIntegral (autoWith inn :: Decoder Natural)\n\nderiving instance FromDhall Scheme\n\nderiving instance FromDhall T.PoolConfig\n\nderiving instance FromDhall T.PostgresConfig\n\nderiving instance FromDhall T.RedisConfig\n\ninstance FromDhall BaseUrl where\n  autoWith = customDecoder showBaseUrlErr parseBaseUrl . autoWith\n    where\n      showBaseUrlErr :: SomeException -> Text\n      showBaseUrlErr e = case fromException e of\n        Just (InvalidBaseUrlException msg) -> toText msg\n        Nothing -> \"Some unknown error: \" <> show e\n\ncustomDecoder :: (a1 -> Text) -> (t -> Either a1 a2) -> Decoder t -> Decoder a2\ncustomDecoder ifErr parser Decoder {..} =\n  Decoder\n    { extract = \\x -> fromMonadic do\n        txt <- toMonadic (extract x)\n        parser txt\n          & either (toMonadic . extractError . ifErr) pure,\n      ..\n    }\n",
      "hash": "5bd66be0a1938f98ebb509d3f1c5212663ed61d0180e083fa8c01e0b33230716",
      "size": 3090
    },
    "/lib/mobility-core/src/Kernel/Utils/Error.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n\nmodule Kernel.Utils.Error (module Error) where\n\nimport Kernel.Utils.Error.FlowHandling as Error\nimport Kernel.Utils.Error.Hierarchy as Error\nimport Kernel.Utils.Error.Throwing as Error\n",
      "hash": "f53b4785df26a7cfaff77d2a714acdaf7f2e85a58d9a79733caaf6cc1a034214",
      "size": 879
    },
    "/lib/mobility-core/src/Kernel/Utils/Error/BaseError/HTTPError/APIError.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n{-# LANGUAGE DeriveAnyClass #-}\n{-# LANGUAGE TemplateHaskell #-}\n\nmodule Kernel.Utils.Error.BaseError.HTTPError.APIError where\n\nimport qualified Data.HashMap.Strict as HM\nimport EulerHS.Prelude\nimport qualified EulerHS.Types as ET\nimport Kernel.Types.Error.BaseError.HTTPError\nimport Kernel.Utils.Error.Throwing\nimport Kernel.Utils.Logging\nimport Kernel.Utils.Servant.Client\nimport Servant.Client\n\nnewtype APICallError = APICallError APIError\n  deriving (Show, IsBecknAPIError)\n\ninstanceExceptionWithParent 'HTTPException ''APICallError\n\ninstance IsBaseError APICallError where\n  toMessage (APICallError APIError {..}) =\n    Just $\n      \"Request to own API returned error code \" <> errorCode\n        <> maybe \"\" (\" with message: \" <>) errorMessage\n\ninstance IsHTTPError APICallError where\n  toErrorCode (APICallError _) = \"API_CALL_ERROR\"\n\ninstance IsAPIError APICallError\n\ncallOwnAPI ::\n  Maybe ET.ManagerSelector ->\n  Maybe Text ->\n  Maybe (HM.HashMap BaseUrl BaseUrl) ->\n  CallAPI env api a\ncallOwnAPI = callApiUnwrappingApiError APICallError\n\ncatchOwnAPI ::\n  ( HasCallStack,\n    MonadCatch m,\n    Log m\n  ) =>\n  m a ->\n  (Text -> m a) ->\n  m a\ncatchOwnAPI m f = m `safeCatch` \\(APICallError APIError {errorCode}) -> f errorCode\n\ninfixl 1 `catchOwnAPI`\n\ntoAPIError :: (IsHTTPError e, IsAPIError e) => e -> APIError\ntoAPIError e =\n  APIError\n    { errorCode = toErrorCode e,\n      errorMessage = toMessageIfNotInternal e,\n      errorPayload = toPayload e\n    }\n",
      "hash": "6ba37b9f5ac7d0a6e39d92fdec295ec7e4c05a9fd22d9e77abfc81f004799372",
      "size": 2158
    },
    "/lib/mobility-core/src/Kernel/Utils/Error/BaseError/HTTPError/BecknAPIError.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n{-# LANGUAGE DeriveAnyClass #-}\n{-# LANGUAGE TemplateHaskell #-}\n\nmodule Kernel.Utils.Error.BaseError.HTTPError.BecknAPIError where\n\nimport qualified Data.HashMap.Strict as HM\nimport EulerHS.Prelude\nimport qualified EulerHS.Types as ET\nimport Kernel.Tools.Metrics.CoreMetrics (CoreMetrics)\nimport Kernel.Types.Common\nimport Kernel.Types.Error.BaseError.HTTPError\nimport Kernel.Utils.Monitoring.Prometheus.Servant\nimport Kernel.Utils.Servant.Client\nimport Servant.Client (Client, HasClient)\n\ndata BecknAPICallError = BecknAPICallError Text Error\n  deriving (Show, IsAPIError, IsBecknAPIError)\n\ninstanceExceptionWithParent 'HTTPException ''BecknAPICallError\n\ninstance IsBaseError BecknAPICallError where\n  toMessage (BecknAPICallError action Error {..}) =\n    Just $\n      \"Beckn \" <> action <> \" request returned error code \" <> code\n        <> maybe \"\" (\"with message: \" <>) message\n\ninstance IsHTTPError BecknAPICallError where\n  toErrorCode (BecknAPICallError _ _) = \"BECKN_API_CALL_ERROR\"\n\ntype IsBecknAPI api req res =\n  ( HasClient ET.EulerClient api,\n    Client ET.EulerClient api ~ (req -> ET.EulerClient res),\n    ToJSON res\n  )\n\ncallBecknAPI ::\n  ( MonadFlow m,\n    CoreMetrics m,\n    IsBecknAPI api req res,\n    SanitizedUrl api\n  ) =>\n  Maybe ET.ManagerSelector ->\n  Maybe Text ->\n  Text ->\n  Proxy api ->\n  BaseUrl ->\n  HM.HashMap BaseUrl BaseUrl ->\n  req ->\n  m res\ncallBecknAPI mbManagerSelector errorCodeMb action api baseUrl internalEndPointHashMap req = do\n  callBecknAPI' mbManagerSelector errorCodeMb (Just internalEndPointHashMap) baseUrl (ET.client api req) action api\n\ncallBecknAPI' ::\n  MonadFlow m =>\n  Maybe ET.ManagerSelector ->\n  Maybe Text ->\n  Maybe (HM.HashMap BaseUrl BaseUrl) ->\n  CallAPI m api res\ncallBecknAPI' mbManagerSelector errorCodeMb internalEndPointHashMap baseUrl eulerClient name api = do\n  callApiUnwrappingApiError\n    (becknAPIErrorToException name)\n    mbManagerSelector\n    errorCodeMb\n    internalEndPointHashMap\n    baseUrl\n    eulerClient\n    name\n    api\n\ncallPseudoBecknAPI ::\n  Maybe ET.ManagerSelector ->\n  Maybe Text ->\n  HM.HashMap BaseUrl BaseUrl ->\n  CallAPI env api a\ncallPseudoBecknAPI mbManagerSelector errorCodeMb internalEndPointHashMap baseUrl eulerClient name api =\n  callApiUnwrappingApiError\n    (becknAPIErrorToException name)\n    mbManagerSelector\n    errorCodeMb\n    (Just internalEndPointHashMap)\n    baseUrl\n    eulerClient\n    name\n    api\n\nbecknAPIErrorToException :: Text -> BecknAPIError -> BecknAPICallError\nbecknAPIErrorToException name (BecknAPIError becknErr) = BecknAPICallError name becknErr\n\ntoBecknAPIError :: (IsHTTPError e, IsBecknAPIError e) => e -> BecknAPIError\ntoBecknAPIError e =\n  BecknAPIError\n    Error\n      { _type = toType e,\n        code = toErrorCode e,\n        path = toPath e,\n        message = toMessageIfNotInternal e\n      }\n",
      "hash": "820c0528d8647276e6d99d336563490d3b66f731ccf81e791d51048cb01cd8a5",
      "size": 3524
    },
    "/lib/mobility-core/src/Kernel/Utils/Error/DB.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n\nmodule Kernel.Utils.Error.DB where\n\nimport EulerHS.Prelude\nimport qualified EulerHS.Types as ET\nimport Kernel.Types.Common\nimport Kernel.Types.Error\nimport Kernel.Types.Error.BaseError.HTTPError\nimport Kernel.Utils.Error.Throwing\n\nthrowDBError :: (MonadThrow m, Log m) => ET.DBError -> m a\nthrowDBError (ET.DBError dbErrType msg) = throwError $\n  case dbErrType of\n    ET.UnexpectedResult -> SQLResultError msg\n    ET.SQLError sqlErr -> SQLRequestError (show sqlErr) msg\n    _ -> DBUnknownError msg\n\ncheckDBError :: (MonadThrow m, Log m) => ET.DBResult a -> m a\ncheckDBError = either throwDBError pure\n\ncheckDBErrorOrEmpty ::\n  (MonadThrow m, Log m, IsBaseException b) =>\n  ET.DBResult (Maybe a) ->\n  b ->\n  m a\ncheckDBErrorOrEmpty dbres domainErrOnEmpty =\n  either throwDBError (fromMaybeM domainErrOnEmpty) dbres\n",
      "hash": "9c9b153b1250d6d2bff0c448da251055c907efea96130c9362b23b4a2385de41",
      "size": 1509
    },
    "/lib/mobility-core/src/Kernel/Utils/Error/FlowHandling.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n\nmodule Kernel.Utils.Error.FlowHandling\n  ( withFlowHandler,\n    withFlowHandler',\n    withDashboardFlowHandler,\n    withDashboardFlowHandler',\n    withFlowHandlerAPI,\n    withFlowHandlerAPI',\n    withDashboardFlowHandlerAPI,\n    withDashboardFlowHandlerAPI',\n    withFlowHandlerBecknAPI,\n    withFlowHandlerBecknAPI',\n    apiHandler,\n    becknApiHandler,\n    someExceptionToBecknApiError,\n    handleIfUp,\n    throwServantError,\n  )\nwhere\n\nimport Control.Concurrent.STM (isEmptyTMVar)\nimport Control.Monad.Reader\nimport qualified Data.Aeson as A\nimport Data.Time.Clock hiding (getCurrentTime)\nimport qualified EulerHS.Language as L\nimport EulerHS.Prelude\nimport GHC.Records.Extra\nimport Kernel.Beam.Lib.UtilsTH\nimport qualified Kernel.Beam.Types as KBT\nimport Kernel.Storage.Beam.SystemConfigs as BeamSC\nimport Kernel.Storage.Clickhouse.Config\nimport Kernel.Storage.Queries.SystemConfigs\nimport qualified Kernel.Tools.Metrics.CoreMetrics as Metrics\nimport Kernel.Tools.Metrics.CoreMetrics.Types\nimport Kernel.Types.App\nimport Kernel.Types.Beckn.Ack\nimport Kernel.Types.Common\nimport Kernel.Types.Error as Err\nimport Kernel.Types.Error.BaseError.HTTPError\nimport Kernel.Types.Flow\nimport Kernel.Utils.Error.BaseError.HTTPError.APIError (toAPIError)\nimport Kernel.Utils.Error.BaseError.HTTPError.BecknAPIError (toBecknAPIError)\nimport Kernel.Utils.Logging\nimport Kernel.Utils.Text\nimport Network.HTTP.Types (Header, hContentType)\nimport Network.HTTP.Types.Header (HeaderName)\nimport Servant (ServerError (..))\n\n-- we are using find query and setoption here which requires the constraint HasFlowHandlerR  has\n-- we will be withFlowHandler only in case db or redis call is required as it has the constraint for db and redis env in HasFlowHandlerR\nwithFlowHandler ::\n  HasFlowHandlerR (FlowR r) r =>\n  FlowR r a ->\n  FlowHandlerR r a\nwithFlowHandler flow = do\n  (EnvR flowRt appEnv) <- ask\n  liftIO . runFlowR flowRt appEnv $ getAndSetKvConfigs >> flow\n  where\n    getAndSetKvConfigs = do\n      now <- getCurrentTime\n      kvConfigLastUpdatedTime <- L.getOption KBT.KvConfigLastUpdatedTime >>= maybe (L.setOption KBT.KvConfigLastUpdatedTime now >> pure now) pure\n      kvConfigUpdateFrequency <- L.getOption KBT.KvConfigUpdateFrequency >>= maybe (pure 10) pure\n      when (round (diffUTCTime now kvConfigLastUpdatedTime) > kvConfigUpdateFrequency) $\n        findById \"kv_configs\" >>= pure . decodeFromText' @Tables\n          >>= maybe (incrementSystemConfigsFailedCounter (\"kv_config_decode_failed_\" <> schemaName (Proxy :: Proxy BeamSC.SystemConfigsT))) (\\result' -> L.setOption KBT.Tables result' >> L.setOption KBT.KvConfigLastUpdatedTime now)\n\nwithDashboardFlowHandler ::\n  ( HasField \"serviceClickhouseCfg\" r ClickhouseCfg,\n    HasField \"serviceClickhouseEnv\" r ClickhouseEnv,\n    HasField \"dashboardClickhouseCfg\" r ClickhouseCfg,\n    HasField \"dashboardClickhouseEnv\" r ClickhouseEnv,\n    HasFlowHandlerR (FlowR r) r\n  ) =>\n  FlowR r a ->\n  FlowHandlerR r a\nwithDashboardFlowHandler flow = do\n  (EnvR flowRt appEnv) <- ask\n  let newappEnv = appEnv{serviceClickhouseCfg = appEnv.dashboardClickhouseCfg, serviceClickhouseEnv = appEnv.dashboardClickhouseEnv}\n  liftIO . runFlowR flowRt newappEnv $ getAndSetKvConfigs >> flow\n  where\n    getAndSetKvConfigs = do\n      now <- getCurrentTime\n      kvConfigLastUpdatedTime <- L.getOption KBT.KvConfigLastUpdatedTime >>= maybe (L.setOption KBT.KvConfigLastUpdatedTime now >> pure now) pure\n      kvConfigUpdateFrequency <- L.getOption KBT.KvConfigUpdateFrequency >>= maybe (pure 10) pure\n      when (round (diffUTCTime now kvConfigLastUpdatedTime) > kvConfigUpdateFrequency) $\n        findById \"kv_configs\" >>= pure . decodeFromText' @Tables\n          >>= maybe (incrementSystemConfigsFailedCounter (\"kv_config_decode_failed_\" <> schemaName (Proxy :: Proxy BeamSC.SystemConfigsT))) (\\result' -> L.setOption KBT.Tables result' >> L.setOption KBT.KvConfigLastUpdatedTime now)\n\n-- in case of normal flow use withFlowHandler' as it does not have any extra constraints\nwithFlowHandler' ::\n  FlowR r a ->\n  FlowHandlerR r a\nwithFlowHandler' flow = do\n  (EnvR flowRt appEnv) <- ask\n  liftIO . runFlowR flowRt appEnv $ flow\n\nwithDashboardFlowHandler' ::\n  ( HasField \"serviceClickhouseCfg\" r ClickhouseCfg,\n    HasField \"serviceClickhouseEnv\" r ClickhouseEnv,\n    HasField \"dashboardClickhouseCfg\" r ClickhouseCfg,\n    HasField \"dashboardClickhouseEnv\" r ClickhouseEnv\n  ) =>\n  FlowR r a ->\n  FlowHandlerR r a\nwithDashboardFlowHandler' flow = do\n  (EnvR flowRt appEnv) <- ask\n  let newappEnv = appEnv{serviceClickhouseCfg = appEnv.dashboardClickhouseCfg, serviceClickhouseEnv = appEnv.dashboardClickhouseEnv}\n  liftIO . runFlowR flowRt newappEnv $ flow\n\nwithFlowHandlerAPI ::\n  ( HasFlowHandlerR (FlowR r) r,\n    Metrics.CoreMetrics (FlowR r),\n    HasField \"isShuttingDown\" r (TMVar ())\n  ) =>\n  FlowR r a ->\n  FlowHandlerR r a\nwithFlowHandlerAPI = withFlowHandler . apiHandler . handleIfUp\n\nwithDashboardFlowHandlerAPI ::\n  ( HasField \"serviceClickhouseCfg\" r ClickhouseCfg,\n    HasField \"serviceClickhouseEnv\" r ClickhouseEnv,\n    HasField \"dashboardClickhouseCfg\" r ClickhouseCfg,\n    HasField \"dashboardClickhouseEnv\" r ClickhouseEnv,\n    HasFlowHandlerR (FlowR r) r,\n    Metrics.CoreMetrics (FlowR r),\n    HasField \"isShuttingDown\" r (TMVar ())\n  ) =>\n  FlowR r a ->\n  FlowHandlerR r a\nwithDashboardFlowHandlerAPI = withDashboardFlowHandler . apiHandler . handleIfUp\n\n-- created this for using it in mock-registry as it does not require any extra constraints\nwithFlowHandlerAPI' ::\n  ( Metrics.CoreMetrics (FlowR r),\n    HasField \"isShuttingDown\" r (TMVar ()),\n    Log (FlowR r)\n  ) =>\n  FlowR r a ->\n  FlowHandlerR r a\nwithFlowHandlerAPI' = withFlowHandler' . apiHandler . handleIfUp\n\nwithDashboardFlowHandlerAPI' ::\n  ( HasField \"serviceClickhouseCfg\" r ClickhouseCfg,\n    HasField \"serviceClickhouseEnv\" r ClickhouseEnv,\n    HasField \"dashboardClickhouseCfg\" r ClickhouseCfg,\n    HasField \"dashboardClickhouseEnv\" r ClickhouseEnv,\n    Metrics.CoreMetrics (FlowR r),\n    HasField \"isShuttingDown\" r (TMVar ()),\n    Log (FlowR r)\n  ) =>\n  FlowR r a ->\n  FlowHandlerR r a\nwithDashboardFlowHandlerAPI' = withDashboardFlowHandler' . apiHandler . handleIfUp\n\nwithFlowHandlerBecknAPI ::\n  ( HasFlowHandlerR (FlowR r) r,\n    Metrics.CoreMetrics (FlowR r),\n    HasField \"isShuttingDown\" r (TMVar ())\n  ) =>\n  FlowR r AckResponse ->\n  FlowHandlerR r AckResponse\nwithFlowHandlerBecknAPI = withFlowHandler . becknApiHandler . handleIfUp\n\n-- created this for using it in beckn-gateway as it does not require any extra constraints\nwithFlowHandlerBecknAPI' ::\n  ( Metrics.CoreMetrics (FlowR r),\n    HasField \"isShuttingDown\" r (TMVar ()),\n    Log (FlowR r)\n  ) =>\n  FlowR r AckResponse ->\n  FlowHandlerR r AckResponse\nwithFlowHandlerBecknAPI' = withFlowHandler' . becknApiHandler . handleIfUp\n\nhandleIfUp ::\n  ( L.MonadFlow m,\n    Log m,\n    MonadReader r m,\n    HasField \"isShuttingDown\" r (TMVar ()),\n    Metrics.CoreMetrics m\n  ) =>\n  m a ->\n  m a\nhandleIfUp flow = do\n  shutdown <- asks (.isShuttingDown)\n  shouldRun <- L.runIO $ atomically $ isEmptyTMVar shutdown\n  if shouldRun\n    then flow\n    else throwAPIError ServerUnavailable\n\napiHandler ::\n  ( MonadCatch m,\n    Log m,\n    Metrics.CoreMetrics m\n  ) =>\n  m a ->\n  m a\napiHandler = (`catch` someExceptionToAPIErrorThrow)\n\nbecknApiHandler ::\n  ( MonadCatch m,\n    Log m,\n    Metrics.CoreMetrics m\n  ) =>\n  m a ->\n  m a\nbecknApiHandler = (`catch` someExceptionToBecknApiErrorThrow)\n\nsomeExceptionToAPIErrorThrow ::\n  ( MonadCatch m,\n    Log m,\n    Metrics.CoreMetrics m\n  ) =>\n  SomeException ->\n  m a\nsomeExceptionToAPIErrorThrow exc\n  | Just (HTTPException err) <- fromException exc = throwAPIError err\n  | Just (BaseException err) <- fromException exc =\n    throwAPIError . InternalError . fromMaybe (show err) $ toMessage err\n  | otherwise = throwAPIError . InternalError $ show exc\n\nsomeExceptionToBecknApiErrorThrow ::\n  ( MonadCatch m,\n    Log m,\n    Metrics.CoreMetrics m\n  ) =>\n  SomeException ->\n  m a\nsomeExceptionToBecknApiErrorThrow exc\n  | Just (HTTPException err) <- fromException exc = throwBecknApiError err\n  | otherwise =\n    throwBecknApiError . InternalError $ show exc\n\nsomeExceptionToBecknApiError :: SomeException -> BecknAPIError\nsomeExceptionToBecknApiError exc\n  | Just (HTTPException err) <- fromException exc = toBecknAPIError err\n  | otherwise = toBecknAPIError . InternalError $ show exc\n\nthrowAPIError ::\n  ( Log m,\n    MonadThrow m,\n    IsHTTPException e,\n    Exception e,\n    Metrics.CoreMetrics m\n  ) =>\n  e ->\n  m a\nthrowAPIError = throwHTTPError toAPIError\n\nthrowBecknApiError ::\n  ( Log m,\n    MonadThrow m,\n    IsHTTPException e,\n    Exception e,\n    Metrics.CoreMetrics m\n  ) =>\n  e ->\n  m a\nthrowBecknApiError = throwHTTPError toBecknAPIError\n\nthrowHTTPError ::\n  ( ToJSON j,\n    Log m,\n    MonadThrow m,\n    IsHTTPException e,\n    Exception e,\n    Metrics.CoreMetrics m\n  ) =>\n  (e -> j) ->\n  e ->\n  m b\nthrowHTTPError toJsonError err = do\n  let someExc = toException err\n  logError $ makeLogSomeException someExc\n  Metrics.incrementErrorCounter \"DEFAULT_ERROR\" someExc\n  throwServantError (toHttpCode err) (toCustomHeaders err) (toJsonError err)\n\nthrowServantError ::\n  (ToJSON a, Log m, MonadThrow m) =>\n  HttpCode ->\n  [Header] ->\n  a ->\n  m b\nthrowServantError httpCode customHeaders jsonError = withLogTag \"HTTP_ERROR\" $ do\n  let body = A.encode jsonError\n  let serverErr = toServerError httpCode\n  throwM\n    serverErr\n      { errBody = body,\n        errHeaders = jsonHeader : customHeaders ++ errHeaders serverErr\n      }\n  where\n    jsonHeader :: (HeaderName, ByteString)\n    jsonHeader = (hContentType, \"application/json;charset=utf-8\")\n",
      "hash": "e1d9c438f79ba27e63a6e769f2b20b054cfa78c22d575557cabde5d13eeb21b2",
      "size": 10370
    },
    "/lib/mobility-core/src/Kernel/Utils/Error/Hierarchy.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n{-# LANGUAGE QuasiQuotes #-}\n{-# LANGUAGE TemplateHaskell #-}\n\nmodule Kernel.Utils.Error.Hierarchy where\n\nimport Data.Typeable (cast)\nimport EulerHS.Prelude\nimport Language.Haskell.TH\n\ninstanceExceptionWithParent :: Name -> Name -> DecsQ\ninstanceExceptionWithParent parent child =\n  [d|\n    instance Exception $(conT child) where\n      toException = toException . $(conE parent)\n      fromException = $(pure unPat) <=< fromException\n    |]\n  where\n    unPat =\n      let x = mkName \"x\"\n       in LamE [ConP parent [] [VarP x]] $\n            AppE (VarE 'cast) (VarE x)\n",
      "hash": "b7311db539cef0e9879a81d69a46a1e8a23b374007076297255b724e40f0ec8d",
      "size": 1260
    },
    "/lib/mobility-core/src/Kernel/Utils/Error/Throwing.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n\nmodule Kernel.Utils.Error.Throwing\n  ( module Kernel.Utils.Error.Throwing,\n    IsHTTPException,\n  )\nwhere\n\nimport Control.Exception (PatternMatchFail)\nimport qualified Data.Text as T\nimport EulerHS.Prelude\nimport Kernel.Types.Error.BaseError.HTTPError\nimport Kernel.Utils.Logging\n\nthrowError :: (HasCallStack, MonadThrow m, Log m, IsBaseException e) => e -> m b\nthrowError exc = do\n  let someExc = toException exc\n  logWarning $ makeLogSomeException someExc\n  logCallStack\n  throwM someExc\n  where\n    logCallStack =\n      withLogTag \"CallStack\" $\n        logDebug . T.pack $ prettyCallStack callStack\n\nfromMaybeM ::\n  (HasCallStack, MonadThrow m, Log m, IsBaseException e) => e -> Maybe b -> m b\nfromMaybeM err = maybe (throwError err) pure\n\nfromEitherM ::\n  (HasCallStack, MonadThrow m, Log m, IsBaseException e) => (left -> e) -> Either left b -> m b\nfromEitherM toerr = fromEitherM' (throwError . toerr)\n\nliftEither ::\n  (HasCallStack, MonadThrow m, Log m, IsBaseException e) => Either e b -> m b\nliftEither = fromEitherM id\n\nfromEitherM' ::\n  Applicative m => (l -> m r) -> Either l r -> m r\nfromEitherM' f = either f pure\n\nsafeCatch ::\n  ( HasCallStack,\n    MonadCatch m,\n    Log m,\n    Exception e\n  ) =>\n  m a ->\n  (e -> m a) ->\n  m a\nsafeCatch m f =\n  m `catch` \\exc ->\n    f exc `catch` \\(_ :: PatternMatchFail) ->\n      throwM exc\n\n-- Given\n--   data E = A | B\n-- an action\n--   throw B `safeCatch` \\A -> ...\n-- does not fail with \"Non-exhaustive patterns\"\n\nrethrow ::\n  ( HasCallStack,\n    MonadCatch m,\n    Log m,\n    Exception e,\n    IsBaseException e'\n  ) =>\n  m a ->\n  (e -> e') ->\n  m a\nrethrow m f = m `safeCatch` (throwError . f)\n",
      "hash": "e973d11476d0944369e5e28f755a408c33689db02d0a7b5e0b40e76f39535ae7",
      "size": 2343
    },
    "/lib/mobility-core/src/Kernel/Utils/Example.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n\nmodule Kernel.Utils.Example where\n\nimport Data.Time\nimport EulerHS.Prelude\n\nclass Example a where\n  -- | Sample value of a thing.\n  --\n  -- This can be used for mocking.\n  -- Also, it is especially useful for including examples into swagger,\n  -- because random generation can produce non-demostrative values\n  -- (e.g. empty lists) unless special care is taken.\n  example :: a\n\ninstance Example a => Example (Maybe a) where\n  example = Just example\n\ninstance Example a => Example [a] where\n  example = one example\n\ninstance Example UTCTime where\n  example =\n    UTCTime\n      (fromGregorian 2020 8 2)\n      (timeOfDayToTime (TimeOfDay 7 7 7))\n\n-- until we start using newtypes everywhere\nidExample :: Text\nidExample = \"123e4567-e89b-12d3-a456-426655440000\"\n",
      "hash": "c4dbfef7a652823faf861eed6420732cb60fea6241bee812574e987236d560df",
      "size": 1452
    },
    "/lib/mobility-core/src/Kernel/Utils/ExternalAPICallLogging.hs": {
      "type": "content",
      "content": "module Kernel.Utils.ExternalAPICallLogging where\n\nimport Data.Aeson\nimport Data.Either\nimport Data.Text\nimport Kernel.Prelude\nimport qualified Kernel.Streaming.Kafka.Producer as KafkaProd\nimport Kernel.Streaming.Kafka.Producer.Types (HasKafkaProducer)\nimport Kernel.Types.Common\nimport Kernel.Types.Id (Id)\nimport qualified Kernel.Utils.Text as KUT\nimport System.Environment (lookupEnv)\n\ndata ExternalAPICallLog = ExternalAPICallLog\n  { id :: Id ExternalAPICallLog,\n    apiName :: Text,\n    svcProvider :: Text,\n    entityId :: Maybe Text,\n    requestPayload :: Maybe Text,\n    responsePayload :: Text,\n    createdAt :: UTCTime,\n    updatedAt :: UTCTime\n  }\n  deriving (Generic, ToJSON, FromJSON, Read, Show)\n\npushExternalApiCallDataToKafka :: (MonadFlow m, MonadReader r m, ToJSON req', ToJSON err, ToJSON res', HasKafkaProducer r) => Text -> Text -> Maybe Text -> Maybe req' -> Either err res' -> m ()\npushExternalApiCallDataToKafka apiName svcProvider entityId req eithRes = do\n  let res = either KUT.encodeToText KUT.encodeToText eithRes\n  kafkaPushEnabled <- liftIO $ fromMaybe False . (readMaybe =<<) <$> lookupEnv \"ENABLE_API_LOGS_KAFKA_PUSH\"\n  when kafkaPushEnabled $ pushExternalApiCallDataToKafkaWithTextEncodedResp apiName svcProvider entityId req res\n\npushExternalApiCallDataToKafkaWithTextEncodedResp :: forall m r req'. (MonadFlow m, MonadReader r m, ToJSON req', HasKafkaProducer r) => Text -> Text -> Maybe Text -> Maybe req' -> Text -> m ()\npushExternalApiCallDataToKafkaWithTextEncodedResp apiName svcProvider entityId req res = do\n  KafkaProd.produceMessage (\"External-API-Call-Logs\", Nothing) =<< buildExternalAPICallLog\n  where\n    buildExternalAPICallLog = do\n      id <- generateGUID\n      timestamp <- getCurrentTime\n      return $\n        ExternalAPICallLog\n          { requestPayload = KUT.encodeToText <$> req,\n            responsePayload = res,\n            createdAt = timestamp,\n            updatedAt = timestamp,\n            ..\n          }\n",
      "hash": "5f364ba83671f7f57c56107f83619e34de7d7e71ad0ca6e0e0f3fbcb5bb4e30b",
      "size": 1970
    },
    "/lib/mobility-core/src/Kernel/Utils/FlowLogging.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n\nmodule Kernel.Utils.FlowLogging\n  ( LoggerConfig (..),\n    getEulerLoggerRuntime,\n    appendLogContext,\n    logOutputImplementation,\n    withLogTagImplementation,\n  )\nwhere\n\nimport Data.Aeson as A\nimport qualified Data.Aeson.KeyMap as AKM\nimport qualified Data.ByteString.Builder as Builder\nimport qualified Data.ByteString.Lazy as LBS\nimport qualified Data.HashMap.Strict as HM\nimport qualified Data.Text as Text\nimport qualified Data.Text.Lazy as LT\nimport qualified Data.Text.Lazy.Builder as LTB\nimport qualified Data.Time as Time\nimport qualified EulerHS.Language as L\nimport EulerHS.Prelude\nimport EulerHS.Runtime\nimport EulerHS.Types (LogContext)\nimport qualified EulerHS.Types as T\nimport qualified Formatting.Buildable as FB (build)\nimport Kernel.Types.Logging\nimport System.Logger (DateFormat, Renderer, renderDefault)\nimport qualified Prelude as P\n\nlogOutputImplementation :: L.MonadFlow m => LogLevel -> T.Message -> m ()\nlogOutputImplementation logLevel message =\n  case logLevel of\n    DEBUG -> L.logDebug EmtpyTag msg\n    INFO -> L.logInfo EmtpyTag msg\n    WARNING -> L.logWarning EmtpyTag msg\n    ERROR -> L.logError EmtpyTag msg\n  where\n    -- the T.Message type from an older version of Euler-hs\n    -- previously used to be a type-synonym to \"Text\"\n    -- It is now a record, with a \"Buildable\" instance\n    -- While the logging functions still expect a Text\n    msg = LT.toStrict . LTB.toLazyText $ FB.build message\n\nwithLogTagImplementation ::\n  L.MonadFlow m =>\n  Text ->\n  ReaderT r m a ->\n  ReaderT r m a\nwithLogTagImplementation lc flowR =\n  ReaderT $\n    (\\r -> appendLogContext' lc *> runReaderT flowR r)\n\ndata EmtpyTag = EmtpyTag\n\ninstance P.Show EmtpyTag where\n  show _ = \"\"\n\nformatTag :: Text -> Text\nformatTag tag = \"[\" <> tag <> \"]\"\n\nappendLogContext' :: L.MonadFlow m => Text -> m ()\nappendLogContext' val = do\n  oldLCText <- fromMaybe \"\" <$> L.getLoggerContext logContextKey\n  L.setLoggerContext logContextKey (oldLCText <> formatTag val)\n\nappendLogContext :: Text -> (IORef LogContext) -> IO (IORef LogContext)\nappendLogContext val _ = newIORef (HM.insert logContextKey (formatTag val) HM.empty)\n\n-- where\n--   func lc =\n--     let oldLCText = fromMaybe \"\" $ HM.lookup logContextKey lc\n--      in HM.insert logContextKey (oldLCText <> formatTag val) lc\n\ngetEulerLoggerConfig :: LoggerConfig -> T.LoggerConfig\ngetEulerLoggerConfig LoggerConfig {..} =\n  T.defaultLoggerConfig\n    { T._isAsync = True,\n      T._logLevel = logLevel,\n      T._logToFile = logToFile,\n      T._logFilePath = eulLogsFilePath,\n      T._logToConsole = logToConsole,\n      T._logRawSql = logSql\n    }\n  where\n    logLevel = case level of\n      DEBUG -> T.Debug\n      INFO -> T.Info\n      WARNING -> T.Warning\n      ERROR -> T.Error\n    logSql =\n      if logRawSql\n        then T.UnsafeLogSQL_DO_NOT_USE_IN_PRODUCTION\n        else T.SafelyOmitSqlLogs\n    eulLogsFilePath = do\n      let (l, r) = Text.breakOnEnd \".\" (Text.pack logFilePath)\n      Text.unpack $\n        if null l\n          then r <> \"-eul\"\n          else Text.init l <> \"-eul.\" <> r\n\ngetEulerLoggerRuntime :: Maybe Text -> LoggerConfig -> IO LoggerRuntime\ngetEulerLoggerRuntime hostname = createOwnLoggerRuntime (logFlowFormatter hostname) . getEulerLoggerConfig\n\ncreateOwnLoggerRuntime :: T.FlowFormatter -> T.LoggerConfig -> IO LoggerRuntime\ncreateOwnLoggerRuntime flowFt = createLoggerRuntime' defaultDateFormat (Just ownRender) defaultBufferSize flowFt Nothing\n  where\n    ownRender :: Renderer\n    ownRender s _ _ xs =\n      let lbsFromBuilder = Builder.toLazyByteString $ renderDefault s xs\n       in if LBS.length lbsFromBuilder > 3 -- 3 character, for deleting prefix\n            then Builder.lazyByteString $ LBS.drop 3 lbsFromBuilder\n            else Builder.lazyByteString lbsFromBuilder\n\n    defaultBufferSize :: T.BufferSize\n    defaultBufferSize = 4096 -- value fro/m euler-hs\n    defaultDateFormat :: Maybe DateFormat\n    defaultDateFormat = Nothing -- value from euler-hs\n\nlogFlowFormatter :: Maybe Text -> T.FlowFormatter\nlogFlowFormatter hostname _ = do\n  currTime <- Time.getCurrentTime\n  pure $ logFormatterText currTime hostname\n\nlogFormatterText :: Time.UTCTime -> Maybe Text -> T.MessageFormatter\nlogFormatterText\n  timestamp\n  hostname\n  (T.V1 _mbFlowGuid elvl eTag (T.Message msg _) msgNum logContHM) = res\n    where\n      logCont = HM.lookupDefault \"\" logContextKey logContHM\n      tag = if null eTag || eTag == \"\\\"\\\"\" then \"\" else formatTag eTag\n      lvl = case elvl of\n        T.Debug -> DEBUG\n        T.Warning -> WARNING\n        T.Info -> INFO\n        T.Error -> ERROR\n      -- textToLBS = LBS.fromStrict . Txt.encodeUtf8\n      res =\n        T.SimpleLBS . A.encode $\n          A.Object $\n            AKM.fromList\n              [ (\"timestamp\", A.String $ show timestamp),\n                (\"lvl\", A.String $ show lvl),\n                (\"msgNum\", A.String $ show msgNum),\n                (\"hostname\", A.String $ fromMaybe \"\" hostname),\n                (\"logCont\", A.String logCont),\n                (\"tag\", A.String tag),\n                (\"msg\", fromMaybe A.Null msg)\n              ]\nlogFormatterText\n  timestamp\n  hostname\n  (T.V2 _mbFlowGuid elvl _ _ _ _ _ _ (T.Message msg _) msgNum logContHM) = res\n    where\n      logCont = HM.lookupDefault \"\" logContextKey logContHM\n      lvl = case elvl of\n        T.Debug -> DEBUG\n        T.Warning -> WARNING\n        T.Info -> INFO\n        T.Error -> ERROR\n      -- textToLBS = LBS.fromStrict . Txt.encodeUtf8\n      res =\n        T.SimpleLBS . A.encode $\n          A.Object $\n            AKM.fromList\n              [ (\"timestamp\", A.String $ show timestamp),\n                (\"lvl\", A.String $ show lvl),\n                (\"msgNum\", A.String $ show msgNum),\n                (\"hostname\", A.String $ fromMaybe \"\" hostname),\n                (\"logCont\", A.String logCont),\n                (\"msg\", fromMaybe A.Null msg)\n              ]\n\nlogContextKey :: Text\nlogContextKey = \"log_context\"\n",
      "hash": "7e4db641205fa5813726b12d44d143ce6f598494a5952509ffacdefe916cf0fb",
      "size": 6617
    },
    "/lib/mobility-core/src/Kernel/Utils/GenericPretty.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n{-# LANGUAGE DefaultSignatures #-}\n{-# LANGUAGE FlexibleContexts #-}\n{-# LANGUAGE FlexibleInstances #-}\n\nmodule Kernel.Utils.GenericPretty\n  ( PrettyShow (..),\n    Showable (..),\n    StrWrap (..),\n    genericPrettyShow,\n    defaultOptionsL,\n    consModifier,\n    LayoutValue,\n    defaultPretty,\n    textPretty,\n    layoutStr,\n    prettyShowViaJSON,\n  )\nwhere\n\nimport Data.Aeson\nimport qualified Data.Aeson.Key as AesonKey\nimport qualified Data.Aeson.KeyMap as AKM\nimport qualified Data.Bifunctor as BFunc\nimport qualified Data.ByteString as BS (ByteString)\nimport qualified Data.ByteString.Lazy as BSL\nimport Data.Fixed\nimport qualified Data.List.NonEmpty as NE\nimport Data.Scientific\nimport qualified Data.Text as Text (Text, pack, unpack)\nimport qualified Data.Time as Time\nimport qualified Data.Vector as V\nimport Data.Void (Void, absurd)\nimport GHC.Generics\nimport Kernel.Prelude\n\nenclose, encloseSq :: String -> String\nenclose s = '{' : s ++ \"}\"\nencloseSq s = '[' : s ++ \"]\"\n\ndata OptionsL = OptionsL\n  { labelModifier :: String -> String,\n    consModifier :: String -> String\n  }\n\ndefaultOptionsL :: OptionsL\ndefaultOptionsL =\n  OptionsL\n    { labelModifier = defaultModif,\n      consModifier = defaultConsModif\n    }\n\ndefaultModif :: String -> String\ndefaultModif x@('_' : ys) =\n  case dropWhile (/= '_') ys of\n    ('_' : zs) -> zs\n    _ -> x\ndefaultModif x = x\n\ndefaultConsModif :: String -> String\ndefaultConsModif = identity\n\ndata LayoutUnit\n  = LayoutUnit String LayoutValue\n  deriving (Show, Eq)\n\ndata LayoutValue\n  = LStr String\n  | LLay String Layout\n  | LEmpty\n  | LJSON String\n  deriving (Show, Eq)\n\nlayoutStr :: String -> LayoutValue\nlayoutStr = LStr\n\nnewtype Layout\n  = Layout [LayoutUnit]\n  deriving (Show, Eq)\n\nlconcat :: Layout -> Layout -> Layout\nlconcat (Layout l) (Layout r) = Layout $ l ++ r\n\ndefaultIndent, defaultWidth :: Int\ndefaultIndent = 4\ndefaultWidth = 80\n\nnumToIndent :: Int -> String\nnumToIndent ind = replicate (ind * defaultIndent) ' '\n\nsplitToFixedWidthWithIndent :: Int -> String -> [String]\nsplitToFixedWidthWithIndent ind s =\n  let width = defaultWidth - ind * defaultIndent\n   in splitToFixedWidth width s\n\nsplitToFixedWidth :: Int -> String -> [String]\nsplitToFixedWidth _ [] = []\nsplitToFixedWidth wid s =\n  let (pref, suf) = splitAt wid s\n   in pref : splitToFixedWidth wid suf\n\nwithIndent :: Int -> String -> String\nwithIndent ind str = numToIndent ind ++ str\n\ndefaultPretty :: (PrettyShow a) => a -> String\ndefaultPretty = prettyValue 0 . prettyShow\n\ntextPretty :: (PrettyShow a) => a -> Text.Text\ntextPretty = Text.pack . defaultPretty\n\nprettyUnit :: Int -> LayoutUnit -> String\nprettyUnit _ (LayoutUnit _ LEmpty) = \"\"\nprettyUnit ind (LayoutUnit s val) =\n  withIndent ind $ s ++ \": \" ++ prettyValue ind val\n\nprettyValue :: Int -> LayoutValue -> String\nprettyValue _ (LStr s) = s ++ \"\\n\"\nprettyValue ind (LLay typ ls) =\n  typ ++ \"\\n\" ++ prettyLayout (ind + 1) ls\nprettyValue ind (LJSON s) =\n  ('\\n' :) $\n    unlines $\n      map (withIndent $ ind + 1) $ splitToFixedWidthWithIndent ind s\nprettyValue _ LEmpty = \"empty\\n\"\n\nprettyLayout :: Int -> Layout -> String\nprettyLayout ind (Layout ls) = concatMap (prettyUnit ind) ls\n\nclass PrettyShow a where\n  prettyShow :: a -> LayoutValue\n  default prettyShow :: (Generic a, GPrettyShow (Rep a)) => a -> LayoutValue\n  prettyShow = genericPrettyShow defaultOptionsL\n\ngenericPrettyShow ::\n  (Generic a, GPrettyShow (Rep a)) =>\n  OptionsL ->\n  a ->\n  LayoutValue\ngenericPrettyShow opts = gprettyShow opts . from\n\nnewtype Showable a\n  = Showable a\n\ninstance (Show a) => PrettyShow (Showable a) where\n  prettyShow (Showable x) = LStr $ show x\n\nnewtype StrWrap = StrWrap\n  { unStrWrap :: String\n  }\n\ninstance PrettyShow StrWrap where\n  prettyShow s = LStr $ unStrWrap s\n\ninstance PrettyShow Int where\n  prettyShow = LStr . show\n\ninstance PrettyShow Integer where\n  prettyShow = LStr . show\n\ninstance PrettyShow Double where\n  prettyShow = LStr . show\n\ninstance PrettyShow Rational where\n  prettyShow = LStr . show\n\ninstance PrettyShow Centi where\n  prettyShow = LStr . showFixed True\n\ninstance PrettyShow Text.Text where\n  prettyShow = LStr . show\n\ninstance PrettyShow Bool where\n  prettyShow = LStr . show\n\ninstance PrettyShow Time.Day where\n  prettyShow = LStr . Time.formatTime Time.defaultTimeLocale \"%F\"\n\ninstance PrettyShow Void where\n  prettyShow = absurd\n\ninstance PrettyShow () where\n  prettyShow _ = LEmpty\n\ninstance PrettyShow BS.ByteString where\n  prettyShow = LStr . show\n\ninstance PrettyShow BSL.ByteString where\n  prettyShow = LStr . show\n\ninstance (PrettyShow a) => PrettyShow (Maybe a) where\n  prettyShow (Just x) = prettyShow x\n  prettyShow Nothing = LEmpty\n\ninstance PrettyShow BaseUrl where\n  prettyShow = LStr . show\n\ninstance (PrettyShow a, PrettyShow b) => PrettyShow (a, b)\n\ninstance (PrettyShow a, PrettyShow b) => PrettyShow (Either a b)\n\ninstance (PrettyShow a) => PrettyShow [a] where\n  prettyShow [] = LEmpty\n  prettyShow xs = prettyShowListLike \"List\" xs\n\ninstance (PrettyShow a) => PrettyShow (NE.NonEmpty a) where\n  prettyShow = prettyShowListLike \"NonEmpty\" . NE.toList\n\nprettyShowListLike :: PrettyShow a => String -> [a] -> LayoutValue\nprettyShowListLike t = LLay (enclose t) . Layout . zipWith f [0 :: Int ..]\n  where\n    f n x = LayoutUnit (encloseSq $ show n) (prettyShow x)\n\ninstance PrettyShow (IO a) where\n  prettyShow _ = LStr \"<IO action>\"\n\nprettyShowViaJSON :: ToJSON a => a -> String\nprettyShowViaJSON = defaultPretty . toJSON\n\ninstance PrettyShow Value where\n  prettyShow (Object obj) = prettyShow obj\n  prettyShow (Array arr') = prettyShow arr'\n  prettyShow (String txt) = prettyShow txt\n  prettyShow (Number num) = prettyShow num\n  prettyShow (Bool bool') = prettyShow bool'\n  prettyShow Null = LEmpty\n\ninstance PrettyShow Object where\n  prettyShow = LLay \"\" . Layout . map f . map (BFunc.first AesonKey.toText) . AKM.toList\n    where\n      f (fieldName, value) = LayoutUnit (Text.unpack fieldName) (prettyShow value)\n\ninstance (PrettyShow a) => PrettyShow (V.Vector a) where\n  prettyShow = prettyShow . V.toList\n\ninstance PrettyShow Scientific where\n  prettyShow = prettyShow . Showable\n\ninstance PrettyShow UTCTime where\n  prettyShow = prettyShow . Showable\n\ninstance PrettyShow NominalDiffTime where\n  prettyShow = prettyShow . Showable\n\nclass GPrettyShow f where\n  gprettyShow :: OptionsL -> f a -> LayoutValue\n\nclass GPrettyShowAux f where\n  gprettyShowAux :: OptionsL -> f a -> Layout\n\nclass GPrettyShowIgnoreConstr f where\n  gprettyShowIgnoreConstr :: OptionsL -> f a -> LayoutValue\n\ninstance (GPrettyShow f) => GPrettyShow (D1 d f) where\n  gprettyShow opts (M1 x) = gprettyShow opts x\n\ninstance\n  (GPrettyShowIgnoreConstr f, GPrettyShowIgnoreConstr g) =>\n  GPrettyShow ((:+:) f g)\n  where\n  gprettyShow = gprettyShowIgnoreConstr\n\ninstance\n  (GPrettyShowIgnoreConstr f, GPrettyShowIgnoreConstr g) =>\n  GPrettyShowIgnoreConstr ((:+:) f g)\n  where\n  gprettyShowIgnoreConstr opts (L1 x) =\n    gprettyShowIgnoreConstr opts x\n  gprettyShowIgnoreConstr opts (R1 x) =\n    gprettyShowIgnoreConstr opts x\n\ninstance\n  (GPrettyShowIgnoreConstr f, Constructor c) =>\n  GPrettyShowIgnoreConstr (C1 c f)\n  where\n  gprettyShowIgnoreConstr opts (M1 x) =\n    gprettyShowIgnoreConstr opts x\n\ninstance (GPrettyShow f) => GPrettyShowIgnoreConstr (S1 c f) where\n  gprettyShowIgnoreConstr opts (M1 x) = gprettyShow opts x\n\ninstance\n  (Constructor c, GPrettyShowAux f) =>\n  GPrettyShow (C1 c f)\n  where\n  gprettyShow opts m@(M1 x) =\n    LLay (enclose $ consModifier opts $ conName m) $\n      gprettyShowAux opts x\n\ninstance (PrettyShow c) => GPrettyShow (Rec0 c) where\n  gprettyShow _ (K1 x) = prettyShow x\n\ninstance\n  (GPrettyShowAux f, GPrettyShowAux g) =>\n  GPrettyShowAux ((:*:) f g)\n  where\n  gprettyShowAux opts (x :*: y) =\n    gprettyShowAux opts x `lconcat` gprettyShowAux opts y\n\ninstance (Selector s, GPrettyShow f) => GPrettyShowAux (S1 s f) where\n  gprettyShowAux opts s@(M1 x) =\n    Layout\n      [ LayoutUnit\n          (labelModifier opts $ selName s)\n          (gprettyShow opts x)\n      ]\n",
      "hash": "d523546db53fcff15048044e45c98d1057705b109a3e3fa11330b8c103251006",
      "size": 8711
    },
    "/lib/mobility-core/src/Kernel/Utils/Geometry.hs": {
      "type": "content",
      "content": "module Kernel.Utils.Geometry where\n\nimport Data.Aeson (decode, encode)\nimport qualified Data.ByteString.Lazy as BL\nimport qualified Data.Text as T\nimport qualified EulerHS.Language as L\nimport Kernel.Prelude\nimport Kernel.Types.Error\nimport Kernel.Utils.Common\nimport Kernel.Utils.JSON\nimport System.Directory (createDirectoryIfMissing, doesDirectoryExist, getCurrentDirectory, removeDirectoryRecursive)\nimport System.FilePath ((</>))\nimport System.Process\nimport Text.Regex\n\ndata Geometry = Geometry\n  { _type :: String,\n    coordinates :: [[[Double]]]\n  }\n  deriving (Generic, Show)\n\ninstance FromJSON Geometry where\n  parseJSON = genericParseJSON stripPrefixUnderscoreIfAny\n\ninstance ToJSON Geometry where\n  toJSON = genericToJSON stripPrefixUnderscoreIfAny\n\ndata Feature = Feature\n  { _type :: String,\n    geometry :: Geometry\n  }\n  deriving (Generic, Show)\n\ninstance FromJSON Feature where\n  parseJSON = genericParseJSON stripPrefixUnderscoreIfAny\n\ninstance ToJSON Feature where\n  toJSON = genericToJSON stripPrefixUnderscoreIfAny\n\ndata GeoJSON = GeoJSON\n  { _type :: String,\n    features :: [Feature]\n  }\n  deriving (Generic, Show)\n\ninstance FromJSON GeoJSON where\n  parseJSON = genericParseJSON stripPrefixUnderscoreIfAny\n\ninstance ToJSON GeoJSON where\n  toJSON = genericToJSON stripPrefixUnderscoreIfAny\n\nconvertTo2D :: GeoJSON -> GeoJSON\nconvertTo2D geoJSON =\n  geoJSON {features = map convertFeature2D $ features geoJSON}\n  where\n    convertFeature2D :: Feature -> Feature\n    convertFeature2D feature =\n      feature {geometry = convertGeometry2D $ geometry feature}\n\n    convertGeometry2D :: Geometry -> Geometry\n    convertGeometry2D geometry =\n      geometry {coordinates = map (map convertCoordinate2D) $ coordinates geometry}\n\n    convertCoordinate2D :: [Double] -> [Double]\n    convertCoordinate2D coordinate = [head coordinate, head $ tail coordinate]\n\nextractGeometry :: String -> Maybe String\nextractGeometry shapeData =\n  case matchRegex geometryPattern shapeData of\n    Just [geometry] -> Just geometry\n    _ -> Nothing\n  where\n    geometryPattern = mkRegex \"INSERT INTO .* VALUES \\\\(.*'(.*)'\\\\);\"\n\ngetGeomFromKML :: (MonadFlow m) => FilePath -> m (Maybe String)\ngetGeomFromKML kmlFilePath = do\n  currentDir <- L.runIO $ getCurrentDirectory\n  logInfo $ \"Current Directory : \" <> T.pack currentDir\n  let tempDirPath = currentDir </> \"temp\"\n      geoJson3DFilePath = tempDirPath </> \"output_3d.json\"\n      geoJson2DFilePath = tempDirPath </> \"output_2d.json\"\n      shpFilePath = tempDirPath </> \"output.shp\"\n      sqlFilePath = tempDirPath </> \"output.sql\"\n  void $\n    L.runIO $ do\n      void $ removeDirectoryRecursiveIfExists tempDirPath\n      void $ createDirectoryIfMissing True tempDirPath\n  let kmlToGeoJson3D = \"ogr2ogr -f GeoJSON \" ++ geoJson3DFilePath ++ \" \" ++ kmlFilePath\n      geoJsonToShp = \"ogr2ogr -f \\\"ESRI Shapefile\\\" \" ++ shpFilePath ++ \" \" ++ geoJson2DFilePath\n      shpToPgsql = \"shp2pgsql -g geom \" ++ shpFilePath ++ \" > \" ++ sqlFilePath\n  _ <- L.runIO $ callCommand kmlToGeoJson3D\n  geoJson2D <-\n    maybe\n      (throwError $ InternalError \"Cannot Convert 3D to 2D GeoJSON.\")\n      (return . Just . convertTo2D)\n      =<< decode <$> (L.runIO $ BL.readFile geoJson3DFilePath)\n  void $\n    L.runIO $ do\n      void $ BL.writeFile geoJson2DFilePath (encode geoJson2D)\n      void $ callCommand geoJsonToShp\n      void $ callCommand shpToPgsql\n  sqlFile <- L.runIO $ readFile sqlFilePath\n  logInfo $ \"SQL Geometry Output : \" <> T.pack sqlFile\n  _ <- L.runIO $ removeDirectoryRecursiveIfExists tempDirPath\n  return $ extractGeometry sqlFile\n  where\n    removeDirectoryRecursiveIfExists :: FilePath -> IO ()\n    removeDirectoryRecursiveIfExists path = do\n      exists <- doesDirectoryExist path\n      when exists $ removeDirectoryRecursive path\n",
      "hash": "8fec5286f52db520a82d8a9b514f7c6c3950de65730259aec752e7ed7086a4f5",
      "size": 3780
    },
    "/lib/mobility-core/src/Kernel/Utils/IOLogging.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n\nmodule Kernel.Utils.IOLogging\n  ( LoggerConfig (..),\n    Logger,\n    LoggerEnv (..),\n    HasLog,\n    prepareLoggerEnv,\n    releaseLoggerEnv,\n    logOutputImplementation,\n    withLogTagImplementation,\n    logOutputIO,\n    appendLogTag,\n    withLoggerEnv,\n    updateLogLevelAndRawSql,\n  )\nwhere\n\nimport qualified Control.Monad.Catch as C\nimport Data.Aeson as A\nimport qualified Data.Aeson.KeyMap as AKM\nimport qualified Data.Text as T\nimport qualified Data.Time as Time\nimport Kernel.Prelude\nimport Kernel.Types.Logging\nimport Kernel.Types.Time\nimport System.Log.FastLogger\n\ntype HasLog r = HasField \"loggerEnv\" r LoggerEnv\n\ndata Logger = Logger\n  { printLogFunc :: FastLogger,\n    cleanUpFunc :: IO ()\n  }\n\ndata LoggerEnv = LoggerEnv\n  { level :: LogLevel,\n    hostName :: Maybe Text,\n    tags :: [Text],\n    fileLogger :: Maybe Logger,\n    consoleLogger :: Maybe Logger,\n    logRawSql :: Bool\n  }\n\nwithLoggerEnv :: LoggerConfig -> Maybe Text -> (LoggerEnv -> IO a) -> IO a\nwithLoggerEnv loggerConfig hostName = C.bracket (prepareLoggerEnv loggerConfig hostName) releaseLoggerEnv\n\nprepareLoggerEnv :: LoggerConfig -> Maybe Text -> IO LoggerEnv\nprepareLoggerEnv loggerConfig hostName = do\n  fileLogger <-\n    if loggerConfig.logToFile\n      then Just <$> prepareLogger (LogFileNoRotate loggerConfig.logFilePath defaultBufSize)\n      else return Nothing\n\n  consoleLogger <-\n    if loggerConfig.logToConsole\n      then Just <$> prepareLogger (LogStdout defaultBufSize)\n      else return Nothing\n\n  return $\n    LoggerEnv\n      { level = loggerConfig.level,\n        logRawSql = loggerConfig.logRawSql,\n        tags = [],\n        ..\n      }\n  where\n    prepareLogger logType = do\n      (printLogFunc, cleanUpFunc) <- newFastLogger logType\n      return $ Logger {..}\n\nreleaseLoggerEnv :: LoggerEnv -> IO ()\nreleaseLoggerEnv LoggerEnv {..} = do\n  whenJust fileLogger $ \\logger -> logger.cleanUpFunc\n  whenJust consoleLogger $ \\logger -> logger.cleanUpFunc\n\nlogOutputImplementation :: (HasLog r, MonadReader r m, MonadIO m, MonadTime m) => LogLevel -> Text -> m ()\nlogOutputImplementation logLevel message = do\n  logEnv <- asks (.loggerEnv)\n  logOutputIO logEnv logLevel message\n\nlogOutputIO :: (MonadIO m, MonadTime m) => LoggerEnv -> LogLevel -> Text -> m ()\nlogOutputIO logEnv logLevel message = do\n  when (logLevel >= logEnv.level) $ do\n    now <- getCurrentTime\n    let formattedMessage = logFormatterText now logEnv.hostName logLevel logEnv.tags message\n    whenJust logEnv.fileLogger $ \\logger ->\n      liftIO . logger.printLogFunc $ toLogStr (A.encode formattedMessage <> \"\\n\")\n    whenJust logEnv.consoleLogger $ \\logger ->\n      liftIO . logger.printLogFunc $ toLogStr (A.encode formattedMessage <> \"\\n\")\n\nwithLogTagImplementation ::\n  (HasLog r, MonadReader r m) =>\n  Text ->\n  m a ->\n  m a\nwithLogTagImplementation tag = local modifyEnv\n  where\n    modifyEnv env = do\n      let logEnv = env.loggerEnv\n          updLogEnv = appendLogTag tag logEnv\n      env{loggerEnv = updLogEnv}\n\nappendLogTag :: Text -> LoggerEnv -> LoggerEnv\nappendLogTag tag logEnv = do\n  logEnv{tags = tag : logEnv.tags}\n\nupdateLogLevelAndRawSql :: Maybe LogLevel -> LoggerEnv -> LoggerEnv\nupdateLogLevelAndRawSql mbNewLogLevel logEnv =\n  maybe\n    logEnv\n    (\\newLogLevel -> logEnv{level = newLogLevel, logRawSql = newLogLevel == DEBUG})\n    mbNewLogLevel\n\nformatTags :: [Text] -> Text\nformatTags tag = \"[\" <> T.intercalate \", \" (reverse tag) <> \"]\"\n\nlogFormatterText :: Time.UTCTime -> Maybe Text -> LogLevel -> [Text] -> Text -> A.Value\nlogFormatterText timestamp hostname lvl tags msg = res\n  where\n    tag = if null tags then \"\" else formatTags tags\n    log =\n      show timestamp\n        <> \" \"\n        <> show lvl\n        <> \"> \"\n        <> maybe \"\" (\"@\" <>) hostname\n        <> \" \"\n        <> tag\n        <> \" |> \"\n        <> msg\n    res = A.Object $ AKM.insert \"log\" (A.String log) AKM.empty\n",
      "hash": "c53446a52b17ce44400428b2a9b5741a02cb671eaa66df7ea6c3ad56793b527c",
      "size": 4570
    },
    "/lib/mobility-core/src/Kernel/Utils/JSON.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n\nmodule Kernel.Utils.JSON where\n\nimport Data.Aeson (Options (..), Result (..), SumEncoding (ObjectWithSingleField, UntaggedValue), Value (..), camelTo2, defaultOptions, fromJSON)\nimport qualified Data.Aeson.KeyMap as AKM\nimport qualified Data.Char as Char\nimport Data.Text (pack, replace, toLower, toUpper, unpack)\nimport EulerHS.Prelude hiding (pack, unpack)\nimport Kernel.Utils.Text (recursiveStrip)\nimport Web.FormUrlEncoded (FormOptions (..))\n\nreplaceUnderscores :: Text -> Text\nreplaceUnderscores = replace \"_\" \"-\"\n\nreplaceUnderscoresString :: String -> String\nreplaceUnderscoresString = unpack . replaceUnderscores . pack\n\nconstructorsWithHyphens :: Options\nconstructorsWithHyphens =\n  defaultOptions\n    { constructorTagModifier = replaceUnderscoresString\n    }\n\nconstructorsWithHyphensUntagged :: Options\nconstructorsWithHyphensUntagged =\n  defaultOptions\n    { constructorTagModifier = replaceUnderscoresString,\n      sumEncoding = UntaggedValue\n    }\n\nconstructorsToLowerOptions :: Options\nconstructorsToLowerOptions =\n  defaultOptions\n    { constructorTagModifier = unpack . toLower . pack\n    }\n\nconstructorsToUpperOptions :: Options\nconstructorsToUpperOptions =\n  defaultOptions\n    { constructorTagModifier = unpack . toUpper . pack\n    }\n\nconstructorsWithHyphensToLowerOptions :: Options\nconstructorsWithHyphensToLowerOptions =\n  defaultOptions\n    { constructorTagModifier = unpack . replaceUnderscores . toLower . pack\n    }\n\nconstructorsWithCapitalToSnakeCase :: Options\nconstructorsWithCapitalToSnakeCase =\n  defaultOptions\n    { constructorTagModifier = recursiveStrip . camelToSnake\n    }\n\ncamelToSnake :: String -> String\ncamelToSnake = foldr f (unpack \"\")\n  where\n    f :: Char.Char -> String -> String\n    f c acc\n      | Char.isUpper c = \"_\" <> (Char.toLower c : acc)\n      | otherwise = c : acc\n\nslashedRecordFields :: Options\nslashedRecordFields =\n  defaultOptions\n    { fieldLabelModifier = unpack . replace \"_\" \"/\" . pack\n    }\n\ndoubleQuotesRecordFields :: Options\ndoubleQuotesRecordFields =\n  defaultOptions\n    { fieldLabelModifier = unpack . replace \"_\" \"\\\"\" . pack\n    }\n\nuniteObjects :: [Value] -> Value\nuniteObjects values =\n  let result = foldl' AKM.union mempty objects\n   in if AKM.size result == sumOfSizes\n        then Object result\n        else error (\"duplication fields in \" <> show values)\n  where\n    objects = map unwrapObject values\n    unwrapObject (Object o) = o\n    unwrapObject e = error (\"expected Object, got \" <> show e)\n    sumOfSizes = sum $ map AKM.size objects\n\nobjectWithSingleFieldParsing :: (String -> String) -> Options\nobjectWithSingleFieldParsing constructorMapping =\n  defaultOptions\n    { sumEncoding = ObjectWithSingleField,\n      constructorTagModifier = constructorMapping\n    }\n\nstripPrefixUnderscoreIfAny :: Options\nstripPrefixUnderscoreIfAny =\n  defaultOptions\n    { fieldLabelModifier = recursiveStrip\n    }\n\nstripPrefixUnderscoreIfAnyForm :: FormOptions\nstripPrefixUnderscoreIfAnyForm =\n  FormOptions\n    { fieldLabelModifier = recursiveStrip\n    }\n\nuntaggedValue :: Options\nuntaggedValue =\n  defaultOptions\n    { sumEncoding = UntaggedValue\n    }\n\ncamelToSnakeCase :: String -> String\ncamelToSnakeCase = camelTo2 '_'\n\nconstructorsWithSnakeCase :: Options\nconstructorsWithSnakeCase =\n  defaultOptions\n    { fieldLabelModifier = camelToSnakeCase\n    }\n\nremoveNullFields :: Options\nremoveNullFields =\n  defaultOptions\n    { omitNothingFields = True\n    }\n\nconstructorsWithLowerCase :: Options\nconstructorsWithLowerCase =\n  defaultOptions\n    { fieldLabelModifier = unpack . toLower . pack\n    }\n\nvalueToMaybe :: forall a. FromJSON a => Value -> Maybe a\nvalueToMaybe value = case fromJSON value of\n  Success a -> Just a\n  Error _ -> Nothing\n",
      "hash": "b9a9590a27558a7bf0d7173054bcc680f60fa40e4a2a4144e0eb0fe07c36a36e",
      "size": 4405
    },
    "/lib/mobility-core/src/Kernel/Utils/JWT.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n{-# LANGUAGE OverloadedStrings #-}\n{-# LANGUAGE TemplateHaskell #-}\n\nmodule Kernel.Utils.JWT where\n\nimport Control.Applicative\nimport qualified Data.Aeson as J\nimport Data.Aeson.Casing\nimport Data.Aeson.TH\nimport Data.Aeson.Types\nimport qualified Data.ByteString.Char8 as C8\nimport qualified Data.ByteString.Lazy as BL\nimport Data.Either\nimport qualified Data.Map as Map\nimport Data.Maybe\nimport Data.String\nimport qualified Data.Text as T\nimport Data.Time.Clock\nimport Data.Time.Clock.POSIX\nimport EulerHS.Prelude hiding (exp, fromRight, try)\nimport Network.HTTP.Client\nimport Network.HTTP.Client.TLS\nimport Network.HTTP.Types\nimport Web.JWT\n\n-- | Google cloud service account json file format\n-- it contains key id, private key and other data needed to get JWT\n-- https://cloud.google.com/compute/docs/access/service-accounts\ndata ServiceAccount = ServiceAccount\n  { saType :: !T.Text,\n    saProjectId :: !T.Text,\n    saPrivateKeyId :: !T.Text,\n    saPrivateKey :: !String,\n    saClientEmail :: !T.Text,\n    saClientId :: !T.Text,\n    saAuthUri :: !T.Text,\n    saTokenUri :: !T.Text,\n    saAuthProviderX509CertUrl :: !T.Text,\n    saClientX509CertUrl :: !T.Text\n  }\n  deriving (Show, Eq, Generic)\n\n$(deriveJSON (aesonPrefix snakeCase) ''ServiceAccount)\n\n-- | JWT body format, is is used for retrieving JWT token\ndata JWTBody = JWTBody\n  { jwtAssertion :: !T.Text,\n    jwtGrantType :: !T.Text\n  }\n  deriving (Show, Eq, Generic)\n\n$(deriveJSON (aesonPrefix snakeCase) ''JWTBody)\n\n-- | JWT token returned from token url\ndata JWToken = JWToken\n  { jwtAccessToken :: !T.Text,\n    jwtExpiresIn :: Integer,\n    jwtTokenType :: !T.Text\n  }\n  deriving (Show, Eq, Generic)\n\n$(deriveJSON (aesonPrefix snakeCase) ''JWToken)\n\n-- | Prepare claims and assertion needed for getting JWT\n-- It is possible to add user-defined claims using the additionalClaims parameter\n-- Returns a pair of claims and assertion of these claims\ncreateJWT :: ServiceAccount -> [(Text, Value)] -> IO (Either String (JWTClaimsSet, Text))\ncreateJWT sa additionalClaims = do\n  let iss = stringOrURI . saClientEmail $ sa\n  let aud = Left <$> (stringOrURI . saTokenUri $ sa)\n  let unregisteredClaims = ClaimsMap $ Map.fromList additionalClaims\n  let jwtHeader =\n        JOSEHeader\n          { typ = Just \"JWT\",\n            cty = Nothing,\n            alg = Just RS256,\n            kid = Just $ saPrivateKeyId sa -- key id from sa json file\n          }\n  let mkey = readRsaSecret . C8.pack $ saPrivateKey sa\n  case mkey of\n    Nothing -> pure $ Left \"Bad RSA key!\"\n    Just pkey -> do\n      let key = EncodeRSAPrivateKey pkey\n      iat <- numericDate <$> getPOSIXTime\n      exp <- numericDate . (+ 3600) <$> getPOSIXTime\n      let searchRequest =\n            mempty\n              { exp = exp, -- Expired at\n                iat = iat, -- Issued at\n                iss = iss, -- Issuer (client email)\n                aud = aud, -- Audience (endpoints where JWT will be used)\n                unregisteredClaims = unregisteredClaims -- additional claims\n              }\n      pure $ Right (searchRequest, encodeSigned key jwtHeader searchRequest)\n\n-- | Prepare a request to the token URL\njwtRequest :: T.Text -> BL.ByteString -> IO Request\njwtRequest tokenUri body = do\n  req <- parseRequest $ T.unpack tokenUri\n  pure $\n    req {method = \"POST\", requestHeaders = [(hContentType, \"application/json\")], requestBody = RequestBodyLBS body}\n\n-- | Geto or refresh JWT token\n-- Note at the moment it is used with FCM service so scope is hardcoded\ndoRefreshToken :: ServiceAccount -> IO (Either String JWToken)\ndoRefreshToken sa = do\n  jwtPair <- createJWT sa [(\"scope\", String \"https://www.googleapis.com/auth/firebase.messaging\")]\n  case jwtPair of\n    Left err -> pure $ Left err\n    Right (claimPairs, assertion) -> do\n      let issuedAt = iat claimPairs\n      manager <- newManager tlsManagerSettings\n      let body =\n            JWTBody\n              { jwtAssertion = assertion,\n                jwtGrantType = \"urn:ietf:params:oauth:grant-type:jwt-bearer\"\n              }\n      req <- jwtRequest (saTokenUri sa) (J.encode body)\n      res <- httpLbs req manager\n      let rBody = J.eitherDecode $ responseBody res\n      case rBody of\n        Left err -> pure $ Left err\n        Right respBody@JWToken {..} -> do\n          let expiry = getExpiry issuedAt jwtExpiresIn\n          pure $\n            Right\n              respBody\n                { jwtExpiresIn = expiry\n                }\n\n-- | Get token expiration date\ngetExpiry :: Maybe NumericDate -> Integer -> Integer\ngetExpiry Nothing expiresIn = expiresIn\ngetExpiry (Just d) expiresIn =\n  expiresIn + round (nominalDiffTimeToSeconds $ secondsSinceEpoch d)\n\n-- | JWT token validation status\ndata JWTValidity\n  = JWTValid Integer -- valid and expires in X seconds\n  | JWTInvalid -- invalid (bad signautre)\n  | JWTExpired Integer -- expired X seconds ago\n  deriving (Show, Eq, Generic)\n\n$(deriveJSON (aesonPrefix snakeCase) ''JWTValidity)\n\n-- | Check token validity\nisValid :: JWToken -> IO JWTValidity\nisValid token = do\n  let expiry = jwtExpiresIn token\n  curInt <- round <$> getPOSIXTime\n  -- check a signature here, not sure it is possible,\n  -- for this we'd need to get a \"public\" key which is stored in google\n  -- PS we can keep claims in options, this will allow us\n  -- recreating the token and verifying it\n  let valid = True\n  let expired = curInt > expiry\n  let diff = abs $ curInt - expiry\n  pure $ case (expired, valid) of\n    (True, _) -> JWTExpired diff\n    (_, True) -> JWTValid diff\n    _ -> JWTInvalid\n",
      "hash": "e9be926831e737040d5f5f9420d09e962d2fc1d0a3bbb26d99da18175a9da436",
      "size": 6214
    },
    "/lib/mobility-core/src/Kernel/Utils/Logging.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n\nmodule Kernel.Utils.Logging\n  ( Log (..),\n    LogLevel (..),\n    log,\n    logTagDebug,\n    logTagInfo,\n    logTagWarning,\n    logTagError,\n    logDebug,\n    logInfo,\n    logWarning,\n    logError,\n    withRandomId,\n    withTransactionIdLogTag,\n    withTransactionIdLogTag',\n    withPersonIdLogTag,\n    makeLogSomeException,\n    logPretty,\n    HasPrettyLogger,\n  )\nwhere\n\nimport EulerHS.Prelude hiding (id)\nimport GHC.Records.Extra\nimport Kernel.Types.Error.BaseError.HTTPError\nimport Kernel.Types.GuidLike (generateGUID)\nimport Kernel.Types.Id\nimport Kernel.Types.Logging\nimport Kernel.Types.MonadGuid\nimport Kernel.Utils.GenericPretty (PrettyShow, textPretty)\n\nlog :: Log m => LogLevel -> Text -> m ()\nlog = logOutput\n\nlogTagDebug :: Log m => Text -> Text -> m ()\nlogTagDebug tag = withLogTag tag . logOutput DEBUG\n\nlogTagInfo :: Log m => Text -> Text -> m ()\nlogTagInfo tag = withLogTag tag . logOutput INFO\n\nlogTagWarning :: Log m => Text -> Text -> m ()\nlogTagWarning tag = withLogTag tag . logOutput WARNING\n\nlogTagError :: Log m => Text -> Text -> m ()\nlogTagError tag = withLogTag tag . logOutput ERROR\n\nlogDebug :: Log m => Text -> m ()\nlogDebug = logOutput DEBUG\n\nlogInfo :: Log m => Text -> m ()\nlogInfo = logOutput INFO\n\nlogWarning :: Log m => Text -> m ()\nlogWarning = logOutput WARNING\n\nlogError :: Log m => Text -> m ()\nlogError = logOutput ERROR\n\nwithRandomId :: (MonadGuid m, Log m) => m b -> m b\nwithRandomId f = do\n  id <- generateGUID\n  withLogTag id f\n\nwithPersonIdLogTag :: Log m => Id b -> m a -> m a\nwithPersonIdLogTag personId = do\n  withLogTag (\"actor-\" <> getId personId)\n\nwithTransactionIdLogTag :: (HasField \"context\" b c, HasField \"transaction_id\" c (Maybe Text), Log m) => b -> m a -> m a\nwithTransactionIdLogTag req =\n  withTransactionIdLogTag' $ fromMaybe \"Unknown\" req.context.transaction_id\n\nwithTransactionIdLogTag' :: Log m => Text -> m a -> m a\nwithTransactionIdLogTag' txnId =\n  withLogTag (\"txnId-\" <> txnId)\n\nmakeLogSomeException :: SomeException -> Text\nmakeLogSomeException someExc\n  | Just (HTTPException err) <- fromException someExc = logHTTPError err\n  | Just (BaseException err) <- fromException someExc =\n    fromMaybe (show err) $ toMessage err\n  | otherwise = show someExc\n  where\n    logHTTPError err =\n      show (toHttpCode err)\n        <> \" \"\n        <> toErrorCode err\n        <> maybe \"\" (\": \" <>) (toMessage err)\n\nrenderViaShow :: (Show a) => Text -> a -> Text\nrenderViaShow description val = description <> \": \" <> show val\n\nrenderViaPrettyShow :: (PrettyShow a) => Text -> a -> Text\nrenderViaPrettyShow description val = description <> \"\\n\" <> textPretty val\n\ntype HasPrettyLogger m env =\n  ( Log m,\n    MonadReader env m,\n    HasField \"loggerConfig\" env LoggerConfig\n  )\n\nlogPretty ::\n  ( PrettyShow a,\n    Show a,\n    HasPrettyLogger m env\n  ) =>\n  LogLevel ->\n  Text ->\n  a ->\n  m ()\nlogPretty logLevel description val = do\n  pretty <- asks (.loggerConfig.prettyPrinting)\n  let render =\n        if pretty\n          then renderViaPrettyShow\n          else renderViaShow\n  logOutput logLevel $ render description val\n",
      "hash": "40b499441e6eba1f196ed2d42f8ca285ecd09cb2ad0b97455d2e9dd5e6f7db88",
      "size": 3770
    },
    "/lib/mobility-core/src/Kernel/Utils/Monitoring/Prometheus/Servant.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n{-# OPTIONS_GHC -Wwarn=incomplete-uni-patterns #-}\n\nmodule Kernel.Utils.Monitoring.Prometheus.Servant where\n\nimport Data.Proxy\nimport Data.Text as DT\nimport EulerHS.Prelude as E\nimport GHC.TypeLits (KnownSymbol, Symbol, symbolVal)\nimport Network.Wai (Request (..))\nimport Servant\n\nclass SanitizedUrl a where\n  getSanitizedUrl :: Proxy a -> Request -> Maybe Text\n\ninstance\n  (SanitizedUrl (a :: Type), SanitizedUrl (b :: Type)) =>\n  SanitizedUrl (a :<|> b)\n  where\n  getSanitizedUrl _ req =\n    getSanitizedUrl (Proxy :: Proxy a) req\n      <|> getSanitizedUrl (Proxy :: Proxy b) req\n\ninstance\n  ( KnownSymbol (path :: Symbol),\n    SanitizedUrl (subroute :: Type)\n  ) =>\n  SanitizedUrl (path :> subroute)\n  where\n  getSanitizedUrl _ req = do\n    let path = pathInfo req\n    if E.null path\n      then Nothing\n      else do\n        let (x : xs) = path\n            p = DT.pack $ symbolVal (Proxy :: Proxy path)\n        if p == x\n          then\n            let maybeUrl = getSanitizedUrl (Proxy :: Proxy subroute) $ req {pathInfo = xs}\n             in (\\url -> Just (p <> \"/\" <> url)) =<< maybeUrl\n          else Nothing\n\ninstance\n  ( KnownSymbol (capture :: Symbol),\n    SanitizedUrl (subroute :: Type)\n  ) =>\n  SanitizedUrl (Capture capture a :> subroute)\n  where\n  getSanitizedUrl _ req = do\n    let path = pathInfo req\n    if E.null path\n      then Nothing\n      else\n        let (_ : xs) = path\n            p = DT.pack $ \":\" <> symbolVal (Proxy :: Proxy capture)\n            maybeUrl = getSanitizedUrl (Proxy :: Proxy subroute) $ req {pathInfo = xs}\n         in (\\url -> Just (p <> \"/\" <> url)) =<< maybeUrl\n\ninstance\n  ReflectMethod m =>\n  SanitizedUrl (Verb (m :: StdMethod) code contentType a)\n  where\n  getSanitizedUrl _ req = do\n    let p = pathInfo req\n    if E.null p && requestMethod req == reflectMethod (Proxy :: Proxy m)\n      then Just \"\"\n      else Nothing\n\ninstance\n  SanitizedUrl (subroute :: Type) =>\n  SanitizedUrl (Description (h :: Symbol) :> subroute)\n  where\n  getSanitizedUrl _ = getSanitizedUrl (Proxy :: Proxy subroute)\n\ninstance\n  SanitizedUrl (subroute :: Type) =>\n  SanitizedUrl (Summary (h :: Symbol) :> subroute)\n  where\n  getSanitizedUrl _ = getSanitizedUrl (Proxy :: Proxy subroute)\n\ninstance\n  SanitizedUrl (subroute :: Type) =>\n  SanitizedUrl (QueryParams (h :: Symbol) a :> subroute)\n  where\n  getSanitizedUrl _ = getSanitizedUrl (Proxy :: Proxy subroute)\n\ninstance\n  SanitizedUrl (subroute :: Type) =>\n  SanitizedUrl (Header h a :> subroute)\n  where\n  getSanitizedUrl _ = getSanitizedUrl (Proxy :: Proxy subroute)\n\ninstance\n  SanitizedUrl (subroute :: Type) =>\n  SanitizedUrl (BasicAuth h a :> subroute)\n  where\n  getSanitizedUrl _ = getSanitizedUrl (Proxy :: Proxy subroute)\n\ninstance\n  SanitizedUrl (subroute :: Type) =>\n  SanitizedUrl (ReqBody cts a :> subroute)\n  where\n  getSanitizedUrl _ = getSanitizedUrl (Proxy :: Proxy subroute)\n\ninstance\n  SanitizedUrl (subroute :: Type) =>\n  SanitizedUrl (QueryParam' modifier name t :> subroute)\n  where\n  getSanitizedUrl _ = getSanitizedUrl (Proxy :: Proxy subroute)\n\ninstance\n  SanitizedUrl (subroute :: Type) =>\n  SanitizedUrl (Header' '[Required, Strict] h v :> subroute)\n  where\n  getSanitizedUrl _ = getSanitizedUrl (Proxy :: Proxy subroute)\n\ninstance SanitizedUrl Raw where\n  getSanitizedUrl _ _ = Nothing\n",
      "hash": "42915bf3e0c1e7f05e8900cc4127ab3d85119c869e975ffdb3e8538b26b241b8",
      "size": 3986
    },
    "/lib/mobility-core/src/Kernel/Utils/NonEmpty.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n\nmodule Kernel.Utils.NonEmpty where\n\nimport Data.List.NonEmpty (NonEmpty (..))\n\nsingleton :: a -> NonEmpty a\nsingleton a = a :| []\n",
      "hash": "40ad852e214cd6fabc88d5b5aeeab181736ad867e596feca96685e830410d12d",
      "size": 824
    },
    "/lib/mobility-core/src/Kernel/Utils/Predicates.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n\nmodule Kernel.Utils.Predicates where\n\nimport Kernel.Prelude\nimport Kernel.Types.Predicate\n\ndigit, latinUC, latinLC, latin, alphanum, latinOrSpace :: Regex\ndigit = charRange '0' '9'\nlatinUC = charRange 'A' 'Z'\nlatinLC = charRange 'a' 'z'\nlatin = latinUC \\/ latinLC\nalphanum = latin \\/ digit\nlatinOrSpace = latin \\/ \" \"\n\nmobileNumber :: ExactLength `And` Regex\nmobileNumber = ExactLength 10 `And` star digit\n\nmobileCountryCode :: LengthInRange `And` Regex\nmobileCountryCode = LengthInRange 2 4 `And` (\"+\" <> star digit)\n\nfullMobilePhone :: LengthInRange `And` Regex\nfullMobilePhone = LengthInRange 12 14 `And` (\"+\" <> star digit)\n\nmobileIndianCode :: Regex\nmobileIndianCode = \"+91\"\n\nname :: Regex\nname = star latinOrSpace\n",
      "hash": "4ab66382a1bee7beb52e9ce8b0005ca1c1f9df5c6ff1e504d9d1141fbd397c5e",
      "size": 1414
    },
    "/lib/mobility-core/src/Kernel/Utils/Registry.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n\nmodule Kernel.Utils.Registry\n  ( registryFetch,\n    Kernel.Utils.Registry.registryLookup,\n    checkBlacklisted,\n    withSubscriberCache,\n    checkWhitelisted,\n  )\nwhere\n\nimport Data.Generics.Labels ()\nimport qualified EulerHS.Types as T\nimport Kernel.Prelude\nimport Kernel.Tools.Metrics.CoreMetrics (CoreMetrics)\nimport Kernel.Types.Beckn.Domain\nimport Kernel.Types.Cache\nimport Kernel.Types.Common\nimport Kernel.Types.Error\nimport Kernel.Types.Registry\nimport qualified Kernel.Types.Registry.API as API\nimport qualified Kernel.Types.Registry.Routes as Registry\nimport Kernel.Utils.Common\nimport Kernel.Utils.Servant.SignatureAuth\n\nregistryLookup ::\n  ( CoreMetrics m,\n    MonadFlow m\n  ) =>\n  BaseUrl ->\n  SimpleLookupRequest ->\n  Text ->\n  m (Maybe Subscriber)\nregistryLookup registryUrl request selfSubId =\n  registryFetch registryUrl (toLookupReq request) selfSubId\n    >>= \\case\n      [] -> pure Nothing\n      -- These are temporary changes as there is bug in ONDC registry. They are sending multiple entries irrespective of ukId So we added traversal at our end.\n      -- It should be removed once issues has been fixed at their end.\n      subs -> do\n        let subscribers = filter (\\subscriber -> subscriber.unique_key_id == request.unique_key_id) subs\n        if length subscribers > 1\n          then throwError $ InternalError \"Multiple subscribers returned for a unique key.\"\n          else\n            if length subscribers == 1\n              then pure $ Just $ head subscribers\n              else pure Nothing\n  where\n    toLookupReq SimpleLookupRequest {..} =\n      API.emptyLookupRequest\n        { API.unique_key_id = Just unique_key_id,\n          API.subscriber_id = Just subscriber_id,\n          API.domain = Just domain,\n          API._type = Just subscriber_type\n        }\n\nregistryFetch ::\n  ( MonadFlow m,\n    CoreMetrics m\n  ) =>\n  BaseUrl ->\n  API.LookupRequest ->\n  Text ->\n  m [Subscriber]\nregistryFetch registryUrl request selfSubId = do\n  callAPI' (Just (T.ManagerSelector (getHttpManagerKey selfSubId))) registryUrl (T.client Registry.lookupAPI request) \"lookup\" Registry.lookupAPI\n    >>= fromEitherM (ExternalAPICallError (Just \"REGISTRY_CALL_ERROR\") registryUrl)\n\ncheckBlacklisted ::\n  (MonadThrow m, Log m) =>\n  (Text -> Domain -> m Bool) ->\n  Maybe Subscriber ->\n  m (Maybe Subscriber)\ncheckBlacklisted isBlackListed = maybe (pure Nothing) \\sub -> do\n  whenM (isBlackListed sub.subscriber_id sub.domain) . throwError . InvalidRequest $\n    \"It is a Blacklisted subscriber \" <> sub.subscriber_id\n  pure (Just sub)\n\ncheckWhitelisted ::\n  (MonadThrow m, Log m) =>\n  (Text -> Domain -> Text -> m Bool) ->\n  Text ->\n  Maybe Subscriber ->\n  m (Maybe Subscriber)\ncheckWhitelisted isNotWhiteListed merchantId = maybe (pure Nothing) \\sub -> do\n  whenM (isNotWhiteListed sub.subscriber_id sub.domain merchantId) . throwError . InvalidRequest $\n    \"Not Whitelisted subscriber \" <> sub.subscriber_id\n  pure (Just sub)\n\nwithSubscriberCache ::\n  ( MonadTime m,\n    CacheEx Subscriber m\n  ) =>\n  (CacheKey Subscriber -> m (Maybe Subscriber)) ->\n  CacheKey Subscriber ->\n  m (Maybe Subscriber)\nwithSubscriberCache getData key = do\n  now <- getCurrentTime\n  caching (getTtl now) getData key\n  where\n    getTtl now Subscriber {..} =\n      nominalDiffTimeToSeconds . fromMaybe (5 * 60) $ valid_until <&> (`diffUTCTime` now)\n",
      "hash": "3a64fdb29a5841a8338190cffe0d47e40ace3bc6b39cc173d55a777c1ae1df9c",
      "size": 4034
    },
    "/lib/mobility-core/src/Kernel/Utils/Schema.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n\nmodule Kernel.Utils.Schema\n  ( stripPrefixUnderscoreIfAny,\n    untaggedValue,\n    genericDeclareUnNamedSchema,\n    objectWithSingleFieldParsing,\n  )\nwhere\n\nimport qualified Data.Aeson as A\nimport Data.OpenApi\nimport Data.OpenApi.Declare\nimport Data.OpenApi.Internal.Schema\nimport GHC.Generics\nimport Kernel.Prelude\nimport Kernel.Utils.Common (recursiveStrip)\n\nstripPrefixUnderscoreIfAny :: SchemaOptions\nstripPrefixUnderscoreIfAny =\n  defaultSchemaOptions\n    { fieldLabelModifier = recursiveStrip\n    }\n\nuntaggedValue :: SchemaOptions\nuntaggedValue =\n  defaultSchemaOptions\n    { sumEncoding = A.UntaggedValue\n    }\n\ngenericDeclareUnNamedSchema :: forall a. (Generic a, GToSchema (Rep a), Typeable a) => SchemaOptions -> Proxy a -> Declare (Definitions Schema) NamedSchema\ngenericDeclareUnNamedSchema opt prx = do\n  res <- genericDeclareNamedSchema opt prx\n  return $ res {_namedSchemaName = Nothing}\n\nobjectWithSingleFieldParsing :: (String -> String) -> SchemaOptions\nobjectWithSingleFieldParsing constructorMapping =\n  defaultSchemaOptions\n    { sumEncoding = A.ObjectWithSingleField,\n      constructorTagModifier = constructorMapping\n    }\n",
      "hash": "96153e8fb547e61554fe0a9737ec13dfeb6d0fbd8a7fbf83b9ad9b554f5da9e0",
      "size": 1839
    },
    "/lib/mobility-core/src/Kernel/Utils/Servant/API.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n{-# LANGUAGE PolyKinds #-}\n\nmodule Kernel.Utils.Servant.API\n  ( type (:>|),\n  )\nwhere\n\nimport Data.Kind (Type)\nimport Servant\n\n-- | This behaves similarly to ':>' from API point of view, but in implementation\n-- it attaches a parameter to /each/ separate endpoint, not /all/ of them at once.\n--\n-- For instance:\n-- @\n-- type API = Header \"auth\" Text :> (Get '[JSON] Text :<|> Post '[JSON] ())\n-- @\n--\n-- requires the following implementation:\n--\n-- @\n-- handlers :: Server API\n-- handlers = \\auth -> get auth :<|> new auth\n-- @\n--\n-- But when ':>' is replaced with ':>|', you can write just\n--\n-- @\n-- handlers = get :<|> auth\n-- @\n--\n-- Note that ':>|' has fewer priority that ':<|>' so you can omit parentheses.\n--\n-- This operator is experimental, if you find ':>' more appropriate then use it.\ntype family (:>|) (pre :: k) (api :: Type) where\n  pre :>| (api1 :<|> api2) = (pre :>| api1) :<|> (pre :>| api2)\n  pre :>| api = pre :> api\n\ninfixr 2 :>|\n",
      "hash": "1c99dc6734d480ee277fe6afe603d08be3dac0fbec7c0f043be183e44f9d51d3",
      "size": 1645
    },
    "/lib/mobility-core/src/Kernel/Utils/Servant/BaseUrl.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n\nmodule Kernel.Utils.Servant.BaseUrl where\n\nimport Data.Text\nimport EulerHS.Prelude\nimport Servant.Client.Core\n\nshowBaseUrlText :: BaseUrl -> Text\nshowBaseUrlText = toText . showBaseUrl\n",
      "hash": "a16c67818387d19e06bcc07f3ad66cc6a7862251d915048113c99b9e32d02c06",
      "size": 879
    },
    "/lib/mobility-core/src/Kernel/Utils/Servant/BasicAuth.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n{-# LANGUAGE InstanceSigs #-}\n{-# OPTIONS_GHC -Wno-orphans #-}\n\nmodule Kernel.Utils.Servant.BasicAuth () where\n\nimport Control.Lens (at, (.=), (.~), (?=))\nimport qualified Data.OpenApi as DS\nimport Data.Typeable (typeRep)\nimport EulerHS.Prelude hiding (fromList, (.~))\nimport GHC.Exts (fromList)\nimport GHC.TypeLits (KnownSymbol)\nimport Kernel.Prelude.OrphanInstances ()\nimport Servant hiding (ResponseHeader (..))\nimport qualified Servant.OpenApi as S\nimport qualified Servant.OpenApi.Internal as S\n\n-- WARNING this instance do not check any auth actually, this is only plug for compiling\ninstance HasContextEntry '[] (BasicAuthCheck BasicAuthData) where\n  getContextEntry :: Context '[] -> BasicAuthCheck BasicAuthData\n  getContextEntry EmptyContext = BasicAuthCheck {unBasicAuthCheck = pure . Authorized} -- TODO test it\n\ninstance\n  ( S.HasOpenApi api,\n    KnownSymbol realm\n  ) =>\n  S.HasOpenApi (BasicAuth realm BasicAuthData :> api)\n  where\n  toOpenApi _ =\n    S.toOpenApi (Proxy @api)\n      & addSecurityRequirement methodName verificationDescription headerName\n      & S.addDefaultResponse400 headerName\n      & addResponse401\n    where\n      headerName = \"Authorization\"\n      methodName = show $ typeRep (Proxy @realm)\n      verificationDescription =\n        \"The basic authentication scheme is based on the model that the \\\n        \\client must authenticate itself with a user-ID and a password for \\\n        \\each realm.\"\n\naddSecurityRequirement :: Text -> Text -> Text -> DS.OpenApi -> DS.OpenApi\naddSecurityRequirement methodName description headerName = execState $ do\n  DS.components . DS.securitySchemes . at methodName ?= securityScheme\n  DS.allOperations . DS.security .= one securityRequirement\n  where\n    securityScheme =\n      DS.SecurityScheme\n        { _securitySchemeDescription = Just description,\n          _securitySchemeType =\n            DS.SecuritySchemeApiKey\n              DS.ApiKeyParams\n                { _apiKeyName = headerName,\n                  _apiKeyIn = DS.ApiKeyHeader\n                }\n        }\n    securityRequirement =\n      let scopes = []\n       in DS.SecurityRequirement $ fromList [(methodName, scopes)]\n\naddResponse401 :: DS.OpenApi -> DS.OpenApi\naddResponse401 = execState $ do\n  DS.components . DS.responses . at response401Name ?= response401\n  DS.allOperations . DS.responses . DS.responses . at 401\n    ?= DS.Ref (DS.Reference response401Name)\n  where\n    response401Name = \"Unauthorized\"\n    response401 = mempty & DS.description .~ \"Unauthorized\"\n",
      "hash": "17fe85fbe3e09f7330b0bef5d50a8e101ae0fb4c3129671683ed8d46290dc60c",
      "size": 3200
    },
    "/lib/mobility-core/src/Kernel/Utils/Servant/Client.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n\nmodule Kernel.Utils.Servant.Client where\n\nimport qualified Data.Aeson as A\nimport qualified Data.HashMap.Strict as HM\nimport qualified Data.HashMap.Strict as HMS\nimport qualified Data.Text as T\nimport qualified EulerHS.Language as L\nimport EulerHS.Prelude hiding (id, notElem)\nimport qualified EulerHS.Types as ET\nimport GHC.Records.Extra (HasField)\nimport Kernel.Prelude as KP\nimport qualified Kernel.Tools.Metrics.CoreMetrics as Metrics\nimport Kernel.Types.Common\nimport Kernel.Types.Error (ExternalAPICallError (..))\nimport Kernel.Types.Error.BaseError.HTTPError\nimport Kernel.Types.Error.BaseError.HTTPError.CallAPIError\nimport Kernel.Types.Error.BaseError.HTTPError.FromResponse\nimport Kernel.Utils.Dhall (FromDhall)\nimport Kernel.Utils.Error.Throwing\nimport Kernel.Utils.Logging\nimport Kernel.Utils.Monitoring.Prometheus.Servant\nimport Kernel.Utils.Servant.BaseUrl\nimport Kernel.Utils.Text\nimport Kernel.Utils.Time\nimport qualified Network.HTTP.Client as Http\nimport qualified Network.HTTP.Client.TLS as Http\nimport Network.HTTP.Types (status404)\nimport qualified Network.Wai as Wai\nimport Network.Wai.Application.Static (staticApp)\nimport qualified Servant\nimport Servant.Client.Core\nimport qualified Text.Regex as TR\nimport WaiAppStatic.Storage.Filesystem\nimport WaiAppStatic.Types (StaticSettings (..))\n\nnewtype HttpClientOptions = HttpClientOptions\n  { timeoutMs :: Int\n  }\n  deriving (Generic, FromDhall)\n\ndata RetryCfg = RetryCfg\n  { maxRetries :: Int,\n    baseCoefficient :: Int\n  }\n  deriving (Generic, FromDhall)\n\ntype HasHttpClientOptions r c = HasField \"httpClientOptions\" r HttpClientOptions\n\ntype HasRetryCfg r c = HasField \"retryCfg\" r RetryCfg\n\ntype HasShortDurationRetryCfg r c = HasField \"shortDurationRetryCfg\" r RetryCfg\n\ntype HasLongDurationRetryCfg r c = HasField \"longDurationRetryCfg\" r RetryCfg\n\ndata RetryType = ShortDurationRetry | LongDurationRetry\n\ntype CallAPI' m api res res' =\n  ( HasCallStack,\n    Metrics.CoreMetrics m,\n    SanitizedUrl api,\n    MonadFlow m,\n    ToJSON res\n  ) =>\n  BaseUrl ->\n  ET.EulerClient res ->\n  Text ->\n  Proxy api ->\n  m res'\n\ntype CallAPI m api res = CallAPI' m api res res\n\ncallAPI ::\n  CallAPI' m api res (Either ClientError res)\ncallAPI = callAPI' Nothing\n\n-- Why do we call L.callAPI' (Just \"default\") instead of L.callAPI' Nothing?\ncallAPI' ::\n  Maybe ET.ManagerSelector ->\n  CallAPI' m api res (Either ClientError res)\ncallAPI' mbManagerSelector baseUrl eulerClient desc api =\n  withLogTag \"callAPI\" $ do\n    let managerSelector = fromMaybe defaultHttpManager mbManagerSelector\n    logDebug $ \"Sanitized URL is \" <> buildSanitizedUrl\n    res <-\n      measuringDuration (Metrics.addRequestLatency buildSanitizedUrl desc) $\n        L.callAPI' (Just managerSelector) baseUrl eulerClient\n    case res of\n      Right r -> logDebug $ \"Ok response: \" <> truncateText (decodeUtf8 (A.encode r))\n      Left err -> logDebug $ \"Error occured during client call: \" <> show err\n    return res\n  where\n    buildSanitizedUrl = do\n      let url = T.split (== '/') $ T.pack (baseUrlPath baseUrl)\n          urlPath = if listToMaybe url == Just \"\" then drop 1 url else url\n      let req = Wai.defaultRequest\n          baseRequest = req {Wai.pathInfo = urlPath}\n      fromMaybe (removeUUID $ showBaseUrlText baseUrl) (getSanitizedUrl api baseRequest)\n\n    removeUUID url = T.pack $ TR.subRegex (TR.mkRegex \"[0-9a-z]{8}-([0-9a-z]{4}-){3}[0-9a-z]{12}\") (T.unpack url) \":id\"\n\ncallApiExtractingApiError ::\n  ( Metrics.CoreMetrics m,\n    FromResponse err\n  ) =>\n  Maybe ET.ManagerSelector ->\n  CallAPI' m api a (Either (CallAPIError err) a)\ncallApiExtractingApiError mbManagerSelector baseUrl eulerClient desc api =\n  callAPI' mbManagerSelector baseUrl eulerClient desc api\n    <&> extractApiError\n\ncallApiUnwrappingApiError ::\n  ( Metrics.CoreMetrics m,\n    FromResponse err,\n    IsHTTPException exc\n  ) =>\n  (err -> exc) ->\n  Maybe ET.ManagerSelector ->\n  Maybe Text ->\n  Maybe (HM.HashMap BaseUrl BaseUrl) ->\n  CallAPI m api a\ncallApiUnwrappingApiError toAPIException mbManagerSelector errorCodeMb internalEndPointHashMap baseUrl eulerClient desc api = do\n  newBaseUrl <-\n    HM.foldrWithKey\n      ( \\k v acc ->\n          if T.isInfixOf (showBaseUrlText k) (showBaseUrlText baseUrl)\n            then do\n              KP.parseBaseUrl (T.replace (showBaseUrlText k) (showBaseUrlText v) (showBaseUrlText baseUrl))\n            else acc\n      )\n      (return baseUrl)\n      (fromMaybe HM.empty internalEndPointHashMap)\n  logDebug $ \"newBaseUrl \" <> showBaseUrlText newBaseUrl\n\n  callApiExtractingApiError mbManagerSelector newBaseUrl eulerClient desc api\n    >>= unwrapEitherCallAPIError errorCodeMb newBaseUrl toAPIException\n\n-- Note on change:-\n-- As \"ManagerSelector\" is now a newtype wrapper around \"Text\" in new Euler-hs\ndefaultHttpManager :: ET.ManagerSelector\ndefaultHttpManager = ET.ManagerSelector \"default\"\n\nsetResponseTimeout :: Int -> Http.ManagerSettings -> Http.ManagerSettings\nsetResponseTimeout timeout settings =\n  settings {Http.managerResponseTimeout = Http.responseTimeoutMicro (timeout * 1000)}\n\ncreateManagers ::\n  ( MonadReader r m,\n    HasHttpClientOptions r c,\n    MonadFlow m\n  ) =>\n  HashMap Text Http.ManagerSettings ->\n  m (HashMap Text Http.Manager)\ncreateManagers managerSettings = do\n  timeout <- asks (.httpClientOptions.timeoutMs)\n  liftIO $ managersFromManagersSettings timeout managerSettings\n\ncreateManagersWithTimeout ::\n  ( MonadReader r m,\n    HasHttpClientOptions r c,\n    MonadFlow m\n  ) =>\n  HashMap Text Http.ManagerSettings ->\n  Maybe Int ->\n  m (HashMap Text Http.Manager)\ncreateManagersWithTimeout managerSettings Nothing = createManagers managerSettings\ncreateManagersWithTimeout managerSettings (Just timeout) = liftIO $ managersFromManagersSettings timeout managerSettings\n\nmanagersFromManagersSettings ::\n  Int ->\n  HashMap Text Http.ManagerSettings ->\n  IO (HashMap Text Http.Manager)\nmanagersFromManagersSettings timeout =\n  mapM Http.newManager\n    . fmap (setResponseTimeout timeout)\n    . HMS.insert defaultHttpManagerString Http.tlsManagerSettings\n  where\n    extractDefaultManagerString (ET.ManagerSelector x) = x\n    defaultHttpManagerString = extractDefaultManagerString defaultHttpManager\n\ncatchConnectionErrors :: (MonadCatch m, Log m) => m a -> (ExternalAPICallError -> m a) -> m a\ncatchConnectionErrors action errorHandler =\n  action `catch` \\err -> do\n    case err.clientError of\n      ConnectionError _ -> errorHandler err\n      _ -> throwError err\n\nretryAction ::\n  ( MonadCatch m,\n    Metrics.CoreMetrics m,\n    MonadIO m,\n    Log m\n  ) =>\n  ExternalAPICallError ->\n  Int ->\n  Int ->\n  Int ->\n  m a ->\n  m a\nretryAction currentErr currentRetryCount maxRetries baseCoefficient action = do\n  logWarning $ \"Error calling \" <> showBaseUrlText currentErr.baseUrl <> \": \" <> show currentErr.clientError\n  logWarning $ \"Retrying attempt \" <> show currentRetryCount <> \" calling \" <> showBaseUrlText currentErr.baseUrl\n  Metrics.addUrlCallRetries currentErr.baseUrl currentRetryCount\n  catchConnectionErrors action $ \\err -> do\n    if currentRetryCount < maxRetries\n      then do\n        liftIO $ threadDelaySec $ Seconds $ baseCoefficient * (2 ^ currentRetryCount)\n        retryAction err (currentRetryCount + 1) maxRetries baseCoefficient action\n      else do\n        logError $ \"Maximum of retrying attempts is reached calling \" <> showBaseUrlText err.baseUrl\n        Metrics.addUrlCallRetryFailures currentErr.baseUrl\n        throwError err\n\nwithRetryConfig ::\n  ( MonadCatch m,\n    MonadReader r m,\n    MonadIO m,\n    Metrics.CoreMetrics m,\n    Log m\n  ) =>\n  RetryCfg ->\n  m a ->\n  m a\nwithRetryConfig retryConfig action = do\n  let maxRetries = retryConfig.maxRetries\n      baseCoefficient = retryConfig.baseCoefficient\n\n  catchConnectionErrors action $ \\err -> do\n    if maxRetries > 0\n      then retryAction err 1 maxRetries baseCoefficient action\n      else do\n        Metrics.addUrlCallRetryFailures err.baseUrl\n        throwError err\n\nwithShortRetry ::\n  ( MonadCatch m,\n    MonadReader r m,\n    MonadIO m,\n    HasShortDurationRetryCfg r c,\n    Metrics.CoreMetrics m,\n    Log m\n  ) =>\n  m a ->\n  m a\nwithShortRetry action = do\n  retryConfig <- asks (.shortDurationRetryCfg)\n  withRetryConfig retryConfig action\n\nwithLongRetry ::\n  ( MonadCatch m,\n    MonadReader r m,\n    MonadIO m,\n    HasLongDurationRetryCfg r c,\n    Metrics.CoreMetrics m,\n    Log m\n  ) =>\n  m a ->\n  m a\nwithLongRetry action = do\n  retryConfig <- asks (.longDurationRetryCfg)\n  withRetryConfig retryConfig action\n\nserveDirectoryWebApp :: FilePath -> Servant.ServerT Servant.Raw m\nserveDirectoryWebApp = serveDirectoryWith' . settings . defaultWebAppSettings\n  where\n    staticApp' :: StaticSettings -> Wai.Application\n    staticApp' _ req sendResponse\n      | Wai.requestMethod req `notElem` [\"GET\", \"HEAD\"] =\n        sendError404 sendResponse\n    staticApp' set req sendResponse = staticApp set req sendResponse\n    serveDirectoryWith' = Servant.Tagged . staticApp'\n    settings StaticSettings {..} = StaticSettings {ss404Handler = Just $ \\_ sendResponse -> sendError404 sendResponse, ..}\n    sendError404 sendResponse =\n      sendResponse $\n        Wai.responseLBS\n          status404\n          [(\"Content-Type\", \"text/plain\")]\n          \"Not found\"\n",
      "hash": "54036f4e40baad8c75a7fa6f8ba3cfe9213de4db82d52320a26c914259740473",
      "size": 9932
    },
    "/lib/mobility-core/src/Kernel/Utils/Servant/HTML.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n\nmodule Kernel.Utils.Servant.HTML where\n\nimport qualified Data.ByteString.Lazy as BS\nimport EulerHS.Prelude\nimport qualified Network.HTTP.Media as M\nimport Servant\n\ndata HTML deriving (Typeable)\n\ninstance Accept HTML where\n  contentTypes _ = pure $ \"text\" M.// \"html\" M./: (\"charset\", \"utf-8\")\n\ninstance MimeRender HTML ByteString where\n  mimeRender _ = BS.fromStrict\n\ninstance MimeUnrender HTML ByteString where\n  mimeUnrender _ = pure . BS.toStrict\n",
      "hash": "9839bd8a183024954f36226c9dddf2b07c8dc0564be8ab672e57a1405f244e77",
      "size": 1144
    },
    "/lib/mobility-core/src/Kernel/Utils/Servant/HeaderAuth.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n{-# LANGUAGE AllowAmbiguousTypes #-}\n{-# LANGUAGE UndecidableInstances #-}\n\nmodule Kernel.Utils.Servant.HeaderAuth where\n\nimport Control.Arrow\nimport Control.Lens (at, (.=), (.~), (?=))\nimport Data.List (lookup)\nimport qualified Data.OpenApi as DS\nimport Data.Typeable (typeRep)\nimport EulerHS.Prelude hiding (fromList, (.~))\nimport GHC.Exts (fromList)\nimport GHC.TypeLits (KnownSymbol, Symbol, symbolVal)\nimport Kernel.Tools.Metrics.CoreMetrics (HasCoreMetrics)\nimport Kernel.Types.App\nimport Kernel.Types.Error\nimport Kernel.Types.Flow\nimport Kernel.Utils.Common\nimport Kernel.Utils.IOLogging (HasLog)\nimport Kernel.Utils.Servant.Server\nimport Network.Wai (Request (..))\nimport Servant hiding (ResponseHeader (..))\nimport Servant.Client\nimport qualified Servant.OpenApi as S\nimport qualified Servant.OpenApi.Internal as S\nimport Servant.Server.Internal.Delayed (addAuthCheck)\nimport Servant.Server.Internal.DelayedIO (DelayedIO, withRequest)\n\n-- | Adds authentication via a header to API\n--\n-- Type argument defines what verification logic is supposed to do.\n-- Normally you should define a type alias for this which fixes the\n-- verification method.\ndata HeaderAuth (header :: Symbol) (verify :: Type)\n\n-- | How token verification is performed.\nclass VerificationMethod verify where\n  -- | Verification result, what is passed to the endpoint implementation.\n  type VerificationResult verify\n\n  -- | Description of this verification scheme as it appears in swagger.\n  verificationDescription :: Text\n\n-- | Implementation of verification.\ndata VerificationAction verify m = VerificationMethod verify =>\n  VerificationAction\n  { -- | Check given header value and extract the information which\n    -- identifies the current user.\n    -- This is allowed to fail with 'ServantError'.\n    runVerifyMethod :: Text -> m (VerificationResult verify)\n  }\n\n-- | This server part implementation accepts token in @token@ header,\n-- verifies it and puts @'VerificationResult'@ to your endpoint.\ninstance\n  ( HasServer api ctx,\n    HasEnvEntry r ctx,\n    HasContextEntry ctx (VerificationAction verify (FlowR r)),\n    VerificationMethod verify,\n    KnownSymbol header,\n    HasLog r,\n    HasCoreMetrics r\n  ) =>\n  HasServer (HeaderAuth header verify :> api) ctx\n  where\n  type\n    ServerT (HeaderAuth header verify :> api) m =\n      VerificationResult verify -> ServerT api m\n\n  route _ ctx subserver =\n    route (Proxy @api) ctx $\n      subserver `addAuthCheck` withRequest authCheck\n    where\n      authCheck :: Request -> DelayedIO (VerificationResult verify)\n      authCheck req = runFlowRDelayedIO env . apiHandler $ do\n        let headerName = fromString $ symbolVal (Proxy @header)\n        requestHeaders req\n          & (lookup headerName >>> fromMaybeM (MissingHeader headerName))\n          >>= (parseHeader >>> fromEitherM (InvalidHeader headerName))\n          >>= verifyMethod\n      env = getEnvEntry ctx\n      VerificationAction verifyMethod = getContextEntry ctx :: VerificationAction verify (FlowR r)\n\n  hoistServerWithContext _ ctxp hst serv =\n    hoistServerWithContext (Proxy @api) ctxp hst . serv\n\n-- | This client part implementation simply accepts token and passes it to\n-- the call.\ninstance\n  (HasClient m api, KnownSymbol header) =>\n  HasClient m (HeaderAuth header verify :> api)\n  where\n  type Client m (HeaderAuth header verify :> api) = RegToken -> Client m api\n\n  clientWithRoute mp _ req =\n    clientWithRoute\n      mp\n      (Proxy @(Header header Text :> api))\n      req\n      . Just\n\n  hoistClientMonad mp _ hst cli = hoistClientMonad mp (Proxy @api) hst . cli\n\ninstance\n  ( S.HasOpenApi api,\n    VerificationMethod verify,\n    Typeable verify,\n    KnownSymbol header\n  ) =>\n  S.HasOpenApi (HeaderAuth header verify :> api)\n  where\n  toOpenApi _ =\n    S.toOpenApi (Proxy @api)\n      & addSecurityRequirement methodName (verificationDescription @verify) headerName\n      & S.addDefaultResponse400 headerName\n      & addResponse401\n    where\n      headerName = toText $ symbolVal (Proxy @header)\n      methodName = show $ typeRep (Proxy @verify)\n\naddSecurityRequirement :: Text -> Text -> Text -> DS.OpenApi -> DS.OpenApi\naddSecurityRequirement methodName description headerName = execState $ do\n  DS.components . DS.securitySchemes . at methodName ?= securityScheme\n  DS.allOperations . DS.security .= one securityRequirement\n  where\n    securityScheme =\n      DS.SecurityScheme\n        { _securitySchemeDescription = Just description,\n          _securitySchemeType =\n            DS.SecuritySchemeApiKey\n              DS.ApiKeyParams\n                { _apiKeyName = headerName,\n                  _apiKeyIn = DS.ApiKeyHeader\n                }\n        }\n    securityRequirement =\n      let scopes = []\n       in DS.SecurityRequirement $ fromList [(methodName, scopes)]\n\naddResponse401 :: DS.OpenApi -> DS.OpenApi\naddResponse401 = execState $ do\n  DS.components . DS.responses . at response401Name ?= response401\n  DS.allOperations . DS.responses . DS.responses . at 401\n    ?= DS.Ref (DS.Reference response401Name)\n  where\n    response401Name = \"Unauthorized\"\n    response401 = mempty & DS.description .~ \"Unauthorized\"\n",
      "hash": "2bfec9d8e8e46181d6f0692e641c97e8341bcbfccb56ef756a5b9d56c4f5783a",
      "size": 5826
    },
    "/lib/mobility-core/src/Kernel/Utils/Servant/JSONBS.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n\nmodule Kernel.Utils.Servant.JSONBS where\n\nimport qualified Data.ByteString.Lazy as BS\nimport qualified Data.List.NonEmpty as NE\nimport EulerHS.Prelude\nimport qualified Network.HTTP.Media as M\nimport Servant\n\ndata JSONBS deriving (Typeable)\n\ninstance Accept JSONBS where\n  contentTypes _ =\n    \"application\" M.// \"json\" M./: (\"charset\", \"utf-8\")\n      NE.:| [\"application\" M.// \"json\"]\n\ninstance MimeRender JSONBS ByteString where\n  mimeRender _ = BS.fromStrict\n\ninstance MimeUnrender JSONBS ByteString where\n  mimeUnrender _ = pure . BS.toStrict\n",
      "hash": "7a391e0235b64a449c6ab81288c23fb2f8fe7299bb9731ac3e6e728057296770",
      "size": 1240
    },
    "/lib/mobility-core/src/Kernel/Utils/Servant/Server.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n{-# LANGUAGE UndecidableInstances #-}\n\nmodule Kernel.Utils.Servant.Server where\n\nimport EulerHS.Prelude\nimport qualified EulerHS.Runtime as E\nimport GHC.Records.Extra (HasField)\nimport Kernel.Prelude (identity)\nimport qualified Kernel.Tools.Metrics.CoreMetrics.Types as Metrics\nimport qualified Kernel.Tools.Metrics.Init as Metrics\nimport Kernel.Tools.Slack.Internal\nimport Kernel.Tools.Slack.Middleware\nimport Kernel.Types.App (EnvR (..), FlowHandlerR, FlowServerR)\nimport Kernel.Types.Flow\nimport Kernel.Types.Time\nimport Kernel.Utils.App\nimport qualified Kernel.Utils.FlowLogging as L\nimport Kernel.Utils.IOLogging\nimport Kernel.Utils.Logging\nimport qualified Kernel.Utils.Monitoring.Prometheus.Servant as Metrics\nimport Network.Wai.Handler.Warp\n  ( Port,\n    Settings,\n    defaultSettings,\n    runSettings,\n    setGracefulShutdownTimeout,\n    setInstallShutdownHandler,\n    setPort,\n  )\nimport Servant\nimport Servant.Server.Internal.DelayedIO (DelayedIO, delayedFailFatal)\n\nclass HasEnvEntry r (context :: [Type]) | context -> r where\n  getEnvEntry :: Context context -> EnvR r\n\ninstance {-# OVERLAPPABLE #-} HasEnvEntry r xs => HasEnvEntry r (notIt ': xs) where\n  getEnvEntry (_ :. xs) = getEnvEntry xs\n\ninstance {-# OVERLAPPING #-} HasEnvEntry r (EnvR r ': xs) where\n  getEnvEntry (x :. _) = x\n\nrun ::\n  forall a r ctx.\n  ( HasContextEntry (ctx .++ '[ErrorFormatters]) ErrorFormatters,\n    HasServer a (EnvR r ': ctx)\n  ) =>\n  Proxy (a :: Type) ->\n  FlowServerR r a ->\n  Context ctx ->\n  EnvR r ->\n  Application\nrun apis server ctx env =\n  serveWithContext apis (env :. ctx) $\n    hoistServerWithContext apis (Proxy @(EnvR r ': ctx)) f server\n  where\n    f :: FlowHandlerR r m -> Handler m\n    f r = do\n      eResult <- liftIO . try $ runReaderT r env\n      case eResult of\n        Left err ->\n          print @String (\"exception thrown: \" <> show err) *> throwError err\n        Right res -> pure res\n\nrunGeneric ::\n  forall api env m ctx.\n  ( HasContextEntry (env ': (ctx .++ '[ErrorFormatters])) ErrorFormatters,\n    HasServer api (env ': ctx),\n    MonadReader env m\n  ) =>\n  Proxy (api :: Type) ->\n  ServerT api m ->\n  Context ctx ->\n  env ->\n  (forall b. env -> m b -> IO b) ->\n  Application\nrunGeneric apis server ctx env runMonad =\n  serveWithContext apis (env :. ctx) $\n    hoistServerWithContext apis (Proxy @(env ': ctx)) f server\n  where\n    f :: m a -> Handler a\n    f action = do\n      eResult <- liftIO . try $ runMonad env action\n      case eResult of\n        Left err ->\n          print @String (\"exception thrown: \" <> show err) *> throwError err\n        Right res -> pure res\n\nrunFlowRDelayedIO :: EnvR r -> FlowR r b -> DelayedIO b\nrunFlowRDelayedIO env f =\n  liftIO (try . runFlowR (flowRuntime env) (appEnv env) $ f)\n    >>= either delayedFailFatal pure\n\nrunServer ::\n  forall env (api :: Type) ctx.\n  ( HasField \"graceTerminationPeriod\" env Seconds,\n    HasField \"isShuttingDown\" env Shutdown,\n    HasField \"loggerConfig\" env L.LoggerConfig,\n    HasField \"loggerEnv\" env LoggerEnv,\n    HasField \"port\" env Port,\n    HasField \"version\" env Metrics.DeploymentVersion,\n    Metrics.SanitizedUrl api,\n    HasContextEntry (ctx .++ '[ErrorFormatters]) ErrorFormatters,\n    HasServer api (EnvR env ': ctx)\n  ) =>\n  env ->\n  Proxy api ->\n  FlowServerR env api ->\n  (Application -> Application) ->\n  (Settings -> Settings) ->\n  Context ctx ->\n  (E.FlowRuntime -> IO () -> IO ()) ->\n  (env -> IO ()) ->\n  (E.FlowRuntime -> FlowR env E.FlowRuntime) ->\n  IO ()\nrunServer appEnv serverAPI serverHandler waiMiddleware waiSettings servantCtx serverStartAction shutdownAction initialize = do\n  let port = appEnv.port\n  hostname <- getPodName\n  let loggerRt = L.getEulerLoggerRuntime hostname $ appEnv.loggerConfig\n  let settings =\n        defaultSettings\n          & setGracefulShutdownTimeout (Just $ getSeconds appEnv.graceTerminationPeriod)\n          & setInstallShutdownHandler (handleShutdown appEnv.isShuttingDown (shutdownAction appEnv))\n          & setPort port\n          & waiSettings\n  let server = withModifiedEnv $ \\modifiedEnv ->\n        run serverAPI serverHandler servantCtx modifiedEnv\n          & logRequestAndResponse modifiedEnv\n          & Metrics.addServantInfo appEnv.version serverAPI\n          & waiMiddleware\n  E.withFlowRuntime (Just loggerRt) $ \\flowRt -> do\n    flowRt' <-\n      runFlowR flowRt appEnv $\n        initialize flowRt <* logInfo (\"Runtime created. Starting server at port \" <> show port)\n    serverStartAction flowRt' $ runSettings settings $ server (EnvR flowRt' appEnv)\n\nrunServerGeneric ::\n  forall m env (api :: Type) ctx.\n  ( MonadReader env m,\n    HasField \"graceTerminationPeriod\" env Seconds,\n    HasField \"isShuttingDown\" env Shutdown,\n    HasField \"loggerConfig\" env L.LoggerConfig,\n    HasField \"loggerEnv\" env LoggerEnv,\n    HasField \"port\" env Port,\n    HasField \"version\" env Metrics.DeploymentVersion,\n    Metrics.SanitizedUrl api,\n    HasContextEntry (env ': (ctx .++ '[ErrorFormatters])) ErrorFormatters,\n    HasServer api (env ': ctx)\n  ) =>\n  env ->\n  Proxy api ->\n  ServerT api m ->\n  (Application -> Application) ->\n  (Settings -> Settings) ->\n  Context ctx ->\n  (env -> IO () -> IO ()) ->\n  (env -> IO ()) ->\n  (forall q. env -> m q -> IO q) ->\n  IO ()\nrunServerGeneric appEnv serverAPI serverHandler waiMiddleware waiSettings servantCtx serverStartAction shutdownAction runMonad = do\n  let port = appEnv.port\n  let settings =\n        defaultSettings\n          & setGracefulShutdownTimeout (Just $ getSeconds appEnv.graceTerminationPeriod)\n          & setInstallShutdownHandler (handleShutdown appEnv.isShuttingDown (shutdownAction appEnv))\n          & setPort port\n          & waiSettings\n  let server = withModifiedEnvGeneric $ \\modifiedEnv ->\n        let loggerFunc = \\tag info -> logOutputIO (appendLogTag tag $ modifiedEnv.loggerEnv) INFO info\n         in runGeneric serverAPI serverHandler servantCtx modifiedEnv runMonad\n              & logRequestAndResponseGeneric loggerFunc\n              & Metrics.addServantInfo appEnv.version serverAPI\n              & waiMiddleware\n  serverStartAction appEnv $ runSettings settings $ server appEnv\n\ntype HealthCheckAPI = Get '[JSON] Text\n\nhealthCheck :: (Monad m) => ServerT HealthCheckAPI m\nhealthCheck = pure \"App is UP\"\n\nrunHealthCheckServerWithService ::\n  forall env ctx.\n  ( HasField \"graceTerminationPeriod\" env Seconds,\n    HasField \"isShuttingDown\" env Shutdown,\n    HasField \"loggerConfig\" env L.LoggerConfig,\n    HasField \"loggerEnv\" env LoggerEnv,\n    HasField \"port\" env Port,\n    HasField \"version\" env Metrics.DeploymentVersion,\n    HasContextEntry (ctx .++ '[ErrorFormatters]) ErrorFormatters\n  ) =>\n  env ->\n  (Application -> Application) ->\n  (Settings -> Settings) ->\n  Context ctx ->\n  (E.FlowRuntime -> IO ()) ->\n  (env -> IO ()) ->\n  (E.FlowRuntime -> FlowR env E.FlowRuntime) ->\n  IO ()\nrunHealthCheckServerWithService appEnv waiMiddleware waiSettings servantCtx service =\n  runServer appEnv (Proxy @HealthCheckAPI) healthCheck waiMiddleware waiSettings servantCtx forkServerStartService\n  where\n    forkServerStartService flowRt startServerAction = do\n      void $ forkIO startServerAction\n      service flowRt\n\nrunServerWithHealthCheck ::\n  forall env (api :: Type) ctx.\n  ( HasField \"graceTerminationPeriod\" env Seconds,\n    HasField \"isShuttingDown\" env Shutdown,\n    HasField \"loggerConfig\" env L.LoggerConfig,\n    HasField \"loggerEnv\" env LoggerEnv,\n    HasField \"port\" env Port,\n    HasField \"version\" env Metrics.DeploymentVersion,\n    Metrics.SanitizedUrl api,\n    HasContextEntry (ctx .++ '[ErrorFormatters]) ErrorFormatters,\n    HasServer api (EnvR env ': ctx)\n  ) =>\n  env ->\n  Proxy api ->\n  FlowServerR env api ->\n  (Application -> Application) ->\n  (Settings -> Settings) ->\n  Context ctx ->\n  (env -> IO ()) ->\n  (E.FlowRuntime -> FlowR env E.FlowRuntime) ->\n  IO ()\nrunServerWithHealthCheck appEnv _ serverHandler waiMiddleware waiSettings servantCtx =\n  runServer appEnv (Proxy @(HealthCheckAPI :<|> api)) (healthCheck :<|> serverHandler) waiMiddleware waiSettings servantCtx (const identity)\n\nrunServerWithHealthCheckAndSlackNotification ::\n  forall env (api :: Type) ctx.\n  ( HasField \"graceTerminationPeriod\" env Seconds,\n    HasField \"isShuttingDown\" env Shutdown,\n    HasField \"loggerConfig\" env L.LoggerConfig,\n    HasField \"loggerEnv\" env LoggerEnv,\n    HasSlackEnv env,\n    HasField \"port\" env Port,\n    HasField \"version\" env Metrics.DeploymentVersion,\n    Metrics.SanitizedUrl api,\n    HasContextEntry (ctx .++ '[ErrorFormatters]) ErrorFormatters,\n    HasServer api (EnvR env ': ctx)\n  ) =>\n  env ->\n  Proxy api ->\n  FlowServerR env api ->\n  (Application -> Application) ->\n  (Settings -> Settings) ->\n  Context ctx ->\n  (env -> IO ()) ->\n  (E.FlowRuntime -> FlowR env E.FlowRuntime) ->\n  IO ()\nrunServerWithHealthCheckAndSlackNotification appEnv _ serverHandler waiMiddleware waiSettings servantCtx =\n  runServer appEnv (Proxy @(HealthCheckAPI :<|> api)) (healthCheck :<|> serverHandler) moreMiddleware waiSettings servantCtx (const identity)\n  where\n    moreMiddleware app =\n      waiMiddleware app\n        & notifyOnSlackMiddleware appEnv\n",
      "hash": "ebf793e73bdc410154f1747488af6c2a17c53c1a9b5f976740325b9c9f5d90fa",
      "size": 9804
    },
    "/lib/mobility-core/src/Kernel/Utils/Servant/SignatureAuth.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n{-# LANGUAGE AllowAmbiguousTypes #-}\n{-# LANGUAGE PackageImports #-}\n{-# LANGUAGE UndecidableInstances #-}\n\nmodule Kernel.Utils.Servant.SignatureAuth where\n\nimport Control.Arrow\nimport Control.Lens (at, (.=), (.~), (?=))\nimport qualified Data.Aeson as A\nimport qualified \"base64-bytestring\" Data.ByteString.Base64 as Base64\nimport qualified Data.ByteString.Lazy as BSL\nimport qualified Data.CaseInsensitive as CI\nimport qualified Data.HashMap.Strict as HMS\nimport Data.List (lookup)\nimport qualified Data.OpenApi as DS\nimport Data.Singletons.TH\nimport qualified Data.Text as T\nimport Data.Time.Clock.POSIX (getPOSIXTime)\nimport Data.Typeable (typeRep)\nimport EulerHS.Prelude hiding (fromList, (.~))\nimport qualified EulerHS.Runtime as R\nimport GHC.Exts (fromList)\nimport GHC.TypeLits (KnownSymbol, Symbol, symbolVal)\nimport Kernel.Tools.ARTUtils (HasARTFlow)\nimport Kernel.Tools.Metrics.CoreMetrics (HasCoreMetrics)\nimport qualified Kernel.Tools.Metrics.CoreMetrics as Metrics\nimport qualified Kernel.Types.Beckn.Context as Context\nimport qualified Kernel.Types.Beckn.Domain as Domain\nimport Kernel.Types.Common\nimport Kernel.Types.Credentials\nimport Kernel.Types.Error\nimport Kernel.Types.Flow\nimport Kernel.Types.Registry\nimport qualified Kernel.Types.Registry.Subscriber as Subscriber\nimport Kernel.Utils.Common\nimport Kernel.Utils.Dhall (FromDhall)\nimport Kernel.Utils.IOLogging (HasLog)\nimport Kernel.Utils.Monitoring.Prometheus.Servant (SanitizedUrl (..))\nimport Kernel.Utils.Servant.Server (HasEnvEntry (..), runFlowRDelayedIO)\nimport qualified Kernel.Utils.SignatureAuth as HttpSig\nimport qualified Network.HTTP.Client as Http\nimport qualified Network.HTTP.Client.TLS as Http\nimport qualified Network.Wai as Wai\nimport Servant\n  ( FromHttpApiData (parseHeader),\n    HasServer (..),\n    type (:>),\n  )\nimport Servant.Client (HasClient (..))\nimport qualified Servant.OpenApi as S\nimport qualified Servant.OpenApi.Internal as S\nimport Servant.Server.Internal.Delayed (addAuthCheck)\nimport Servant.Server.Internal.DelayedIO (DelayedIO, withRequest)\n\n-- | Adds authentication via a signature in the API\n--\n-- Follows the HTTP Signature specification at\n-- https://tools.ietf.org/id/draft-cavage-http-signatures-12.html\n--\n-- The header is a parameter, so we can support both `Authorize` and\n-- `Proxy-Authorize` variants.\n--\n-- The lookup argument defines how keys can be looked up for performing\n-- signature matches.\ndata SignatureAuth (domain :: Domain.Domain) (header :: Symbol)\n\nclass AuthenticatingEntity r where\n  getSigningKey :: r -> PrivateKey\n  getSignatureExpiry :: r -> Seconds\n\ndata AuthenticatingEntity' = AuthenticatingEntity'\n  { signingKey :: PrivateKey,\n    uniqueKeyId :: Text,\n    signatureExpiry :: Seconds\n  }\n  deriving (Generic, FromDhall)\n\ndata SignatureAuthResult = SignatureAuthResult\n  { signature :: HttpSig.SignaturePayload,\n    subscriber :: Subscriber\n  }\n\n-- | This server part implementation accepts a signature in @header@ and\n-- verifies it using registry\ninstance\n  ( HasServer api ctx,\n    HasEnvEntry r ctx,\n    KnownSymbol header,\n    HasLog r,\n    HasField \"hostName\" r Text,\n    HasField \"disableSignatureAuth\" r Bool,\n    Registry (FlowR r),\n    HasCoreMetrics r,\n    SingI domain,\n    HasARTFlow r\n  ) =>\n  HasServer (SignatureAuth domain header :> api) ctx\n  where\n  type\n    ServerT (SignatureAuth domain header :> api) m =\n      SignatureAuthResult -> ServerT api m\n\n  route _ ctx subserver =\n    route (Proxy @api) ctx $\n      subserver `addAuthCheck` withRequest authCheck'\n    where\n      authCheck' :: Wai.Request -> DelayedIO SignatureAuthResult\n      authCheck' req = runFlowRDelayedIO env . becknApiHandler . withLogTag \"authCheck\" $ do\n        let headers = Wai.requestHeaders req\n            pathInfo = Wai.rawPathInfo req\n        (actionTxt, merchantId) <- getLastTwoElements (decodeUtf8 pathInfo) & fromMaybeM (InternalError $ \"Beckn \" <> show pathInfo <> \" path doesn't have merchant id\")\n        logDebug $ \"Incoming headers: \" +|| headers ||+ \"\"\n        let mbBodyHashHeader = lookup HttpSig.bodyHashHeader headers\n        let mbSignPayloadHeader = lookup headerName headers\n        action <- case A.fromJSON (A.String actionTxt) of\n          A.Success action -> pure action\n          A.Error err -> throwError (InternalError $ \"Could not parse api name: \" <> show actionTxt <> \"; err: \" <> show err)\n        let subscriberType = case (headerName :: Text) of\n              \"X-Gateway-Authorization\" -> Subscriber.BG\n              _ -> Context.getSubscriberType action\n        let domain = fromSing (sing @domain)\n        logDebug $ \"Action: \" <> show action <> \"; subscriberType: \" <> show subscriberType <> \"; domain: \" <> show domain\n        authCheck headerName mbSignPayloadHeader mbBodyHashHeader merchantId subscriberType domain\n\n      headerNameStr = symbolVal (Proxy @header)\n      headerName = fromString headerNameStr\n      headerName :: IsString a => a\n      -- These are 500 because we must add that header in wai middleware\n      env = getEnvEntry ctx\n\n  hoistServerWithContext _ ctxp hst serv =\n    hoistServerWithContext (Proxy @api) ctxp hst . serv\n\nauthCheck ::\n  ( HasLog r,\n    HasField \"hostName\" r Text,\n    HasField \"disableSignatureAuth\" r Bool,\n    Registry (FlowR r),\n    HasCoreMetrics r,\n    HasARTFlow r\n  ) =>\n  String ->\n  Maybe ByteString ->\n  Maybe ByteString ->\n  Text ->\n  SubscriberType ->\n  Domain.Domain ->\n  FlowR r SignatureAuthResult\nauthCheck headerNameStr mbSignPayloadHeader mbBodyHashHeader merchantId subscriberType domain = do\n  bodyHash <-\n    mbBodyHashHeader\n      & fromMaybeM missingHashHeader\n      >>= (Base64.decodeLenient >>> HttpSig.hashFromByteString >>> fromMaybeM invalidHashHeader)\n  signPayload <-\n    mbSignPayloadHeader\n      & fromMaybeM (MissingHeader headerName)\n      >>= (parseHeader >>> fromEitherM (InvalidHeader headerName))\n      >>= (HttpSig.decode . fromString >>> fromEitherM CannotDecodeSignature)\n  subscriber <- verifySignature headerName signPayload bodyHash merchantId subscriberType domain\n  return $ SignatureAuthResult signPayload subscriber\n  where\n    -- These are 500 because we must add that header in wai middleware\n    missingHashHeader = InternalError $ \"Header \" +|| HttpSig.bodyHashHeader ||+ \" not found\"\n    invalidHashHeader = InternalError $ \"Header \" +|| HttpSig.bodyHashHeader ||+ \" does not contain a valid hash\"\n\n    headerName = fromString headerNameStr\n    headerName :: IsString a => a\n\n-- | The client implementation for SignatureAuth is a no-op, as we do not have\n-- a request that we can work with at this layer. Clients should instead use\n-- `prepareAuthManager` as their `Manager` to create and add the signature.\n-- This is a bit ugly, but it does not appear that we have much of a choice in\n-- this regard given what plumbing options Servant gives us.\ninstance\n  (HasClient m api, KnownSymbol header) =>\n  HasClient m (SignatureAuth domain header :> api)\n  where\n  type Client m (SignatureAuth domain header :> api) = Client m api\n\n  clientWithRoute mp _ req =\n    clientWithRoute\n      mp\n      (Proxy @api)\n      req\n\n  hoistClientMonad mp _ hst cli = hoistClientMonad mp (Proxy @api) hst cli\n\nsignatureAuthManagerKey :: Text\nsignatureAuthManagerKey = \"http-signature\"\n\ngetHttpManagerKey :: Text -> Text\ngetHttpManagerKey keyId = signatureAuthManagerKey <> T.pack \"-\" <> keyId\n\nprepareAuthManager ::\n  HasLog r =>\n  AuthenticatingEntity r =>\n  R.FlowRuntime ->\n  r ->\n  [Text] ->\n  Text ->\n  Text ->\n  Http.ManagerSettings\nprepareAuthManager flowRt appEnv signHeaders subscriberId uniqueKeyId =\n  Http.tlsManagerSettings {Http.managerModifyRequest = runFlowR flowRt appEnv . doSignature}\n  where\n    doSignature req = withLogTag \"prepareAuthManager\" do\n      now <- liftIO getPOSIXTime\n      let params = HttpSig.mkSignatureParams subscriberId uniqueKeyId now signatureExpiry HttpSig.Ed25519\n      let body = getBody $ Http.requestBody req\n      let bodyHash = HttpSig.becknSignatureHash body\n      let headers = Http.requestHeaders req\n      let signatureMsg = HttpSig.makeSignatureString params bodyHash headers\n      logDebug $ \"Request body for signing: \" +|| body ||+ \"\"\n      logDebug $ \"Signature Message: \" +|| signatureMsg ||+ \"\"\n      foldM (addSignature bodyHash params headers) req signHeaders\n        & fromMaybeM (InternalError $ \"Could not add signature: \" <> show params)\n    getBody (Http.RequestBodyLBS body) = BSL.toStrict body\n    getBody (Http.RequestBodyBS body) = body\n    getBody _ = \"<MISSING_BODY>\"\n    signPrivKey = getSigningKey appEnv\n    signatureExpiry = getSignatureExpiry appEnv\n\n    -- FIXME: we don't currently deal with Content-Length not being there (this is\n    -- filled later, so we might need to have some special handling)\n    addSignature bodyHash params headers req signHeader =\n      let ciHeader = CI.mk $ encodeUtf8 signHeader\n       in -- We check if the signHeader exists because `managerModifyRequest` might be\n          -- called multiple times, so we already added it once, let's skip right over\n          if isJust $ lookup ciHeader headers\n            then Just req\n            else do\n              signature <- HttpSig.sign signPrivKey params bodyHash headers\n              let headerVal = HttpSig.encode $ HttpSig.SignaturePayload signature params\n              Just $ req {Http.requestHeaders = (ciHeader, headerVal) : headers}\n\nverifySignature ::\n  ( MonadFlow m,\n    MonadReader r m,\n    Metrics.CoreMetrics m,\n    HasField \"hostName\" r Text,\n    HasField \"disableSignatureAuth\" r Bool,\n    Registry m,\n    HasLog r\n  ) =>\n  Text ->\n  HttpSig.SignaturePayload ->\n  HttpSig.Hash ->\n  Text ->\n  SubscriberType ->\n  Domain.Domain ->\n  m Subscriber\nverifySignature headerName signPayload bodyHash merchantId subscriberType domain = do\n  hostName <- asks (.hostName)\n  logTagDebug \"SignatureAuth\" $ \"Got Signature: \" <> show signPayload\n  let uniqueKeyId = signPayload.params.keyId.uniqueKeyId\n      subscriberId = signPayload.params.keyId.subscriberId\n      lookupRequest =\n        SimpleLookupRequest\n          { unique_key_id = uniqueKeyId,\n            subscriber_id = subscriberId,\n            merchant_id = merchantId,\n            subscriber_type = subscriberType,\n            domain\n          }\n  registryLookup lookupRequest >>= \\case\n    Just subscriber -> do\n      disableSignatureAuth <- asks (.disableSignatureAuth)\n      unless disableSignatureAuth do\n        let publicKey = subscriber.signing_public_key\n        isVerified <- performVerification publicKey hostName\n        unless isVerified $ do\n          logTagError logTag \"Signature is not valid.\"\n          throwError $ getSignatureError hostName\n      pure subscriber\n    Nothing -> do\n      logTagError logTag $\n        \"Subscriber with unique_key_id:\"\n          <> signPayload.params.keyId.uniqueKeyId\n          <> \"; subscriber type: \"\n          <> show lookupRequest.subscriber_type\n          <> \"; domain: \"\n          <> show lookupRequest.domain\n          <> \" not found.\"\n      throwError $ getSignatureError hostName\n  where\n    logTag = \"verifySignature-\" <> headerName\n    performVerification key hostName = do\n      let headers =\n            [ (\"(created)\", maybe \"\" show (signPayload.params.created)),\n              (\"(expires)\", maybe \"\" show (signPayload.params.expires)),\n              (\"digest\", \"\")\n            ]\n      let signatureParams = signPayload.params\n      let signature = signPayload.signature\n      let signatureMsg = HttpSig.makeSignatureString signatureParams bodyHash headers\n      logTagDebug logTag $\n        \"Start verifying. Signature: \" +|| HttpSig.encode signPayload ||+ \", Signature Message: \" +|| signatureMsg ||+ \", Body hash: \" +|| bodyHash ||+ \"\"\n      let verificationResult =\n            HttpSig.verify\n              key\n              signatureParams\n              bodyHash\n              headers\n              signature\n      case verificationResult of\n        Right result -> pure result\n        Left err -> do\n          logTagError logTag $ \"Failed to verify the signature. Error: \" <> show err\n          throwError $ getSignatureError hostName\n\n    getSignatureError hostName =\n      SignatureVerificationFailure [HttpSig.mkSignatureRealm getRealm hostName]\n\n    getRealm = case headerName of\n      \"Authorization\" -> \"WWW-Authenticate\"\n      \"Proxy-Authorization\" -> \"Proxy-Authenticate\"\n      \"X-Gateway-Authorization\" -> \"Proxy-Authenticate\"\n      _ -> \"\"\n\nprepareAuthManagers ::\n  (AuthenticatingEntity r, HasLog r) =>\n  R.FlowRuntime ->\n  r ->\n  [(Text, Text)] ->\n  HashMap Text Http.ManagerSettings\nprepareAuthManagers flowRt appEnv allShortIds = do\n  flip foldMap allShortIds \\(shortId, uniqueKeyId) ->\n    HMS.singleton\n      (signatureAuthManagerKey <> (T.pack \"-\") <> shortId)\n      (prepareAuthManager flowRt appEnv [\"Authorization\"] shortId uniqueKeyId)\n\nmodFlowRtWithAuthManagers ::\n  ( AuthenticatingEntity r,\n    HasHttpClientOptions r c,\n    MonadReader r m,\n    HasLog r,\n    MonadFlow m\n  ) =>\n  R.FlowRuntime ->\n  r ->\n  [(Text, Text)] ->\n  m R.FlowRuntime\nmodFlowRtWithAuthManagers flowRt appEnv orgShortIds = do\n  let managersSettings = prepareAuthManagers flowRt appEnv orgShortIds\n  managers <- createManagers managersSettings\n  logInfo $ \"Loaded http managers - \" <> show orgShortIds\n  pure $ flowRt {R._httpClientManagers = managers}\n\n-- Note on Changes:\n{-\n in now-old version of Euler-hs the type of\n   _httpClientManagers       :: Map String Manager\n\n but, now in the Newer version of Euler, it is\n   _httpClientManagers       :: HashMap Text Manager\n\n The changes made here and in Client.hs file accommodate for this same fact\n-}\naddAuthManagersToFlowRt ::\n  ( HasHttpClientOptions r c,\n    MonadReader r m,\n    HasLog r,\n    MonadFlow m\n  ) =>\n  R.FlowRuntime ->\n  [(Maybe Int, HashMap Text Http.ManagerSettings)] ->\n  m R.FlowRuntime\naddAuthManagersToFlowRt flowRt managersList = do\n  managers <- mapM createManager managersList\n  pure $ flowRt {R._httpClientManagers = HMS.unions managers}\n  where\n    createManager (timeout, managersSettings) = do\n      logInfo $ \"Loaded http managers - \" <> show (HMS.keys managersSettings)\n      createManagersWithTimeout managersSettings timeout\n\n-- Notes on changes:-\n{-\nthe type of \"_componentsSecuritySchemes\" field from Data.OpenApi module\nchanged it's representation in openapi3 package version 3.2.0.\n\nit went from being a \"Definitions SecurityScheme\" to \"SecurityDefinitions\".\n\nwhile \"Definitions\" was just a type-synonym for an \"InsOrdHashMap Text\".\nThe new \"SecurityDefinitions\" type is newtype wrapper over \"Definitions\" type\n, Thus it would need it's own instances to be indexable via lens.\n\nThese type-class and type-family instances were absent and were added in a previous commit.\nA PR was also opened on the main package repository of the package for this.\n-}\ninstance\n  ( S.HasOpenApi api,\n    KnownSymbol header\n  ) =>\n  S.HasOpenApi (SignatureAuth domain header :> api)\n  where\n  toOpenApi _ =\n    S.toOpenApi (Proxy @api)\n      & addSecurityRequirement \"Looks up the given key Id in the Core registry.\"\n      & S.addDefaultResponse400 headerName\n      & addResponse401\n    where\n      headerName = toText $ symbolVal (Proxy @header)\n      methodName = T.pack $ show $ typeRep (Proxy @Subscriber) -- since the \"Index SecurityDefinitions\" is a \"Text\"\n      addSecurityRequirement :: Text -> DS.OpenApi -> DS.OpenApi\n      addSecurityRequirement description = execState $ do\n        DS.components . DS.securitySchemes . at methodName ?= securityScheme\n        DS.allOperations . DS.security .= one securityRequirement\n        where\n          securityScheme =\n            DS.SecurityScheme\n              { _securitySchemeDescription = Just description,\n                _securitySchemeType =\n                  DS.SecuritySchemeApiKey\n                    DS.ApiKeyParams\n                      { _apiKeyName = headerName,\n                        _apiKeyIn = DS.ApiKeyHeader\n                      }\n              }\n          securityRequirement =\n            let scopes = []\n             in DS.SecurityRequirement $ fromList [(methodName, scopes)]\n\n      addResponse401 :: DS.OpenApi -> DS.OpenApi\n      addResponse401 = execState $ do\n        DS.components . DS.responses . at response401Name ?= response401\n        DS.allOperations . DS.responses . DS.responses . at 401\n          ?= DS.Ref (DS.Reference response401Name)\n        where\n          response401Name = \"Unauthorized\"\n          response401 = mempty & DS.description .~ \"Unauthorized\"\n\ninstance\n  SanitizedUrl (subroute :: Type) =>\n  SanitizedUrl (SignatureAuth domain h :> subroute)\n  where\n  getSanitizedUrl _ = getSanitizedUrl (Proxy :: Proxy subroute)\n\ngetLastTwoElements :: Text -> Maybe (Text, Text)\ngetLastTwoElements str =\n  case reverse (T.splitOn \"/\" str) of\n    (last : secondLast : _) -> Just (last, secondLast)\n    _ -> Nothing\n",
      "hash": "f7b816e4c833c70b49563979a74ed34c05e320ea4aa8edfa771e024bfa4678c1",
      "size": 17525
    },
    "/lib/mobility-core/src/Kernel/Utils/Service.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n\nmodule Kernel.Utils.Service\n  ( startService,\n  )\nwhere\n\nimport Kernel.Prelude\nimport Kernel.Utils.Common as CoreCommon\nimport Kernel.Utils.Shutdown\n\nstartService ::\n  ( Forkable m,\n    MonadIO m,\n    MonadReader r m,\n    HasField \"isShuttingDown\" r Shutdown,\n    MonadCatch m,\n    Log m\n  ) =>\n  Text ->\n  m () ->\n  m ()\nstartService name f =\n  fork name . untilShutdown $\n    f `catch` \\e -> do\n      log ERROR $ makeLogSomeException e\n      threadDelay 1000000\n",
      "hash": "e5a750dc25ffa499a008208b631d0752e911520a7a331ba0c3d73622e5c6abbb",
      "size": 1158
    },
    "/lib/mobility-core/src/Kernel/Utils/Shutdown.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n\nmodule Kernel.Utils.Shutdown where\n\nimport Control.Concurrent.STM.TMVar\nimport GHC.Conc\nimport Kernel.Prelude\nimport System.Posix.Signals (Handler (Catch), installHandler, sigINT, sigTERM)\n\ntype Shutdown = TMVar ()\n\nhandleShutdown :: Shutdown -> IO () -> IO () -> IO ()\nhandleShutdown shutdown onShutdown closeSocket = do\n  void $ installHandler sigTERM (Catch $ shutdownAction \"sigTERM\") Nothing\n  void $ installHandler sigINT (Catch $ shutdownAction \"sigINT\") Nothing\n  where\n    shutdownAction reason = do\n      isLocked <- atomically $ do\n        isEmptyTMVar shutdown >>= \\case\n          True -> do\n            putTMVar shutdown ()\n            return True\n          False -> return False\n      when isLocked $ do\n        putStrLn (\"Shutting down by \" <> reason :: Text)\n      onShutdown\n      closeSocket\n\nwaitForShutdown :: Shutdown -> IO ()\nwaitForShutdown = atomically . takeTMVar\n\nmkShutdown :: IO Shutdown\nmkShutdown = newEmptyTMVarIO\n\nuntilShutdown ::\n  ( MonadIO m,\n    MonadReader r m,\n    HasField \"isShuttingDown\" r Shutdown\n  ) =>\n  m () ->\n  m ()\nuntilShutdown =\n  whileM isRunning\n\nisRunning ::\n  ( MonadIO m,\n    MonadReader r m,\n    HasField \"isShuttingDown\" r Shutdown\n  ) =>\n  m Bool\nisRunning = liftIO . atomically . isEmptyTMVar =<< asks (.isShuttingDown)\n",
      "hash": "d013597a185871642fac8f39b76660ece8c8dc156bf4dbe0e9bc3eb4c62bfbda",
      "size": 1974
    },
    "/lib/mobility-core/src/Kernel/Utils/SignatureAuth.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n{-# LANGUAGE PackageImports #-}\n\nmodule Kernel.Utils.SignatureAuth\n  ( PublicKey,\n    PrivateKey,\n    SignatureAlgorithm (..),\n    SignatureParams (..),\n    SignaturePayload (..),\n    KeyId (..),\n    Hash,\n    decode,\n    encode,\n    sign,\n    verify,\n    encodeKeyId,\n    decodeKeyId,\n    mkSignatureRealm,\n    defaultHeaderFields,\n    makeSignatureString,\n    mkSignatureParams,\n    generateKeyPair,\n    becknSignatureHash,\n    hashFromByteString,\n    bodyHashHeader,\n  )\nwhere\n\nimport qualified Crypto.Error as Crypto\nimport qualified Crypto.Hash as Hash\nimport qualified Crypto.PubKey.Ed25519 as Ed25519\nimport qualified Data.ByteArray as BA\nimport qualified Data.ByteString as BS\nimport qualified \"base64-bytestring\" Data.ByteString.Base64 as Base64\nimport qualified Data.CaseInsensitive as CI\nimport Data.List (lookup)\nimport qualified Data.Text as T\nimport qualified Data.Text as Text\nimport Data.Time.Clock.POSIX (POSIXTime)\nimport Data.Time.Format\nimport EulerHS.Prelude\nimport Kernel.Types.Base64\nimport Kernel.Types.Credentials\nimport Kernel.Types.Time (Seconds, getSeconds)\nimport Network.HTTP.Types (Header, HeaderName)\nimport Servant (FromHttpApiData (..), ToHttpApiData (..))\nimport Text.ParserCombinators.Parsec\n\n-- | Implementation of HTTP Signature authorization based on\n-- https://tools.ietf.org/id/draft-cavage-http-signatures-12.html\n\n-- | Keys are bytestrings, aliased for readability\n-- | Signatures are bytestrings, aliased for readability\ntype Signature = ByteString\n\n-- | List of supported algorithms, this should grow over time\ndata SignatureAlgorithm\n  = Hs2019\n  | Ed25519\n  deriving (Eq, Show)\n\ntype Hash = Hash.Digest Hash.Blake2b_512\n\nhashFromByteString :: ByteString -> Maybe Hash\nhashFromByteString = Hash.digestFromByteString\n\nbodyHashHeader :: HeaderName\nbodyHashHeader = \"Beckn-Body-Hash\"\n\nbecknSignatureHash :: ByteString -> Hash\nbecknSignatureHash = Hash.hash\n\ndefaultHeaderFields :: [Text]\ndefaultHeaderFields = [\"(created)\", \"(expires)\", \"digest\"]\n\nencodeAlg :: SignatureAlgorithm -> Text\nencodeAlg Hs2019 = \"hs2019\"\nencodeAlg Ed25519 = \"ed25519\"\n\ndecodeAlg :: String -> Maybe SignatureAlgorithm\ndecodeAlg \"hs2019\" = Just Hs2019\ndecodeAlg \"ed25519\" = Just Ed25519\ndecodeAlg _ = Nothing\n\ndata KeyId = KeyId\n  { subscriberId :: Text,\n    uniqueKeyId :: Text,\n    alg :: SignatureAlgorithm\n  }\n  deriving (Show, Eq, Generic)\n\nencodeKeyId :: KeyId -> Text\nencodeKeyId KeyId {..} = subscriberId <> \"|\" <> uniqueKeyId <> \"|\" <> encodeAlg alg\n\ndecodeKeyId :: Text -> Either String KeyId\ndecodeKeyId input =\n  case Text.splitOn \"|\" input of\n    [subscriberId, uniqueKeyId, rAlg] -> do\n      alg <- maybeToRight \"INVALID_ALG\" . decodeAlg . Text.unpack $ rAlg\n      pure KeyId {..}\n    _ -> Left \"INVALID_KEY_ID\"\n\n-- | Signature parameters as per the specification\ndata SignatureParams = SignatureParams\n  { -- | The key Id that should be used to to generate/verify the signature\n    keyId :: KeyId,\n    -- | The signature algorithm to use\n    algorithm :: SignatureAlgorithm,\n    -- | Ordered list of headers to sign along with the request body\n    headers :: [Text],\n    -- | Optional signature creation date/time (as UNIX time)\n    created :: Maybe POSIXTime,\n    -- | Optional signature expiration date/time (as UNIX time)\n    expires :: Maybe POSIXTime\n  }\n  deriving (Eq, Show, Generic)\n\nmkSignatureParams :: Text -> Text -> POSIXTime -> Seconds -> SignatureAlgorithm -> SignatureParams\nmkSignatureParams shortOrgId uniqueKeyId now validity alg =\n  SignatureParams\n    { keyId =\n        KeyId\n          { subscriberId = shortOrgId,\n            uniqueKeyId = uniqueKeyId,\n            alg = alg\n          },\n      algorithm = alg,\n      headers = defaultHeaderFields,\n      created = Just now,\n      expires = Just $ now + (fromInteger . fromIntegral $ getSeconds validity)\n    }\n\n-- | Signature payload representation that carries signature and it's params\ndata SignaturePayload = SignaturePayload\n  { signature :: Signature,\n    params :: SignatureParams\n  }\n  deriving (Show, Eq, Generic)\n\ninstance ToHttpApiData SignaturePayload where\n  toQueryParam = decodeUtf8 . encode\n\ninstance FromHttpApiData SignaturePayload where\n  parseQueryParam = first show <$> decode . encodeUtf8\n\n-- | Decode the contents of a signature header to a signature and corresponding params\ndecode :: ByteString -> Either String SignaturePayload\ndecode val = do\n  values <-\n    first show $\n      parse signatureHeader \"\" val\n  sig <-\n    Base64.decode\n      =<< (maybeToRight \"no valid signature\" . fmap fromString . lookup \"signature\") values\n  key <-\n    join . maybeToRight \"no keyId\" $ decodeKeyId . Text.pack <$> lookup \"keyId\" values\n  alg <-\n    maybeToRight \"no algorithm\" $\n      decodeAlg =<< lookup \"algorithm\" values\n  unless (checkAlg alg key) $ Left \"Algorithm is invalid\"\n  hdrs <-\n    maybeToRight \"no headers\" $\n      T.splitOn \" \" . fromString <$> lookup \"headers\" values\n  -- FIXME: these will silently fail\n  let crt = fromInteger <$> (readMaybe =<< lookup \"created\" values)\n  let expi = fromInteger <$> (readMaybe =<< lookup \"expires\" values)\n  return $ SignaturePayload sig (SignatureParams key alg hdrs crt expi)\n  where\n    checkAlg algo KeyId {..} = algo == alg\n    signatureHeader = do\n      string \"Signature\" *> spaces\n      keyValues `sepBy` (char ',' *> spaces)\n    keyValues = do\n      key <- many1 letter\n      spaces *> char '=' *> spaces\n      value <-\n        choice\n          [ many1 digit,\n            quoted $ many1 $ satisfy (/= '\"')\n          ]\n      return (key, value)\n    quoted = between (char '\"') (char '\"')\n\n-- | Encode a signature and corresponding params to a value that can be packed\n-- into the appropriate HTTP header\nencode :: SignaturePayload -> ByteString\nencode SignaturePayload {..} =\n  \"Signature \"\n    <> \"keyId=\\\"\"\n    <> encodeUtf8 (encodeKeyId $ keyId params)\n    <> \"\\\",\"\n    <> \"algorithm=\\\"\"\n    <> encodeUtf8 (encodeAlg $ algorithm params)\n    <> \"\\\",\"\n    <> maybeTime \"created\" (created params)\n    <> maybeTime \"expires\" (expires params)\n    <> \"headers=\\\"\"\n    <> (encodeUtf8 . T.toLower . T.intercalate \" \" . headers) params\n    <> \"\\\",\"\n    <> \"signature=\\\"\"\n    <> Base64.encode signature\n    <> \"\\\"\"\n  where\n    maybeTime h (Just v) = fromString $ h <> \"=\\\"\" <> formatTime defaultTimeLocale \"%s\" v <> \"\\\",\"\n    maybeTime _ Nothing = \"\"\n\nmakeSignatureString :: SignatureParams -> Hash -> [Header] -> ByteString\nmakeSignatureString params bodyHash allHeaders =\n  let signHeaders =\n        catMaybes $\n          fmap makeHeaderLine . findHeader <$> headers params\n   in BS.intercalate \"\\n\" signHeaders\n  where\n    makeHeaderLine (header, value) =\n      (encodeUtf8 . T.toLower $ header) <> \": \" <> value\n\n    findHeader :: Text -> Maybe (Text, ByteString)\n    findHeader h =\n      let alg = algorithm params\n       in (h,) . bsStrip\n            <$> case h of\n              \"(created)\" | alg == Hs2019 || alg == Ed25519 -> (show :: Int -> ByteString) . floor <$> created params\n              \"(expires)\" | alg == Hs2019 || alg == Ed25519 -> (show :: Int -> ByteString) . floor <$> expires params\n              \"(created)\" -> Nothing -- FIXME: this should error out\n              \"(expires)\" -> Nothing -- FIXME: this should error out\n              \"digest\" -> pure $ \"BLAKE-512=\" <> Base64.encode (BA.convert bodyHash)\n              _ ->\n                -- Find all instances of this header, concatenate values separated by a comma\n                let ciHeader = CI.mk $ encodeUtf8 h\n                 in bsToMaybe\n                      . BS.intercalate \", \"\n                      $ snd <$> filter (\\h' -> fst h' == ciHeader) allHeaders\n\n    bsStrip = encodeUtf8 . T.strip . decodeUtf8\n    bsToMaybe b = if null b then Nothing else Just b\n\n-- | Sign a request given the key, parameters and request headers\nsign :: PrivateKey -> SignatureParams -> Hash -> [Header] -> Maybe Signature\nsign (Base64 key) params bodyHash allHeaders =\n  let msg = makeSignatureString params bodyHash allHeaders\n      sk = Ed25519.secretKey key\n      pk = Ed25519.toPublic <$> sk\n      signature = Ed25519.sign <$> sk <*> pk <*> pure msg\n   in Crypto.maybeCryptoError $ BA.convert <$> signature\n\nverify :: PublicKey -> SignatureParams -> Hash -> [Header] -> Signature -> Either Crypto.CryptoError Bool\nverify (Base64 key) params bodyHash allHeaders signatureBs =\n  let msg = makeSignatureString params bodyHash allHeaders\n      pk = Ed25519.publicKey key\n      signature = Ed25519.signature signatureBs\n   in Crypto.eitherCryptoError $ Ed25519.verify <$> pk <*> pure msg <*> signature\n\nmkSignatureRealm :: Text -> Text -> Header\nmkSignatureRealm headerName host =\n  ( CI.mk $ encodeUtf8 headerName,\n    \"Signature realm=\\\"\" <> encodeUtf8 host <> \"\\\",headers=\\\"\" <> encodeUtf8 (unwords defaultHeaderFields) <> \"\\\"\"\n  )\n\n-- Generates random public/private key pair for Ed25519 alg\ngenerateKeyPair :: IO (PrivateKey, PublicKey)\ngenerateKeyPair = do\n  secretKey <- Ed25519.generateSecretKey\n  let publicKey = Ed25519.toPublic secretKey\n  pure (Base64 . BS.pack . BA.unpack $ secretKey, Base64 . BS.pack . BA.unpack $ publicKey)\n",
      "hash": "5714634c0823d349ebde75021f42a1653f540c62e8b0240d6e0f32a722cc6d0f",
      "size": 9777
    },
    "/lib/mobility-core/src/Kernel/Utils/SlidingWindowCounters.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n\nmodule Kernel.Utils.SlidingWindowCounters\n  ( incrementWindowCount,\n    incrementByValue,\n    incrementByValueInTimeBucket,\n    decrementWindowCount,\n    getkeysForLastPeriods,\n    makeSWKeyForTime,\n    getCurrentWindowValuesUptoLast,\n    getLatestRatio,\n    getCurrentWindowCount,\n    getCurrentWindowValues,\n    makeSlidingWindowKey,\n    splitOnPeriodGranuality,\n    incrementPeriod,\n    convertPeriodTypeToSeconds,\n    deleteCurrentWindowValues,\n  )\nwhere\n\nimport qualified Control.Monad.Extra as CME\nimport qualified Data.Text as T\nimport Data.Time\nimport qualified EulerHS.Language as L\nimport EulerHS.Prelude hiding (id)\nimport qualified Kernel.Storage.Hedis as Redis\nimport Kernel.Types.SlidingWindowCounters\n\n-- ========================== Helper functions ==========================\n\nsplitOnPeriodGranuality :: PeriodType -> TimePair -> [TimePair]\nsplitOnPeriodGranuality periodType (startTime, endTime)\n  | startTime > endTime = []\n  | otherwise = go startTime (incrementPeriod periodType startTime)\n  where\n    go lastTime newTime\n      | newTime < endTime = (lastTime, newTime) : go newTime (incrementPeriod periodType newTime)\n      | otherwise = [(lastTime, endTime)]\n\n-- | incrementPeriod :: PeriodType -> timeStamp -> nextRoumdedupTime\n--  this function gives the rounded up time for the given timestamp\n--  based on the periodType.\n--  example : executing >> incrementPeriod Hours \"02:14 PM\"\n--            gives you >> 03:00 PM\n--  How it works ?\n--   we get the number of seconds as integer that have been passed\n--   in the given day. Then based on the period type, we divide that\n--   by the unit of seconds in that periodType. i.e. 60 sec for a minute.\n--   which gives us a quotient, and incrementing the quotient by 1 and\n--   then multuplying by the unit seconds in period type you get the\n--   next rounded up timestamp (seconds passed since midnight).\n--\n--   example -> >> timestamp = 11:40 AM , periodType = Hours\n--              >> secondPassedSinceMidNight (sp) = 42000\n--              >> unitTimeInPeriodType = 3600 (seconds in an hour)\n--              >> 42000 / 3600 = 11\n--              >> 3600 * 12 = 43200 (which equals 12:00 PM)\n--   ( other implemtations details can be seen in code, like adding days when\n--     number of seconds exceed the total seconds a day can have etc.)\nincrementPeriod :: PeriodType -> UTCTime -> UTCTime\nincrementPeriod periodType (UTCTime date time) = do\n  let secs = diffTimeToPicoseconds time `div` (10 ^ (12 :: Integer))\n      secInPeriod = convertPeriodTypeToSeconds periodType\n      quotient = secs `div` secInPeriod\n      newTime' = secInPeriod * (quotient + 1)\n      res\n        | periodType `elem` [Minutes, Hours, Days] =\n          if newTime' >= 86400 -- number of secongs in a day\n            then (addDays (newTime' `div` 86400) date, 0)\n            else (date, fromIntegral newTime')\n        | periodType == Months = do\n          let (year, month, _) = toGregorian date\n              newMonth' = month + 1\n              (newYear, newMonth) = if newMonth' > 12 then (year + 1, 1) else (year, newMonth')\n              newDate = fromGregorian newYear newMonth 1\n          (newDate, 0)\n        | otherwise = do\n          let (year, _, _) = toGregorian date\n              newDate = fromGregorian (year + 1) 1 1\n          (newDate, 0)\n  uncurry UTCTime res\n\nmakeCachingLockKey :: Text -> Text\nmakeCachingLockKey key = (\"SW-CACHE-FOR-\" <> key)\n\nmakeSlidingWindowKey :: PeriodType -> Text -> UTCTime -> Text\nmakeSlidingWindowKey pt k = (<> \"-sliding-window\") . makeTimeBasedKey pt k\n\nmakeQuickAccessWindowCountKey :: Text -> Text\nmakeQuickAccessWindowCountKey = (<> \"-sliding-window-result\")\n\nmakeTimeBasedKey :: PeriodType -> Text -> UTCTime -> Text\nmakeTimeBasedKey periodType oldKey = do\n  (\\periodString -> oldKey <> \"-\" <> periodString)\n    . T.pack\n    . formatTime\n      defaultTimeLocale\n      ( case periodType of\n          Minutes -> \"%Y-%m-%d-%H-%M\"\n          Hours -> \"%Y-%m-%d-%H\"\n          Days -> \"%Y-%m-%d\"\n          Months -> \"%Y-%m\"\n          Years -> \"%Y\"\n      )\n\n-- gives time in second\nconvertPeriodTypeToSeconds :: PeriodType -> Integer\nconvertPeriodTypeToSeconds periodType =\n  case periodType of\n    Minutes -> 60\n    Hours -> 60 * 60\n    Days -> 60 * 60 * 24\n    Months -> 31 * 60 * 60 * 24\n    Years -> 365 * 31 * 60 * 60 * 24\n\ngetkeysForLastPeriods :: SlidingWindowOptions -> UTCTime -> (UTCTime -> Text) -> [Text]\ngetkeysForLastPeriods swo utcTime keyModifier = map (makeSWKeyForTime swo utcTime keyModifier) [0 .. swo.period - 1]\n\ngetkeysUptoThisPeriod :: SlidingWindowOptions -> UTCTime -> (UTCTime -> Text) -> Integer -> [Text]\ngetkeysUptoThisPeriod swo utcTime keyModifier uptoPeriod = map (makeSWKeyForTime swo utcTime keyModifier) [0 .. uptoPeriod - 1]\n\nmakeSWKeyForTime :: SlidingWindowOptions -> UTCTime -> (UTCTime -> Text) -> Integer -> Text\nmakeSWKeyForTime SlidingWindowOptions {..} utcTime keyModifier periodMagnitude =\n  keyModifier\n    . flip addUTCTime utcTime\n    . fromInteger\n    $ getTimeUnit\n  where\n    getTimeUnit :: Integer\n    getTimeUnit = -1 * periodMagnitude * convertPeriodTypeToSeconds periodType\n\n-- ========================== Sliding Window Counters ==========================\n\nincrementWindowCount ::\n  ( L.MonadFlow m,\n    Redis.HedisFlow m r\n  ) =>\n  Text ->\n  SlidingWindowOptions ->\n  m ()\nincrementWindowCount = incrementCounter makeSWKeyForTime makeQuickAccessWindowCountKey makeSlidingWindowKey\n\nincrementByValue ::\n  ( L.MonadFlow m,\n    Redis.HedisFlow m r\n  ) =>\n  Integer ->\n  Text ->\n  SlidingWindowOptions ->\n  m ()\nincrementByValue val = incrementByValueImpl Nothing val makeSWKeyForTime makeQuickAccessWindowCountKey makeSlidingWindowKey\n\nincrementByValueInTimeBucket ::\n  ( L.MonadFlow m,\n    Redis.HedisFlow m r\n  ) =>\n  UTCTime ->\n  Integer ->\n  Text ->\n  SlidingWindowOptions ->\n  m ()\nincrementByValueInTimeBucket utcTime val = incrementByValueImpl (Just utcTime) val makeSWKeyForTime makeQuickAccessWindowCountKey makeSlidingWindowKey\n\nincrementCounter ::\n  ( L.MonadFlow m,\n    Redis.HedisFlow m r\n  ) =>\n  (SlidingWindowOptions -> UTCTime -> (UTCTime -> Text) -> Integer -> Text) ->\n  (Text -> Text) ->\n  (PeriodType -> Text -> UTCTime -> Text) ->\n  Text ->\n  SlidingWindowOptions ->\n  m ()\nincrementCounter = incrementByValueImpl Nothing 1\n\nincrementByValueImpl ::\n  ( L.MonadFlow m,\n    Redis.HedisFlow m r\n  ) =>\n  Maybe UTCTime ->\n  Integer ->\n  (SlidingWindowOptions -> UTCTime -> (UTCTime -> Text) -> Integer -> Text) ->\n  (Text -> Text) ->\n  (PeriodType -> Text -> UTCTime -> Text) ->\n  Text ->\n  SlidingWindowOptions ->\n  m ()\nincrementByValueImpl mbTimeStamp val getOutOfWindowKey getStoredResultKey getWindowKey key swo@SlidingWindowOptions {..} = do\n  now <- L.runIO getCurrentTime\n  let utcTime = fromMaybe now mbTimeStamp\n      finalKey = getWindowKey periodType key utcTime\n  Redis.whenWithLockRedis (makeCachingLockKey key) 10 . void $ cacheTheCounts now val getOutOfWindowKey getStoredResultKey getWindowKey key swo\n  let expirationTime = (period + 1) * convertPeriodTypeToSeconds periodType\n  void $ Redis.incrby finalKey val\n  Redis.expire finalKey $ fromIntegral expirationTime\n\ndecrementWindowCount ::\n  ( L.MonadFlow m,\n    Redis.HedisFlow m r\n  ) =>\n  Text ->\n  SlidingWindowOptions ->\n  m ()\ndecrementWindowCount = decrementCounter makeSWKeyForTime makeQuickAccessWindowCountKey makeSlidingWindowKey\n\ndecrementCounter ::\n  ( L.MonadFlow m,\n    Redis.HedisFlow m r\n  ) =>\n  (SlidingWindowOptions -> UTCTime -> (UTCTime -> Text) -> Integer -> Text) ->\n  (Text -> Text) ->\n  (PeriodType -> Text -> UTCTime -> Text) ->\n  Text ->\n  SlidingWindowOptions ->\n  m ()\ndecrementCounter = decrementByValueImpl Nothing 1\n\ndecrementByValueImpl ::\n  ( L.MonadFlow m,\n    Redis.HedisFlow m r\n  ) =>\n  Maybe UTCTime ->\n  Integer ->\n  (SlidingWindowOptions -> UTCTime -> (UTCTime -> Text) -> Integer -> Text) ->\n  (Text -> Text) ->\n  (PeriodType -> Text -> UTCTime -> Text) ->\n  Text ->\n  SlidingWindowOptions ->\n  m ()\ndecrementByValueImpl mbTimeStamp val getOutOfWindowKey getStoredResultKey getWindowKey key swo@SlidingWindowOptions {..} = do\n  now <- L.runIO getCurrentTime\n  let utcTime = fromMaybe now mbTimeStamp\n      finalKey = getWindowKey periodType key utcTime\n  Redis.whenWithLockRedis (makeCachingLockKey key) 10 . void $ cacheTheCounts now val getOutOfWindowKey getStoredResultKey getWindowKey key swo\n  let expirationTime = (period + 1) * convertPeriodTypeToSeconds periodType\n  void $ Redis.decrby finalKey val\n  Redis.expire finalKey $ fromIntegral expirationTime\n\n-- the cached value would stay correct for current and current + 1 peroid in any given periodType so keeping the expiry as end of (current + 1) periodType from now\ncacheTheCounts ::\n  ( L.MonadFlow m,\n    Redis.HedisFlow m r\n  ) =>\n  UTCTime ->\n  Integer ->\n  (SlidingWindowOptions -> UTCTime -> (UTCTime -> Text) -> Integer -> Text) ->\n  (Text -> Text) ->\n  (PeriodType -> Text -> UTCTime -> Text) ->\n  Text ->\n  SlidingWindowOptions ->\n  m Integer\ncacheTheCounts now val getOutOfWindowKey getStoredResultKey getWindowKey key swo@SlidingWindowOptions {..} = do\n  let storedResultKey = getStoredResultKey key\n  mbOldStoredResult <- Redis.get storedResultKey\n  (updatedValueToStore, shouldRecache) <-\n    case mbOldStoredResult of\n      Just oldStoredResult -> do\n        let noLongerPartOfWindowKey = getOutOfWindowKey swo now (getWindowKey periodType key) period\n        mbValToRemoveFromWindow <- Redis.get noLongerPartOfWindowKey\n        let finalValToRemoveFromWindow =\n              case mbValToRemoveFromWindow of\n                Just valToRemoveFromWindow | valToRemoveFromWindow > 0 -> valToRemoveFromWindow\n                _ -> 0\n            newStoreValue = max 0 $ oldStoredResult + val - finalValToRemoveFromWindow\n        whenJust mbValToRemoveFromWindow $ \\_ -> Redis.del noLongerPartOfWindowKey\n        if newStoreValue == oldStoredResult\n          then pure (newStoreValue, False)\n          else pure (newStoreValue, True)\n      Nothing -> (,True) . (+ val) . sum . catMaybes <$> getCurrentWindowValues key swo\n  bool\n    (pure updatedValueToStore)\n    ( do\n        let storedResultExpTime = fromInteger $ floor (diffUTCTime (incrementPeriod periodType now) now) + (convertPeriodTypeToSeconds periodType)\n        void $ Redis.setExp storedResultKey updatedValueToStore storedResultExpTime\n        pure updatedValueToStore\n    )\n    shouldRecache\n\n-- ================= Getter functions for fetching window results during first calculation ======================\n\n-- Logic :\n--  get last n (n=period) postivie and total counts from redis, add them up and simply divide them\n--  How it works ?\n--    SlidingWindowOptions = {period = 3, periodType = Days}\n--\n--           day 1 counts | day 2 counts | day 3 counts | day 4 counts | now counts\n--                                       | -------------------------------------- |\n--                                        counts.TIMEBASED_KEY_FOR_POSITIVE_CASE\n--                            result =  ___________________________________________\n--                                       counts.TIMEBASED_KEY_FOR_THE_TOTAL_CASES\n--\n--           day 1 counts | day 2 counts | day 3 counts | now counts\n--                        | -------------------------------------- |\n--                          counts.TIMEBASED_KEY_FOR_POSITIVE_CASE\n--              result =  ___________________________________________\n--                          counts.TIMEBASED_KEY_FOR_THE_TOTAL_CASES\n--\n--    ** counts = {<TIMEBASED_KEY_FOR_POSITIVE_CASE>: positiveCases , <TIMEBASED_KEY_FOR_THE_TOTAL_CASES>: totalCases}\n\n-- | getLatestRatio :: (id to getResult for, and generate TIMEBASED_KEY_FOR_THE_TOTAL_CASES) -> (id modifier to create TIMEBASED_KEY_FOR_POSITIVE_CASE) -> Resultsant Ratio of the sliding window\n-- Minutes | Hours | Days | Months | Years\ngetCountsFromCache :: (L.MonadFlow m, Redis.HedisFlow m r) => Text -> m (Maybe Integer)\ngetCountsFromCache key = do\n  let storesResultKey = makeQuickAccessWindowCountKey key\n  Redis.get storesResultKey\n\ncacheAndGetNumDeno ::\n  ( L.MonadFlow m,\n    Redis.HedisFlow m r\n  ) =>\n  UTCTime ->\n  Text ->\n  (Text -> Text) ->\n  (Text -> Text) ->\n  SlidingWindowOptions ->\n  m (Integer, Integer)\ncacheAndGetNumDeno now driverId mkPostiveCaseKeyfn mkTotalCaseKeyfn swo = do\n  let totalCaseKey = mkTotalCaseKeyfn driverId\n      positiveCaseKey = mkPostiveCaseKeyfn driverId\n  totalCases <- cacheTheCounts now 0 makeSWKeyForTime makeQuickAccessWindowCountKey makeSlidingWindowKey totalCaseKey swo\n  positiveCases <- cacheTheCounts now 0 makeSWKeyForTime makeQuickAccessWindowCountKey makeSlidingWindowKey positiveCaseKey swo\n  pure (positiveCases, totalCases)\n\ngetLatestRatio ::\n  ( L.MonadFlow m,\n    Redis.HedisFlow m r\n  ) =>\n  Text ->\n  (Text -> Text) ->\n  (Text -> Text) ->\n  SlidingWindowOptions ->\n  m Double\ngetLatestRatio driverId mkPostiveCaseKeyfn mkTotalCaseKeyfn slidingWindowOptions = do\n  now <- L.runIO getCurrentTime\n  (positiveCases, totalCases) <-\n    CME.fromMaybeM\n      (cacheAndGetNumDeno now driverId mkPostiveCaseKeyfn mkTotalCaseKeyfn slidingWindowOptions)\n      (getNumDenFromCache (mkPostiveCaseKeyfn driverId) (mkTotalCaseKeyfn driverId))\n  return $ fromIntegral positiveCases / fromIntegral (max 1 totalCases)\n\ngetNumDenFromCache :: (L.MonadFlow m, Redis.HedisFlow m r) => Text -> Text -> m (Maybe (Integer, Integer))\ngetNumDenFromCache postiveCaseKey totalCaseKey =\n  runMaybeT $ do\n    positiveCases <- MaybeT $ getCountsFromCache postiveCaseKey\n    totalCases <- MaybeT $ getCountsFromCache totalCaseKey\n    pure (positiveCases, totalCases)\n\ngetCurrentWindowCount ::\n  ( L.MonadFlow m,\n    Redis.HedisFlow m r\n  ) =>\n  Text ->\n  SlidingWindowOptions ->\n  m Integer\ngetCurrentWindowCount key swo = do\n  now <- L.runIO getCurrentTime\n  mbCountFromCache <- getCountsFromCache key\n  case mbCountFromCache of\n    Just count -> pure count\n    Nothing -> Redis.withWaitAndLockRedis (makeCachingLockKey key) 10 20 $ cacheTheCounts now 0 makeSWKeyForTime makeQuickAccessWindowCountKey makeSlidingWindowKey key swo\n\ngetCurrentWindowValuesUptoLast ::\n  ( L.MonadFlow m,\n    Redis.HedisFlow m r,\n    FromJSON a\n  ) =>\n  Integer ->\n  Text ->\n  SlidingWindowOptions ->\n  m [Maybe a]\ngetCurrentWindowValuesUptoLast nPeriod key swo = do\n  utcTime <- L.runIO getCurrentTime\n  let keysToFetch = getkeysUptoThisPeriod swo utcTime (makeSlidingWindowKey (periodType swo) key) nPeriod\n  mapM Redis.get keysToFetch\n\ngetCurrentWindowValues ::\n  ( L.MonadFlow m,\n    Redis.HedisFlow m r,\n    FromJSON a\n  ) =>\n  Text ->\n  SlidingWindowOptions ->\n  m [Maybe a]\ngetCurrentWindowValues key swo = do\n  utcTime <- L.runIO getCurrentTime\n  let keysToFetch = getkeysForLastPeriods swo utcTime $ makeSlidingWindowKey (periodType swo) key\n  mapM Redis.get keysToFetch\n\ndeleteCurrentWindowValues ::\n  ( L.MonadFlow m,\n    Redis.HedisFlow m r\n  ) =>\n  Text ->\n  SlidingWindowOptions ->\n  m ()\ndeleteCurrentWindowValues key swo = do\n  utcTime <- L.runIO getCurrentTime\n  let keysToDel = getkeysForLastPeriods swo utcTime $ makeSlidingWindowKey (periodType swo) key\n  mapM_ Redis.del keysToDel\n",
      "hash": "4abc3c9adc38fa459276e133b4fc4cc90197e412e6ae2f49266506db0ffa3143",
      "size": 15812
    },
    "/lib/mobility-core/src/Kernel/Utils/SlidingWindowLimiter.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n\nmodule Kernel.Utils.SlidingWindowLimiter where\n\nimport Data.Time hiding (getCurrentTime)\nimport Data.Time.Clock.POSIX (utcTimeToPOSIXSeconds)\nimport EulerHS.Prelude hiding (id)\nimport GHC.Records.Extra\nimport qualified Kernel.Storage.Hedis as Redis\nimport Kernel.Types.Common as Common\nimport Kernel.Types.Error\nimport Kernel.Types.SlidingWindowLimiter\nimport Kernel.Utils.Common hiding (nominalDiffTimeToSeconds)\n\ncheckSlidingWindowLimit ::\n  ( Redis.HedisFlow m r,\n    HasFlowEnv m r '[\"apiRateLimitOptions\" ::: APIRateLimitOptions]\n  ) =>\n  Text ->\n  m ()\ncheckSlidingWindowLimit key = do\n  limitOptions <- asks (.apiRateLimitOptions)\n  checkSlidingWindowLimitWithOptions key limitOptions\n\ncheckSlidingWindowLimitWithOptions ::\n  ( Redis.HedisFlow m r,\n    MonadTime m\n  ) =>\n  Text ->\n  APIRateLimitOptions ->\n  m ()\ncheckSlidingWindowLimitWithOptions key APIRateLimitOptions {..} = do\n  unlessM (slidingWindowLimiter key limit limitResetTimeInSec) $\n    throwError $ HitsLimitError limitResetTimeInSec\n\n-- Sliding window rate limiter.\n-- Returns True if limit is not exceed and further\n-- actions should be allowed. False otherwise.\n\nslidingWindowLimiter :: (Redis.HedisFlow m r, MonadTime m) => Text -> Int -> Int -> m Bool\nslidingWindowLimiter key frameHitsLim frameLen = do\n  currTime <- getCurrentTime\n  hits <- fromMaybe [] <$> Redis.get key\n  let (filtHits, ret) = slidingWindowLimiterPure currTime hits frameHitsLim frameLen\n  when ret $ Redis.setExp key filtHits frameLen\n  return ret\n\nslidingWindowLimiterPure :: UTCTime -> [Integer] -> Int -> Int -> ([Integer], Bool)\nslidingWindowLimiterPure currTime hits frameHitsLim frameLen = do\n  -- How it works:\n  -- We convert UTCTime value to Integer and `div` it by frameLen to\n  -- get its frame number. After that we getting list with\n  -- timeFrames from redis and getting number of calls within\n  -- current and previous frame. Getting prevFrameWeight\n  -- (timePassedSinceCurrFrameStart/frameLen == 1 >= n >= 0) and\n  -- doing check (prevFrameHitsLen * prevFrameWeight + currFrameHitsLen < frameHitsLim).\n  -- If passed - add currFrame to frames list, save it in redis and return True. False otherwise.\n  let currFrame = getTimeFrame currTime\n      filtHits = filter (hitsFilter currFrame) hits\n      prevFrameHitsLen = length $ filter (prevFrameHitsFilter currFrame) filtHits\n      prevFrameWeight = 1 - (fromIntegral (getTimeWithinFrame currTime) :: Double) / frameLen'\n      currFrameHitsLen = length $ filter (currFrameHitsFilter currFrame) filtHits\n      res = floor (fromIntegral prevFrameHitsLen * prevFrameWeight) + currFrameHitsLen < frameHitsLim\n  (if res then currFrame : filtHits else filtHits, res)\n  where\n    frameLen' :: Num a => a\n    frameLen' = fromIntegral frameLen\n    getTimeFrame time = getTime time `div` frameLen'\n    getTimeWithinFrame time = getTime time `mod` frameLen'\n    getTime :: UTCTime -> Integer\n    getTime = floor . nominalDiffTimeToSeconds . utcTimeToPOSIXSeconds\n    hitsFilter currFrame timeFrame = (timeFrame == currFrame - 1) || (timeFrame == currFrame)\n    prevFrameHitsFilter currFrame timeFrame = timeFrame == currFrame - 1\n    currFrameHitsFilter currFrame timeFrame = timeFrame == currFrame\n",
      "hash": "cd949d9944e4f41ad2c11fa9b45b9c5fb7287edd397f705860b8b27c66ddd861",
      "size": 3897
    },
    "/lib/mobility-core/src/Kernel/Utils/TH.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n{-# LANGUAGE DerivingStrategies #-}\n{-# LANGUAGE GeneralizedNewtypeDeriving #-}\n{-# LANGUAGE QuasiQuotes #-}\n{-# LANGUAGE StandaloneDeriving #-}\n{-# LANGUAGE TemplateHaskell #-}\n\nmodule Kernel.Utils.TH where\n\nimport qualified Data.Bifunctor as BF\nimport qualified Data.ByteString.Lazy as BSL\nimport Data.OpenApi (ToSchema)\nimport qualified Data.Text as T\nimport qualified Data.Text.Encoding as DT\nimport EulerHS.Prelude\nimport qualified Language.Haskell.TH as TH\nimport Servant (FromHttpApiData (..), ToHttpApiData (..))\n\n-- | A set of instances common for all identifier newtypes.\nderiveIdentifierInstances :: TH.Name -> TH.Q [TH.Dec]\nderiveIdentifierInstances name = do\n  let tyQ = pure (TH.ConT name)\n  [d|\n    deriving stock instance Eq $tyQ\n\n    deriving stock instance Ord $tyQ\n\n    deriving newtype instance ToJSON $tyQ\n\n    deriving newtype instance FromJSON $tyQ\n\n    deriving newtype instance ToHttpApiData $tyQ\n\n    deriving newtype instance FromHttpApiData $tyQ\n\n    deriving newtype instance ToSchema $tyQ\n    |]\n\nmkHttpInstancesForEnum :: TH.Name -> TH.Q [TH.Dec]\nmkHttpInstancesForEnum name = do\n  fromInstance <- mkFromHttpInstanceForEnum name\n  toInstance <- mkToHttpInstanceForEnum name\n  pure $ fromInstance <> toInstance\n\nmkFromHttpInstanceForEnum :: TH.Name -> TH.Q [TH.Dec]\nmkFromHttpInstanceForEnum name = do\n  let tyQ = pure (TH.ConT name)\n  [d|\n    instance FromHttpApiData $tyQ where\n      parseUrlPiece = parseHeader . DT.encodeUtf8\n      parseQueryParam = parseUrlPiece\n      parseHeader = BF.first T.pack . eitherDecode . BSL.fromStrict\n    |]\n\nmkToHttpInstanceForEnum :: TH.Name -> TH.Q [TH.Dec]\nmkToHttpInstanceForEnum name = do\n  let tyQ = pure (TH.ConT name)\n  [d|\n    instance ToHttpApiData $tyQ where\n      toUrlPiece = DT.decodeUtf8 . toHeader\n      toQueryParam = toUrlPiece\n      toHeader = BSL.toStrict . encode\n    |]\n",
      "hash": "58a00cf20f590bd940ec5774abcd05ed97b463a28791053b2809745c9a2fc202",
      "size": 2551
    },
    "/lib/mobility-core/src/Kernel/Utils/Text.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n\nmodule Kernel.Utils.Text where\n\nimport qualified Data.Aeson as A\nimport qualified Data.ByteString.Lazy as BSL\nimport qualified Data.Char as Char\nimport qualified Data.Text as T\nimport qualified Data.Text.Encoding as DT\nimport EulerHS.Prelude\n\ncompareWithoutRightSpaces :: Text -> Text -> Bool\ncompareWithoutRightSpaces = (==) `on` T.dropWhileEnd Char.isSpace\n\ndecodeFromText :: FromJSON a => Text -> Maybe a\ndecodeFromText = A.decode . BSL.fromStrict . DT.encodeUtf8\n\ndecodeFromText' :: FromJSON a => Maybe Text -> Maybe a\ndecodeFromText' = maybe Nothing decodeFromText\n\nencodeToText :: ToJSON a => a -> Text\nencodeToText = DT.decodeUtf8 . BSL.toStrict . A.encode\n\npadLeft :: Int -> Char -> Text -> Text\npadLeft n c txt = T.replicate (max 0 $ n - length txt) (T.singleton c) <> txt\n\n-- Suits only for non-negative numbers\npadNumber :: Integral i => Int -> i -> Text\npadNumber n num = padLeft n '0' $ show (fromIntegral num :: Natural)\n\nrecursiveStrip :: String -> String\nrecursiveStrip = \\case\n  ('_' : xs) -> recursiveStrip xs\n  a -> a\n\nmaskText :: Text -> Text\nmaskText text =\n  if length text > 6\n    then T.take 3 text <> \"...\" <> T.takeEnd 3 text\n    else \"...\"\n\ntruncateText :: Text -> Text\ntruncateText text =\n  if length text > 100000 -- TODO: Change this to mutually decided value\n    then T.take 100 text <> \"...\"\n    else text\n\ncamelCaseToSnakeCase :: Text -> Text\ncamelCaseToSnakeCase =\n  T.concatMap \\c ->\n    if Char.isUpper c then T.pack ['_', Char.toLower c] else T.singleton c\n\nvalidateAllDigitWithMinLength :: Int -> Text -> Bool\nvalidateAllDigitWithMinLength minLength str = validateLength && validateAllDigits (T.unpack str)\n  where\n    validateLength = T.length str >= minLength\n    validateAllDigits (x : xs) = fromEnum x <= 57 && fromEnum x >= 48 && validateAllDigits xs\n    validateAllDigits [] = True\n\nvalidateAlphaNumericWithLength :: Text -> Int -> Bool\nvalidateAlphaNumericWithLength str minLength = validateLength && validateAlphaNumeric (T.unpack str)\n  where\n    validateLength = T.length str == minLength\n    validateAlphaNumeric (x : xs) = (fromEnum x <= 57 && fromEnum x >= 48) || (fromEnum x <= 90 && fromEnum x >= 65) || (fromEnum x <= 122 && fromEnum x >= 97) && validateAlphaNumeric xs\n    validateAlphaNumeric [] = True\n",
      "hash": "9016b23abb650afe4fceb86105fac06a26ab71186202d21c56fcbbcc20da07e9",
      "size": 2953
    },
    "/lib/mobility-core/src/Kernel/Utils/Time.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n\nmodule Kernel.Utils.Time\n  ( module Kernel.Utils.Time,\n    module Kernel.Types.Time,\n    UTCTime,\n    addUTCTime,\n    diffUTCTime,\n  )\nwhere\n\nimport qualified Data.Text as T\nimport Data.Time hiding (getCurrentTime, nominalDiffTimeToSeconds, secondsToNominalDiffTime)\nimport qualified Data.Time as Time hiding (secondsToNominalDiffTime)\nimport Data.Time.Clock.POSIX (posixSecondsToUTCTime, utcTimeToPOSIXSeconds)\nimport Data.Time.Clock.System\nimport EulerHS.Prelude\nimport Kernel.Types.Time\nimport Kernel.Utils.Logging\nimport System.Clock (toNanoSecs)\n\nisExpired :: MonadTime m => NominalDiffTime -> UTCTime -> m Bool\nisExpired nominal time = do\n  now <- getCurrentTime\n  let addedUTCTime = addUTCTime nominal time\n  return $ now > addedUTCTime\n\ngetLocalCurrentTime :: MonadTime m => Seconds -> m UTCTime\ngetLocalCurrentTime timeDiff = addUTCTime (secondsToNominalDiffTime timeDiff) <$> getCurrentTime\n\n-- | Format time in IST and return it as text\n-- Converts and Formats in the format\n-- TODO: make a generic function and then pass format\n-- and timezone as arguments. Currently adds +5:30\nshowTimeIst :: UTCTime -> Text\nshowTimeIst time =\n  T.pack $\n    formatTime defaultTimeLocale \"%d %b, %I:%M %p\" $\n      addUTCTime (60 * 330) time\n\ngetClockTimeInMs :: MonadClock m => m Milliseconds\ngetClockTimeInMs = Milliseconds . fromInteger . (`div` 1000000) . toNanoSecs <$> getClockTime\n\nmeasureDuration :: MonadClock m => m a -> m (a, Milliseconds)\nmeasureDuration f = do\n  start <- getClockTimeInMs\n  res <- f\n  end <- getClockTimeInMs\n  return (res, end - start)\n\nmeasuringDuration :: (Milliseconds -> a -> m ()) -> MeasuringDuration m a\nmeasuringDuration doWithDuration f = do\n  (res, dur) <- measureDuration f\n  doWithDuration dur res\n  return res\n\nmeasuringDurationToLog :: Log m => LogLevel -> Text -> MeasuringDuration m a\nmeasuringDurationToLog logLevel fname = tabs . measuringDuration $ \\duration _ ->\n  withLogTag \"duration\"\n    . logOutput logLevel\n    $ fname <> \" took \" <> show duration <> \" milliseconds\"\n  where\n    -- debugging feature, use only in dev\n    -- tabs = (withLogTag \"  \" .)\n    tabs = id\n\nmillisecondsToMicroseconds :: Milliseconds -> Microseconds\nmillisecondsToMicroseconds (Milliseconds mill) = Microseconds $ mill * 1000\n\nsecondsToMinutes :: Seconds -> Minutes\nsecondsToMinutes (Seconds secs) = Minutes $ secs `div` 60\n\nsecondsToMcs :: Seconds -> Microseconds\nsecondsToMcs (Seconds s) = Microseconds (s * 1000000)\n\nsecondsToMillis :: Seconds -> Milliseconds\nsecondsToMillis (Seconds s) = Milliseconds (s * 1000)\n\nsecondsToNominalDiffTime :: Seconds -> NominalDiffTime\nsecondsToNominalDiffTime = millisToNominalDiffTime . secondsToMillis\n\nnominalDiffTimeToSeconds :: NominalDiffTime -> Seconds\nnominalDiffTimeToSeconds = round . Time.nominalDiffTimeToSeconds\n\nmillisToSecondsDouble :: Milliseconds -> Double\nmillisToSecondsDouble (Milliseconds ms) = fromIntegral ms / 1000\n\nmillisToNominalDiffTime :: Milliseconds -> NominalDiffTime\nmillisToNominalDiffTime = realToFrac @Double @NominalDiffTime . millisToSecondsDouble\n\nthreadDelayMilliSec :: (MonadIO m) => Milliseconds -> m ()\nthreadDelayMilliSec milli = liftIO $ threadDelay $ milli.getMilliseconds * 1000\n\nthreadDelaySec :: (MonadIO m) => Seconds -> m ()\nthreadDelaySec sec = liftIO $ threadDelay $ sec.getSeconds * 1000000\n\nsecondsFromTimeOfDay :: TimeOfDay -> Seconds\nsecondsFromTimeOfDay timeOfDay =\n  Seconds . fromIntegral $ (diffTimeToPicoseconds $ timeOfDayToTime timeOfDay) `div` 1000000000000\n\ncompareTimeWithInterval :: NominalDiffTime -> UTCTime -> UTCTime -> Ordering\ncompareTimeWithInterval dt time1 time2\n  | abs (diffUTCTime time1 time2) < abs dt = EQ\n  | time1 < time2 = LT\n  | otherwise = GT -- time1 > time2\n\nutcToMilliseconds :: UTCTime -> Double\nutcToMilliseconds utcTime = fromIntegral $ div (systemSeconds systemTime * 1000000000 + fromIntegral (systemNanoseconds systemTime)) 1000000\n  where\n    systemTime = utcToSystemTime utcTime\n\nmillisecondsToUTC :: Integer -> UTCTime\nmillisecondsToUTC ms = posixSecondsToUTCTime (fromIntegral ms / 1000)\n\nparseISO8601UTC :: String -> Maybe UTCTime\nparseISO8601UTC = parseTimeM True defaultTimeLocale \"%Y-%m-%dT%H:%M:%SZ\"\n\ngetCurrentTimestamp :: (Monad m, MonadTime m) => m Double\ngetCurrentTimestamp = do\n  utcToMilliseconds <$> getCurrentTime\n\nsecondsToTimeOfDay :: Seconds -> TimeOfDay\nsecondsToTimeOfDay (Seconds s) =\n  TimeOfDay hours minutes seconds\n  where\n    (hours, remainingSeconds) = s `divMod` 3600\n    (minutes, seconds') = remainingSeconds `divMod` 60\n    seconds = fromIntegral seconds'\n\nisTimeWithinBounds :: Time.TimeOfDay -> Time.TimeOfDay -> Time.TimeOfDay -> Bool\nisTimeWithinBounds startTime endTime time =\n  if startTime >= endTime\n    then do\n      let midnightBeforeTimeleap = TimeOfDay 23 59 60\n      (startTime < time && time < midnightBeforeTimeleap) || (midnight <= time && time < endTime)\n    else startTime < time && time < endTime\n\nutcTimeToDiffTime :: UTCTime -> DiffTime\nutcTimeToDiffTime = timeOfDayToTime . localTimeOfDay . zonedTimeToLocalTime . utcToZonedTime utc\n\nutcTimeToText :: UTCTime -> Text\nutcTimeToText = T.pack . formatTime defaultTimeLocale \"%FT%T%z\"\n\nutcToEpochSeconds :: UTCTime -> Seconds\nutcToEpochSeconds = nominalDiffTimeToSeconds . utcTimeToPOSIXSeconds\n",
      "hash": "b139e62e8fb9eef6814d79ef7302a867015cd97aaea5e3ad031b42c07f93d7aa",
      "size": 5951
    },
    "/lib/mobility-core/src/Kernel/Utils/Validation.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n{-# LANGUAGE TemplateHaskell #-}\n\nmodule Kernel.Utils.Validation\n  ( module Kernel.Utils.Validation,\n    module Kernel.Types.Validation,\n  )\nwhere\n\nimport Control.Lens ((%~))\nimport qualified Data.Either.Validation as V\nimport Data.Generics.Labels ()\nimport EulerHS.Prelude hiding (pred, (%~))\nimport Kernel.Types.Error.BaseError.HTTPError\nimport Kernel.Types.Logging\nimport Kernel.Types.Predicate\nimport Kernel.Types.Validation\nimport Kernel.Utils.Error.Throwing\n\nnewtype RequestValidationFailure = RequestValidationFailure [ValidationDescription]\n  deriving (Show, IsBaseError, IsBecknAPIError)\n\ninstance IsHTTPError RequestValidationFailure where\n  toErrorCode (RequestValidationFailure _failures) = \"REQUEST_VALIDATION_FAILURE\"\n  toHttpCode (RequestValidationFailure _failures) = E400\n\ninstance IsAPIError RequestValidationFailure where\n  toPayload (RequestValidationFailure failures) = toJSON failures\n\ninstanceExceptionWithParent 'HTTPException ''RequestValidationFailure\n\nrunRequestValidation ::\n  (MonadThrow m, Log m) =>\n  Validate obj ->\n  obj ->\n  m ()\nrunRequestValidation validator obj =\n  V.validationToEither (validator obj)\n    & fromEitherM RequestValidationFailure\n\nvalidateField ::\n  (Predicate a p, ShowablePredicate p) =>\n  Text ->\n  a ->\n  p ->\n  Validation\nvalidateField fieldName fieldValue pred =\n  unless (pFun pred fieldValue) . V.Failure $ [validationDescription]\n  where\n    validationDescription =\n      ValidationDescription\n        { fieldName = [fieldName],\n          expectation = pShow pred fieldName\n        }\n\nvalidateObject ::\n  Text ->\n  a ->\n  Validate a ->\n  Validation\nvalidateObject fieldName object validator = addPrefixes fieldName $ validator object\n\nvalidateList ::\n  Container a =>\n  Text ->\n  a ->\n  Validate (Element a) ->\n  Validation\nvalidateList fieldName list validator =\n  traverse_ f (zip (map (\\i -> fieldName <> \"[\" <> show i <> \"]\") [0 :: Int ..]) $ toList list)\n  where\n    f (pref, val) = addPrefixes pref $ validator val\n\naddPrefixes :: Text -> Validation -> Validation\naddPrefixes fieldName = first $ map (addPrefixToFieldName fieldName)\n\naddPrefixToFieldName ::\n  Text ->\n  ValidationDescription ->\n  ValidationDescription\naddPrefixToFieldName prefix = #fieldName %~ (prefix :)\n",
      "hash": "e8e328b97d92adf898e0a52fa9264d5bc268ab2e93acb53573bb52f6690a96f4",
      "size": 2935
    },
    "/lib/mobility-core/src/Kernel/Utils/Version.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n{-# LANGUAGE AllowAmbiguousTypes #-}\n{-# OPTIONS_GHC -Wwarn=incomplete-uni-patterns #-}\n\nmodule Kernel.Utils.Version (Reexport.versionToText, readVersion, textToVersionDefault, getDeviceFromText, mkClientDevice) where\n\nimport Data.Text hiding (reverse)\nimport qualified Data.Text as T\nimport Kernel.Prelude as Prelude\nimport Kernel.Types.Logging\nimport Kernel.Types.Version as Reexport\nimport Prelude (id)\n\nreadVersion :: (MonadThrow m, Log m) => Text -> m Version\nreadVersion versionText =\n  case textToVersion versionText of\n    Right version -> return version\n    _ -> pure $ zeroVersion\n\nzeroVersion :: Version\nzeroVersion = Version {major = 0, minor = 0, maintenance = 0, preRelease = Nothing, build = Nothing}\n\nhighVersion :: Version\nhighVersion =\n  Version\n    { major = 9999,\n      minor = 9999,\n      maintenance = 9999,\n      preRelease = Nothing,\n      build = Nothing\n    }\n\ntextToVersionDefault :: Text -> Version\ntextToVersionDefault = either (const highVersion) id . textToVersion\n\ngetDeviceFromText :: Maybe Text -> Maybe Device\ngetDeviceFromText deviceText = do\n  text <- deviceText\n  let deviceInfo = T.splitOn \"/\" text\n  case deviceInfo of\n    _ : deviceModel : version' : xs -> do\n      let mbManufacturer = getManufacturer xs\n      let [deviceTypeStr, deviceVersion] = T.splitOn \" v\" version'\n      deviceType <- case T.toLower deviceTypeStr of\n        \"android\" -> Just ANDROID\n        \"ios\" -> Just IOS\n        _ -> Nothing\n      return Device {deviceType = deviceType, deviceVersion = deviceVersion, deviceModel = deviceModel, deviceManufacturer = mbManufacturer}\n    _ -> Nothing\n\nmkClientDevice :: Maybe DeviceType -> Maybe Text -> Maybe Text -> Maybe Text -> Maybe Device\nmkClientDevice clientOsType clientOsVersion clientModel clientManufacturer =\n  Device <$> clientOsType <*> clientOsVersion <*> clientModel <*> pure clientManufacturer\n\ngetManufacturer :: [Text] -> Maybe Text\ngetManufacturer xs = do\n  manufacturer' <- listToMaybe (reverse xs)\n  let parts = T.splitOn \":\" manufacturer' -- expecting manufacturer at the end of deviceText\n  case parts of\n    (\"mf\" : manufacturer : _) -> Just manufacturer\n    _ -> Nothing\n",
      "hash": "ddb5281617aa2cd846ff8ced56d1a37c9251032dd9fd119c652889236afd9e62",
      "size": 2845
    },
    "/lib/mobility-core/src/Kernel/Utils/XML.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n\nmodule Kernel.Utils.XML where\n\nimport Data.Aeson\nimport Kernel.Prelude\nimport Xmlbf\n\nnewtype XmlText = XmlText Text\n  deriving (Generic, Eq, Show, FromJSON, ToJSON, ToSchema)\n\ninstance ToXml XmlText where\n  toXml (XmlText txt) = text txt\n",
      "hash": "99c7c8982c1ebfe9d250fa05f0565d069089a2769df697d86a07efc35b29b1df",
      "size": 932
    },
    "/lib/mobility-core/test/app/Main.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n\nmodule Main where\n\nimport APIExceptions\nimport Centesimal\nimport ComputeIntersectionTests\nimport DistanceCalculation\nimport EulerHS.Prelude\nimport SignatureAuth\nimport SlidingWindowLimiter\nimport SnippetsCheck (snippetsCheckTests)\nimport Test.Tasty\nimport Version\n\nmain :: IO ()\nmain = defaultMain =<< specs\n\nspecs :: IO TestTree\nspecs = return $ testGroup \"Tests\" [unitTests]\n  where\n    unitTests =\n      testGroup\n        \"Unit tests\"\n        [ computeIntersectionTests,\n          centesimalTests,\n          signatureAuthTests,\n          httpExceptionTests,\n          slidingWindowLimiterTests,\n          distanceCalculation,\n          readVersionTests,\n          snippetsCheckTests\n        ]\n",
      "hash": "a8d661236354b52a0255cc880d59bb7605eb3142653e13bea9a239830731dce3",
      "size": 1390
    },
    "/lib/mobility-core/test/src/APIExceptions.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n{-# LANGUAGE AllowAmbiguousTypes #-}\n{-# LANGUAGE ScopedTypeVariables #-}\n{-# LANGUAGE TemplateHaskell #-}\n{-# OPTIONS_GHC -Wno-orphans #-}\n\nmodule APIExceptions (httpExceptionTests) where\n\nimport Control.Arrow (left)\nimport qualified Data.Aeson as A\nimport Data.Maybe (fromJust)\nimport EulerHS.Prelude\nimport Kernel.Tools.Metrics.CoreMetrics\nimport qualified Kernel.Tools.Metrics.CoreMetrics as Metrics\nimport Kernel.Types.Error.BaseError.HTTPError\nimport Kernel.Utils.Error.FlowHandling\nimport qualified Servant as S\nimport Test.Hspec\nimport Test.Tasty\nimport Test.Tasty.HUnit\nimport TestSilentIOLogger ()\n\ndata SomeAPIError = SomeAPIError deriving (Show)\n\ninstance IsBaseError SomeAPIError\n\ninstance IsHTTPError SomeAPIError where\n  toErrorCode SomeAPIError = \"SOME_API_ERROR\"\n\ninstance IsAPIError SomeAPIError\n\ninstance IsBecknAPIError SomeAPIError\n\ninstanceExceptionWithParent 'HTTPException ''SomeAPIError\n\ndata SomeBecknAPIError = SomeBecknAPIError deriving (Show)\n\ninstance IsBaseError SomeBecknAPIError\n\ninstance IsHTTPError SomeBecknAPIError where\n  toErrorCode SomeBecknAPIError = \"SOME_BECKN_API_ERROR\"\n\ninstance IsAPIError SomeBecknAPIError\n\ninstance IsBecknAPIError SomeBecknAPIError where\n  toType SomeBecknAPIError = INTERNAL_ERROR\n\ninstanceExceptionWithParent 'HTTPException ''SomeBecknAPIError\n\ninstance Metrics.CoreMetrics IO where\n  addRequestLatency _ _ _ _ = return ()\n  addDatastoreLatency _ _ _ = return ()\n  incrementErrorCounter _ _ = return ()\n  addUrlCallRetries _ _ = return ()\n  addUrlCallRetryFailures _ = return ()\n  incrementSortedSetCounter _ = return ()\n  incrementStreamCounter _ = return ()\n  addGenericLatency _ _ = return ()\n  incrementSchedulerFailureCounter _ = return ()\n  incrementGenericMetrics _ = return ()\n  incrementSystemConfigsFailedCounter _ = return ()\n  addGenericLatencyMetrics _ _ = return ()\n\nhttpExceptionTests :: TestTree\nhttpExceptionTests =\n  testGroup\n    \"Endpoint exception catchers tests\"\n    [ testGroup\n        \"Throwing any error in our endpoints must return HTTPError\"\n        [ apiErrorInEndpoint,\n          becknApiErrorInEndpoint,\n          someErrorInEndpoint\n        ],\n      testGroup\n        \"Throwing any error in Beckn endpoints must return BecknAPIError\"\n        [ apiErrorInBecknEndpoint,\n          becknApiErrorInBecknEndpoint,\n          someErrorInBecknEndpoint\n        ]\n    ]\n\napiErrorInEndpoint :: TestTree\napiErrorInEndpoint =\n  testCase \"Throwing some Domain error\" $\n    mustThrow @APIError $ apiHandler (throwM SomeAPIError)\n\nbecknApiErrorInEndpoint :: TestTree\nbecknApiErrorInEndpoint =\n  testCase \"Throwing some Beckn API error\" $\n    mustThrow @APIError $ apiHandler (throwM SomeBecknAPIError)\n\nsomeErrorInEndpoint :: TestTree\nsomeErrorInEndpoint =\n  testCase \"Throwing SomeException\" $\n    mustThrow @APIError $ apiHandler (error \"Some error\")\n\napiErrorInBecknEndpoint :: TestTree\napiErrorInBecknEndpoint =\n  testCase \"Throwing some Domain error\" $\n    mustThrow @BecknAPIError $ becknApiHandler (throwM SomeAPIError)\n\nbecknApiErrorInBecknEndpoint :: TestTree\nbecknApiErrorInBecknEndpoint =\n  testCase \"Throwing some Beckn API error\" $\n    mustThrow @BecknAPIError $ becknApiHandler (throwM SomeBecknAPIError)\n\nsomeErrorInBecknEndpoint :: TestTree\nsomeErrorInBecknEndpoint =\n  testCase \"Throwing SomeException\" $\n    mustThrow @BecknAPIError $ becknApiHandler (error \"Some error\")\n\nmustThrow :: forall (e :: Type). (Show e, FromJSON e) => IO () -> IO ()\nmustThrow flow = try flow >>= (`shouldSatisfy` isLeft) . serverErrorTo @e\n\nserverErrorTo :: FromJSON a => Either S.ServerError () -> Either a ()\nserverErrorTo = left (fromJust . A.decode . S.errBody)\n",
      "hash": "97610ef03b610f3910fb944fdabd809779cfcf62519a63f21c7ee6b7a9488745",
      "size": 4339
    },
    "/lib/mobility-core/test/src/Centesimal.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n\nmodule Centesimal where\n\nimport Data.Aeson\nimport EulerHS.Prelude\nimport Kernel.Types.Centesimal (Centesimal (..))\nimport Test.Tasty\nimport Test.Tasty.HUnit\n\njsonParsing :: TestTree\njsonParsing = testCase \"Parsing JSON with 2 digits precision\" $ do\n  let result = fromJSON (Number 1.25) :: Result Centesimal\n  case result of\n    Error err -> assertFailure $ \"Parsing of \\\"1.25\\\" should succeed, but encountered error: \" <> err\n    Success x -> x @?= 1.25\n\njsonParsingWithZeros :: TestTree\njsonParsingWithZeros = testCase \"Parsing JSON with trailing zeros (1.250000)\" $ do\n  let result = fromJSON (Number 1.250000) :: Result Centesimal\n  case result of\n    Error err -> assertFailure $ \"Parsing of \\\"1.250000\\\" should succeed, but encountered error: \" <> err\n    Success x -> x @?= 1.25\n\njsonParsingRoundingUp :: TestTree\njsonParsingRoundingUp = testCase \"Parsing JSON with rounding to upper (1.259999 should be 1.26)\" $ do\n  let result = fromJSON (Number 1.259999) :: Result Centesimal\n  case result of\n    Error err -> assertFailure $ \"Parsing of \\\"1.259999\\\" should succeed, but encountered error: \" <> err\n    Success x -> x @?= 1.26\n\njsonParsingRoundingDown :: TestTree\njsonParsingRoundingDown = testCase \"Parsing JSON with rounding to lower (1.251111 should be 1.25)\" $ do\n  let result = fromJSON (Number 1.251111) :: Result Centesimal\n  case result of\n    Error err -> assertFailure $ \"Parsing of \\\"1.251111\\\" should succeed, but encountered error: \" <> err\n    Success x -> x @?= 1.25\n\njsonParsingNegativeRoundingUp :: TestTree\njsonParsingNegativeRoundingUp = testCase \"Parsing JSON with rounding to upper (-1.251111 should be -1.25)\" $ do\n  let result = fromJSON (Number (negate 1.251111)) :: Result Centesimal\n  case result of\n    Error err -> assertFailure $ \"Parsing of \\\"-1.251111\\\" should succeed, but encountered error: \" <> err\n    Success x -> x @?= -1.25\n\njsonParsingNegativeRoundingDown :: TestTree\njsonParsingNegativeRoundingDown = testCase \"Parsing JSON with rounding to lower (-1.259999 should be -1.26)\" $ do\n  let result = fromJSON (Number (negate 1.259999)) :: Result Centesimal\n  case result of\n    Error err -> assertFailure $ \"Parsing of \\\"-1.259999\\\" should succeed, but encountered error: \" <> err\n    Success x -> x @?= -1.26\n\njsonParsingRoundingUpFiveHundredth :: TestTree\njsonParsingRoundingUpFiveHundredth = testCase \"Parsing JSON with rounding to upper having five hundredth (1.255 should be 1.26)\" $ do\n  let result = fromJSON (Number 1.255) :: Result Centesimal\n  case result of\n    Error err -> assertFailure $ \"Parsing of \\\"1.255\\\" should succeed, but encountered error: \" <> err\n    Success x -> x @?= 1.26\n\njsonParsingNegativeRoundingDownFiveHundredth :: TestTree\njsonParsingNegativeRoundingDownFiveHundredth = testCase \"Parsing JSON with rounding to upper having five hundredth (-1.255 should be -1.26)\" $ do\n  let result = fromJSON (Number (-1.255)) :: Result Centesimal\n  case result of\n    Error err -> assertFailure $ \"Parsing of \\\"1.255\\\" should succeed, but encountered error: \" <> err\n    Success x -> x @?= (-1.26)\n\nconvertingFromDouble :: TestTree\nconvertingFromDouble = testCase \"Converting from Double\" $ do\n  let result :: Centesimal = realToFrac (-1.25 :: Double)\n  result @?= -1.25\n\nconvertingFromDoubleWithZeros :: TestTree\nconvertingFromDoubleWithZeros = testCase \"Converting from Double with trailing zeros (-1.250000)\" $ do\n  let result :: Centesimal = realToFrac (-1.250000 :: Double)\n  result @?= -1.25\n\nconvertingFromDoubleRoundingUp :: TestTree\nconvertingFromDoubleRoundingUp = testCase \"Converting from Double with rounding to upper (1.2599999 should be 1.26)\" $ do\n  let result :: Centesimal = realToFrac (1.2599999 :: Double)\n  result @?= 1.26\n\nconvertingFromDoubleRoundingDown :: TestTree\nconvertingFromDoubleRoundingDown = testCase \"Converting from Double with rounding to lower (1.251 should be 1.25)\" $ do\n  let result :: Centesimal = realToFrac (1.251 :: Double)\n  result @?= 1.25\n\nconvertingFromDoubleRoundingUpFiveHundredth :: TestTree\nconvertingFromDoubleRoundingUpFiveHundredth = testCase \"Converting from Double with rounding to upper having five hundredth (1.255 should be 1.26)\" $ do\n  let result :: Centesimal = realToFrac (1.255 :: Double)\n  result @?= 1.26\n\nconvertingFromDoubleRoundingDownFiveHundredthNegative :: TestTree\nconvertingFromDoubleRoundingDownFiveHundredthNegative = testCase \"Converting from Double with rounding to upper having five hundredth negative (-1.255 should be -1.26)\" $ do\n  let result :: Centesimal = realToFrac ((-1.255) :: Double)\n  result @?= (-1.26)\n\ncentesimalTests :: TestTree\ncentesimalTests =\n  testGroup\n    \"Centi tests\"\n    [ jsonParsing,\n      jsonParsingWithZeros,\n      jsonParsingRoundingUp,\n      jsonParsingRoundingDown,\n      jsonParsingNegativeRoundingUp,\n      jsonParsingNegativeRoundingDown,\n      jsonParsingRoundingUpFiveHundredth,\n      jsonParsingNegativeRoundingDownFiveHundredth,\n      convertingFromDouble,\n      convertingFromDoubleWithZeros,\n      convertingFromDoubleRoundingUp,\n      convertingFromDoubleRoundingDown,\n      convertingFromDoubleRoundingUpFiveHundredth,\n      convertingFromDoubleRoundingDownFiveHundredthNegative\n    ]\n",
      "hash": "3b35c055ac51d08fd7fcfb9d81b1ef3c983d1b60e4f2edaa33a9cf8d0074472f",
      "size": 5869
    },
    "/lib/mobility-core/test/src/ComputeIntersectionTests.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n\nmodule ComputeIntersectionTests (computeIntersectionTests) where\n\nimport Kernel.External.Maps.Types\nimport Kernel.Prelude\nimport Kernel.Utils.ComputeIntersection\nimport Test.Tasty\nimport Test.Tasty.HUnit\n\nroute :: RoutePoints\nroute =\n  [ LatLong 13.01111 77.58381,\n    LatLong 13.01165 77.58384,\n    LatLong 13.01194 77.58386,\n    LatLong 13.01204 77.58387,\n    LatLong 13.01223 77.58388,\n    LatLong 13.0126 77.5839,\n    LatLong 13.01342 77.58392,\n    LatLong 13.01376 77.58392,\n    LatLong 13.01393 77.58392,\n    LatLong 13.01424 77.58392,\n    LatLong 13.0145 77.58393,\n    LatLong 13.01458 77.58393,\n    LatLong 13.01479 77.58394,\n    LatLong 13.01532 77.58396,\n    LatLong 13.01567 77.58396,\n    LatLong 13.01605 77.58396,\n    LatLong 13.01628 77.58395,\n    LatLong 13.01672 77.58393,\n    LatLong 13.018 77.58388,\n    LatLong 13.01819 77.58388,\n    LatLong 13.01867 77.58387,\n    LatLong 13.01919 77.58385,\n    LatLong 13.0192 77.58385,\n    LatLong 13.01956 77.58386,\n    LatLong 13.01988 77.58386,\n    LatLong 13.01989 77.58386,\n    LatLong 13.0202 77.58389,\n    LatLong 13.02034 77.5839,\n    LatLong 13.02047 77.58391,\n    LatLong 13.02054 77.58392,\n    LatLong 13.0206 77.58394,\n    LatLong 13.02067 77.58396,\n    LatLong 13.02075 77.58398,\n    LatLong 13.02077 77.58398,\n    LatLong 13.02094 77.58403,\n    LatLong 13.02154 77.58419,\n    LatLong 13.0219 77.5843,\n    LatLong 13.02221 77.58437,\n    LatLong 13.02261 77.58447,\n    LatLong 13.02286 77.58452,\n    LatLong 13.02308 77.58455,\n    LatLong 13.02325 77.58458,\n    LatLong 13.0235 77.58465,\n    LatLong 13.02364 77.58468,\n    LatLong 13.02366 77.58468,\n    LatLong 13.02372 77.5847,\n    LatLong 13.0238 77.58472,\n    LatLong 13.02388 77.58474,\n    LatLong 13.02419 77.58483,\n    LatLong 13.02451 77.58492,\n    LatLong 13.02487 77.58502,\n    LatLong 13.02523 77.58512,\n    LatLong 13.02552 77.58518,\n    LatLong 13.02567 77.58521,\n    LatLong 13.02612 77.58531,\n    LatLong 13.02639 77.58537,\n    LatLong 13.02662 77.58543,\n    LatLong 13.02693 77.58552,\n    LatLong 13.02696 77.58553,\n    LatLong 13.02701 77.58554,\n    LatLong 13.02706 77.58556,\n    LatLong 13.02711 77.58557,\n    LatLong 13.02724 77.58561,\n    LatLong 13.02738 77.58565,\n    LatLong 13.0279 77.58583,\n    LatLong 13.02796 77.58585,\n    LatLong 13.02802 77.58587,\n    LatLong 13.02808 77.5859,\n    LatLong 13.02836 77.58601,\n    LatLong 13.02855 77.58609,\n    LatLong 13.02889 77.58625,\n    LatLong 13.02922 77.58639,\n    LatLong 13.02934 77.58643,\n    LatLong 13.03017 77.58677,\n    LatLong 13.03076 77.58702,\n    LatLong 13.03132 77.58726,\n    LatLong 13.03189 77.58752,\n    LatLong 13.03239 77.58777,\n    LatLong 13.03242 77.58778,\n    LatLong 13.03247 77.58781,\n    LatLong 13.03256 77.58785,\n    LatLong 13.03297 77.58803,\n    LatLong 13.03311 77.58809,\n    LatLong 13.03324 77.58813,\n    LatLong 13.03339 77.58817,\n    LatLong 13.03361 77.58822,\n    LatLong 13.03389 77.58827,\n    LatLong 13.03408 77.58831,\n    LatLong 13.03429 77.58835,\n    LatLong 13.03447 77.5884,\n    LatLong 13.03457 77.58842,\n    LatLong 13.03468 77.58846,\n    LatLong 13.03473 77.58847,\n    LatLong 13.03476 77.58849,\n    LatLong 13.03512 77.58862,\n    LatLong 13.0354 77.58873,\n    LatLong 13.036 77.58899,\n    LatLong 13.03601 77.58899,\n    LatLong 13.03612 77.58905,\n    LatLong 13.03632 77.58914,\n    LatLong 13.0365 77.58917,\n    LatLong 13.03673 77.58917,\n    LatLong 13.03686 77.58917,\n    LatLong 13.03721 77.58918,\n    LatLong 13.03758 77.5892,\n    LatLong 13.03807 77.58922,\n    LatLong 13.03829 77.58925,\n    LatLong 13.03848 77.58927,\n    LatLong 13.03857 77.58928,\n    LatLong 13.03866 77.58929,\n    LatLong 13.0388 77.58931,\n    LatLong 13.0392 77.58939,\n    LatLong 13.03929 77.5894,\n    LatLong 13.03937 77.58942,\n    LatLong 13.03986 77.58951,\n    LatLong 13.04 77.58953,\n    LatLong 13.04054 77.58963,\n    LatLong 13.04071 77.58967,\n    LatLong 13.041 77.58976,\n    LatLong 13.04122 77.58984,\n    LatLong 13.04135 77.58988,\n    LatLong 13.04153 77.58993,\n    LatLong 13.04157 77.58994,\n    LatLong 13.04168 77.58997,\n    LatLong 13.04176 77.58999,\n    LatLong 13.04184 77.59001,\n    LatLong 13.0419 77.59003,\n    LatLong 13.04207 77.59008,\n    LatLong 13.04245 77.59019,\n    LatLong 13.04256 77.59023,\n    LatLong 13.04262 77.59025,\n    LatLong 13.04298 77.5904,\n    LatLong 13.0432 77.5905,\n    LatLong 13.04321 77.59051,\n    LatLong 13.04347 77.59064,\n    LatLong 13.04362 77.59072,\n    LatLong 13.04366 77.59073,\n    LatLong 13.04372 77.59076,\n    LatLong 13.04419 77.59095,\n    LatLong 13.04441 77.59103,\n    LatLong 13.04487 77.59115,\n    LatLong 13.04519 77.59121,\n    LatLong 13.04568 77.59127,\n    LatLong 13.04598 77.59131,\n    LatLong 13.04623 77.59135,\n    LatLong 13.04629 77.59136,\n    LatLong 13.0463 77.59136,\n    LatLong 13.04648 77.59141,\n    LatLong 13.04663 77.59146,\n    LatLong 13.04687 77.59153,\n    LatLong 13.04711 77.59162,\n    LatLong 13.04756 77.59185,\n    LatLong 13.04786 77.59199,\n    LatLong 13.048 77.59205,\n    LatLong 13.0482 77.59215,\n    LatLong 13.04853 77.59232,\n    LatLong 13.04886 77.59247,\n    LatLong 13.04912 77.59257,\n    LatLong 13.04933 77.59264,\n    LatLong 13.04948 77.59268,\n    LatLong 13.04996 77.59279,\n    LatLong 13.0513 77.59311,\n    LatLong 13.0518 77.59324,\n    LatLong 13.05209 77.59332,\n    LatLong 13.05233 77.59338,\n    LatLong 13.05251 77.59342,\n    LatLong 13.05264 77.59345,\n    LatLong 13.05279 77.59346,\n    LatLong 13.05293 77.59348,\n    LatLong 13.05306 77.5935,\n    LatLong 13.05317 77.5935,\n    LatLong 13.05332 77.59349,\n    LatLong 13.05346 77.59348,\n    LatLong 13.0537 77.59346,\n    LatLong 13.05377 77.59345,\n    LatLong 13.05392 77.59344,\n    LatLong 13.05458 77.59342,\n    LatLong 13.05488 77.59341,\n    LatLong 13.0557 77.59337,\n    LatLong 13.05572 77.59337,\n    LatLong 13.05641 77.59338,\n    LatLong 13.05716 77.59341,\n    LatLong 13.05731 77.59341,\n    LatLong 13.05759 77.59342,\n    LatLong 13.05804 77.59344,\n    LatLong 13.05874 77.59345,\n    LatLong 13.06002 77.59347,\n    LatLong 13.06013 77.59346,\n    LatLong 13.06029 77.59346,\n    LatLong 13.06059 77.59346,\n    LatLong 13.06185 77.5934,\n    LatLong 13.06325 77.59331,\n    LatLong 13.06368 77.59329,\n    LatLong 13.06422 77.59327,\n    LatLong 13.06436 77.59326,\n    LatLong 13.06448 77.59326,\n    LatLong 13.06524 77.59321,\n    LatLong 13.06566 77.59319,\n    LatLong 13.0661 77.59317,\n    LatLong 13.06658 77.59314,\n    LatLong 13.06693 77.59311,\n    LatLong 13.06712 77.59308,\n    LatLong 13.06729 77.59306,\n    LatLong 13.06744 77.59305,\n    LatLong 13.06891 77.59293,\n    LatLong 13.07004 77.59285,\n    LatLong 13.07047 77.59282,\n    LatLong 13.07066 77.59281,\n    LatLong 13.07219 77.59271,\n    LatLong 13.07335 77.59264,\n    LatLong 13.0734 77.59263,\n    LatLong 13.07348 77.59263,\n    LatLong 13.07364 77.59262,\n    LatLong 13.0739 77.59261,\n    LatLong 13.07438 77.59262,\n    LatLong 13.0748 77.59262,\n    LatLong 13.07508 77.59263,\n    LatLong 13.07531 77.59264,\n    LatLong 13.07584 77.59268,\n    LatLong 13.07622 77.59272,\n    LatLong 13.0769 77.59277,\n    LatLong 13.08015 77.59307,\n    LatLong 13.08104 77.59314,\n    LatLong 13.08122 77.59316,\n    LatLong 13.08139 77.59318,\n    LatLong 13.08146 77.59318,\n    LatLong 13.08167 77.5932,\n    LatLong 13.08185 77.59322,\n    LatLong 13.08201 77.59325,\n    LatLong 13.08215 77.59327,\n    LatLong 13.08228 77.5933,\n    LatLong 13.0825 77.59335,\n    LatLong 13.08266 77.59339,\n    LatLong 13.08281 77.59343,\n    LatLong 13.08306 77.59351,\n    LatLong 13.08322 77.59357,\n    LatLong 13.08345 77.59365,\n    LatLong 13.08369 77.59374,\n    LatLong 13.08442 77.59404,\n    LatLong 13.08543 77.59442,\n    LatLong 13.0858 77.59457,\n    LatLong 13.08621 77.59473,\n    LatLong 13.08718 77.59516,\n    LatLong 13.08736 77.59524,\n    LatLong 13.08759 77.59534,\n    LatLong 13.08775 77.59541,\n    LatLong 13.08796 77.59551,\n    LatLong 13.08813 77.59558,\n    LatLong 13.08834 77.59568,\n    LatLong 13.08851 77.59575,\n    LatLong 13.08872 77.59583,\n    LatLong 13.0891 77.59599,\n    LatLong 13.08939 77.59611,\n    LatLong 13.08965 77.59623,\n    LatLong 13.08991 77.59633,\n    LatLong 13.09018 77.59642,\n    LatLong 13.09055 77.59653,\n    LatLong 13.09064 77.59655,\n    LatLong 13.0907 77.59657,\n    LatLong 13.0908 77.59659,\n    LatLong 13.09125 77.59669,\n    LatLong 13.09167 77.59678,\n    LatLong 13.09245 77.59693,\n    LatLong 13.09284 77.59702,\n    LatLong 13.09295 77.59704,\n    LatLong 13.09305 77.59707,\n    LatLong 13.09355 77.59719,\n    LatLong 13.0937 77.59722,\n    LatLong 13.09394 77.59728,\n    LatLong 13.0942 77.59734,\n    LatLong 13.09487 77.59754,\n    LatLong 13.095 77.59759,\n    LatLong 13.09534 77.59772,\n    LatLong 13.09584 77.59792,\n    LatLong 13.09599 77.59799,\n    LatLong 13.09611 77.59804,\n    LatLong 13.09621 77.59808,\n    LatLong 13.09644 77.59817,\n    LatLong 13.09665 77.59825,\n    LatLong 13.09676 77.59829,\n    LatLong 13.09685 77.59833,\n    LatLong 13.09698 77.59838,\n    LatLong 13.09709 77.59843,\n    LatLong 13.09723 77.59848,\n    LatLong 13.0974 77.59855,\n    LatLong 13.0977 77.59867,\n    LatLong 13.09792 77.59875,\n    LatLong 13.09815 77.59884,\n    LatLong 13.09874 77.59902,\n    LatLong 13.09938 77.5992,\n    LatLong 13.10005 77.59938,\n    LatLong 13.10119 77.5997,\n    LatLong 13.10149 77.59978,\n    LatLong 13.10166 77.59982,\n    LatLong 13.10176 77.59985,\n    LatLong 13.10181 77.59986,\n    LatLong 13.10194 77.5999,\n    LatLong 13.10215 77.59995,\n    LatLong 13.10235 77.60001,\n    LatLong 13.10304 77.60019,\n    LatLong 13.10346 77.60032,\n    LatLong 13.10352 77.60033,\n    LatLong 13.10358 77.60036,\n    LatLong 13.10363 77.60037,\n    LatLong 13.10387 77.60046,\n    LatLong 13.1041 77.60054,\n    LatLong 13.10455 77.60072,\n    LatLong 13.10475 77.60081,\n    LatLong 13.10514 77.601,\n    LatLong 13.10535 77.60112,\n    LatLong 13.10561 77.60126,\n    LatLong 13.10617 77.6016,\n    LatLong 13.1065 77.60179,\n    LatLong 13.1075 77.60241,\n    LatLong 13.1078 77.60259,\n    LatLong 13.10932 77.6035,\n    LatLong 13.11019 77.60404,\n    LatLong 13.11084 77.60443,\n    LatLong 13.11122 77.60467,\n    LatLong 13.11136 77.60476,\n    LatLong 13.11146 77.60481,\n    LatLong 13.11283 77.60565,\n    LatLong 13.11304 77.60579,\n    LatLong 13.11373 77.60621,\n    LatLong 13.11396 77.60635,\n    LatLong 13.11418 77.60649,\n    LatLong 13.11425 77.60653,\n    LatLong 13.11478 77.60686,\n    LatLong 13.11506 77.60702,\n    LatLong 13.11538 77.60722,\n    LatLong 13.11627 77.60778,\n    LatLong 13.117 77.60823,\n    LatLong 13.11706 77.60827,\n    LatLong 13.11743 77.60848,\n    LatLong 13.11756 77.60856,\n    LatLong 13.11799 77.60879,\n    LatLong 13.11807 77.60884,\n    LatLong 13.11871 77.60916,\n    LatLong 13.11876 77.60919,\n    LatLong 13.11886 77.60924,\n    LatLong 13.11905 77.60934,\n    LatLong 13.11939 77.60952,\n    LatLong 13.1199 77.60978,\n    LatLong 13.12059 77.61013,\n    LatLong 13.12125 77.61045,\n    LatLong 13.12158 77.6106,\n    LatLong 13.1217 77.61066,\n    LatLong 13.12186 77.61073,\n    LatLong 13.12202 77.61081,\n    LatLong 13.12307 77.61131,\n    LatLong 13.12438 77.61192,\n    LatLong 13.12485 77.61214,\n    LatLong 13.1263 77.61284,\n    LatLong 13.12772 77.61353,\n    LatLong 13.12783 77.61356,\n    LatLong 13.12843 77.61384,\n    LatLong 13.12987 77.61453,\n    LatLong 13.13082 77.61499,\n    LatLong 13.13122 77.61517,\n    LatLong 13.1313 77.61521,\n    LatLong 13.13162 77.61535,\n    LatLong 13.13171 77.6154,\n    LatLong 13.13174 77.61541,\n    LatLong 13.13255 77.61579,\n    LatLong 13.133 77.61601,\n    LatLong 13.13322 77.6161,\n    LatLong 13.13377 77.61636,\n    LatLong 13.13402 77.61648,\n    LatLong 13.13418 77.61656,\n    LatLong 13.13447 77.61669,\n    LatLong 13.13513 77.61698,\n    LatLong 13.13556 77.61716,\n    LatLong 13.13578 77.61725,\n    LatLong 13.13597 77.61731,\n    LatLong 13.13631 77.61741,\n    LatLong 13.13651 77.61745,\n    LatLong 13.13655 77.61747,\n    LatLong 13.13683 77.6175,\n    LatLong 13.13707 77.61751,\n    LatLong 13.13719 77.61752,\n    LatLong 13.13755 77.61751,\n    LatLong 13.13855 77.61749,\n    LatLong 13.13876 77.61748,\n    LatLong 13.1411 77.61742,\n    LatLong 13.14209 77.61739,\n    LatLong 13.14218 77.61739,\n    LatLong 13.14259 77.61739,\n    LatLong 13.14315 77.6174,\n    LatLong 13.14369 77.61743,\n    LatLong 13.14415 77.61747,\n    LatLong 13.14436 77.61749,\n    LatLong 13.14438 77.6175,\n    LatLong 13.14456 77.61751,\n    LatLong 13.1454 77.61762,\n    LatLong 13.14548 77.61762,\n    LatLong 13.14613 77.6177,\n    LatLong 13.14637 77.61774,\n    LatLong 13.14647 77.61776,\n    LatLong 13.14655 77.61777,\n    LatLong 13.14666 77.61778,\n    LatLong 13.14692 77.61783,\n    LatLong 13.14708 77.61787,\n    LatLong 13.14716 77.61789,\n    LatLong 13.14718 77.61789,\n    LatLong 13.1476 77.61804,\n    LatLong 13.14787 77.61816,\n    LatLong 13.14881 77.61865,\n    LatLong 13.15001 77.61927,\n    LatLong 13.1501 77.61932,\n    LatLong 13.15065 77.6196,\n    LatLong 13.15081 77.61968,\n    LatLong 13.15099 77.61976,\n    LatLong 13.15182 77.62019,\n    LatLong 13.1519 77.62023,\n    LatLong 13.15299 77.62082,\n    LatLong 13.15328 77.62098,\n    LatLong 13.1533 77.62099,\n    LatLong 13.15376 77.62128,\n    LatLong 13.15389 77.62136,\n    LatLong 13.15408 77.62148,\n    LatLong 13.15444 77.62172,\n    LatLong 13.15478 77.62195,\n    LatLong 13.15513 77.62218,\n    LatLong 13.15569 77.62256,\n    LatLong 13.15603 77.62279,\n    LatLong 13.15641 77.62305,\n    LatLong 13.15673 77.62328,\n    LatLong 13.15683 77.62335,\n    LatLong 13.15703 77.62351,\n    LatLong 13.15768 77.62404,\n    LatLong 13.1581 77.62436,\n    LatLong 13.15973 77.62562,\n    LatLong 13.16027 77.62602,\n    LatLong 13.16072 77.62633,\n    LatLong 13.16116 77.62663,\n    LatLong 13.16121 77.62666,\n    LatLong 13.1615 77.62688,\n    LatLong 13.16176 77.62709,\n    LatLong 13.16177 77.6271,\n    LatLong 13.16208 77.62736,\n    LatLong 13.16242 77.62765,\n    LatLong 13.16311 77.62821,\n    LatLong 13.16324 77.62832,\n    LatLong 13.16344 77.62847,\n    LatLong 13.16387 77.6288,\n    LatLong 13.16436 77.62919,\n    LatLong 13.16455 77.62933,\n    LatLong 13.16459 77.62936,\n    LatLong 13.16505 77.6297,\n    LatLong 13.16529 77.62987,\n    LatLong 13.16558 77.63003,\n    LatLong 13.16589 77.63019,\n    LatLong 13.16665 77.63056,\n    LatLong 13.168 77.63119,\n    LatLong 13.16893 77.63162,\n    LatLong 13.16996 77.63211,\n    LatLong 13.16998 77.63211,\n    LatLong 13.17013 77.63218,\n    LatLong 13.17014 77.63219,\n    LatLong 13.17127 77.63272,\n    LatLong 13.17129 77.63273,\n    LatLong 13.17131 77.63274,\n    LatLong 13.17169 77.63291,\n    LatLong 13.17227 77.63317,\n    LatLong 13.17234 77.6332,\n    LatLong 13.17279 77.6334,\n    LatLong 13.17304 77.6335,\n    LatLong 13.17308 77.63352,\n    LatLong 13.17328 77.6336,\n    LatLong 13.17338 77.63364,\n    LatLong 13.17354 77.63371,\n    LatLong 13.17394 77.63388,\n    LatLong 13.17412 77.63398,\n    LatLong 13.17424 77.63405,\n    LatLong 13.17432 77.63409,\n    LatLong 13.17455 77.63423,\n    LatLong 13.17478 77.63439,\n    LatLong 13.17503 77.63458,\n    LatLong 13.17592 77.63527,\n    LatLong 13.176 77.63533,\n    LatLong 13.17632 77.63557,\n    LatLong 13.17695 77.63604,\n    LatLong 13.17704 77.6361,\n    LatLong 13.17756 77.63647,\n    LatLong 13.17812 77.63689,\n    LatLong 13.17825 77.63698,\n    LatLong 13.18024 77.63844,\n    LatLong 13.18039 77.63854,\n    LatLong 13.18054 77.63865,\n    LatLong 13.18129 77.63919,\n    LatLong 13.1822 77.63985,\n    LatLong 13.18338 77.64069,\n    LatLong 13.18341 77.64072,\n    LatLong 13.18366 77.6409,\n    LatLong 13.18416 77.64125,\n    LatLong 13.1844 77.64141,\n    LatLong 13.18476 77.64165,\n    LatLong 13.18487 77.64173,\n    LatLong 13.1852 77.64197,\n    LatLong 13.18556 77.64223,\n    LatLong 13.18573 77.64235,\n    LatLong 13.18626 77.64273,\n    LatLong 13.18665 77.64301,\n    LatLong 13.18703 77.6433,\n    LatLong 13.18732 77.64351,\n    LatLong 13.18846 77.64433,\n    LatLong 13.18958 77.64514,\n    LatLong 13.1901 77.64553,\n    LatLong 13.19025 77.64564,\n    LatLong 13.19036 77.64573,\n    LatLong 13.1905 77.64583,\n    LatLong 13.19083 77.64611,\n    LatLong 13.19105 77.64632,\n    LatLong 13.19111 77.64638,\n    LatLong 13.19128 77.64655,\n    LatLong 13.19138 77.64666,\n    LatLong 13.19184 77.64719,\n    LatLong 13.19214 77.64752,\n    LatLong 13.19224 77.64765,\n    LatLong 13.19243 77.64791,\n    LatLong 13.19282 77.64844,\n    LatLong 13.19296 77.64861,\n    LatLong 13.19312 77.64882,\n    LatLong 13.19354 77.64941,\n    LatLong 13.19366 77.64964,\n    LatLong 13.19367 77.64964,\n    LatLong 13.19392 77.64998,\n    LatLong 13.19417 77.65033,\n    LatLong 13.19431 77.65056,\n    LatLong 13.19444 77.65078,\n    LatLong 13.19466 77.65117,\n    LatLong 13.19488 77.65149,\n    LatLong 13.19494 77.6516\n  ]\n\ncheckIntersectionTest :: TestTree\ncheckIntersectionTest = do\n  testGroup\n    \"Check for Intersection of Line Segment with the Route tests\"\n    [ testCase \"Toll Gate Intersection Line Segment\" $\n        assertBool \"Toll Gate Intersection Failed\" (checkIntersection route (LineSegment (LatLong 13.194035537466561 77.64945751470611) (LatLong 13.193132939951079 77.65010378799398))),\n      testCase \"Toll Gate Intersection Line Segment - Reversed\" $\n        assertBool \"Toll Gate Intersection Failed\" (checkIntersection route (LineSegment (LatLong 13.193132939951079 77.65010378799398) (LatLong 13.194035537466561 77.64945751470611))),\n      testCase \"Intersecting Line Segment On The Route\" $\n        assertBool \"Random Non Intersecting Failed\" (checkIntersection route (LineSegment (LatLong 13.18958 77.64514) (LatLong 13.19488 77.65149))),\n      testCase \"Intersecting Line Segment On The Route - Reversed\" $\n        assertBool \"Random Non Intersecting Failed\" (checkIntersection route (LineSegment (LatLong 13.18958 77.64514) (LatLong 13.19488 77.65149))),\n      testCase \"Random Non Intersecting Line Segment Parallel To The Route On Left\" $\n        assertBool \"Random Non Intersecting Failed\" (not $ checkIntersection route (LineSegment (LatLong 13.133001338627825 77.61534703605838) (LatLong 13.133539191728158 77.6158097729554))),\n      testCase \"Random Non Intersecting Line Segment Parallel To The Route On Right\" $\n        assertBool \"Random Non Intersecting Failed\" (not $ checkIntersection route (LineSegment (LatLong 13.127782648739322 77.61461561322118) (LatLong 13.129522696016432 77.61483522604748)))\n    ]\n\ngetBoundingBoxTest :: TestTree\ngetBoundingBoxTest = do\n  testCase \"Get Bounding Box Test with sample route\" $ do\n    let boundingBox = getBoundingBox route\n    assertBool \"Bounding Box Failed\" (boundingBox == BoundingBox (LatLong 13.19494 77.58381) (LatLong 13.19494 77.6516) (LatLong 13.01111 77.58381) (LatLong 13.01111 77.6516))\n\ncomputeIntersectionTests :: TestTree\ncomputeIntersectionTests =\n  testGroup\n    \"ComputeIntersection tests\"\n    [ getBoundingBoxTest,\n      checkIntersectionTest\n    ]\n",
      "hash": "d27c239f71eca12a54f43e6fcc902d5d1b91a6c1eaa0389c80b7138cc1a00576",
      "size": 19459
    },
    "/lib/mobility-core/test/src/DistanceCalculation.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n\nmodule DistanceCalculation where\n\nimport Data.List (head, last)\nimport EulerHS.Prelude\nimport Kernel.External.Maps.Types\nimport Kernel.Types.Common\nimport Kernel.Utils.CalculateDistance\nimport Test.Tasty\nimport Test.Tasty.HUnit\nimport Utils.Numeric\n\ntestTotalRouteLinearLenghtCalculation :: TestTree\ntestTotalRouteLinearLenghtCalculation =\n  testCase \"Total route linear length calculation\" $\n    checkTolerance 0.08 linearLength manuallyCalculatedLength -- 8%\n\ntestLinearLengthCalculationDuringStop :: TestTree\ntestLinearLengthCalculationDuringStop =\n  testCase \"Linear length calculation during a stop\" $\n    checkTolerance 3.0 lenghtDuringStop realLenghtDuringStop -- 300%\n\nlenghtDuringStop, realLenghtDuringStop :: HighPrecMeters\nlenghtDuringStop = getRouteLinearLength pointsDuringStop Nothing\nrealLenghtDuringStop = distanceBetweenInMeters (head pointsDuringStop) (last pointsDuringStop)\n\ndistanceCalculation :: TestTree\ndistanceCalculation =\n  testGroup\n    \"Distance calculation\"\n    [ testTotalRouteLinearLenghtCalculation,\n      testLinearLengthCalculationDuringStop\n    ]\n\nlinearLength, manuallyCalculatedLength :: HighPrecMeters\nlinearLength = getRouteLinearLength realRoute Nothing\nmanuallyCalculatedLength = 16930 -- may be not very accurate\n\nrealRoute :: [LatLong]\nrealRoute =\n  [ LatLong 9.9398944 76.2544582,\n    LatLong 9.9398909 76.2544567,\n    LatLong 9.939888 76.254453,\n    LatLong 9.9398883 76.2544531,\n    LatLong 9.9398829 76.2544371,\n    LatLong 9.9398768 76.2544257,\n    LatLong 9.9398604 76.2544371,\n    LatLong 9.9398524 76.2544493,\n    LatLong 9.939908 76.2543671,\n    LatLong 9.9399302 76.2543952,\n    LatLong 9.9400302 76.2544405,\n    LatLong 9.9400567 76.2544309,\n    LatLong 9.9401069 76.2543531,\n    LatLong 9.9401888 76.2543246,\n    LatLong 9.940274 76.2543199,\n    LatLong 9.9403908 76.2543252,\n    LatLong 9.9403922 76.254325,\n    LatLong 9.9403912 76.2543255,\n    LatLong 9.9403894 76.2543261,\n    LatLong 9.9403933 76.2543236,\n    LatLong 9.9404058 76.254299,\n    LatLong 9.940435 76.2543254,\n    LatLong 9.9404082 76.2544591,\n    LatLong 9.9404217 76.2545058,\n    LatLong 9.9404428 76.2545107,\n    LatLong 9.9404445 76.2545127,\n    LatLong 9.9404456 76.254513,\n    LatLong 9.9404458 76.2545127,\n    LatLong 9.9404459 76.2545135,\n    LatLong 9.940446 76.2545139,\n    LatLong 9.9404465 76.254514,\n    LatLong 9.9404489 76.2545165,\n    LatLong 9.940447 76.254507,\n    LatLong 9.9404535 76.2545367,\n    LatLong 9.940485 76.2544063,\n    LatLong 9.9404856 76.2544054,\n    LatLong 9.9404867 76.2544041,\n    LatLong 9.9404873 76.2544039,\n    LatLong 9.9404885 76.2544044,\n    LatLong 9.9404831 76.2544035,\n    LatLong 9.9405054 76.254401,\n    LatLong 9.9404917 76.2543863,\n    LatLong 9.9405356 76.2543739,\n    LatLong 9.9404698 76.2543737,\n    LatLong 9.9405352 76.2548744,\n    LatLong 9.940589 76.2553461,\n    LatLong 9.9401319 76.2555534,\n    LatLong 9.9395652 76.2555812,\n    LatLong 9.9392106 76.2556376,\n    LatLong 9.9385047 76.2556366,\n    LatLong 9.9375899 76.2556057,\n    LatLong 9.9366767 76.2556794,\n    LatLong 9.9363119 76.2556921,\n    LatLong 9.9351912 76.2558317,\n    LatLong 9.9351557 76.2560704,\n    LatLong 9.9353335 76.256792,\n    LatLong 9.9354633 76.2573945,\n    LatLong 9.9355591 76.2581132,\n    LatLong 9.9355043 76.258261,\n    LatLong 9.9353529 76.25832,\n    LatLong 9.9347847 76.2584784,\n    LatLong 9.934107 76.2586099,\n    LatLong 9.9329574 76.2588132,\n    LatLong 9.9323185 76.2591149,\n    LatLong 9.9320081 76.2593105,\n    LatLong 9.9322084 76.2599253,\n    LatLong 9.9324095 76.2608791,\n    LatLong 9.932475 76.2617346,\n    LatLong 9.932479 76.2618825,\n    LatLong 9.9326096 76.2621351,\n    LatLong 9.9330211 76.262919,\n    LatLong 9.9335388 76.2640871,\n    LatLong 9.9337354 76.2644983,\n    LatLong 9.9334285 76.264736,\n    LatLong 9.9330363 76.2653446,\n    LatLong 9.9328202 76.2658018,\n    LatLong 9.9322172 76.2661768,\n    LatLong 9.9317685 76.2664856,\n    LatLong 9.9315057 76.2670869,\n    LatLong 9.9315215 76.267064,\n    LatLong 9.9315072 76.2670681,\n    LatLong 9.9315695 76.2669322,\n    LatLong 9.9319097 76.2662313,\n    LatLong 9.9322136 76.2660685,\n    LatLong 9.9329054 76.2656673,\n    LatLong 9.9335088 76.2648101,\n    LatLong 9.9337261 76.2646656,\n    LatLong 9.9338295 76.2645363,\n    LatLong 9.9336978 76.264466,\n    LatLong 9.9336755 76.2644644,\n    LatLong 9.9336972 76.2643114,\n    LatLong 9.9333984 76.2636898,\n    LatLong 9.9330346 76.2628183,\n    LatLong 9.9325948 76.2619272,\n    LatLong 9.9324081 76.2611435,\n    LatLong 9.9321841 76.2602847,\n    LatLong 9.9320771 76.2595885,\n    LatLong 9.9321323 76.2592183,\n    LatLong 9.9327819 76.258968,\n    LatLong 9.9333936 76.2587619,\n    LatLong 9.9338434 76.2587383,\n    LatLong 9.9342633 76.2586622,\n    LatLong 9.934598 76.2585258,\n    LatLong 9.9352644 76.2583415,\n    LatLong 9.935577 76.2582758,\n    LatLong 9.9356161 76.258063,\n    LatLong 9.9355687 76.2573506,\n    LatLong 9.9354151 76.2566043,\n    LatLong 9.9352069 76.2560722,\n    LatLong 9.9352094 76.255868,\n    LatLong 9.9354833 76.2557625,\n    LatLong 9.9361751 76.2557119,\n    LatLong 9.9371143 76.2555911,\n    LatLong 9.9379369 76.2555983,\n    LatLong 9.938632 76.2556986,\n    LatLong 9.9389736 76.255741,\n    LatLong 9.9394014 76.2557381,\n    LatLong 9.9399124 76.2556095,\n    LatLong 9.9407917 76.2557176,\n    LatLong 9.9418247 76.2558436,\n    LatLong 9.9424599 76.2558964,\n    LatLong 9.942946 76.255968,\n    LatLong 9.9435518 76.2559449,\n    LatLong 9.9438331 76.2559526,\n    LatLong 9.9440321 76.256003,\n    LatLong 9.9444502 76.2560629,\n    LatLong 9.9446595 76.2560492,\n    LatLong 9.9448985 76.2560086,\n    LatLong 9.945373 76.2559084,\n    LatLong 9.9460681 76.2558452,\n    LatLong 9.9467327 76.2558197,\n    LatLong 9.947248 76.2559258,\n    LatLong 9.9477598 76.2558551,\n    LatLong 9.948272 76.2556759,\n    LatLong 9.949095 76.2556278,\n    LatLong 9.9493114 76.2557103,\n    LatLong 9.9494124 76.2555746,\n    LatLong 9.9494283 76.2549797,\n    LatLong 9.9494653 76.2541804,\n    LatLong 9.9494084 76.253778,\n    LatLong 9.9494707 76.2534851,\n    LatLong 9.9495028 76.2532594,\n    LatLong 9.9495729 76.2529304,\n    LatLong 9.9496094 76.2524137,\n    LatLong 9.9496595 76.2519506,\n    LatLong 9.9496786 76.2511073,\n    LatLong 9.949829 76.2504006,\n    LatLong 9.949746 76.2502432,\n    LatLong 9.9496946 76.2498126,\n    LatLong 9.9497162 76.2493365,\n    LatLong 9.9488983 76.2493126,\n    LatLong 9.9482119 76.2493073,\n    LatLong 9.9476222 76.2493323,\n    LatLong 9.947077 76.2493599,\n    LatLong 9.9465928 76.2494519,\n    LatLong 9.9461945 76.2495408,\n    LatLong 9.9460593 76.2494892,\n    LatLong 9.9457926 76.2492072,\n    LatLong 9.9457317 76.2485888,\n    LatLong 9.9458146 76.2478109,\n    LatLong 9.9459228 76.2474178,\n    LatLong 9.9458006 76.2468397,\n    LatLong 9.945748 76.2459569,\n    LatLong 9.945839 76.245265,\n    LatLong 9.9466031 76.2450449,\n    LatLong 9.9475667 76.2449813,\n    LatLong 9.9479818 76.2450643,\n    LatLong 9.9487161 76.2449397,\n    LatLong 9.949558 76.2448184,\n    LatLong 9.9501572 76.2446354,\n    LatLong 9.9505948 76.2446262,\n    LatLong 9.951299 76.244686,\n    LatLong 9.9515957 76.2446221,\n    LatLong 9.9516244 76.2441339,\n    LatLong 9.9516122 76.2434132,\n    LatLong 9.9516515 76.2426795,\n    LatLong 9.9521181 76.2424165,\n    LatLong 9.9533909 76.2423739,\n    LatLong 9.9544857 76.242439,\n    LatLong 9.9553803 76.2424938,\n    LatLong 9.9569953 76.2424815,\n    LatLong 9.9580443 76.2425291,\n    LatLong 9.9590512 76.2426587,\n    LatLong 9.9597582 76.2427202,\n    LatLong 9.9600314 76.2427758,\n    LatLong 9.960336 76.242884,\n    LatLong 9.9610344 76.2429602,\n    LatLong 9.9614003 76.2429196,\n    LatLong 9.9619112 76.2429355,\n    LatLong 9.9626063 76.2430359,\n    LatLong 9.9630785 76.2430546,\n    LatLong 9.963587 76.2429774,\n    LatLong 9.9641474 76.2429025,\n    LatLong 9.96467 76.2432158,\n    LatLong 9.9650579 76.2434864,\n    LatLong 9.9652889 76.2435833,\n    LatLong 9.9662792 76.2440292,\n    LatLong 9.9668321 76.2442162,\n    LatLong 9.9671789 76.244374,\n    LatLong 9.9680518 76.2443197,\n    LatLong 9.9684303 76.2444205,\n    LatLong 9.9684431 76.2445717,\n    LatLong 9.9684486 76.2446346,\n    LatLong 9.9684292 76.244613,\n    LatLong 9.968421 76.2447441,\n    LatLong 9.968836 76.2449155,\n    LatLong 9.9688942 76.2449145,\n    LatLong 9.968915 76.2448988,\n    LatLong 9.9688228 76.2449572,\n    LatLong 9.9687608 76.2449791,\n    LatLong 9.9688348 76.2449417,\n    LatLong 9.9689061 76.2449002,\n    LatLong 9.9689559 76.2449258,\n    LatLong 9.9698299 76.245046,\n    LatLong 9.971594 76.245025,\n    LatLong 9.9730622 76.24485,\n    LatLong 9.9734527 76.2446998,\n    LatLong 9.9736689 76.2446262,\n    LatLong 9.9736669 76.2446251,\n    LatLong 9.9736669 76.2446252,\n    LatLong 9.9736662 76.244619,\n    LatLong 9.9736642 76.2446193,\n    LatLong 9.9736628 76.2446195,\n    LatLong 9.9736608 76.2446171,\n    LatLong 9.9736529 76.2446106,\n    LatLong 9.9736523 76.2446029,\n    LatLong 9.9736433 76.2445917,\n    LatLong 9.9737532 76.2445318,\n    LatLong 9.9737765 76.2442782,\n    LatLong 9.9737356 76.244145,\n    LatLong 9.9737354 76.244145,\n    LatLong 9.9737354 76.2441457,\n    LatLong 9.9737351 76.2441477,\n    LatLong 9.9737354 76.2441479,\n    LatLong 9.9737338 76.2441522,\n    LatLong 9.9737343 76.2441547,\n    LatLong 9.9737346 76.2441575,\n    LatLong 9.9737341 76.2441575,\n    LatLong 9.9737331 76.2441583,\n    LatLong 9.9737331 76.244156,\n    LatLong 9.9737332 76.2441554,\n    LatLong 9.9737377 76.2441512,\n    LatLong 9.9737365 76.244149,\n    LatLong 9.9737362 76.2441471,\n    LatLong 9.9737393 76.2441443,\n    LatLong 9.9737415 76.2441467,\n    LatLong 9.9737408 76.2441508,\n    LatLong 9.9737433 76.2441611,\n    LatLong 9.9737324 76.2441815,\n    LatLong 9.9737368 76.244183,\n    LatLong 9.9737373 76.2441826,\n    LatLong 9.9737316 76.2441844,\n    LatLong 9.9737302 76.244185,\n    LatLong 9.9737362 76.2441849,\n    LatLong 9.9737605 76.244097,\n    LatLong 9.9756913 76.24201,\n    LatLong 9.9824053 76.2410449,\n    LatLong 9.9891453 76.239389, -- start of a stop, see pointsDuringStop\n    LatLong 9.9892493 76.239371,\n    LatLong 9.989232 76.2393878,\n    LatLong 9.9892407 76.2393784,\n    LatLong 9.9892555 76.2393528,\n    LatLong 9.9892489 76.2393519,\n    LatLong 9.989244 76.2393575,\n    LatLong 9.9892844 76.2393815,\n    LatLong 9.9892773 76.2393929,\n    LatLong 9.9892725 76.2394076,\n    LatLong 9.9892784 76.2394103,\n    LatLong 9.989289 76.239411,\n    LatLong 9.9892911 76.2394052,\n    LatLong 9.9892874 76.2393925,\n    LatLong 9.9892868 76.239392,\n    LatLong 9.9892864 76.239379,\n    LatLong 9.9892983 76.2393893,\n    LatLong 9.989309 76.2393714,\n    LatLong 9.9893104 76.2393791,\n    LatLong 9.9892975 76.2394138,\n    LatLong 9.9893209 76.2394068,\n    LatLong 9.9893312 76.23941,\n    LatLong 9.9893393 76.2394146,\n    LatLong 9.9893531 76.2394152,\n    LatLong 9.9893319 76.2394066,\n    LatLong 9.9891736 76.2393959,\n    LatLong 9.9891244 76.2393988,\n    LatLong 9.9891728 76.2393731,\n    LatLong 9.9892152 76.2393964,\n    LatLong 9.9892443 76.2394006,\n    LatLong 9.9892907 76.2394366,\n    LatLong 9.9893956 76.2393084, -- end of a stop\n    LatLong 9.9900996 76.2390688,\n    LatLong 9.9905339 76.2387819,\n    LatLong 9.990837 76.2386553,\n    LatLong 9.991896 76.2383919,\n    LatLong 9.9920605 76.2382383,\n    LatLong 9.9921439 76.2382709,\n    LatLong 9.9926276 76.2380238,\n    LatLong 9.9932555 76.2377877,\n    LatLong 9.9937166 76.2376653,\n    LatLong 9.9945786 76.2373995,\n    LatLong 9.9953113 76.2370529,\n    LatLong 9.99675 76.2364221,\n    LatLong 9.9976691 76.2360054,\n    LatLong 9.9984918 76.2356272,\n    LatLong 9.9993733 76.2352193,\n    LatLong 10.000078 76.235049,\n    LatLong 10.0006924 76.234794,\n    LatLong 10.0009878 76.234666,\n    LatLong 10.001904 76.2341222,\n    LatLong 10.0027179 76.233674,\n    LatLong 10.0034642 76.233255,\n    LatLong 10.0038188 76.233080,\n    LatLong 10.0039789 76.233067,\n    LatLong 10.0046606 76.232736,\n    LatLong 10.0053718 76.232434,\n    LatLong 10.006461 76.2319021,\n    LatLong 10.0073689 76.231529,\n    LatLong 10.008346 76.2311696,\n    LatLong 10.0090234 76.230678,\n    LatLong 10.0126962 76.228819,\n    LatLong 10.0117747 76.229352,\n    LatLong 10.0136695 76.228404,\n    LatLong 10.0143905 76.227951,\n    LatLong 10.0150747 76.227441,\n    LatLong 10.0157321 76.227040,\n    LatLong 10.0162389 76.226730,\n    LatLong 10.0163395 76.226772,\n    LatLong 10.0170941 76.226547,\n    LatLong 10.0179779 76.226124,\n    LatLong 10.0185677 76.225849,\n    LatLong 10.0186785 76.225820,\n    LatLong 10.0186785 76.225821,\n    LatLong 10.0186782 76.225821,\n    LatLong 10.0186774 76.22582,\n    LatLong 10.0186776 76.225819,\n    LatLong 10.0186778 76.225820,\n    LatLong 10.0186774 76.225819,\n    LatLong 10.0186773 76.225819,\n    LatLong 10.0186773 76.225820,\n    LatLong 10.0186769 76.225820,\n    LatLong 10.0186764 76.225821,\n    LatLong 10.0186745 76.225819,\n    LatLong 10.0186747 76.225820,\n    LatLong 10.0186747 76.225821,\n    LatLong 10.0186743 76.225820,\n    LatLong 10.0186732 76.225819,\n    LatLong 10.0186726 76.225820,\n    LatLong 10.0186727 76.225822,\n    LatLong 10.0186703 76.225824,\n    LatLong 10.0186739 76.225823,\n    LatLong 10.0186729 76.225818,\n    LatLong 10.0186732 76.225818,\n    LatLong 10.0186766 76.225816,\n    LatLong 10.0186765 76.225815,\n    LatLong 10.0186772 76.225817,\n    LatLong 10.0186795 76.22582,\n    LatLong 10.0186814 76.225819,\n    LatLong 10.0186817 76.225815,\n    LatLong 10.0186841 76.225813,\n    LatLong 10.0186818 76.225813,\n    LatLong 10.0186872 76.225816,\n    LatLong 10.018692 76.2258186,\n    LatLong 10.0187008 76.225819,\n    LatLong 10.0187011 76.225815,\n    LatLong 10.0187018 76.225816,\n    LatLong 10.0187008 76.225818,\n    LatLong 10.0187001 76.225818,\n    LatLong 10.0187001 76.225822,\n    LatLong 10.0187051 76.225833,\n    LatLong 10.0186517 76.225847,\n    LatLong 10.021131 76.2247227,\n    LatLong 10.0235072 76.224224,\n    LatLong 10.0304166 76.221982\n  ]\n\npointsDuringStop :: [LatLong]\npointsDuringStop =\n  [ LatLong 9.9891453 76.239389, -- start of a stop\n    LatLong 9.9892493 76.239371,\n    LatLong 9.989232 76.2393878,\n    LatLong 9.9892407 76.2393784,\n    LatLong 9.9892555 76.2393528,\n    LatLong 9.9892489 76.2393519,\n    LatLong 9.989244 76.2393575,\n    LatLong 9.9892844 76.2393815,\n    LatLong 9.9892773 76.2393929,\n    LatLong 9.9892725 76.2394076,\n    LatLong 9.9892784 76.2394103,\n    LatLong 9.989289 76.239411,\n    LatLong 9.9892911 76.2394052,\n    LatLong 9.9892874 76.2393925,\n    LatLong 9.9892868 76.239392,\n    LatLong 9.9892864 76.239379,\n    LatLong 9.9892983 76.2393893,\n    LatLong 9.989309 76.2393714,\n    LatLong 9.9893104 76.2393791,\n    LatLong 9.9892975 76.2394138,\n    LatLong 9.9893209 76.2394068,\n    LatLong 9.9893312 76.23941,\n    LatLong 9.9893393 76.2394146,\n    LatLong 9.9893531 76.2394152,\n    LatLong 9.9893319 76.2394066,\n    LatLong 9.9891736 76.2393959,\n    LatLong 9.9891244 76.2393988,\n    LatLong 9.9891728 76.2393731,\n    LatLong 9.9892152 76.2393964,\n    LatLong 9.9892443 76.2394006,\n    LatLong 9.9892907 76.2394366,\n    LatLong 9.9893956 76.2393084 -- end of a stop\n  ]\n",
      "hash": "378dd0ddf45d8fdbdd1d7ad7633f061b72426a51528b9066aa045cc90bfa7501",
      "size": 15767
    },
    "/lib/mobility-core/test/src/SignatureAuth.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n{-# LANGUAGE PackageImports #-}\n{-# OPTIONS_GHC -Wwarn=incomplete-uni-patterns #-}\n\nmodule SignatureAuth\n  ( signatureAuthTests,\n  )\nwhere\n\nimport qualified Data.ByteString as BS\nimport qualified \"base64-bytestring\" Data.ByteString.Base64 as Base64\nimport qualified Data.CaseInsensitive as CI\nimport qualified Data.Text as T\nimport Data.Time.Clock (NominalDiffTime)\nimport EulerHS.Prelude\nimport Kernel.Types.Base64\nimport qualified Kernel.Utils.SignatureAuth as HttpSig\nimport Network.HTTP.Types (methodPost)\nimport Test.Tasty\nimport Test.Tasty.HUnit\n\nsecretKey :: Base64\nsecretKey = \"faGTaRPYJx8OQ7zbQOlrevtWTmqs+hAJr2tn08Dgx1U=\"\n\npublicKey :: Base64\npublicKey = \"oUvUHbL/9ZU4JT0RjcnAvgSXpXtyNTDBWRWDpnlP4N0=\"\n\nexamplePath :: ByteString\nexamplePath = \"/foo?param=value&pet=dog\"\n\nexampleMethod :: ByteString\nexampleMethod = methodPost\n\nexampleHeaders :: [(Text, ByteString)]\nexampleHeaders =\n  [ (\"(request-target)\", exampleMethod <> \" \" <> examplePath),\n    (\"(created)\", \"\"),\n    (\"(expires)\", \"\"),\n    (\"host\", \"example.com\"),\n    (\"date\", \"Sun, 05 Jan 2014 21:31:40 GMT\"),\n    (\"content-type\", \"application/json\"),\n    (\"digest\", \"BLAKE-512=20cb8f1175aaa3f23f020b3962300c483ba33dda3f1ae32734605db4d834419f874f19963636ff0c79d45a054af895b20fdac745f354c865d938ef6e801b8e33\"),\n    (\"content-length\", \"18\")\n  ]\n\nexampleBodyHash :: HttpSig.Hash\nexampleBodyHash = HttpSig.becknSignatureHash \"{\\\"hello\\\": \\\"world\\\"}\"\n\nexampleKeyId :: ByteString\nexampleKeyId = \"example-bg.com|bg432|ed25519\"\n\nexampleCreated :: Integer\nexampleCreated = 1402170695\n\nexampleExpires :: Integer\nexampleExpires = 1402170699\n\nexampleSignature :: ByteString\nexampleSignature = \"WJoZi2DBgQQ1ChHus4F6L0S4pOVeSvhmViZK3W0x+kCpmrVC6cgcmj2x7P2g5fHjft1OB5LKJLmIid2qd1XZCA==\"\n\nexampleSignatureMessage :: ByteString\nexampleSignatureMessage =\n  encodeUtf8 $\n    unlines\n      [ \"(request-target): \" <> decodeUtf8 methodPost <> \" \" <> decodeUtf8 examplePath,\n        \"(created): \" <> show exampleCreated,\n        \"(expires): \" <> show exampleExpires,\n        \"host: example.com\",\n        \"date: Sun, 05 Jan 2014 21:31:40 GMT\",\n        \"content-type: application/json\",\n        \"digest: BLAKE-512=IMuPEXWqo/I/Ags5YjAMSDujPdo/GuMnNGBdtNg0QZ+HTxmWNjb/DHnUWgVK+JWyD9rHRfNUyGXZOO9ugBuOMw==\",\n        \"content-length: 18\"\n      ]\n\n-- | algorithm is modified to hs2019\nexampleSignatureHeader :: ByteString\nexampleSignatureHeader =\n  \"Signature keyId=\\\"\" <> exampleKeyId <> \"\\\",algorithm=\\\"ed25519\\\",\\n\"\n    <> \"created=\\\"\"\n    <> show exampleCreated\n    <> \"\\\",expires=\\\"\"\n    <> show exampleExpires\n    <> \"\\\",\\n\"\n    <> \"headers=\\\"\"\n    <> (encodeUtf8 . T.intercalate \" \" $ fst <$> exampleHeaders)\n    <> \"\\\",\\n\"\n    <> \"signature=\\\"\"\n    <> exampleSignature\n    <> \"\\\"\"\n\ntoTime :: Integer -> Maybe NominalDiffTime\ntoTime = Just . fromInteger\n\nsimpleDecode :: TestTree\nsimpleDecode =\n  testCase \"Simple header decode\" $\n    case HttpSig.decode exampleSignatureHeader of\n      Left err -> assertFailure $ \"signature decode failed: \" <> err\n      Right HttpSig.SignaturePayload {..} -> do\n        Right signature @?= Base64.decode exampleSignature\n        HttpSig.headers params @?= fst <$> exampleHeaders\n        HttpSig.algorithm params @?= HttpSig.Ed25519\n        HttpSig.created params @?= toTime exampleCreated\n        HttpSig.expires params @?= toTime exampleExpires\n\nexampleParams :: HttpSig.SignatureParams\nexampleParams =\n  let Right keyId = HttpSig.decodeKeyId $ decodeUtf8 exampleKeyId\n   in HttpSig.SignatureParams\n        keyId\n        HttpSig.Ed25519\n        (fst <$> exampleHeaders)\n        (toTime exampleCreated)\n        (toTime exampleExpires)\n\ndropNewline :: ByteString -> ByteString\ndropNewline = BS.filter (/= 10)\n\nsimpleEncode :: TestTree\nsimpleEncode =\n  testCase \"Simple header encode\" $ do\n    let Right sig = Base64.decode exampleSignature\n    -- filtering '\\n'\n    HttpSig.encode (HttpSig.SignaturePayload sig exampleParams) @?= dropNewline exampleSignatureHeader\n\ncheckSignatureMessage :: TestTree\ncheckSignatureMessage =\n  testCase \"Check Signature Message\" $ do\n    let message = HttpSig.makeSignatureString exampleParams exampleBodyHash $ first (CI.mk . encodeUtf8) <$> exampleHeaders\n    -- filtering '\\n'\n    dropNewline message @?= dropNewline exampleSignatureMessage\n\nsignRequest :: TestTree\nsignRequest =\n  testCase \"Sign a request\" $ do\n    let mSig =\n          HttpSig.sign secretKey exampleParams exampleBodyHash (first (CI.mk . encodeUtf8) <$> exampleHeaders)\n    case mSig of\n      Nothing -> assertFailure \"Could not sign request\"\n      Just sig ->\n        -- filtering '\\n'\n        HttpSig.encode (HttpSig.SignaturePayload sig exampleParams) @?= dropNewline exampleSignatureHeader\n\nverifyRequest :: TestTree\nverifyRequest =\n  testCase \"Verify a signed request\" $ do\n    let eSig = Base64.decode exampleSignature\n    case eSig of\n      Left err -> assertFailure $ \"Could not decode request: \" <> show err\n      Right sig -> do\n        case HttpSig.verify publicKey exampleParams exampleBodyHash (first (CI.mk . encodeUtf8) <$> exampleHeaders) sig of\n          Left err -> assertFailure $ \"Could not verify signature: \" <> show err\n          Right isVerified -> assertBool \"Signature is valid\" isVerified\n\nsignAndVerifyWithGeneratedKeyPair :: TestTree\nsignAndVerifyWithGeneratedKeyPair =\n  testCase \"Sign and verify a request with generated key pair\" $ do\n    (privateKey, publicKey') <- HttpSig.generateKeyPair\n    let mSig =\n          HttpSig.sign privateKey exampleParams exampleBodyHash (first (CI.mk . encodeUtf8) <$> exampleHeaders)\n    case mSig of\n      Nothing -> assertFailure \"Could not sign request\"\n      Just sig -> do\n        case HttpSig.verify publicKey' exampleParams exampleBodyHash (first (CI.mk . encodeUtf8) <$> exampleHeaders) sig of\n          Left err -> assertFailure $ \"Could not verify signature: \" <> show err\n          Right isVerified -> assertBool \"Signature is valid\" isVerified\n\nsignatureAuthTests :: TestTree\nsignatureAuthTests =\n  testGroup\n    \"Signature auth tests\"\n    [ simpleDecode,\n      simpleEncode,\n      checkSignatureMessage,\n      signRequest,\n      verifyRequest,\n      signAndVerifyWithGeneratedKeyPair\n    ]\n",
      "hash": "73282b5ee8d9c26d451ef8ae2230797053c5216830555cfa852a826d805b3c61",
      "size": 6846
    },
    "/lib/mobility-core/test/src/SlidingWindowLimiter.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n\nmodule SlidingWindowLimiter where\n\nimport Data.Time\nimport Data.Time.Clock.POSIX\nimport EulerHS.Prelude\nimport Kernel.Utils.SlidingWindowLimiter (slidingWindowLimiterPure)\nimport Test.Tasty\nimport Test.Tasty.HUnit\n\nhitsLimit :: Int\nhitsLimit = 4\n\nframeLen :: Int\nframeLen = 10\n\nframe0 :: UTCTime\nframe0 = posixSecondsToUTCTime $ secondsToNominalDiffTime 0\n\nframe1 :: UTCTime\nframe1 = posixSecondsToUTCTime $ secondsToNominalDiffTime (fromIntegral frameLen + 1)\n\nframe1Late :: UTCTime\nframe1Late = posixSecondsToUTCTime $ secondsToNominalDiffTime (fromIntegral frameLen * 2 - 1)\n\nframe2 :: UTCTime\nframe2 = posixSecondsToUTCTime $ secondsToNominalDiffTime (fromIntegral frameLen * 2 + 1)\n\nemptyList :: TestTree\nemptyList = testCase \"Empty list\" $ do\n  slidingWindowLimiterPure frame0 [] hitsLimit frameLen @?= ([0], True)\n  slidingWindowLimiterPure frame1 [] hitsLimit frameLen @?= ([1], True)\n  slidingWindowLimiterPure frame2 [] hitsLimit frameLen @?= ([2], True)\n\nsuccessful :: TestTree\nsuccessful = testCase \"Successful tests\" $ do\n  slidingWindowLimiterPure frame0 [0, 0] hitsLimit frameLen @?= ([0, 0, 0], True)\n  slidingWindowLimiterPure frame1 [0, 0, 0] hitsLimit frameLen @?= ([1, 0, 0, 0], True)\n  slidingWindowLimiterPure frame1 [0, 0, 0, 0] hitsLimit frameLen @?= ([1, 0, 0, 0, 0], True)\n  slidingWindowLimiterPure frame1Late [0, 0, 0, 0, 1] hitsLimit frameLen @?= ([1, 0, 0, 0, 0, 1], True)\n  slidingWindowLimiterPure frame2 [0, 0, 1, 1, 0, 0, 1] hitsLimit frameLen @?= ([2, 1, 1, 1], True)\n\nfailing :: TestTree\nfailing = testCase \"Failing tests\" $ do\n  slidingWindowLimiterPure frame0 [0, 0, 0, 0] hitsLimit frameLen @?= ([0, 0, 0, 0], False)\n  slidingWindowLimiterPure frame1 [0, 0, 0, 0, 1] hitsLimit frameLen @?= ([0, 0, 0, 0, 1], False)\n  slidingWindowLimiterPure frame1 [0, 0, 0, 0, 1, 1, 1, 1] hitsLimit frameLen @?= ([0, 0, 0, 0, 1, 1, 1, 1], False)\n  slidingWindowLimiterPure frame2 [0, 0, 1, 1, 0, 2, 1, 1] hitsLimit frameLen @?= ([1, 1, 2, 1, 1], False)\n\nslidingWindowLimiterTests :: TestTree\nslidingWindowLimiterTests =\n  testGroup\n    \"Sliding window limiter tests\"\n    [ emptyList,\n      successful,\n      failing\n    ]\n",
      "hash": "b5e41f17556c6c6e62c3f88c8b66ad5a936e7affbc770567f1b29aa946243a52",
      "size": 2840
    },
    "/lib/mobility-core/test/src/SnippetsCheck.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n\nmodule SnippetsCheck where\n\nimport EulerHS.Prelude\nimport Kernel.External.Maps.Types (LatLong (..))\nimport Kernel.Utils.CalculateDistance (everySnippetIs)\nimport Test.Tasty (TestTree, testGroup)\nimport Test.Tasty.HUnit\n\nsnippetsCheckTests :: TestTree\nsnippetsCheckTests =\n  testGroup\n    \"Testing everySnippetIs function\"\n    [ testSnippetsCheckInCorrectRealRoute,\n      testFailIfLastSnippetBad,\n      testFailIfFirstSnippetBad,\n      testFailIfSnippetsInTheMiddleBad,\n      testZeroPointsShouldReturnTrue,\n      testOnePointShouldReturnTrue\n    ]\n\ntestSnippetsCheckInCorrectRealRoute :: TestTree\ntestSnippetsCheckInCorrectRealRoute =\n  testCase \"Calling everySnippetIs with good snippets route should return true\" $\n    everySnippetIs (< 300) goodSnippetsRoute @?= True\n\ntestFailIfLastSnippetBad :: TestTree\ntestFailIfLastSnippetBad =\n  let badLastSnippetRoute = goodSnippetsRoute ++ [LatLong 9.9737605 76.284097]\n   in testCase \"Calling everySnippetIs with bad last snippet should return false\" $\n        everySnippetIs (< 300) badLastSnippetRoute @?= False\n\ntestFailIfFirstSnippetBad :: TestTree\ntestFailIfFirstSnippetBad =\n  let badFirstSnippetRoute = LatLong 9.9737605 76.244097 : goodSnippetsRoute\n   in testCase \"Calling everySnippetIs with bad first snippet should return false\" $\n        everySnippetIs (< 300) badFirstSnippetRoute @?= False\n\ntestFailIfSnippetsInTheMiddleBad :: TestTree\ntestFailIfSnippetsInTheMiddleBad =\n  testCase \"Calling everySnippetIs with bad snippets in the middle should return false\" $\n    everySnippetIs (< 300) badSnippetsInTheMiddleRoute @?= False\n\ntestZeroPointsShouldReturnTrue :: TestTree\ntestZeroPointsShouldReturnTrue =\n  testCase \"Calling everySnippetIs with zero points should return true\" $\n    everySnippetIs (error \"Should be never reached\") [] @?= True\n\ntestOnePointShouldReturnTrue :: TestTree\ntestOnePointShouldReturnTrue =\n  testCase \"Calling everySnippetIs with one point should return true\" $\n    everySnippetIs (error \"Should be never reached\") [LatLong 20.0 20.0] @?= True\n\nbadSnippetsInTheMiddleRoute :: [LatLong]\nbadSnippetsInTheMiddleRoute =\n  [ LatLong 9.9398944 76.2544582,\n    LatLong 9.9398909 76.2544567,\n    LatLong 9.939888 76.254453,\n    LatLong 9.9398883 76.2544531,\n    LatLong 9.9398829 76.2544371,\n    LatLong 9.9398768 76.2544257,\n    LatLong 9.9398604 76.2544371,\n    LatLong 9.9398524 76.2544493,\n    LatLong 9.939908 76.2543671,\n    LatLong 9.939908 76.2843671, -- bad point\n    LatLong 9.9399302 76.2543952,\n    LatLong 9.9400302 76.2544405,\n    LatLong 9.9400567 76.2544309,\n    LatLong 9.9401069 76.2543531,\n    LatLong 9.9401888 76.2543246,\n    LatLong 9.940274 76.2543199,\n    LatLong 9.9403908 76.2543252,\n    LatLong 9.9403922 76.254325\n  ]\n\ngoodSnippetsRoute :: [LatLong]\ngoodSnippetsRoute =\n  [ LatLong 9.9398944 76.2544582,\n    LatLong 9.9398909 76.2544567,\n    LatLong 9.939888 76.254453,\n    LatLong 9.9398883 76.2544531,\n    LatLong 9.9398829 76.2544371,\n    LatLong 9.9398768 76.2544257,\n    LatLong 9.9398604 76.2544371,\n    LatLong 9.9398524 76.2544493,\n    LatLong 9.939908 76.2543671,\n    LatLong 9.9399302 76.2543952,\n    LatLong 9.9400302 76.2544405,\n    LatLong 9.9400567 76.2544309,\n    LatLong 9.9401069 76.2543531,\n    LatLong 9.9401888 76.2543246,\n    LatLong 9.940274 76.2543199,\n    LatLong 9.9403908 76.2543252,\n    LatLong 9.9403922 76.254325,\n    LatLong 9.9403912 76.2543255,\n    LatLong 9.9403894 76.2543261,\n    LatLong 9.9403933 76.2543236,\n    LatLong 9.9404058 76.254299,\n    LatLong 9.940435 76.2543254,\n    LatLong 9.9404082 76.2544591,\n    LatLong 9.9404217 76.2545058,\n    LatLong 9.9404428 76.2545107,\n    LatLong 9.9404445 76.2545127,\n    LatLong 9.9404456 76.254513,\n    LatLong 9.9404458 76.2545127,\n    LatLong 9.9404459 76.2545135,\n    LatLong 9.940446 76.2545139,\n    LatLong 9.9404465 76.254514,\n    LatLong 9.9404489 76.2545165,\n    LatLong 9.940447 76.254507,\n    LatLong 9.9404535 76.2545367,\n    LatLong 9.940485 76.2544063,\n    LatLong 9.9404856 76.2544054,\n    LatLong 9.9404867 76.2544041,\n    LatLong 9.9404873 76.2544039,\n    LatLong 9.9404885 76.2544044,\n    LatLong 9.9404831 76.2544035,\n    LatLong 9.9405054 76.254401,\n    LatLong 9.9404917 76.2543863,\n    LatLong 9.9405356 76.2543739,\n    LatLong 9.9404698 76.2543737,\n    LatLong 9.9405352 76.2548744,\n    LatLong 9.940589 76.2553461,\n    LatLong 9.9401319 76.2555534,\n    LatLong 9.9395652 76.2555812,\n    LatLong 9.9392106 76.2556376,\n    LatLong 9.9385047 76.2556366,\n    LatLong 9.9375899 76.2556057,\n    LatLong 9.9366767 76.2556794,\n    LatLong 9.9363119 76.2556921,\n    LatLong 9.9351912 76.2558317,\n    LatLong 9.9351557 76.2560704,\n    LatLong 9.9353335 76.256792,\n    LatLong 9.9354633 76.2573945,\n    LatLong 9.9355591 76.2581132,\n    LatLong 9.9355043 76.258261,\n    LatLong 9.9353529 76.25832,\n    LatLong 9.9347847 76.2584784,\n    LatLong 9.934107 76.2586099,\n    LatLong 9.9329574 76.2588132,\n    LatLong 9.9323185 76.2591149,\n    LatLong 9.9320081 76.2593105,\n    LatLong 9.9322084 76.2599253,\n    LatLong 9.9324095 76.2608791,\n    LatLong 9.932475 76.2617346,\n    LatLong 9.932479 76.2618825,\n    LatLong 9.9326096 76.2621351,\n    LatLong 9.9330211 76.262919,\n    LatLong 9.9335388 76.2640871,\n    LatLong 9.9337354 76.2644983,\n    LatLong 9.9334285 76.264736,\n    LatLong 9.9330363 76.2653446,\n    LatLong 9.9328202 76.2658018,\n    LatLong 9.9322172 76.2661768,\n    LatLong 9.9317685 76.2664856,\n    LatLong 9.9315057 76.2670869,\n    LatLong 9.9315215 76.267064,\n    LatLong 9.9315072 76.2670681,\n    LatLong 9.9315695 76.2669322,\n    LatLong 9.9319097 76.2662313,\n    LatLong 9.9322136 76.2660685,\n    LatLong 9.9329054 76.2656673,\n    LatLong 9.9335088 76.2648101,\n    LatLong 9.9337261 76.2646656,\n    LatLong 9.9338295 76.2645363,\n    LatLong 9.9336978 76.264466,\n    LatLong 9.9336755 76.2644644,\n    LatLong 9.9336972 76.2643114,\n    LatLong 9.9333984 76.2636898,\n    LatLong 9.9330346 76.2628183,\n    LatLong 9.9325948 76.2619272,\n    LatLong 9.9324081 76.2611435,\n    LatLong 9.9321841 76.2602847,\n    LatLong 9.9320771 76.2595885,\n    LatLong 9.9321323 76.2592183,\n    LatLong 9.9327819 76.258968,\n    LatLong 9.9333936 76.2587619,\n    LatLong 9.9338434 76.2587383,\n    LatLong 9.9342633 76.2586622,\n    LatLong 9.934598 76.2585258,\n    LatLong 9.9352644 76.2583415,\n    LatLong 9.935577 76.2582758,\n    LatLong 9.9356161 76.258063,\n    LatLong 9.9355687 76.2573506,\n    LatLong 9.9354151 76.2566043,\n    LatLong 9.9352069 76.2560722,\n    LatLong 9.9352094 76.255868,\n    LatLong 9.9354833 76.2557625,\n    LatLong 9.9361751 76.2557119,\n    LatLong 9.9371143 76.2555911,\n    LatLong 9.9379369 76.2555983,\n    LatLong 9.938632 76.2556986,\n    LatLong 9.9389736 76.255741,\n    LatLong 9.9394014 76.2557381,\n    LatLong 9.9399124 76.2556095,\n    LatLong 9.9407917 76.2557176,\n    LatLong 9.9418247 76.2558436,\n    LatLong 9.9424599 76.2558964,\n    LatLong 9.942946 76.255968,\n    LatLong 9.9435518 76.2559449,\n    LatLong 9.9438331 76.2559526,\n    LatLong 9.9440321 76.256003,\n    LatLong 9.9444502 76.2560629,\n    LatLong 9.9446595 76.2560492,\n    LatLong 9.9448985 76.2560086,\n    LatLong 9.945373 76.2559084,\n    LatLong 9.9460681 76.2558452,\n    LatLong 9.9467327 76.2558197,\n    LatLong 9.947248 76.2559258,\n    LatLong 9.9477598 76.2558551,\n    LatLong 9.948272 76.2556759,\n    LatLong 9.949095 76.2556278,\n    LatLong 9.9493114 76.2557103,\n    LatLong 9.9494124 76.2555746,\n    LatLong 9.9494283 76.2549797,\n    LatLong 9.9494653 76.2541804,\n    LatLong 9.9494084 76.253778,\n    LatLong 9.9494707 76.2534851,\n    LatLong 9.9495028 76.2532594,\n    LatLong 9.9495729 76.2529304,\n    LatLong 9.9496094 76.2524137,\n    LatLong 9.9496595 76.2519506,\n    LatLong 9.9496786 76.2511073,\n    LatLong 9.949829 76.2504006,\n    LatLong 9.949746 76.2502432,\n    LatLong 9.9496946 76.2498126,\n    LatLong 9.9497162 76.2493365,\n    LatLong 9.9488983 76.2493126,\n    LatLong 9.9482119 76.2493073,\n    LatLong 9.9476222 76.2493323,\n    LatLong 9.947077 76.2493599,\n    LatLong 9.9465928 76.2494519,\n    LatLong 9.9461945 76.2495408,\n    LatLong 9.9460593 76.2494892,\n    LatLong 9.9457926 76.2492072,\n    LatLong 9.9457317 76.2485888,\n    LatLong 9.9458146 76.2478109,\n    LatLong 9.9459228 76.2474178,\n    LatLong 9.9458006 76.2468397,\n    LatLong 9.945748 76.2459569,\n    LatLong 9.945839 76.245265,\n    LatLong 9.9466031 76.2450449,\n    LatLong 9.9475667 76.2449813,\n    LatLong 9.9479818 76.2450643,\n    LatLong 9.9487161 76.2449397,\n    LatLong 9.949558 76.2448184,\n    LatLong 9.9501572 76.2446354,\n    LatLong 9.9505948 76.2446262,\n    LatLong 9.951299 76.244686,\n    LatLong 9.9515957 76.2446221,\n    LatLong 9.9516244 76.2441339,\n    LatLong 9.9516122 76.2434132,\n    LatLong 9.9516515 76.2426795,\n    LatLong 9.9521181 76.2424165,\n    LatLong 9.9533909 76.2423739,\n    LatLong 9.9544857 76.242439,\n    LatLong 9.9553803 76.2424938,\n    LatLong 9.9569953 76.2424815,\n    LatLong 9.9580443 76.2425291,\n    LatLong 9.9590512 76.2426587,\n    LatLong 9.9597582 76.2427202,\n    LatLong 9.9600314 76.2427758,\n    LatLong 9.960336 76.242884,\n    LatLong 9.9610344 76.2429602,\n    LatLong 9.9614003 76.2429196,\n    LatLong 9.9619112 76.2429355,\n    LatLong 9.9626063 76.2430359,\n    LatLong 9.9630785 76.2430546,\n    LatLong 9.963587 76.2429774,\n    LatLong 9.9641474 76.2429025,\n    LatLong 9.96467 76.2432158,\n    LatLong 9.9650579 76.2434864,\n    LatLong 9.9652889 76.2435833,\n    LatLong 9.9662792 76.2440292,\n    LatLong 9.9668321 76.2442162,\n    LatLong 9.9671789 76.244374,\n    LatLong 9.9680518 76.2443197,\n    LatLong 9.9684303 76.2444205,\n    LatLong 9.9684431 76.2445717,\n    LatLong 9.9684486 76.2446346,\n    LatLong 9.9684292 76.244613,\n    LatLong 9.968421 76.2447441,\n    LatLong 9.968836 76.2449155,\n    LatLong 9.9688942 76.2449145,\n    LatLong 9.968915 76.2448988,\n    LatLong 9.9688228 76.2449572,\n    LatLong 9.9687608 76.2449791,\n    LatLong 9.9688348 76.2449417,\n    LatLong 9.9689061 76.2449002,\n    LatLong 9.9689559 76.2449258,\n    LatLong 9.9698299 76.245046,\n    LatLong 9.971594 76.245025,\n    LatLong 9.9730622 76.24485,\n    LatLong 9.9734527 76.2446998,\n    LatLong 9.9736689 76.2446262,\n    LatLong 9.9736669 76.2446251,\n    LatLong 9.9736669 76.2446252,\n    LatLong 9.9736662 76.244619,\n    LatLong 9.9736642 76.2446193,\n    LatLong 9.9736628 76.2446195,\n    LatLong 9.9736608 76.2446171,\n    LatLong 9.9736529 76.2446106,\n    LatLong 9.9736523 76.2446029,\n    LatLong 9.9736433 76.2445917,\n    LatLong 9.9737532 76.2445318,\n    LatLong 9.9737765 76.2442782,\n    LatLong 9.9737356 76.244145,\n    LatLong 9.9737354 76.244145,\n    LatLong 9.9737354 76.2441457,\n    LatLong 9.9737351 76.2441477,\n    LatLong 9.9737354 76.2441479,\n    LatLong 9.9737338 76.2441522,\n    LatLong 9.9737343 76.2441547,\n    LatLong 9.9737346 76.2441575,\n    LatLong 9.9737341 76.2441575,\n    LatLong 9.9737331 76.2441583,\n    LatLong 9.9737331 76.244156,\n    LatLong 9.9737332 76.2441554,\n    LatLong 9.9737377 76.2441512,\n    LatLong 9.9737365 76.244149,\n    LatLong 9.9737362 76.2441471,\n    LatLong 9.9737393 76.2441443,\n    LatLong 9.9737415 76.2441467,\n    LatLong 9.9737408 76.2441508,\n    LatLong 9.9737433 76.2441611,\n    LatLong 9.9737324 76.2441815,\n    LatLong 9.9737368 76.244183,\n    LatLong 9.9737373 76.2441826,\n    LatLong 9.9737316 76.2441844,\n    LatLong 9.9737302 76.244185,\n    LatLong 9.9737362 76.2441849\n  ]\n",
      "hash": "d384fcb3b86aa64d7a83fa9ce012ffe49c984f60b33ef24043306e7a60653a7f",
      "size": 12037
    },
    "/lib/mobility-core/test/src/TestSilentIOLogger.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n{-# OPTIONS_GHC -Wno-orphans #-}\n\nmodule TestSilentIOLogger where\n\nimport EulerHS.Prelude\nimport Kernel.Types.Common\n\ninstance Log IO where\n  logOutput _logLevel _msg = pure ()\n  withLogTag _ a = a\n",
      "hash": "d6e1b31086f633bb78b72ac49bbb4d92ae06a8ed95bf82b4fac04dbcb1c36649",
      "size": 891
    },
    "/lib/mobility-core/test/src/Utils/Numeric.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n\nmodule Utils.Numeric where\n\nimport Test.Hspec\nimport Prelude\n\ncheckTolerance :: (Ord a, Show a, Fractional a) => a -> a -> a -> Expectation\ncheckTolerance tol val valIdeal =\n  abs (val - valIdeal) / valIdeal `shouldSatisfy` (< tol)\n",
      "hash": "0a799f5927eb30a24e86df80f57e32158f6252d096865c2de1f1376fb00e620c",
      "size": 926
    },
    "/lib/mobility-core/test/src/Version.hs": {
      "type": "content",
      "content": "{-\n  Copyright 2022-23, Juspay India Pvt Ltd\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License\n\n  as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is\n\n  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\n  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero\n\n  General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\n-}\n{-# OPTIONS_GHC -Wno-orphans #-}\n\nmodule Version where\n\nimport Kernel.Prelude\nimport Kernel.Types.Common\nimport Kernel.Utils.Version\nimport Test.Tasty\nimport Test.Tasty.HUnit\n\ninstance Log (Either SomeException) where\n  logOutput _logLevel _msg = pure ()\n  withLogTag _ a = a\n\nsuccessfull :: TestTree\nsuccessfull =\n  testCase \"Successfull version reading\" $\n    successfullRead @?= \"1.0.1\"\n\nfailed :: TestTree\nfailed =\n  testCase \"Failed version reading\" $\n    failRead @?= \"something wrong\"\n\nsuccessfullRead :: Text\nsuccessfullRead = case readVersion \"1.0.1\" of\n  Left _ -> \"something wrong\"\n  Right v -> versionToText v\n\nfailRead :: Text\nfailRead = case readVersion \"1.01\" of\n  Left _ -> \"something wrong\"\n  Right v -> versionToText v\n\nreadVersionTests :: TestTree\nreadVersionTests =\n  testGroup\n    \"Read versions tests\"\n    [ successfull\n    ]\n",
      "hash": "de229a1a9472a923109a38eafa6b87c5b40e80345d16c4652e85e690bfaf931b",
      "size": 1541
    }
  }
}